(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("@iota-pico/pow-wasm", [], factory);
	else if(typeof exports === 'object')
		exports["@iota-pico/pow-wasm"] = factory();
	else
		root["IotaPicoPowWasm"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./dist/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../core/dist/error/coreError.js":
/*!***************************************!*\
  !*** ../core/dist/error/coreError.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _extendableBuiltin(cls) {
  function ExtendableBuiltin() {
    var instance = Reflect.construct(cls, Array.from(arguments));
    Object.setPrototypeOf(instance, Object.getPrototypeOf(this));
    return instance;
  }

  ExtendableBuiltin.prototype = Object.create(cls.prototype, {
    constructor: {
      value: cls,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });

  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(ExtendableBuiltin, cls);
  } else {
    ExtendableBuiltin.__proto__ = cls;
  }

  return ExtendableBuiltin;
}

Object.defineProperty(exports, "__esModule", {
  value: true
});

var jsonHelper_1 = __webpack_require__(/*! ../helpers/jsonHelper */ "../core/dist/helpers/jsonHelper.js");

var stringHelper_1 = __webpack_require__(/*! ../helpers/stringHelper */ "../core/dist/helpers/stringHelper.js");
/**
 * A core implementation of an error.
 */


var CoreError =
/*#__PURE__*/
function (_extendableBuiltin2) {
  _inherits(CoreError, _extendableBuiltin2);

  /**
   * Create an instance of CoreError.
   * @param message The message for the error.
   * @param additional Additional details about the error.
   * @param innerError Add information from inner error if there was one.
   */
  function CoreError(message, additional, innerError) {
    var _this;

    _classCallCheck(this, CoreError);

    _this = _possibleConstructorReturn(this, (CoreError.__proto__ || Object.getPrototypeOf(CoreError)).call(this, message));
    _this.additional = additional ? additional : {};
    _this.innerError = innerError;
    _this.domain = "Core";
    return _this;
  }
  /**
   * Check if an object could be a CoreError.
   * @param obj The object to check if it is a CoreError.
   * @returns true If the tested object is a CoreError.
   */


  _createClass(CoreError, [{
    key: "format",

    /**
     * Format the error to a readable version.
     * @returns Formatted version of the error.
     */
    value: function format() {
      var _this2 = this;

      var out = "";

      if (!stringHelper_1.StringHelper.isEmpty(this.domain)) {
        out += "".concat(this.domain, ": ");
      }

      if (!stringHelper_1.StringHelper.isEmpty(this.message)) {
        out += "".concat(this.message);
      }

      var keys = Object.keys(this.additional);

      if (keys.length > 0) {
        if (out.length > 0) {
          out += "\n";
        }

        keys.forEach(function (key) {
          out += "\t".concat(key, ": ").concat(jsonHelper_1.JsonHelper.stringify(_this2.additional[key]), "\n");
        });
      }

      return out;
    }
  }], [{
    key: "isError",
    value: function isError(obj) {
      return obj !== undefined && obj !== null && _typeof(obj) === "object" && "message" in obj && "additional" in obj;
    }
  }]);

  return CoreError;
}(_extendableBuiltin(Error));

exports.CoreError = CoreError;

/***/ }),

/***/ "../core/dist/factories/factoryBase.js":
/*!*********************************************!*\
  !*** ../core/dist/factories/factoryBase.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Factory to generate types.
 * @typeparam T The generic type for the object types in the factory.
 */

var FactoryBase =
/*#__PURE__*/
function () {
  function FactoryBase() {
    _classCallCheck(this, FactoryBase);

    /* @internal */
    this._types = {};
  }
  /**
   * Register a new type with the factory.
   * @param name The name of the type to register.
   * @param typeConstructor The constructor for the type.
   */


  _createClass(FactoryBase, [{
    key: "register",
    value: function register(name, typeConstructor) {
      this.getInstance()._types[name] = typeConstructor;
    }
    /**
     * Unregister a type from the factory.
     * @param name The name of the type to unregister.
     */

  }, {
    key: "unregister",
    value: function unregister(name) {
      delete this.getInstance()._types[name];
    }
    /**
     * Does the factory contain a specific type.
     * @param name The name of the type to look for.
     * @returns True if the type exists.
     */

  }, {
    key: "exists",
    value: function exists(name) {
      return this.getInstance()._types[name] !== undefined;
    }
    /**
     * List the types in the factory.
     * @param name The name of the type to look for.
     * @returns True if the type exists.
     */

  }, {
    key: "types",
    value: function types() {
      return Object.keys(this.getInstance()._types);
    }
    /**
     * Create an instance of an object from the factory.
     * @param name The name of the type to create.
     * @param args Any parameters to pass to the constructor.
     * @returns A new instance of the type if it exists, or undefined if it does not.
     */

  }, {
    key: "create",
    value: function create(name) {
      var instance = this.getInstance();

      if (instance._types[name]) {
        var _instance$_types;

        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        return (_instance$_types = instance._types)[name].apply(_instance$_types, args);
      } else {
        return undefined;
      }
    }
  }]);

  return FactoryBase;
}();

exports.FactoryBase = FactoryBase;

/***/ }),

/***/ "../core/dist/helpers/arrayHelper.js":
/*!*******************************************!*\
  !*** ../core/dist/helpers/arrayHelper.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var objectHelper_1 = __webpack_require__(/*! ./objectHelper */ "../core/dist/helpers/objectHelper.js");
/**
 * Array helper methods.
 */


var ArrayHelper =
/*#__PURE__*/
function () {
  function ArrayHelper() {
    _classCallCheck(this, ArrayHelper);
  }

  _createClass(ArrayHelper, null, [{
    key: "isArray",

    /**
     * Is the value an array.
     * @param value Object to test.
     * @returns True if the value is an array.
     */
    value: function isArray(value) {
      return value === null || value === undefined ? false : Array.isArray(value);
    }
    /**
     * Is the value a empty array.
     * @param value Object to test.
     * @returns True if the value is a empty array.
     */

  }, {
    key: "isEmpty",
    value: function isEmpty(value) {
      return !ArrayHelper.isArray(value) || value.length === 0;
    }
    /**
     * Is the value a non empty array of specific type.
     * @param value Object to test.
     * @param type The type of the object
     * @returns True if the value is a non empty array of a specific type.
     */

  }, {
    key: "isTyped",
    value: function isTyped(value, type) {
      return !ArrayHelper.isEmpty(value) && !value.includes(undefined) && !value.includes(null) && value.every(function (a) {
        return objectHelper_1.ObjectHelper.isType(a, type);
      });
    }
  }]);

  return ArrayHelper;
}();

exports.ArrayHelper = ArrayHelper;

/***/ }),

/***/ "../core/dist/helpers/jsonHelper.js":
/*!******************************************!*\
  !*** ../core/dist/helpers/jsonHelper.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Json helper methods.
 */

var JsonHelper =
/*#__PURE__*/
function () {
  function JsonHelper() {
    _classCallCheck(this, JsonHelper);
  }

  _createClass(JsonHelper, null, [{
    key: "stringify",

    /**
     * Stringify an object with recursion breaking.
     * @param value A JavaScript value, usually an object or array, to be converted.
     * @param replacer A function that transforms the results.
     * @param space Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.
     * @returns String version of the object.
     */
    value: function stringify(value, replacer, space) {
      // eliminates any recursion in the stringify
      var cache = [];

      var recusionReplacer = function recusionReplacer(key, replaceValue) {
        if (_typeof(replaceValue) === "object" && value !== null && replaceValue !== undefined) {
          if (cache.indexOf(replaceValue) !== -1) {
            // circular reference found, discard key
            return;
          } else {
            cache.push(replaceValue);
          }
        }

        return replacer ? replacer(key, replaceValue) : replaceValue;
      };

      return JSON.stringify(value, recusionReplacer, space);
    }
  }]);

  return JsonHelper;
}();

exports.JsonHelper = JsonHelper;

/***/ }),

/***/ "../core/dist/helpers/numberHelper.js":
/*!********************************************!*\
  !*** ../core/dist/helpers/numberHelper.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Number helper methods.
 */

var NumberHelper =
/*#__PURE__*/
function () {
  function NumberHelper() {
    _classCallCheck(this, NumberHelper);
  }

  _createClass(NumberHelper, null, [{
    key: "isInteger",

    /**
     * Is the value an integer.
     * @param value Object to test for its integerness.
     * @returns True if the object is a integer.
     */
    value: function isInteger(value) {
      return Number.isInteger(value) && !Number.isNaN(value) && Number.isFinite(value);
    }
    /**
     * Is the value a number.
     * @param value Object to test for its numberyness.
     * @returns True if the object is a number.
     */

  }, {
    key: "isNumber",
    value: function isNumber(value) {
      return value !== undefined && value !== null && typeof value === "number" && !Number.isNaN(value) && Number.isFinite(value);
    }
    /**
     * Is the value a float number formatted as a string, can be used for big numbers that would overflow parseFloat.
     * @param value The value to check
     * @returns True if the number is formatted correctly.
     */

  }, {
    key: "isFloatString",
    value: function isFloatString(value) {
      return /^-?\d*\.?\d+$/.test(value);
    }
    /**
     * Is the value a integer number formatted as a string, can be used for big numbers that would overflow parseInt.
     * @param value The value to check
     * @returns True if the number is formatted correctly.
     */

  }, {
    key: "isIntegerString",
    value: function isIntegerString(value) {
      return /^-?\d+$/.test(value);
    }
  }]);

  return NumberHelper;
}();

exports.NumberHelper = NumberHelper;

/***/ }),

/***/ "../core/dist/helpers/objectHelper.js":
/*!********************************************!*\
  !*** ../core/dist/helpers/objectHelper.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Object helper methods.
 */

var ObjectHelper =
/*#__PURE__*/
function () {
  function ObjectHelper() {
    _classCallCheck(this, ObjectHelper);
  }

  _createClass(ObjectHelper, null, [{
    key: "isEmpty",

    /**
     * Is the value empty.
     * @param value Object to test.
     * @returns True if the value is empty.
     */
    value: function isEmpty(value) {
      return value === null || value === undefined;
    }
    /**
     * Is the value an object.
     * @param value Object to test.
     * @returns True if the value is an object.
     */

  }, {
    key: "isObject",
    value: function isObject(value) {
      return value === null || value === undefined ? false : _typeof(value) === "object" && !Array.isArray(value);
    }
    /**
     * Is the value an object if given type.
     * @param value Object to test.
     * @param typeConstructor A callback method which returns an instance of the object.
     * @returns True if the value is an object of the specified type.
     */

  }, {
    key: "isType",
    value: function isType(value, typeConstructor) {
      var valueClassName = ObjectHelper.getClassName(value);
      return valueClassName !== undefined && valueClassName === ObjectHelper.getClassName(typeConstructor);
    }
    /**
     * Get the class name of an object if it has one.
     * @param object The object to get the class name for.
     * @returns The class name if it has one or undefined if not.
     */

  }, {
    key: "getClassName",
    value: function getClassName(object) {
      if (object === null || object === undefined) {
        return undefined;
      } else {
        var _constructor = typeof object === "function" ? object.toString() : object.constructor.toString();

        var results = _constructor.match(/\w+/g);

        return results && results.length > 1 ? results[1] : undefined;
      }
    }
  }]);

  return ObjectHelper;
}();

exports.ObjectHelper = ObjectHelper;

/***/ }),

/***/ "../core/dist/helpers/stringHelper.js":
/*!********************************************!*\
  !*** ../core/dist/helpers/stringHelper.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * String helper methods.
 */

var StringHelper =
/*#__PURE__*/
function () {
  function StringHelper() {
    _classCallCheck(this, StringHelper);
  }

  _createClass(StringHelper, null, [{
    key: "isString",

    /**
     * Is the value a string.
     * @param value Object to test for its stringyness.
     * @returns True if the object is a string.
     */
    value: function isString(value) {
      return value === null || value === undefined ? false : Object.prototype.toString.call(value) === "[object String]";
    }
    /**
     * Is the value a string that is empty.
     * @param value Object to test for its no emptyness.
     * @returns True if the object is an empty string.
     */

  }, {
    key: "isEmpty",
    value: function isEmpty(value) {
      return !StringHelper.isString(value) || value.length === 0;
    }
    /**
     * Is the string all ASCII characters.
     * @param value string to test if is is ASCII.
     * @returns True if the object is all ASCII.
     */

  }, {
    key: "isAscii",
    value: function isAscii(value) {
      return value === null || value === undefined ? false : /^[\x00-\xFF]*$/.test(value);
    }
    /**
     * Encode non ASCII characters with control characters.
     * @param value The string value to escape.
     * @returns The escaped version of the string.
     */

  }, {
    key: "encodeNonASCII",
    value: function encodeNonASCII(value) {
      return StringHelper.isString(value) ? value.replace(/[\u007F-\uFFFF]/g, function (chr) {
        return "\\u".concat("0000".concat(chr.charCodeAt(0).toString(16)).substr(-4));
      }) : undefined;
    }
    /**
     * Decode control characters to ASCII.
     * @param value The encoded string to convert back to ASCII.
     * @returns The decoded version of the string.
     */

  }, {
    key: "decodeNonASCII",
    value: function decodeNonASCII(value) {
      return StringHelper.isString(value) ? value.replace(/\\u([\d\w]{4})/gi, function (match, grp) {
        return String.fromCharCode(parseInt(grp, 16));
      }) : undefined;
    }
  }]);

  return StringHelper;
}();

exports.StringHelper = StringHelper;

/***/ }),

/***/ "../core/dist/services/timeService.js":
/*!********************************************!*\
  !*** ../core/dist/services/timeService.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Represents a class which can provide the time.
 */

var TimeService =
/*#__PURE__*/
function () {
  function TimeService() {
    _classCallCheck(this, TimeService);
  }

  _createClass(TimeService, [{
    key: "msSinceEpoch",

    /**
     * Returns the number of milliseconds since 1970/01/01.
     * @returns Number of milliseconds.
     */
    value: function msSinceEpoch() {
      return Date.now();
    }
  }]);

  return TimeService;
}();

exports.TimeService = TimeService;

/***/ }),

/***/ "../crypto/dist/digests/sha3.js":
/*!**************************************!*\
  !*** ../crypto/dist/digests/sha3.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ "../core/dist/helpers/objectHelper.js");

var cryptoError_1 = __webpack_require__(/*! ../error/cryptoError */ "../crypto/dist/error/cryptoError.js");
/**
 * Sha3 implementation.
 */


var Sha3 =
/*#__PURE__*/
function () {
  /**
   * Create a new instance of SHA3.
   * @param bits The number of input bits.
   * @param padding The padding to use.
   * @param outputBits The number of output bits.
   */
  function Sha3(bits, padding, outputBits) {
    _classCallCheck(this, Sha3);

    this._padding = padding;
    this._outputBits = outputBits;
    this._blockCount = 1600 - (bits << 1) >> 5;
    this._byteCount = this._blockCount << 2;
    this._outputBlocks = outputBits >> 5;
    this._extraBytes = (outputBits & 31) >> 3;
    this.reset();
  }
  /**
   * Reset the digest.
   */


  _createClass(Sha3, [{
    key: "reset",
    value: function reset() {
      this._reset = true;
      this._block = 0;
      this._start = 0;
      this._blocks = new Uint32Array(this._blockCount + 1);
      this._state = new Uint32Array(50);
    }
    /**
     * Update the digest.
     * @param input Array of data to use in the update.
     */

  }, {
    key: "update",
    value: function update(input) {
      if (!objectHelper_1.ObjectHelper.isType(input, ArrayBuffer)) {
        throw new cryptoError_1.CryptoError("Input is not of type ArrayBuffer");
      }

      var message = new Uint8Array(input);
      var length = message.length;
      var index = 0;
      var i;

      while (index < length) {
        if (this._reset) {
          this._reset = false;
          this._blocks[0] = this._block;

          for (i = 1; i < this._blockCount + 1; ++i) {
            this._blocks[i] = 0;
          }
        }

        for (i = this._start; index < length && i < this._byteCount; ++index) {
          this._blocks[i >> 2] |= message[index] << Sha3.SHIFT[i++ & 3];
        }

        this._lastByteIndex = i;

        if (i >= this._byteCount) {
          this._start = i - this._byteCount;
          this._block = this._blocks[this._blockCount];

          for (i = 0; i < this._blockCount; ++i) {
            this._state[i] ^= this._blocks[i];
          }

          this.keccakPermutation(this._state);
          this._reset = true;
        } else {
          this._start = i;
        }
      }
    }
    /**
     * Finalize and return the hash for the digest, will also reset the state.
     * @returns Array buffer containing the digest.
     */

  }, {
    key: "digest",
    value: function digest() {
      this.finalize();
      var i = 0;
      var j = 0;
      var bytes = this._outputBits >> 3;
      var buffer;

      if (this._extraBytes) {
        buffer = new ArrayBuffer(this._outputBlocks + 1 << 2);
      } else {
        buffer = new ArrayBuffer(bytes);
      }

      var array = new Uint32Array(buffer);

      while (j < this._outputBlocks) {
        for (i = 0; i < this._blockCount && j < this._outputBlocks; ++i, ++j) {
          array[j] = this._state[i];
        }
      }

      if (this._extraBytes) {
        array[i] = this._state[i];
        buffer = buffer.slice(0, bytes);
      }

      this.reset();
      return buffer;
    }
    /* @internal */

  }, {
    key: "finalize",
    value: function finalize() {
      var i = this._lastByteIndex;
      this._blocks[i >> 2] |= this._padding[i & 3];

      if (this._lastByteIndex === this._byteCount) {
        this._blocks[0] = this._blocks[this._blockCount];

        for (i = 1; i < this._blockCount + 1; ++i) {
          this._blocks[i] = 0;
        }
      }

      this._blocks[this._blockCount - 1] |= 0x80000000;

      for (i = 0; i < this._blockCount; ++i) {
        this._state[i] ^= this._blocks[i];
      }

      this.keccakPermutation(this._state);
    }
    /* @internal */

  }, {
    key: "keccakPermutation",
    value: function keccakPermutation(s) {
      // tslint:disable-next-line:one-variable-per-declaration
      var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;

      for (n = 0; n < 48; n += 2) {
        c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
        c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
        c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
        c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
        c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
        c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
        c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
        c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
        c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
        c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];
        h = c8 ^ (c2 << 1 | c3 >>> 31);
        l = c9 ^ (c3 << 1 | c2 >>> 31);
        s[0] ^= h;
        s[1] ^= l;
        s[10] ^= h;
        s[11] ^= l;
        s[20] ^= h;
        s[21] ^= l;
        s[30] ^= h;
        s[31] ^= l;
        s[40] ^= h;
        s[41] ^= l;
        h = c0 ^ (c4 << 1 | c5 >>> 31);
        l = c1 ^ (c5 << 1 | c4 >>> 31);
        s[2] ^= h;
        s[3] ^= l;
        s[12] ^= h;
        s[13] ^= l;
        s[22] ^= h;
        s[23] ^= l;
        s[32] ^= h;
        s[33] ^= l;
        s[42] ^= h;
        s[43] ^= l;
        h = c2 ^ (c6 << 1 | c7 >>> 31);
        l = c3 ^ (c7 << 1 | c6 >>> 31);
        s[4] ^= h;
        s[5] ^= l;
        s[14] ^= h;
        s[15] ^= l;
        s[24] ^= h;
        s[25] ^= l;
        s[34] ^= h;
        s[35] ^= l;
        s[44] ^= h;
        s[45] ^= l;
        h = c4 ^ (c8 << 1 | c9 >>> 31);
        l = c5 ^ (c9 << 1 | c8 >>> 31);
        s[6] ^= h;
        s[7] ^= l;
        s[16] ^= h;
        s[17] ^= l;
        s[26] ^= h;
        s[27] ^= l;
        s[36] ^= h;
        s[37] ^= l;
        s[46] ^= h;
        s[47] ^= l;
        h = c6 ^ (c0 << 1 | c1 >>> 31);
        l = c7 ^ (c1 << 1 | c0 >>> 31);
        s[8] ^= h;
        s[9] ^= l;
        s[18] ^= h;
        s[19] ^= l;
        s[28] ^= h;
        s[29] ^= l;
        s[38] ^= h;
        s[39] ^= l;
        s[48] ^= h;
        s[49] ^= l;
        b0 = s[0];
        b1 = s[1];
        b32 = s[11] << 4 | s[10] >>> 28;
        b33 = s[10] << 4 | s[11] >>> 28;
        b14 = s[20] << 3 | s[21] >>> 29;
        b15 = s[21] << 3 | s[20] >>> 29;
        b46 = s[31] << 9 | s[30] >>> 23;
        b47 = s[30] << 9 | s[31] >>> 23;
        b28 = s[40] << 18 | s[41] >>> 14;
        b29 = s[41] << 18 | s[40] >>> 14;
        b20 = s[2] << 1 | s[3] >>> 31;
        b21 = s[3] << 1 | s[2] >>> 31;
        b2 = s[13] << 12 | s[12] >>> 20;
        b3 = s[12] << 12 | s[13] >>> 20;
        b34 = s[22] << 10 | s[23] >>> 22;
        b35 = s[23] << 10 | s[22] >>> 22;
        b16 = s[33] << 13 | s[32] >>> 19;
        b17 = s[32] << 13 | s[33] >>> 19;
        b48 = s[42] << 2 | s[43] >>> 30;
        b49 = s[43] << 2 | s[42] >>> 30;
        b40 = s[5] << 30 | s[4] >>> 2;
        b41 = s[4] << 30 | s[5] >>> 2;
        b22 = s[14] << 6 | s[15] >>> 26;
        b23 = s[15] << 6 | s[14] >>> 26;
        b4 = s[25] << 11 | s[24] >>> 21;
        b5 = s[24] << 11 | s[25] >>> 21;
        b36 = s[34] << 15 | s[35] >>> 17;
        b37 = s[35] << 15 | s[34] >>> 17;
        b18 = s[45] << 29 | s[44] >>> 3;
        b19 = s[44] << 29 | s[45] >>> 3;
        b10 = s[6] << 28 | s[7] >>> 4;
        b11 = s[7] << 28 | s[6] >>> 4;
        b42 = s[17] << 23 | s[16] >>> 9;
        b43 = s[16] << 23 | s[17] >>> 9;
        b24 = s[26] << 25 | s[27] >>> 7;
        b25 = s[27] << 25 | s[26] >>> 7;
        b6 = s[36] << 21 | s[37] >>> 11;
        b7 = s[37] << 21 | s[36] >>> 11;
        b38 = s[47] << 24 | s[46] >>> 8;
        b39 = s[46] << 24 | s[47] >>> 8;
        b30 = s[8] << 27 | s[9] >>> 5;
        b31 = s[9] << 27 | s[8] >>> 5;
        b12 = s[18] << 20 | s[19] >>> 12;
        b13 = s[19] << 20 | s[18] >>> 12;
        b44 = s[29] << 7 | s[28] >>> 25;
        b45 = s[28] << 7 | s[29] >>> 25;
        b26 = s[38] << 8 | s[39] >>> 24;
        b27 = s[39] << 8 | s[38] >>> 24;
        b8 = s[48] << 14 | s[49] >>> 18;
        b9 = s[49] << 14 | s[48] >>> 18;
        s[0] = b0 ^ ~b2 & b4;
        s[1] = b1 ^ ~b3 & b5;
        s[10] = b10 ^ ~b12 & b14;
        s[11] = b11 ^ ~b13 & b15;
        s[20] = b20 ^ ~b22 & b24;
        s[21] = b21 ^ ~b23 & b25;
        s[30] = b30 ^ ~b32 & b34;
        s[31] = b31 ^ ~b33 & b35;
        s[40] = b40 ^ ~b42 & b44;
        s[41] = b41 ^ ~b43 & b45;
        s[2] = b2 ^ ~b4 & b6;
        s[3] = b3 ^ ~b5 & b7;
        s[12] = b12 ^ ~b14 & b16;
        s[13] = b13 ^ ~b15 & b17;
        s[22] = b22 ^ ~b24 & b26;
        s[23] = b23 ^ ~b25 & b27;
        s[32] = b32 ^ ~b34 & b36;
        s[33] = b33 ^ ~b35 & b37;
        s[42] = b42 ^ ~b44 & b46;
        s[43] = b43 ^ ~b45 & b47;
        s[4] = b4 ^ ~b6 & b8;
        s[5] = b5 ^ ~b7 & b9;
        s[14] = b14 ^ ~b16 & b18;
        s[15] = b15 ^ ~b17 & b19;
        s[24] = b24 ^ ~b26 & b28;
        s[25] = b25 ^ ~b27 & b29;
        s[34] = b34 ^ ~b36 & b38;
        s[35] = b35 ^ ~b37 & b39;
        s[44] = b44 ^ ~b46 & b48;
        s[45] = b45 ^ ~b47 & b49;
        s[6] = b6 ^ ~b8 & b0;
        s[7] = b7 ^ ~b9 & b1;
        s[16] = b16 ^ ~b18 & b10;
        s[17] = b17 ^ ~b19 & b11;
        s[26] = b26 ^ ~b28 & b20;
        s[27] = b27 ^ ~b29 & b21;
        s[36] = b36 ^ ~b38 & b30;
        s[37] = b37 ^ ~b39 & b31;
        s[46] = b46 ^ ~b48 & b40;
        s[47] = b47 ^ ~b49 & b41;
        s[8] = b8 ^ ~b0 & b2;
        s[9] = b9 ^ ~b1 & b3;
        s[18] = b18 ^ ~b10 & b12;
        s[19] = b19 ^ ~b11 & b13;
        s[28] = b28 ^ ~b20 & b22;
        s[29] = b29 ^ ~b21 & b23;
        s[38] = b38 ^ ~b30 & b32;
        s[39] = b39 ^ ~b31 & b33;
        s[48] = b48 ^ ~b40 & b42;
        s[49] = b49 ^ ~b41 & b43;
        s[0] ^= Sha3.ROUND_CONSTANTS[n];
        s[1] ^= Sha3.ROUND_CONSTANTS[n + 1];
      }
    }
  }]);

  return Sha3;
}();
/* Padding to use for Keccak */


Sha3.KECCAK_PADDING = new Uint32Array([1, 256, 65536, 16777216]);
/* @internal */

Sha3.SHIFT = new Uint8Array([0, 8, 16, 24]);
/* @internal */

Sha3.ROUND_CONSTANTS = new Uint32Array([1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648]);
exports.Sha3 = Sha3;

/***/ }),

/***/ "../crypto/dist/error/cryptoError.js":
/*!*******************************************!*\
  !*** ../crypto/dist/error/cryptoError.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var coreError_1 = __webpack_require__(/*! @iota-pico/core/dist/error/coreError */ "../core/dist/error/coreError.js");
/**
 * A crypto implementation of an error.
 */


var CryptoError =
/*#__PURE__*/
function (_coreError_1$CoreErro) {
  _inherits(CryptoError, _coreError_1$CoreErro);

  /**
   * Create an instance of CryptoError.
   * @param message The message for the error.
   * @param additional Additional details about the error.
   * @param innerError Add information from inner error if there was one.
   */
  function CryptoError(message, additional, innerError) {
    var _this;

    _classCallCheck(this, CryptoError);

    _this = _possibleConstructorReturn(this, (CryptoError.__proto__ || Object.getPrototypeOf(CryptoError)).call(this, message, additional, innerError));
    _this.domain = "Crypto";
    return _this;
  }

  return CryptoError;
}(coreError_1.CoreError);

exports.CryptoError = CryptoError;

/***/ }),

/***/ "../crypto/dist/factories/spongeFactory.js":
/*!*************************************************!*\
  !*** ../crypto/dist/factories/spongeFactory.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var factoryBase_1 = __webpack_require__(/*! @iota-pico/core/dist/factories/factoryBase */ "../core/dist/factories/factoryBase.js");

var curl_1 = __webpack_require__(/*! ../sponges/curl */ "../crypto/dist/sponges/curl.js");

var kerl_1 = __webpack_require__(/*! ../sponges/kerl */ "../crypto/dist/sponges/kerl.js");
/**
 * Factory to generate sponges.
 */


var SpongeFactory =
/*#__PURE__*/
function (_factoryBase_1$Factor) {
  _inherits(SpongeFactory, _factoryBase_1$Factor);

  /**
   * Don't allow manual construction of the factory.
   * @internal
   */
  function SpongeFactory() {
    _classCallCheck(this, SpongeFactory);

    return _possibleConstructorReturn(this, (SpongeFactory.__proto__ || Object.getPrototypeOf(SpongeFactory)).call(this));
  }
  /**
   * Get the instance of the factory.
   * @returns The factory instance.
   */


  _createClass(SpongeFactory, [{
    key: "getInstance",

    /* @internal */
    value: function getInstance() {
      return SpongeFactory.instance();
    }
  }], [{
    key: "instance",
    value: function instance() {
      if (!SpongeFactory._instance) {
        SpongeFactory._instance = new SpongeFactory();

        SpongeFactory._instance.register("curl", function () {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          return new (Function.prototype.bind.apply(curl_1.Curl, [null].concat(args)))();
        });

        SpongeFactory._instance.register("curl81", function () {
          return new curl_1.Curl(81);
        });

        SpongeFactory._instance.register("curl27", function () {
          return new curl_1.Curl(27);
        });

        SpongeFactory._instance.register("kerl", function () {
          return new kerl_1.Kerl();
        });
      }

      return SpongeFactory._instance;
    }
  }]);

  return SpongeFactory;
}(factoryBase_1.FactoryBase);

exports.SpongeFactory = SpongeFactory;

/***/ }),

/***/ "../crypto/dist/helpers/bigIntegerHelper.js":
/*!**************************************************!*\
  !*** ../crypto/dist/helpers/bigIntegerHelper.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ "../core/dist/helpers/numberHelper.js");

var objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ "../core/dist/helpers/objectHelper.js"); // tslint:disable-next-line:import-name


var big_integer_1 = __importDefault(__webpack_require__(/*! big-integer */ "../crypto/node_modules/big-integer/BigInteger.js"));

var cryptoError_1 = __webpack_require__(/*! ../error/cryptoError */ "../crypto/dist/error/cryptoError.js");
/**
 * Helper class to convert between BigInteger and other types.
 * Converted from https://github.com/iotaledger/iri/blob/dev/src/main/java/com/iota/iri/hash/Kerl.java
 */


var BigIntegerHelper =
/*#__PURE__*/
function () {
  function BigIntegerHelper() {
    _classCallCheck(this, BigIntegerHelper);
  }

  _createClass(BigIntegerHelper, null, [{
    key: "tritsToBigInteger",

    /**
     * Convert trits to a bigInteger.
     * @param trits The trits to convert.
     * @param offset Offset within the array to start.
     * @param length The length of the trits array to convert.
     * @returns Big integer version of trits.
     */
    value: function tritsToBigInteger(trits, offset, length) {
      if (!objectHelper_1.ObjectHelper.isType(trits, Int8Array) || trits.length === 0) {
        throw new cryptoError_1.CryptoError("The trits must be a non empty Int8Array");
      }

      if (!numberHelper_1.NumberHelper.isInteger(offset) || offset < 0) {
        throw new cryptoError_1.CryptoError("The offset must be a number >= 0");
      }

      if (!numberHelper_1.NumberHelper.isInteger(length) || length <= 0) {
        throw new cryptoError_1.CryptoError("The length must be a number > 0");
      }

      if (offset + length > trits.length) {
        throw new cryptoError_1.CryptoError("The offset + length is beyond the length of the array");
      }

      var value = big_integer_1.default.zero;

      for (var i = length - 1; i >= 0; i--) {
        value = value.multiply(BigIntegerHelper.RADIX).add(big_integer_1.default(trits[offset + i]));
      }

      return value;
    }
    /**
     * Convert bigInteger to trits.
     * @param value The bigInteger to convert to trits.
     * @param trits The array to receive the trits.
     * @param offset The offset to place the trits in the array.
     * @param length The length of the array.
     */

  }, {
    key: "bigIntegerToTrits",
    value: function bigIntegerToTrits(value, trits, offset, length) {
      if (!objectHelper_1.ObjectHelper.isType(value, big_integer_1.default)) {
        throw new cryptoError_1.CryptoError("The value must be a bigInteger type");
      }

      if (!objectHelper_1.ObjectHelper.isType(trits, Int8Array)) {
        throw new cryptoError_1.CryptoError("The trits must be an Int8Array");
      }

      if (!numberHelper_1.NumberHelper.isInteger(offset) || offset < 0) {
        throw new cryptoError_1.CryptoError("The offset must be a number >= 0");
      }

      if (!numberHelper_1.NumberHelper.isInteger(length) || length <= 0) {
        throw new cryptoError_1.CryptoError("The length must be a number > 0");
      }

      if (offset + length > trits.length) {
        throw new cryptoError_1.CryptoError("The offset + length is beyond the length of the array");
      }

      var absoluteValue = value.compareTo(big_integer_1.default.zero) < 0 ? value.negate() : value;

      for (var i = 0; i < length; i++) {
        var divRemainder = absoluteValue.divmod(BigIntegerHelper.RADIX);
        absoluteValue = divRemainder.quotient;
        var remainder = divRemainder.remainder;

        if (remainder > BigIntegerHelper.MAX_TRIT_VALUE) {
          remainder = BigIntegerHelper.MIN_TRIT_VALUE;
          absoluteValue = absoluteValue.add(big_integer_1.default["1"]);
        }

        trits[offset + i] = remainder.toJSNumber();
      }

      if (value.compareTo(big_integer_1.default.zero) < 0) {
        for (var _i = 0; _i < length; _i++) {
          // Avoid negative zero
          trits[offset + _i] = trits[offset + _i] === 0 ? 0 : -trits[offset + _i];
        }
      }
    }
    /**
     * Convert the bigInteger into bytes.
     * @param value The value to convert.
     * @param destination The destination array to store the bytes.
     * @param offset The offset within the array to store the bytes.
     */

  }, {
    key: "bigIntegerToBytes",
    value: function bigIntegerToBytes(value, destination, offset) {
      if (!objectHelper_1.ObjectHelper.isType(value, big_integer_1.default)) {
        throw new cryptoError_1.CryptoError("The value must be a bigInteger type");
      }

      if (!objectHelper_1.ObjectHelper.isType(destination, ArrayBuffer) || destination.byteLength === 0) {
        throw new cryptoError_1.CryptoError("The destination must be an array");
      }

      if (!numberHelper_1.NumberHelper.isInteger(offset) || offset < 0) {
        throw new cryptoError_1.CryptoError("The offset must be a number >= 0");
      }

      if (destination.byteLength - offset < BigIntegerHelper.BYTE_HASH_LENGTH) {
        throw new cryptoError_1.CryptoError("Destination array has invalid size, it must be at least ".concat(BigIntegerHelper.BYTE_HASH_LENGTH));
      } // Remember if it is negative for later


      var isNeg = value.isNegative() ? -1 : 0;
      var hexString = value.toString(16);

      if (isNeg === -1) {
        // But remove it for now
        hexString = hexString.slice(1);
      } // Now make sure the hex string is an even length so the regex works


      if (hexString.length % 2 === 1) {
        hexString = "0".concat(hexString);
      }

      var matches = hexString.match(/[0-9a-f]{2}/g); // Convert the hex to numbers

      var signedBytes = new Int8Array(matches.map(function (hex) {
        return parseInt("0x".concat(hex), 16);
      }));

      if (isNeg === -1) {
        BigIntegerHelper.twosComplement(signedBytes);
      }

      var dataView = new DataView(destination); // Pad the start of the buffer with the neg value

      var i = offset;

      while (i + signedBytes.length < BigIntegerHelper.BYTE_HASH_LENGTH) {
        dataView.setInt8(i++, isNeg);
      } // And copy in the actual bytes


      for (var j = signedBytes.length; j-- > 0;) {
        dataView.setInt8(i++, signedBytes[signedBytes.length - 1 - j]);
      }
    }
    /**
     * Convert bytes to a bigInteger.
     * @param source The source bytes.
     * @param offset The offset within the bytes to start conversion.
     * @param length The length of the bytes to use for conversion.
     * @returns Big integer version of bytes.
     */

  }, {
    key: "bytesToBigInteger",
    value: function bytesToBigInteger(source, offset, length) {
      if (!objectHelper_1.ObjectHelper.isType(source, ArrayBuffer) || source.byteLength === 0) {
        throw new cryptoError_1.CryptoError("The source must be a non empty number array");
      }

      if (!numberHelper_1.NumberHelper.isInteger(offset) || offset < 0) {
        throw new cryptoError_1.CryptoError("The offset must be a number >= 0");
      }

      if (!numberHelper_1.NumberHelper.isInteger(length) || length <= 0) {
        throw new cryptoError_1.CryptoError("The length must be a number > 0");
      }

      if (source.byteLength - offset < BigIntegerHelper.BYTE_HASH_LENGTH) {
        throw new cryptoError_1.CryptoError("Source array has invalid size, it must be at least ".concat(BigIntegerHelper.BYTE_HASH_LENGTH));
      }

      var dataView = new DataView(source);
      var signedBytes = new Int8Array(dataView.byteLength);

      for (var b = 0; b < dataView.byteLength; b++) {
        signedBytes[b] = dataView.getInt8(b + offset);
      } // Remove the initial padding leaving at least one byte


      var paddingOffset = 0;
      var firstByte = signedBytes[0];
      var isNeg = firstByte < 0; // If the first padding character is negative then reverse the 2s complement
      // but first strip of the leading padding

      if (firstByte === 0 || firstByte === -1) {
        while (signedBytes[paddingOffset] === firstByte && paddingOffset < signedBytes.length - 1) {
          paddingOffset++;
        } // Strip any padding


        signedBytes = signedBytes.slice(paddingOffset);
      }

      if (isNeg) {
        BigIntegerHelper.twosComplement(signedBytes);
      }

      var hexString = isNeg ? "-" : "";
      var dv = new DataView(signedBytes.buffer);

      for (var h = 0; h < dv.byteLength; h++) {
        hexString += "00".concat(dv.getUint8(h).toString(16)).slice(-2);
      }

      return big_integer_1.default(hexString, 16);
    }
    /* @internal */

  }, {
    key: "twosComplement",
    value: function twosComplement(signedBytes) {
      // if the whole number is negative then
      // change to 2's complements by noting all the numbers
      // and adding 1 to the last i.e. ~bignum+1
      for (var b = 0; b < signedBytes.length; b++) {
        signedBytes[b] = ~signedBytes[b];
      } // Add 1 to last number, if the number is 0xFF continue to carry


      var c = signedBytes.length - 1;

      do {
        signedBytes[c]++;
      } while (signedBytes[c--] === 0 && c > 0);
    }
  }]);

  return BigIntegerHelper;
}();
/* @internal */


BigIntegerHelper.RADIX = big_integer_1.default(3);
/* @internal */

BigIntegerHelper.MAX_TRIT_VALUE = BigIntegerHelper.RADIX.minus(1).divide(2);
/* @internal */

BigIntegerHelper.MIN_TRIT_VALUE = BigIntegerHelper.MAX_TRIT_VALUE.negate();
/* @internal */

BigIntegerHelper.BIT_HASH_LENGTH = 384;
/* @internal */

BigIntegerHelper.BYTE_HASH_LENGTH = BigIntegerHelper.BIT_HASH_LENGTH / 8;
exports.BigIntegerHelper = BigIntegerHelper;

/***/ }),

/***/ "../crypto/dist/helpers/transactionHelper.js":
/*!***************************************************!*\
  !*** ../crypto/dist/helpers/transactionHelper.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ "../core/dist/helpers/objectHelper.js");

var hash_1 = __webpack_require__(/*! @iota-pico/data/dist/data/hash */ "../data/dist/data/hash.js");

var transaction_1 = __webpack_require__(/*! @iota-pico/data/dist/data/transaction */ "../data/dist/data/transaction.js");

var trits_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trits */ "../data/dist/data/trits.js");

var cryptoError_1 = __webpack_require__(/*! ../error/cryptoError */ "../crypto/dist/error/cryptoError.js");

var spongeFactory_1 = __webpack_require__(/*! ../factories/spongeFactory */ "../crypto/dist/factories/spongeFactory.js");
/**
 * Helper class for transactions.
 * Converted https://github.com/iotaledger/iota.lib.js/blob/master/lib/crypto/signing/signing.js
 */


var TransactionHelper =
/*#__PURE__*/
function () {
  function TransactionHelper() {
    _classCallCheck(this, TransactionHelper);
  }

  _createClass(TransactionHelper, null, [{
    key: "hash",

    /**
     * Create the hash for a transaction.
     * @param transaction The transaction to generate the hash.
     * @returns The hash of thr transaction.
     */
    value: function hash(transaction) {
      if (!objectHelper_1.ObjectHelper.isType(transaction, transaction_1.Transaction)) {
        throw new cryptoError_1.CryptoError("The transaction must be of type Transaction");
      }

      var curl = spongeFactory_1.SpongeFactory.instance().create("curl");
      var transactionTrits = trits_1.Trits.fromTrytes(transaction.toTrytes()).toArray();
      curl.initialize();
      curl.absorb(transactionTrits, 0, transactionTrits.length);
      var hashTrits = new Int8Array(curl.getConstant("HASH_LENGTH"));
      curl.squeeze(hashTrits, 0, hashTrits.length);
      return hash_1.Hash.fromTrytes(trits_1.Trits.fromArray(hashTrits).toTrytes());
    }
  }]);

  return TransactionHelper;
}();

exports.TransactionHelper = TransactionHelper;

/***/ }),

/***/ "../crypto/dist/proofOfWork/proofOfWorkBase.js":
/*!*****************************************************!*\
  !*** ../crypto/dist/proofOfWork/proofOfWorkBase.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ "../crypto/node_modules/@babel/runtime/regenerator/index.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _next(value) { step("next", value); } function _throw(err) { step("throw", err); } _next(); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var arrayHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/arrayHelper */ "../core/dist/helpers/arrayHelper.js");

var numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ "../core/dist/helpers/numberHelper.js");

var objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ "../core/dist/helpers/objectHelper.js");

var timeService_1 = __webpack_require__(/*! @iota-pico/core/dist/services/timeService */ "../core/dist/services/timeService.js");

var hash_1 = __webpack_require__(/*! @iota-pico/data/dist/data/hash */ "../data/dist/data/hash.js");

var tag_1 = __webpack_require__(/*! @iota-pico/data/dist/data/tag */ "../data/dist/data/tag.js");

var transaction_1 = __webpack_require__(/*! @iota-pico/data/dist/data/transaction */ "../data/dist/data/transaction.js");

var tryteNumber_1 = __webpack_require__(/*! @iota-pico/data/dist/data/tryteNumber */ "../data/dist/data/tryteNumber.js");

var trytes_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trytes */ "../data/dist/data/trytes.js");

var cryptoError_1 = __webpack_require__(/*! ../error/cryptoError */ "../crypto/dist/error/cryptoError.js");

var transactionHelper_1 = __webpack_require__(/*! ../helpers/transactionHelper */ "../crypto/dist/helpers/transactionHelper.js");
/**
 * Base class for proof of work.
 */


var ProofOfWorkBase =
/*#__PURE__*/
function () {
  /**
   * Create an instance of ProofOfWork.
   * @param timeService Service to get the time for attachments.
   */
  function ProofOfWorkBase(timeService) {
    _classCallCheck(this, ProofOfWorkBase);

    this._timeService = timeService || new timeService_1.TimeService();
  }
  /**
   * Allow the proof of work to perform any initialization.
   * Will throw an exception if the implementation is not supported.
   * @returns Promise.
   */


  _createClass(ProofOfWorkBase, [{
    key: "initialize",
    value: function () {
      var _initialize = _asyncToGenerator(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee() {
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", Promise.resolve());

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      return function initialize() {
        return _initialize.apply(this, arguments);
      };
    }()
    /**
     * Perform a proof of work on the data.
     * @param trunkTransaction The trunkTransaction to use for the pow.
     * @param branchTransaction The branchTransaction to use for the pow.
     * @param trytes The trytes to perform the pow on.
     * @param minWeightMagnitude The minimum weight magnitude.
     * @returns The trytes produced by the proof of work.
     */

  }, {
    key: "pow",
    value: function () {
      var _pow = _asyncToGenerator(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee2(trunkTransaction, branchTransaction, trytes, minWeightMagnitude) {
        var finalTrytes, previousTransactionHash, i, transaction, newTrytes, singleTrytes, returnTransaction;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (objectHelper_1.ObjectHelper.isType(trunkTransaction, hash_1.Hash)) {
                  _context2.next = 2;
                  break;
                }

                throw new cryptoError_1.CryptoError("The trunkTransaction must be an object of type Hash");

              case 2:
                if (objectHelper_1.ObjectHelper.isType(branchTransaction, hash_1.Hash)) {
                  _context2.next = 4;
                  break;
                }

                throw new cryptoError_1.CryptoError("The branchTransaction must be an object of type Hash");

              case 4:
                if (arrayHelper_1.ArrayHelper.isTyped(trytes, trytes_1.Trytes)) {
                  _context2.next = 6;
                  break;
                }

                throw new cryptoError_1.CryptoError("The trytes must be an array of type Trytes");

              case 6:
                if (!(!numberHelper_1.NumberHelper.isInteger(minWeightMagnitude) || minWeightMagnitude <= 0)) {
                  _context2.next = 8;
                  break;
                }

                throw new cryptoError_1.CryptoError("The minWeightMagnitude must be > 0");

              case 8:
                finalTrytes = [];
                i = 0;

              case 10:
                if (!(i < trytes.length)) {
                  _context2.next = 35;
                  break;
                }

                transaction = transaction_1.Transaction.fromTrytes(trytes[i]); // Start with last index transaction
                // Assign it the trunk / branch which the user has supplied
                // If there is a bundle, chain the bundle transactions via
                // trunkTransaction together

                transaction.attachmentTimestamp = tryteNumber_1.TryteNumber.fromNumber(this._timeService.msSinceEpoch());
                transaction.attachmentTimestampLowerBound = tryteNumber_1.TryteNumber.fromNumber(0);
                transaction.attachmentTimestampUpperBound = tryteNumber_1.TryteNumber.fromNumber(ProofOfWorkBase.MAX_TIMESTAMP_VALUE); // If this is the first transaction, to be processed
                // Make sure that it's the last in the bundle and then
                // assign it the supplied trunk and branch transactions

                if (!objectHelper_1.ObjectHelper.isEmpty(previousTransactionHash)) {
                  _context2.next = 22;
                  break;
                }

                if (!(transaction.lastIndex.toNumber() !== transaction.currentIndex.toNumber())) {
                  _context2.next = 18;
                  break;
                }

                throw new cryptoError_1.CryptoError("Wrong bundle order. The bundle should be ordered in descending order from currentIndex");

              case 18:
                transaction.trunkTransaction = trunkTransaction;
                transaction.branchTransaction = branchTransaction;
                _context2.next = 24;
                break;

              case 22:
                transaction.trunkTransaction = previousTransactionHash;
                transaction.branchTransaction = trunkTransaction;

              case 24:
                newTrytes = transaction.toTrytes();
                _context2.next = 27;
                return this.singlePow(newTrytes, minWeightMagnitude);

              case 27:
                singleTrytes = _context2.sent;
                transaction.nonce = tag_1.Tag.fromTrytes(singleTrytes.sub(transaction_1.Transaction.LENGTH - tag_1.Tag.LENGTH, tag_1.Tag.LENGTH)); // Calculate the hash of the new transaction with nonce and use that as the previous hash for next entry

                returnTransaction = transaction_1.Transaction.fromTrytes(singleTrytes);
                previousTransactionHash = transactionHelper_1.TransactionHelper.hash(returnTransaction);
                finalTrytes.push(returnTransaction);

              case 32:
                i++;
                _context2.next = 10;
                break;

              case 35:
                return _context2.abrupt("return", finalTrytes.reverse().map(function (transaction) {
                  return transaction.toTrytes();
                }));

              case 36:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      return function pow(_x, _x2, _x3, _x4) {
        return _pow.apply(this, arguments);
      };
    }()
  }]);

  return ProofOfWorkBase;
}();
/**
 * The maximum timestamp value used in proof of work.
 */


ProofOfWorkBase.MAX_TIMESTAMP_VALUE = (Math.pow(3, 27) - 1) / 2;
exports.ProofOfWorkBase = ProofOfWorkBase;

/***/ }),

/***/ "../crypto/dist/sponges/curl.js":
/*!**************************************!*\
  !*** ../crypto/dist/sponges/curl.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ "../core/dist/helpers/numberHelper.js");

var objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ "../core/dist/helpers/objectHelper.js");

var cryptoError_1 = __webpack_require__(/*! ../error/cryptoError */ "../crypto/dist/error/cryptoError.js");
/**
 * Implementation of ISponge using Curl algorithm.
 * https://github.com/iotaledger/iota.lib.js/blob/master/lib/crypto/curl/curl.js
 */


var Curl =
/*#__PURE__*/
function () {
  /**
   * Create a new instance of Curl.
   * @param rounds The number of rounds to use.
   */
  function Curl() {
    var rounds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Curl.NUMBER_OF_ROUNDS;

    _classCallCheck(this, Curl);

    this._numberOfRounds = rounds;
  }
  /**
   * Get the constant for the spone.
   * @param name The name of the constant to get.
   * @returns The constant.
   */


  _createClass(Curl, [{
    key: "getConstant",
    value: function getConstant(name) {
      switch (name) {
        case "NUMBER_OF_ROUNDS":
          {
            return this._numberOfRounds;
          }

        case "HASH_LENGTH":
        case "STATE_LENGTH":
          {
            return Curl[name];
          }

        default:
          throw new cryptoError_1.CryptoError("Unknown constant requested ".concat(name));
      }
    }
    /**
     * Get the state.
     * @returns The state.
     */

  }, {
    key: "getState",
    value: function getState() {
      return this._state;
    }
    /**
     * Initialise the hasher.
     * @param state The initial state for the hasher.
     */

  }, {
    key: "initialize",
    value: function initialize(state) {
      if (state) {
        this._state = state;
      } else {
        this._state = new Int8Array(Curl.STATE_LENGTH);
      }
    }
    /**
     * Reset the hasher.
     */

  }, {
    key: "reset",
    value: function reset() {
      this.initialize();
    }
    /**
     * Absorb trits into the hash.
     * @param trits The trits to absorb.
     * @param offset The offset into the trits to absorb from.
     * @param length The number of trits to absorb.
     */

  }, {
    key: "absorb",
    value: function absorb(trits, offset, length) {
      if (!objectHelper_1.ObjectHelper.isType(trits, Int8Array) || trits.length === 0) {
        throw new cryptoError_1.CryptoError("Trits must be a non empty Int8Array");
      }

      if (!numberHelper_1.NumberHelper.isInteger(offset) || offset < 0) {
        throw new cryptoError_1.CryptoError("Offset must be a number >= 0");
      }

      if (!numberHelper_1.NumberHelper.isInteger(length) || length < 0) {
        throw new cryptoError_1.CryptoError("Length must be a number >= 0");
      }

      if (length + offset > trits.length) {
        throw new cryptoError_1.CryptoError("The offset + length is beyond the length of the trits");
      }

      var localOffset = offset;
      var localLength = length;

      do {
        var i = 0;
        var limit = localLength < Curl.HASH_LENGTH ? localLength : Curl.HASH_LENGTH;

        while (i < limit) {
          this._state[i++] = trits[localOffset++];
        }

        this.transform();
        localLength -= Curl.HASH_LENGTH;
      } while (localLength > 0);
    }
    /**
     * Squeeze trits into the hash.
     * @param trits The trits to squeeze.
     * @param offset The offset into the trits to squeeze from.
     * @param length The number of trits to squeeze.
     */

  }, {
    key: "squeeze",
    value: function squeeze(trits, offset, length) {
      if (!objectHelper_1.ObjectHelper.isType(trits, Int8Array) || trits.length === 0) {
        throw new cryptoError_1.CryptoError("Trits must be a non empty Int8Array");
      }

      if (!numberHelper_1.NumberHelper.isInteger(offset) || offset < 0) {
        throw new cryptoError_1.CryptoError("Offset must be a number >= 0");
      }

      if (!numberHelper_1.NumberHelper.isInteger(length) || length < 0) {
        throw new cryptoError_1.CryptoError("Length must be a number >= 0");
      }

      if (length + offset > trits.length) {
        throw new cryptoError_1.CryptoError("The offset + length is beyond the length of the trits");
      }

      var localOffset = offset;
      var localLength = length;

      do {
        var i = 0;
        var limit = localLength < Curl.HASH_LENGTH ? length : Curl.HASH_LENGTH;

        while (i < limit) {
          trits[localOffset++] = this._state[i++];
        }

        this.transform();
        localLength -= Curl.HASH_LENGTH;
      } while (localLength > 0);
    }
    /**
     * Transform the hash.
     * @internal
     */

  }, {
    key: "transform",
    value: function transform() {
      var stateCopy;
      var index = 0;

      for (var round = 0; round < this._numberOfRounds; round++) {
        stateCopy = new Int8Array(this._state.slice());

        for (var i = 0; i < Curl.STATE_LENGTH; i++) {
          this._state[i] = Curl.TRUTH_TABLE[stateCopy[index] + (stateCopy[index += index < 365 ? 364 : -365] << 2) + 5];
        }
      }
    }
  }]);

  return Curl;
}();

Curl.HASH_LENGTH = 243;
Curl.NUMBER_OF_ROUNDS = 81;
Curl.STATE_LENGTH = Curl.HASH_LENGTH * 3;
/* @internal */

Curl.TRUTH_TABLE = new Int8Array([1, 0, -1, 2, 1, -1, 0, 2, -1, 1, 0]);
exports.Curl = Curl;

/***/ }),

/***/ "../crypto/dist/sponges/kerl.js":
/*!**************************************!*\
  !*** ../crypto/dist/sponges/kerl.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ "../core/dist/helpers/numberHelper.js");

var objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ "../core/dist/helpers/objectHelper.js");

var sha3_1 = __webpack_require__(/*! ../digests/sha3 */ "../crypto/dist/digests/sha3.js");

var cryptoError_1 = __webpack_require__(/*! ../error/cryptoError */ "../crypto/dist/error/cryptoError.js");

var bigIntegerHelper_1 = __webpack_require__(/*! ../helpers/bigIntegerHelper */ "../crypto/dist/helpers/bigIntegerHelper.js");
/**
 * Implementation of ISponge using Kerl algorithm.
 * https://github.com/iotaledger/iri/blob/dev/src/main/java/com/iota/iri/hash/Kerl.java
 */


var Kerl =
/*#__PURE__*/
function () {
  /**
   * Create a new instance of Kerl.
   */
  function Kerl() {
    _classCallCheck(this, Kerl);

    this._keccak = new sha3_1.Sha3(384, sha3_1.Sha3.KECCAK_PADDING, 384);
  }
  /**
   * Get the constant for the spone.
   * @param name The name of the constant to get.
   * @returns The constant.
   */


  _createClass(Kerl, [{
    key: "getConstant",
    value: function getConstant(name) {
      switch (name) {
        case "HASH_LENGTH":
        case "BIT_HASH_LENGTH":
        case "BYTE_HASH_LENGTH":
          {
            return Kerl[name];
          }

        default:
          throw new cryptoError_1.CryptoError("Unknown constant requested ".concat(name));
      }
    }
    /**
     * Get the state.
     * @returns The state.
     */

  }, {
    key: "getState",
    value: function getState() {
      return undefined;
    }
    /**
     * Initialise the hasher.
     * @param state The initial state for the hasher.
     */

  }, {
    key: "initialize",
    value: function initialize(state) {}
    /**
     * Reset the hasher.
     */

  }, {
    key: "reset",
    value: function reset() {
      this._keccak.reset();
    }
    /**
     * Absorb trits into the hash.
     * @param trits The trits to absorb.
     * @param offset The offset into the trits to absorb from.
     * @param length The number of trits to absorb.
     */

  }, {
    key: "absorb",
    value: function absorb(trits, offset, length) {
      if (!objectHelper_1.ObjectHelper.isType(trits, Int8Array) || trits.length === 0) {
        throw new cryptoError_1.CryptoError("Trits must be a non empty Int8Array");
      }

      if (!numberHelper_1.NumberHelper.isInteger(offset) || offset < 0) {
        throw new cryptoError_1.CryptoError("Offset must be a number >= 0");
      }

      if (!numberHelper_1.NumberHelper.isInteger(length) || length < 0) {
        throw new cryptoError_1.CryptoError("Length must be a number >= 0");
      }

      if (length + offset > trits.length) {
        throw new cryptoError_1.CryptoError("The offset + length is beyond the length of the trits");
      }

      if (length % 243 !== 0) {
        throw new cryptoError_1.CryptoError("Length must be a multiple of ".concat(Kerl.HASH_LENGTH), {
          length: length
        });
      }

      var localOffset = offset;
      var localLength = length;

      do {
        var tritState = trits.slice(localOffset, localOffset + Kerl.HASH_LENGTH);
        tritState[Kerl.HASH_LENGTH - 1] = 0;
        var bigInt = bigIntegerHelper_1.BigIntegerHelper.tritsToBigInteger(tritState, 0, tritState.length);
        var byteState = new ArrayBuffer(Kerl.BYTE_HASH_LENGTH);
        bigIntegerHelper_1.BigIntegerHelper.bigIntegerToBytes(bigInt, byteState, 0);

        this._keccak.update(byteState);

        localOffset += Kerl.HASH_LENGTH;
        localLength -= Kerl.HASH_LENGTH;
      } while (localLength > 0);
    }
    /**
     * Squeeze trits into the hash.
     * @param trits The trits to squeeze.
     * @param offset The offset into the trits to squeeze from.
     * @param length The number of trits to squeeze.
     */

  }, {
    key: "squeeze",
    value: function squeeze(trits, offset, length) {
      if (!objectHelper_1.ObjectHelper.isType(trits, Int8Array) || trits.length === 0) {
        throw new cryptoError_1.CryptoError("Trits must be a non empty Int8Array");
      }

      if (!numberHelper_1.NumberHelper.isInteger(offset) || offset < 0) {
        throw new cryptoError_1.CryptoError("Offset must be a number >= 0");
      }

      if (!numberHelper_1.NumberHelper.isInteger(length) || length < 0) {
        throw new cryptoError_1.CryptoError("Length must be a number >= 0");
      }

      if (length + offset > trits.length) {
        throw new cryptoError_1.CryptoError("The offset + length is beyond the length of the trits");
      }

      if (length % 243 !== 0) {
        throw new cryptoError_1.CryptoError("Length must be a multiple of ".concat(Kerl.HASH_LENGTH), {
          length: length
        });
      }

      var localOffset = offset;
      var localLength = length;

      do {
        var byteStateBuffer = this._keccak.digest();

        var bigInt = bigIntegerHelper_1.BigIntegerHelper.bytesToBigInteger(byteStateBuffer, 0, Kerl.BYTE_HASH_LENGTH);
        var tritState = new Int8Array(Kerl.HASH_LENGTH);
        bigIntegerHelper_1.BigIntegerHelper.bigIntegerToTrits(bigInt, tritState, 0, Kerl.HASH_LENGTH);
        tritState[Kerl.HASH_LENGTH - 1] = 0;
        var i = 0;

        while (i < Kerl.HASH_LENGTH) {
          trits[localOffset++] = tritState[i++];
        }

        var dv = new DataView(byteStateBuffer);

        for (i = 0; i < dv.byteLength; i++) {
          dv.setUint8(i, dv.getUint8(i) ^ 0xFF);
        }

        this._keccak.update(byteStateBuffer);

        localLength -= Kerl.HASH_LENGTH;
      } while (localLength > 0);
    }
  }]);

  return Kerl;
}();
/* @internal */


Kerl.HASH_LENGTH = 243;
/* @internal */

Kerl.BIT_HASH_LENGTH = 384;
/* @internal */

Kerl.BYTE_HASH_LENGTH = Kerl.BIT_HASH_LENGTH / 8;
exports.Kerl = Kerl;

/***/ }),

/***/ "../crypto/node_modules/@babel/runtime/regenerator/index.js":
/*!******************************************************************!*\
  !*** ../crypto/node_modules/@babel/runtime/regenerator/index.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! regenerator-runtime */ "../crypto/node_modules/regenerator-runtime/runtime-module.js");


/***/ }),

/***/ "../crypto/node_modules/big-integer/BigInteger.js":
/*!********************************************************!*\
  !*** ../crypto/node_modules/big-integer/BigInteger.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var bigInt = (function (undefined) {
    "use strict";

    var BASE = 1e7,
        LOG_BASE = 7,
        MAX_INT = 9007199254740992,
        MAX_INT_ARR = smallToArray(MAX_INT),
        LOG_MAX_INT = Math.log(MAX_INT);

    function Integer(v, radix) {
        if (typeof v === "undefined") return Integer[0];
        if (typeof radix !== "undefined") return +radix === 10 ? parseValue(v) : parseBase(v, radix);
        return parseValue(v);
    }

    function BigInteger(value, sign) {
        this.value = value;
        this.sign = sign;
        this.isSmall = false;
    }
    BigInteger.prototype = Object.create(Integer.prototype);

    function SmallInteger(value) {
        this.value = value;
        this.sign = value < 0;
        this.isSmall = true;
    }
    SmallInteger.prototype = Object.create(Integer.prototype);

    function isPrecise(n) {
        return -MAX_INT < n && n < MAX_INT;
    }

    function smallToArray(n) { // For performance reasons doesn't reference BASE, need to change this function if BASE changes
        if (n < 1e7)
            return [n];
        if (n < 1e14)
            return [n % 1e7, Math.floor(n / 1e7)];
        return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];
    }

    function arrayToSmall(arr) { // If BASE changes this function may need to change
        trim(arr);
        var length = arr.length;
        if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {
            switch (length) {
                case 0: return 0;
                case 1: return arr[0];
                case 2: return arr[0] + arr[1] * BASE;
                default: return arr[0] + (arr[1] + arr[2] * BASE) * BASE;
            }
        }
        return arr;
    }

    function trim(v) {
        var i = v.length;
        while (v[--i] === 0);
        v.length = i + 1;
    }

    function createArray(length) { // function shamelessly stolen from Yaffle's library https://github.com/Yaffle/BigInteger
        var x = new Array(length);
        var i = -1;
        while (++i < length) {
            x[i] = 0;
        }
        return x;
    }

    function truncate(n) {
        if (n > 0) return Math.floor(n);
        return Math.ceil(n);
    }

    function add(a, b) { // assumes a and b are arrays with a.length >= b.length
        var l_a = a.length,
            l_b = b.length,
            r = new Array(l_a),
            carry = 0,
            base = BASE,
            sum, i;
        for (i = 0; i < l_b; i++) {
            sum = a[i] + b[i] + carry;
            carry = sum >= base ? 1 : 0;
            r[i] = sum - carry * base;
        }
        while (i < l_a) {
            sum = a[i] + carry;
            carry = sum === base ? 1 : 0;
            r[i++] = sum - carry * base;
        }
        if (carry > 0) r.push(carry);
        return r;
    }

    function addAny(a, b) {
        if (a.length >= b.length) return add(a, b);
        return add(b, a);
    }

    function addSmall(a, carry) { // assumes a is array, carry is number with 0 <= carry < MAX_INT
        var l = a.length,
            r = new Array(l),
            base = BASE,
            sum, i;
        for (i = 0; i < l; i++) {
            sum = a[i] - base + carry;
            carry = Math.floor(sum / base);
            r[i] = sum - carry * base;
            carry += 1;
        }
        while (carry > 0) {
            r[i++] = carry % base;
            carry = Math.floor(carry / base);
        }
        return r;
    }

    BigInteger.prototype.add = function (v) {
        var n = parseValue(v);
        if (this.sign !== n.sign) {
            return this.subtract(n.negate());
        }
        var a = this.value, b = n.value;
        if (n.isSmall) {
            return new BigInteger(addSmall(a, Math.abs(b)), this.sign);
        }
        return new BigInteger(addAny(a, b), this.sign);
    };
    BigInteger.prototype.plus = BigInteger.prototype.add;

    SmallInteger.prototype.add = function (v) {
        var n = parseValue(v);
        var a = this.value;
        if (a < 0 !== n.sign) {
            return this.subtract(n.negate());
        }
        var b = n.value;
        if (n.isSmall) {
            if (isPrecise(a + b)) return new SmallInteger(a + b);
            b = smallToArray(Math.abs(b));
        }
        return new BigInteger(addSmall(b, Math.abs(a)), a < 0);
    };
    SmallInteger.prototype.plus = SmallInteger.prototype.add;

    function subtract(a, b) { // assumes a and b are arrays with a >= b
        var a_l = a.length,
            b_l = b.length,
            r = new Array(a_l),
            borrow = 0,
            base = BASE,
            i, difference;
        for (i = 0; i < b_l; i++) {
            difference = a[i] - borrow - b[i];
            if (difference < 0) {
                difference += base;
                borrow = 1;
            } else borrow = 0;
            r[i] = difference;
        }
        for (i = b_l; i < a_l; i++) {
            difference = a[i] - borrow;
            if (difference < 0) difference += base;
            else {
                r[i++] = difference;
                break;
            }
            r[i] = difference;
        }
        for (; i < a_l; i++) {
            r[i] = a[i];
        }
        trim(r);
        return r;
    }

    function subtractAny(a, b, sign) {
        var value;
        if (compareAbs(a, b) >= 0) {
            value = subtract(a,b);
        } else {
            value = subtract(b, a);
            sign = !sign;
        }
        value = arrayToSmall(value);
        if (typeof value === "number") {
            if (sign) value = -value;
            return new SmallInteger(value);
        }
        return new BigInteger(value, sign);
    }

    function subtractSmall(a, b, sign) { // assumes a is array, b is number with 0 <= b < MAX_INT
        var l = a.length,
            r = new Array(l),
            carry = -b,
            base = BASE,
            i, difference;
        for (i = 0; i < l; i++) {
            difference = a[i] + carry;
            carry = Math.floor(difference / base);
            difference %= base;
            r[i] = difference < 0 ? difference + base : difference;
        }
        r = arrayToSmall(r);
        if (typeof r === "number") {
            if (sign) r = -r;
            return new SmallInteger(r);
        } return new BigInteger(r, sign);
    }

    BigInteger.prototype.subtract = function (v) {
        var n = parseValue(v);
        if (this.sign !== n.sign) {
            return this.add(n.negate());
        }
        var a = this.value, b = n.value;
        if (n.isSmall)
            return subtractSmall(a, Math.abs(b), this.sign);
        return subtractAny(a, b, this.sign);
    };
    BigInteger.prototype.minus = BigInteger.prototype.subtract;

    SmallInteger.prototype.subtract = function (v) {
        var n = parseValue(v);
        var a = this.value;
        if (a < 0 !== n.sign) {
            return this.add(n.negate());
        }
        var b = n.value;
        if (n.isSmall) {
            return new SmallInteger(a - b);
        }
        return subtractSmall(b, Math.abs(a), a >= 0);
    };
    SmallInteger.prototype.minus = SmallInteger.prototype.subtract;

    BigInteger.prototype.negate = function () {
        return new BigInteger(this.value, !this.sign);
    };
    SmallInteger.prototype.negate = function () {
        var sign = this.sign;
        var small = new SmallInteger(-this.value);
        small.sign = !sign;
        return small;
    };

    BigInteger.prototype.abs = function () {
        return new BigInteger(this.value, false);
    };
    SmallInteger.prototype.abs = function () {
        return new SmallInteger(Math.abs(this.value));
    };

    function multiplyLong(a, b) {
        var a_l = a.length,
            b_l = b.length,
            l = a_l + b_l,
            r = createArray(l),
            base = BASE,
            product, carry, i, a_i, b_j;
        for (i = 0; i < a_l; ++i) {
            a_i = a[i];
            for (var j = 0; j < b_l; ++j) {
                b_j = b[j];
                product = a_i * b_j + r[i + j];
                carry = Math.floor(product / base);
                r[i + j] = product - carry * base;
                r[i + j + 1] += carry;
            }
        }
        trim(r);
        return r;
    }

    function multiplySmall(a, b) { // assumes a is array, b is number with |b| < BASE
        var l = a.length,
            r = new Array(l),
            base = BASE,
            carry = 0,
            product, i;
        for (i = 0; i < l; i++) {
            product = a[i] * b + carry;
            carry = Math.floor(product / base);
            r[i] = product - carry * base;
        }
        while (carry > 0) {
            r[i++] = carry % base;
            carry = Math.floor(carry / base);
        }
        return r;
    }

    function shiftLeft(x, n) {
        var r = [];
        while (n-- > 0) r.push(0);
        return r.concat(x);
    }

    function multiplyKaratsuba(x, y) {
        var n = Math.max(x.length, y.length);

        if (n <= 30) return multiplyLong(x, y);
        n = Math.ceil(n / 2);

        var b = x.slice(n),
            a = x.slice(0, n),
            d = y.slice(n),
            c = y.slice(0, n);

        var ac = multiplyKaratsuba(a, c),
            bd = multiplyKaratsuba(b, d),
            abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));

        var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));
        trim(product);
        return product;
    }

    // The following function is derived from a surface fit of a graph plotting the performance difference
    // between long multiplication and karatsuba multiplication versus the lengths of the two arrays.
    function useKaratsuba(l1, l2) {
        return -0.012 * l1 - 0.012 * l2 + 0.000015 * l1 * l2 > 0;
    }

    BigInteger.prototype.multiply = function (v) {
        var n = parseValue(v),
            a = this.value, b = n.value,
            sign = this.sign !== n.sign,
            abs;
        if (n.isSmall) {
            if (b === 0) return Integer[0];
            if (b === 1) return this;
            if (b === -1) return this.negate();
            abs = Math.abs(b);
            if (abs < BASE) {
                return new BigInteger(multiplySmall(a, abs), sign);
            }
            b = smallToArray(abs);
        }
        if (useKaratsuba(a.length, b.length)) // Karatsuba is only faster for certain array sizes
            return new BigInteger(multiplyKaratsuba(a, b), sign);
        return new BigInteger(multiplyLong(a, b), sign);
    };

    BigInteger.prototype.times = BigInteger.prototype.multiply;

    function multiplySmallAndArray(a, b, sign) { // a >= 0
        if (a < BASE) {
            return new BigInteger(multiplySmall(b, a), sign);
        }
        return new BigInteger(multiplyLong(b, smallToArray(a)), sign);
    }
    SmallInteger.prototype._multiplyBySmall = function (a) {
            if (isPrecise(a.value * this.value)) {
                return new SmallInteger(a.value * this.value);
            }
            return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);
    };
    BigInteger.prototype._multiplyBySmall = function (a) {
            if (a.value === 0) return Integer[0];
            if (a.value === 1) return this;
            if (a.value === -1) return this.negate();
            return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);
    };
    SmallInteger.prototype.multiply = function (v) {
        return parseValue(v)._multiplyBySmall(this);
    };
    SmallInteger.prototype.times = SmallInteger.prototype.multiply;

    function square(a) {
        var l = a.length,
            r = createArray(l + l),
            base = BASE,
            product, carry, i, a_i, a_j;
        for (i = 0; i < l; i++) {
            a_i = a[i];
            for (var j = 0; j < l; j++) {
                a_j = a[j];
                product = a_i * a_j + r[i + j];
                carry = Math.floor(product / base);
                r[i + j] = product - carry * base;
                r[i + j + 1] += carry;
            }
        }
        trim(r);
        return r;
    }

    BigInteger.prototype.square = function () {
        return new BigInteger(square(this.value), false);
    };

    SmallInteger.prototype.square = function () {
        var value = this.value * this.value;
        if (isPrecise(value)) return new SmallInteger(value);
        return new BigInteger(square(smallToArray(Math.abs(this.value))), false);
    };

    function divMod1(a, b) { // Left over from previous version. Performs faster than divMod2 on smaller input sizes.
        var a_l = a.length,
            b_l = b.length,
            base = BASE,
            result = createArray(b.length),
            divisorMostSignificantDigit = b[b_l - 1],
            // normalization
            lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)),
            remainder = multiplySmall(a, lambda),
            divisor = multiplySmall(b, lambda),
            quotientDigit, shift, carry, borrow, i, l, q;
        if (remainder.length <= a_l) remainder.push(0);
        divisor.push(0);
        divisorMostSignificantDigit = divisor[b_l - 1];
        for (shift = a_l - b_l; shift >= 0; shift--) {
            quotientDigit = base - 1;
            if (remainder[shift + b_l] !== divisorMostSignificantDigit) {
              quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);
            }
            // quotientDigit <= base - 1
            carry = 0;
            borrow = 0;
            l = divisor.length;
            for (i = 0; i < l; i++) {
                carry += quotientDigit * divisor[i];
                q = Math.floor(carry / base);
                borrow += remainder[shift + i] - (carry - q * base);
                carry = q;
                if (borrow < 0) {
                    remainder[shift + i] = borrow + base;
                    borrow = -1;
                } else {
                    remainder[shift + i] = borrow;
                    borrow = 0;
                }
            }
            while (borrow !== 0) {
                quotientDigit -= 1;
                carry = 0;
                for (i = 0; i < l; i++) {
                    carry += remainder[shift + i] - base + divisor[i];
                    if (carry < 0) {
                        remainder[shift + i] = carry + base;
                        carry = 0;
                    } else {
                        remainder[shift + i] = carry;
                        carry = 1;
                    }
                }
                borrow += carry;
            }
            result[shift] = quotientDigit;
        }
        // denormalization
        remainder = divModSmall(remainder, lambda)[0];
        return [arrayToSmall(result), arrayToSmall(remainder)];
    }

    function divMod2(a, b) { // Implementation idea shamelessly stolen from Silent Matt's library http://silentmatt.com/biginteger/
        // Performs faster than divMod1 on larger input sizes.
        var a_l = a.length,
            b_l = b.length,
            result = [],
            part = [],
            base = BASE,
            guess, xlen, highx, highy, check;
        while (a_l) {
            part.unshift(a[--a_l]);
            trim(part);
            if (compareAbs(part, b) < 0) {
                result.push(0);
                continue;
            }
            xlen = part.length;
            highx = part[xlen - 1] * base + part[xlen - 2];
            highy = b[b_l - 1] * base + b[b_l - 2];
            if (xlen > b_l) {
                highx = (highx + 1) * base;
            }
            guess = Math.ceil(highx / highy);
            do {
                check = multiplySmall(b, guess);
                if (compareAbs(check, part) <= 0) break;
                guess--;
            } while (guess);
            result.push(guess);
            part = subtract(part, check);
        }
        result.reverse();
        return [arrayToSmall(result), arrayToSmall(part)];
    }

    function divModSmall(value, lambda) {
        var length = value.length,
            quotient = createArray(length),
            base = BASE,
            i, q, remainder, divisor;
        remainder = 0;
        for (i = length - 1; i >= 0; --i) {
            divisor = remainder * base + value[i];
            q = truncate(divisor / lambda);
            remainder = divisor - q * lambda;
            quotient[i] = q | 0;
        }
        return [quotient, remainder | 0];
    }

    function divModAny(self, v) {
        var value, n = parseValue(v);
        var a = self.value, b = n.value;
        var quotient;
        if (b === 0) throw new Error("Cannot divide by zero");
        if (self.isSmall) {
            if (n.isSmall) {
                return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];
            }
            return [Integer[0], self];
        }
        if (n.isSmall) {
            if (b === 1) return [self, Integer[0]];
            if (b == -1) return [self.negate(), Integer[0]];
            var abs = Math.abs(b);
            if (abs < BASE) {
                value = divModSmall(a, abs);
                quotient = arrayToSmall(value[0]);
                var remainder = value[1];
                if (self.sign) remainder = -remainder;
                if (typeof quotient === "number") {
                    if (self.sign !== n.sign) quotient = -quotient;
                    return [new SmallInteger(quotient), new SmallInteger(remainder)];
                }
                return [new BigInteger(quotient, self.sign !== n.sign), new SmallInteger(remainder)];
            }
            b = smallToArray(abs);
        }
        var comparison = compareAbs(a, b);
        if (comparison === -1) return [Integer[0], self];
        if (comparison === 0) return [Integer[self.sign === n.sign ? 1 : -1], Integer[0]];

        // divMod1 is faster on smaller input sizes
        if (a.length + b.length <= 200)
            value = divMod1(a, b);
        else value = divMod2(a, b);

        quotient = value[0];
        var qSign = self.sign !== n.sign,
            mod = value[1],
            mSign = self.sign;
        if (typeof quotient === "number") {
            if (qSign) quotient = -quotient;
            quotient = new SmallInteger(quotient);
        } else quotient = new BigInteger(quotient, qSign);
        if (typeof mod === "number") {
            if (mSign) mod = -mod;
            mod = new SmallInteger(mod);
        } else mod = new BigInteger(mod, mSign);
        return [quotient, mod];
    }

    BigInteger.prototype.divmod = function (v) {
        var result = divModAny(this, v);
        return {
            quotient: result[0],
            remainder: result[1]
        };
    };
    SmallInteger.prototype.divmod = BigInteger.prototype.divmod;

    BigInteger.prototype.divide = function (v) {
        return divModAny(this, v)[0];
    };
    SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;

    BigInteger.prototype.mod = function (v) {
        return divModAny(this, v)[1];
    };
    SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;

    BigInteger.prototype.pow = function (v) {
        var n = parseValue(v),
            a = this.value,
            b = n.value,
            value, x, y;
        if (b === 0) return Integer[1];
        if (a === 0) return Integer[0];
        if (a === 1) return Integer[1];
        if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];
        if (n.sign) {
            return Integer[0];
        }
        if (!n.isSmall) throw new Error("The exponent " + n.toString() + " is too large.");
        if (this.isSmall) {
            if (isPrecise(value = Math.pow(a, b)))
                return new SmallInteger(truncate(value));
        }
        x = this;
        y = Integer[1];
        while (true) {
            if (b & 1 === 1) {
                y = y.times(x);
                --b;
            }
            if (b === 0) break;
            b /= 2;
            x = x.square();
        }
        return y;
    };
    SmallInteger.prototype.pow = BigInteger.prototype.pow;

    BigInteger.prototype.modPow = function (exp, mod) {
        exp = parseValue(exp);
        mod = parseValue(mod);
        if (mod.isZero()) throw new Error("Cannot take modPow with modulus 0");
        var r = Integer[1],
            base = this.mod(mod);
        while (exp.isPositive()) {
            if (base.isZero()) return Integer[0];
            if (exp.isOdd()) r = r.multiply(base).mod(mod);
            exp = exp.divide(2);
            base = base.square().mod(mod);
        }
        return r;
    };
    SmallInteger.prototype.modPow = BigInteger.prototype.modPow;

    function compareAbs(a, b) {
        if (a.length !== b.length) {
            return a.length > b.length ? 1 : -1;
        }
        for (var i = a.length - 1; i >= 0; i--) {
            if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;
        }
        return 0;
    }

    BigInteger.prototype.compareAbs = function (v) {
        var n = parseValue(v),
            a = this.value,
            b = n.value;
        if (n.isSmall) return 1;
        return compareAbs(a, b);
    };
    SmallInteger.prototype.compareAbs = function (v) {
        var n = parseValue(v),
            a = Math.abs(this.value),
            b = n.value;
        if (n.isSmall) {
            b = Math.abs(b);
            return a === b ? 0 : a > b ? 1 : -1;
        }
        return -1;
    };

    BigInteger.prototype.compare = function (v) {
        // See discussion about comparison with Infinity:
        // https://github.com/peterolson/BigInteger.js/issues/61
        if (v === Infinity) {
            return -1;
        }
        if (v === -Infinity) {
            return 1;
        }

        var n = parseValue(v),
            a = this.value,
            b = n.value;
        if (this.sign !== n.sign) {
            return n.sign ? 1 : -1;
        }
        if (n.isSmall) {
            return this.sign ? -1 : 1;
        }
        return compareAbs(a, b) * (this.sign ? -1 : 1);
    };
    BigInteger.prototype.compareTo = BigInteger.prototype.compare;

    SmallInteger.prototype.compare = function (v) {
        if (v === Infinity) {
            return -1;
        }
        if (v === -Infinity) {
            return 1;
        }

        var n = parseValue(v),
            a = this.value,
            b = n.value;
        if (n.isSmall) {
            return a == b ? 0 : a > b ? 1 : -1;
        }
        if (a < 0 !== n.sign) {
            return a < 0 ? -1 : 1;
        }
        return a < 0 ? 1 : -1;
    };
    SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;

    BigInteger.prototype.equals = function (v) {
        return this.compare(v) === 0;
    };
    SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;

    BigInteger.prototype.notEquals = function (v) {
        return this.compare(v) !== 0;
    };
    SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;

    BigInteger.prototype.greater = function (v) {
        return this.compare(v) > 0;
    };
    SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;

    BigInteger.prototype.lesser = function (v) {
        return this.compare(v) < 0;
    };
    SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;

    BigInteger.prototype.greaterOrEquals = function (v) {
        return this.compare(v) >= 0;
    };
    SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;

    BigInteger.prototype.lesserOrEquals = function (v) {
        return this.compare(v) <= 0;
    };
    SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;

    BigInteger.prototype.isEven = function () {
        return (this.value[0] & 1) === 0;
    };
    SmallInteger.prototype.isEven = function () {
        return (this.value & 1) === 0;
    };

    BigInteger.prototype.isOdd = function () {
        return (this.value[0] & 1) === 1;
    };
    SmallInteger.prototype.isOdd = function () {
        return (this.value & 1) === 1;
    };

    BigInteger.prototype.isPositive = function () {
        return !this.sign;
    };
    SmallInteger.prototype.isPositive = function () {
        return this.value > 0;
    };

    BigInteger.prototype.isNegative = function () {
        return this.sign;
    };
    SmallInteger.prototype.isNegative = function () {
        return this.value < 0;
    };

    BigInteger.prototype.isUnit = function () {
        return false;
    };
    SmallInteger.prototype.isUnit = function () {
        return Math.abs(this.value) === 1;
    };

    BigInteger.prototype.isZero = function () {
        return false;
    };
    SmallInteger.prototype.isZero = function () {
        return this.value === 0;
    };
    BigInteger.prototype.isDivisibleBy = function (v) {
        var n = parseValue(v);
        var value = n.value;
        if (value === 0) return false;
        if (value === 1) return true;
        if (value === 2) return this.isEven();
        return this.mod(n).equals(Integer[0]);
    };
    SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;

    function isBasicPrime(v) {
        var n = v.abs();
        if (n.isUnit()) return false;
        if (n.equals(2) || n.equals(3) || n.equals(5)) return true;
        if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;
        if (n.lesser(25)) return true;
        // we don't know if it's prime: let the other functions figure it out
    }

    BigInteger.prototype.isPrime = function () {
        var isPrime = isBasicPrime(this);
        if (isPrime !== undefined) return isPrime;
        var n = this.abs(),
            nPrev = n.prev();
        var a = [2, 3, 5, 7, 11, 13, 17, 19],
            b = nPrev,
            d, t, i, x;
        while (b.isEven()) b = b.divide(2);
        for (i = 0; i < a.length; i++) {
            x = bigInt(a[i]).modPow(b, n);
            if (x.equals(Integer[1]) || x.equals(nPrev)) continue;
            for (t = true, d = b; t && d.lesser(nPrev) ; d = d.multiply(2)) {
                x = x.square().mod(n);
                if (x.equals(nPrev)) t = false;
            }
            if (t) return false;
        }
        return true;
    };
    SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;

    BigInteger.prototype.isProbablePrime = function (iterations) {
        var isPrime = isBasicPrime(this);
        if (isPrime !== undefined) return isPrime;
        var n = this.abs();
        var t = iterations === undefined ? 5 : iterations;
        // use the Fermat primality test
        for (var i = 0; i < t; i++) {
            var a = bigInt.randBetween(2, n.minus(2));
            if (!a.modPow(n.prev(), n).isUnit()) return false; // definitely composite
        }
        return true; // large chance of being prime
    };
    SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;

    BigInteger.prototype.modInv = function (n) {
        var t = bigInt.zero, newT = bigInt.one, r = parseValue(n), newR = this.abs(), q, lastT, lastR;
        while (!newR.equals(bigInt.zero)) {
            q = r.divide(newR);
            lastT = t;
            lastR = r;
            t = newT;
            r = newR;
            newT = lastT.subtract(q.multiply(newT));
            newR = lastR.subtract(q.multiply(newR));
        }
        if (!r.equals(1)) throw new Error(this.toString() + " and " + n.toString() + " are not co-prime");
        if (t.compare(0) === -1) {
            t = t.add(n);
        }
        if (this.isNegative()) {
            return t.negate();
        }
        return t;
    };

    SmallInteger.prototype.modInv = BigInteger.prototype.modInv;

    BigInteger.prototype.next = function () {
        var value = this.value;
        if (this.sign) {
            return subtractSmall(value, 1, this.sign);
        }
        return new BigInteger(addSmall(value, 1), this.sign);
    };
    SmallInteger.prototype.next = function () {
        var value = this.value;
        if (value + 1 < MAX_INT) return new SmallInteger(value + 1);
        return new BigInteger(MAX_INT_ARR, false);
    };

    BigInteger.prototype.prev = function () {
        var value = this.value;
        if (this.sign) {
            return new BigInteger(addSmall(value, 1), true);
        }
        return subtractSmall(value, 1, this.sign);
    };
    SmallInteger.prototype.prev = function () {
        var value = this.value;
        if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);
        return new BigInteger(MAX_INT_ARR, true);
    };

    var powersOfTwo = [1];
    while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE) powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);
    var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];

    function shift_isSmall(n) {
        return ((typeof n === "number" || typeof n === "string") && +Math.abs(n) <= BASE) ||
            (n instanceof BigInteger && n.value.length <= 1);
    }

    BigInteger.prototype.shiftLeft = function (n) {
        if (!shift_isSmall(n)) {
            throw new Error(String(n) + " is too large for shifting.");
        }
        n = +n;
        if (n < 0) return this.shiftRight(-n);
        var result = this;
        while (n >= powers2Length) {
            result = result.multiply(highestPower2);
            n -= powers2Length - 1;
        }
        return result.multiply(powersOfTwo[n]);
    };
    SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;

    BigInteger.prototype.shiftRight = function (n) {
        var remQuo;
        if (!shift_isSmall(n)) {
            throw new Error(String(n) + " is too large for shifting.");
        }
        n = +n;
        if (n < 0) return this.shiftLeft(-n);
        var result = this;
        while (n >= powers2Length) {
            if (result.isZero()) return result;
            remQuo = divModAny(result, highestPower2);
            result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
            n -= powers2Length - 1;
        }
        remQuo = divModAny(result, powersOfTwo[n]);
        return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
    };
    SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;

    function bitwise(x, y, fn) {
        y = parseValue(y);
        var xSign = x.isNegative(), ySign = y.isNegative();
        var xRem = xSign ? x.not() : x,
            yRem = ySign ? y.not() : y;
        var xDigit = 0, yDigit = 0;
        var xDivMod = null, yDivMod = null;
        var result = [];
        while (!xRem.isZero() || !yRem.isZero()) {
            xDivMod = divModAny(xRem, highestPower2);
            xDigit = xDivMod[1].toJSNumber();
            if (xSign) {
                xDigit = highestPower2 - 1 - xDigit; // two's complement for negative numbers
            }

            yDivMod = divModAny(yRem, highestPower2);
            yDigit = yDivMod[1].toJSNumber();
            if (ySign) {
                yDigit = highestPower2 - 1 - yDigit; // two's complement for negative numbers
            }

            xRem = xDivMod[0];
            yRem = yDivMod[0];
            result.push(fn(xDigit, yDigit));
        }
        var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);
        for (var i = result.length - 1; i >= 0; i -= 1) {
            sum = sum.multiply(highestPower2).add(bigInt(result[i]));
        }
        return sum;
    }

    BigInteger.prototype.not = function () {
        return this.negate().prev();
    };
    SmallInteger.prototype.not = BigInteger.prototype.not;

    BigInteger.prototype.and = function (n) {
        return bitwise(this, n, function (a, b) { return a & b; });
    };
    SmallInteger.prototype.and = BigInteger.prototype.and;

    BigInteger.prototype.or = function (n) {
        return bitwise(this, n, function (a, b) { return a | b; });
    };
    SmallInteger.prototype.or = BigInteger.prototype.or;

    BigInteger.prototype.xor = function (n) {
        return bitwise(this, n, function (a, b) { return a ^ b; });
    };
    SmallInteger.prototype.xor = BigInteger.prototype.xor;

    var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;
    function roughLOB(n) { // get lowestOneBit (rough)
        // SmallInteger: return Min(lowestOneBit(n), 1 << 30)
        // BigInteger: return Min(lowestOneBit(n), 1 << 14) [BASE=1e7]
        var v = n.value, x = typeof v === "number" ? v | LOBMASK_I : v[0] + v[1] * BASE | LOBMASK_BI;
        return x & -x;
    }

    function max(a, b) {
        a = parseValue(a);
        b = parseValue(b);
        return a.greater(b) ? a : b;
    }
    function min(a, b) {
        a = parseValue(a);
        b = parseValue(b);
        return a.lesser(b) ? a : b;
    }
    function gcd(a, b) {
        a = parseValue(a).abs();
        b = parseValue(b).abs();
        if (a.equals(b)) return a;
        if (a.isZero()) return b;
        if (b.isZero()) return a;
        var c = Integer[1], d, t;
        while (a.isEven() && b.isEven()) {
            d = Math.min(roughLOB(a), roughLOB(b));
            a = a.divide(d);
            b = b.divide(d);
            c = c.multiply(d);
        }
        while (a.isEven()) {
            a = a.divide(roughLOB(a));
        }
        do {
            while (b.isEven()) {
                b = b.divide(roughLOB(b));
            }
            if (a.greater(b)) {
                t = b; b = a; a = t;
            }
            b = b.subtract(a);
        } while (!b.isZero());
        return c.isUnit() ? a : a.multiply(c);
    }
    function lcm(a, b) {
        a = parseValue(a).abs();
        b = parseValue(b).abs();
        return a.divide(gcd(a, b)).multiply(b);
    }
    function randBetween(a, b) {
        a = parseValue(a);
        b = parseValue(b);
        var low = min(a, b), high = max(a, b);
        var range = high.subtract(low).add(1);
        if (range.isSmall) return low.add(Math.floor(Math.random() * range));
        var length = range.value.length - 1;
        var result = [], restricted = true;
        for (var i = length; i >= 0; i--) {
            var top = restricted ? range.value[i] : BASE;
            var digit = truncate(Math.random() * top);
            result.unshift(digit);
            if (digit < top) restricted = false;
        }
        result = arrayToSmall(result);
        return low.add(typeof result === "number" ? new SmallInteger(result) : new BigInteger(result, false));
    }
    var parseBase = function (text, base) {
        var length = text.length;
		var i;
		var absBase = Math.abs(base);
		for(var i = 0; i < length; i++) {
			var c = text[i].toLowerCase();
			if(c === "-") continue;
			if(/[a-z0-9]/.test(c)) {
			    if(/[0-9]/.test(c) && +c >= absBase) {
					if(c === "1" && absBase === 1) continue;
                    throw new Error(c + " is not a valid digit in base " + base + ".");
				} else if(c.charCodeAt(0) - 87 >= absBase) {
					throw new Error(c + " is not a valid digit in base " + base + ".");
				}
			}
		}
        if (2 <= base && base <= 36) {
            if (length <= LOG_MAX_INT / Math.log(base)) {
				var result = parseInt(text, base);
				if(isNaN(result)) {
					throw new Error(c + " is not a valid digit in base " + base + ".");
				}
                return new SmallInteger(parseInt(text, base));
            }
        }
        base = parseValue(base);
        var digits = [];
        var isNegative = text[0] === "-";
        for (i = isNegative ? 1 : 0; i < text.length; i++) {
            var c = text[i].toLowerCase(),
                charCode = c.charCodeAt(0);
            if (48 <= charCode && charCode <= 57) digits.push(parseValue(c));
            else if (97 <= charCode && charCode <= 122) digits.push(parseValue(c.charCodeAt(0) - 87));
            else if (c === "<") {
                var start = i;
                do { i++; } while (text[i] !== ">");
                digits.push(parseValue(text.slice(start + 1, i)));
            }
            else throw new Error(c + " is not a valid character");
        }
        return parseBaseFromArray(digits, base, isNegative);
    };

    function parseBaseFromArray(digits, base, isNegative) {
        var val = Integer[0], pow = Integer[1], i;
        for (i = digits.length - 1; i >= 0; i--) {
            val = val.add(digits[i].times(pow));
            pow = pow.times(base);
        }
        return isNegative ? val.negate() : val;
    }

    function stringify(digit) {
        if (digit <= 35) {
            return "0123456789abcdefghijklmnopqrstuvwxyz".charAt(digit);
        }
        return "<" + digit + ">";
    }

    function toBase(n, base) {
        base = bigInt(base);
        if (base.isZero()) {
            if (n.isZero()) return {value: [0], isNegative: false};
            throw new Error("Cannot convert nonzero numbers to base 0.");
        }
        if (base.equals(-1)) {
            if (n.isZero()) return {value: [0], isNegative: false};
            if (n.isNegative())
              return {
                value: [].concat.apply([], Array.apply(null, Array(-n))
                            .map(Array.prototype.valueOf, [1, 0])
                          ),
                isNegative: false
              };

            var arr = Array.apply(null, Array(+n - 1))
              .map(Array.prototype.valueOf, [0, 1]);
            arr.unshift([1]);
            return {
              value: [].concat.apply([], arr),
              isNegative: false
            };
        }

        var neg = false;
        if (n.isNegative() && base.isPositive()) {
            neg = true;
            n = n.abs();
        }
        if (base.equals(1)) {
            if (n.isZero()) return {value: [0], isNegative: false};
            
            return {
              value: Array.apply(null, Array(+n))
                       .map(Number.prototype.valueOf, 1),
              isNegative: neg
            };
        }
        var out = [];
        var left = n, divmod;
        while (left.isNegative() || left.compareAbs(base) >= 0) {
            divmod = left.divmod(base);
            left = divmod.quotient;
            var digit = divmod.remainder;
            if (digit.isNegative()) {
                digit = base.minus(digit).abs();
                left = left.next();
            }
            out.push(digit.toJSNumber());
        }
        out.push(left.toJSNumber());
        return {value: out.reverse(), isNegative: neg};
    }

    function toBaseString(n, base) {
        var arr = toBase(n, base);
        return (arr.isNegative ? "-" : "") + arr.value.map(stringify).join('');
    }

    BigInteger.prototype.toArray = function (radix) {
      return toBase(this, radix);
    };

    SmallInteger.prototype.toArray = function (radix) {
      return toBase(this, radix);
    };

    BigInteger.prototype.toString = function (radix) {
        if (radix === undefined) radix = 10;
        if (radix !== 10) return toBaseString(this, radix);
        var v = this.value, l = v.length, str = String(v[--l]), zeros = "0000000", digit;
        while (--l >= 0) {
            digit = String(v[l]);
            str += zeros.slice(digit.length) + digit;
        }
        var sign = this.sign ? "-" : "";
        return sign + str;
    };

    SmallInteger.prototype.toString = function (radix) {
        if (radix === undefined) radix = 10;
        if (radix != 10) return toBaseString(this, radix);
        return String(this.value);
    };
    BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function() { return this.toString(); }

    BigInteger.prototype.valueOf = function () {
        return parseInt(this.toString(), 10);
    };
    BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;

    SmallInteger.prototype.valueOf = function () {
        return this.value;
    };
    SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;

    function parseStringValue(v) {
            if (isPrecise(+v)) {
                var x = +v;
                if (x === truncate(x))
                    return new SmallInteger(x);
                throw "Invalid integer: " + v;
            }
            var sign = v[0] === "-";
            if (sign) v = v.slice(1);
            var split = v.split(/e/i);
            if (split.length > 2) throw new Error("Invalid integer: " + split.join("e"));
            if (split.length === 2) {
                var exp = split[1];
                if (exp[0] === "+") exp = exp.slice(1);
                exp = +exp;
                if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error("Invalid integer: " + exp + " is not a valid exponent.");
                var text = split[0];
                var decimalPlace = text.indexOf(".");
                if (decimalPlace >= 0) {
                    exp -= text.length - decimalPlace - 1;
                    text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);
                }
                if (exp < 0) throw new Error("Cannot include negative exponent part for integers");
                text += (new Array(exp + 1)).join("0");
                v = text;
            }
            var isValid = /^([0-9][0-9]*)$/.test(v);
            if (!isValid) throw new Error("Invalid integer: " + v);
            var r = [], max = v.length, l = LOG_BASE, min = max - l;
            while (max > 0) {
                r.push(+v.slice(min, max));
                min -= l;
                if (min < 0) min = 0;
                max -= l;
            }
            trim(r);
            return new BigInteger(r, sign);
    }

    function parseNumberValue(v) {
        if (isPrecise(v)) {
            if (v !== truncate(v)) throw new Error(v + " is not an integer.");
            return new SmallInteger(v);
        }
        return parseStringValue(v.toString());
    }

    function parseValue(v) {
        if (typeof v === "number") {
            return parseNumberValue(v);
        }
        if (typeof v === "string") {
            return parseStringValue(v);
        }
        return v;
    }
    // Pre-define numbers in range [-999,999]
    for (var i = 0; i < 1000; i++) {
        Integer[i] = new SmallInteger(i);
        if (i > 0) Integer[-i] = new SmallInteger(-i);
    }
    // Backwards compatibility
    Integer.one = Integer[1];
    Integer.zero = Integer[0];
    Integer.minusOne = Integer[-1];
    Integer.max = max;
    Integer.min = min;
    Integer.gcd = gcd;
    Integer.lcm = lcm;
    Integer.isInstance = function (x) { return x instanceof BigInteger || x instanceof SmallInteger; };
    Integer.randBetween = randBetween;

    Integer.fromArray = function (digits, base, isNegative) {
        return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);
    };

    return Integer;
})();

// Node.js check
if (typeof module !== "undefined" && module.hasOwnProperty("exports")) {
    module.exports = bigInt;
}

//amd check
if ( true ) {
  !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
    return bigInt;
  }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../pow-wasm/node_modules/webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "../crypto/node_modules/regenerator-runtime/runtime-module.js":
/*!********************************************************************!*\
  !*** ../crypto/node_modules/regenerator-runtime/runtime-module.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g = (function() { return this })() || Function("return this")();

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = __webpack_require__(/*! ./runtime */ "../crypto/node_modules/regenerator-runtime/runtime.js");

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}


/***/ }),

/***/ "../crypto/node_modules/regenerator-runtime/runtime.js":
/*!*************************************************************!*\
  !*** ../crypto/node_modules/regenerator-runtime/runtime.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  (function() { return this })() || Function("return this")()
);


/***/ }),

/***/ "../data/dist/data/address.js":
/*!************************************!*\
  !*** ../data/dist/data/address.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ "../core/dist/helpers/objectHelper.js");

var dataError_1 = __webpack_require__(/*! ../error/dataError */ "../data/dist/error/dataError.js");

var trytes_1 = __webpack_require__(/*! ./trytes */ "../data/dist/data/trytes.js");
/**
 * A class for handling addresses.
 */


var Address =
/*#__PURE__*/
function () {
  /* @internal */
  function Address(addressTrytes, checksumTrytes) {
    _classCallCheck(this, Address);

    this._addressTrytes = addressTrytes;
    this._checksumTrytes = checksumTrytes;
  }
  /**
   * Create address from trytes.
   * @param address The trytes to create the address from.
   * @returns An instance of Address.
   */


  _createClass(Address, [{
    key: "toTrytes",

    /**
     * Convert the address to trytes with no checksum.
     * @returns Trytes version of the address with no checksum.
     */
    value: function toTrytes() {
      return trytes_1.Trytes.fromString(this._addressTrytes);
    }
    /**
     * Convert the address to trytes with a checksum, creating a blank one if needed.
     * @returns Trytes version of the address with checksu,.
     */

  }, {
    key: "toTrytesWithChecksum",
    value: function toTrytesWithChecksum() {
      if (!objectHelper_1.ObjectHelper.isEmpty(this._checksumTrytes)) {
        return trytes_1.Trytes.fromString(this._addressTrytes + this._checksumTrytes);
      } else {
        throw new dataError_1.DataError("This address has no checksum calculated for it");
      }
    }
    /**
     * Get the string view of the object.
     * @returns string of the trytes.
     */

  }, {
    key: "toString",
    value: function toString() {
      if (!objectHelper_1.ObjectHelper.isEmpty(this._checksumTrytes)) {
        return this._addressTrytes + this._checksumTrytes;
      } else {
        return this._addressTrytes;
      }
    }
  }], [{
    key: "fromTrytes",
    value: function fromTrytes(address) {
      if (!objectHelper_1.ObjectHelper.isType(address, trytes_1.Trytes)) {
        throw new dataError_1.DataError("The address should be a valid Trytes object");
      }

      var trytesString = address.toString();

      if (trytesString.length !== Address.LENGTH && trytesString.length !== Address.LENGTH_WITH_CHECKSUM) {
        throw new dataError_1.DataError("The address should either be ".concat(Address.LENGTH, " or ").concat(Address.LENGTH_WITH_CHECKSUM, " characters in length"), {
          length: trytesString.length
        });
      }

      var addressTrytes = trytesString.substr(0, Address.LENGTH);
      var checksumTrytes;

      if (trytesString.length === Address.LENGTH_WITH_CHECKSUM) {
        checksumTrytes = trytesString.substr(Address.LENGTH);
      }

      return new Address(addressTrytes, checksumTrytes);
    }
  }]);

  return Address;
}();
/**
 * The length for a valid address without checksum (81).
 */


Address.LENGTH = 81;
/**
 * The length for an address checksum (9).
 */

Address.LENGTH_CHECKSUM = 9;
/**
 * The length for valid address with checksum (90).
 */

Address.LENGTH_WITH_CHECKSUM = Address.LENGTH + Address.LENGTH_CHECKSUM;
/**
 * An empty hash all 9s.
 */

Address.EMPTY = Address.fromTrytes(trytes_1.Trytes.fromString("9".repeat(Address.LENGTH)));
exports.Address = Address;

/***/ }),

/***/ "../data/dist/data/hash.js":
/*!*********************************!*\
  !*** ../data/dist/data/hash.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ "../core/dist/helpers/objectHelper.js");

var dataError_1 = __webpack_require__(/*! ../error/dataError */ "../data/dist/error/dataError.js");

var trytes_1 = __webpack_require__(/*! ./trytes */ "../data/dist/data/trytes.js");
/**
 * A class for handling hashes.
 */


var Hash =
/*#__PURE__*/
function () {
  /* @internal */
  function Hash(trytes) {
    _classCallCheck(this, Hash);

    this._trytes = trytes;
  }
  /**
   * Create hash from trytes.
   * @param hash The trytes to create the hash from.
   * @returns An instance of Hash.
   */


  _createClass(Hash, [{
    key: "toTrytes",

    /**
     * Convert the hash to trytes.
     * @returns Trytes version of the hash.
     */
    value: function toTrytes() {
      return this._trytes;
    }
    /**
     * Get the string view of the object.
     * @returns string of the trytes.
     */

  }, {
    key: "toString",
    value: function toString() {
      return this._trytes.toString();
    }
  }], [{
    key: "fromTrytes",
    value: function fromTrytes(hash) {
      if (!objectHelper_1.ObjectHelper.isType(hash, trytes_1.Trytes)) {
        throw new dataError_1.DataError("The hash should be a valid Trytes object");
      }

      var length = hash.length();

      if (length !== Hash.LENGTH) {
        throw new dataError_1.DataError("The hash should be ".concat(Hash.LENGTH, " characters in length"), {
          length: length
        });
      }

      return new Hash(hash);
    }
  }]);

  return Hash;
}();
/**
 * The length for a valid hash (81).
 */


Hash.LENGTH = 81;
/**
 * An empty hash all 9s.
 */

Hash.EMPTY = Hash.fromTrytes(trytes_1.Trytes.fromString("9".repeat(Hash.LENGTH)));
exports.Hash = Hash;

/***/ }),

/***/ "../data/dist/data/signatureMessageFragment.js":
/*!*****************************************************!*\
  !*** ../data/dist/data/signatureMessageFragment.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ "../core/dist/helpers/objectHelper.js");

var dataError_1 = __webpack_require__(/*! ../error/dataError */ "../data/dist/error/dataError.js");

var trytes_1 = __webpack_require__(/*! ./trytes */ "../data/dist/data/trytes.js");
/**
 * A class for handling signature message fragments.
 */


var SignatureMessageFragment =
/*#__PURE__*/
function () {
  /* @internal */
  function SignatureMessageFragment(trytes) {
    _classCallCheck(this, SignatureMessageFragment);

    this._trytes = trytes;
  }
  /**
   * Create signature fragment from trytes.
   * @param signatureMessageFragment The trytes to create the signature fragment from.
   * @returns An instance of SignatureMessageFragment.
   */


  _createClass(SignatureMessageFragment, [{
    key: "toTrytes",

    /**
     * Convert the signature fragment to trytes.
     * @returns Trytes version of the signature fragment.
     */
    value: function toTrytes() {
      return this._trytes;
    }
    /**
     * Get the string view of the object.
     * @returns string of the trytes.
     */

  }, {
    key: "toString",
    value: function toString() {
      return this._trytes.toString();
    }
  }], [{
    key: "fromTrytes",
    value: function fromTrytes(signatureMessageFragment) {
      if (!objectHelper_1.ObjectHelper.isType(signatureMessageFragment, trytes_1.Trytes)) {
        throw new dataError_1.DataError("The signatureMessageFragment should be a valid Trytes object");
      }

      var length = signatureMessageFragment.length();

      if (length !== SignatureMessageFragment.LENGTH) {
        throw new dataError_1.DataError("The signatureMessageFragment should be ".concat(SignatureMessageFragment.LENGTH, " characters in length"), {
          length: length
        });
      }

      return new SignatureMessageFragment(signatureMessageFragment);
    }
  }]);

  return SignatureMessageFragment;
}();
/**
 * The length of a valid signature message fragment (2187)
 */


SignatureMessageFragment.LENGTH = 2187;
/**
 * An empty signature message fragment all 9s.
 */

SignatureMessageFragment.EMPTY = SignatureMessageFragment.fromTrytes(trytes_1.Trytes.fromString("9".repeat(SignatureMessageFragment.LENGTH)));
exports.SignatureMessageFragment = SignatureMessageFragment;

/***/ }),

/***/ "../data/dist/data/tag.js":
/*!********************************!*\
  !*** ../data/dist/data/tag.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ "../core/dist/helpers/objectHelper.js");

var dataError_1 = __webpack_require__(/*! ../error/dataError */ "../data/dist/error/dataError.js");

var trytes_1 = __webpack_require__(/*! ./trytes */ "../data/dist/data/trytes.js");
/**
 * A class for handling tags.
 */


var Tag =
/*#__PURE__*/
function () {
  /* @internal */
  function Tag(trytes) {
    _classCallCheck(this, Tag);

    this._trytes = trytes;
  }
  /**
   * Create tag from trytes.
   * @param tag The trytes to create the tag from.
   * @returns An instance of Tag.
   */


  _createClass(Tag, [{
    key: "toTrytes",

    /**
     * Convert the tag to trytes.
     * @returns Trytes version of the tag.
     */
    value: function toTrytes() {
      return trytes_1.Trytes.fromString(this._trytes);
    }
    /**
     * Get the string view of the object.
     * @returns string of the trytes.
     */

  }, {
    key: "toString",
    value: function toString() {
      return this._trytes;
    }
  }], [{
    key: "fromTrytes",
    value: function fromTrytes(tag) {
      if (!objectHelper_1.ObjectHelper.isType(tag, trytes_1.Trytes)) {
        throw new dataError_1.DataError("The tag should be a valid Trytes object");
      }

      var trytesString = tag.toString();

      if (trytesString.length > Tag.LENGTH) {
        throw new dataError_1.DataError("The tag should be at most ".concat(Tag.LENGTH, " characters in length"), {
          length: trytesString.length
        });
      }

      while (trytesString.length < Tag.LENGTH) {
        trytesString += "9";
      }

      return new Tag(trytesString);
    }
  }]);

  return Tag;
}();
/**
 * The length of a valid tag (27).
 */


Tag.LENGTH = 27;
/**
 * An empty tag all 9s.
 */

Tag.EMPTY = Tag.fromTrytes(trytes_1.Trytes.fromString("9".repeat(Tag.LENGTH)));
exports.Tag = Tag;

/***/ }),

/***/ "../data/dist/data/transaction.js":
/*!****************************************!*\
  !*** ../data/dist/data/transaction.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ "../core/dist/helpers/objectHelper.js");

var dataError_1 = __webpack_require__(/*! ../error/dataError */ "../data/dist/error/dataError.js");

var address_1 = __webpack_require__(/*! ./address */ "../data/dist/data/address.js");

var hash_1 = __webpack_require__(/*! ./hash */ "../data/dist/data/hash.js");

var signatureMessageFragment_1 = __webpack_require__(/*! ./signatureMessageFragment */ "../data/dist/data/signatureMessageFragment.js");

var tag_1 = __webpack_require__(/*! ./tag */ "../data/dist/data/tag.js");

var tryteNumber_1 = __webpack_require__(/*! ./tryteNumber */ "../data/dist/data/tryteNumber.js");

var trytes_1 = __webpack_require__(/*! ./trytes */ "../data/dist/data/trytes.js");
/**
 * A class for handling transactions.
 */


var Transaction =
/*#__PURE__*/
function () {
  /* @internal */
  function Transaction() {
    _classCallCheck(this, Transaction);
  }
  /**
   * Create instance of transaction from parameters.
   * @param signatureMessageFragment The signature message fragment.
   * @param address The address.
   * @param value The value.
   * @param obsoleteTag Obsolete transaction tag.
   * @param timestamp The timestamp.
   * @param currentIndex The current index.
   * @param lastIndex The last index.
   * @param bundle The bundle.
   * @param trunkTransaction The trunk transaction.
   * @param branchTransaction The branch transaction.
   * @param tag The tag.
   * @param attachmentTimestamp The attachment timestamp.
   * @param attachmentTimestampLowerBound The attachment timestamp lower bound.
   * @param attachmentTimestampUpperBound  The attachment timestamp upper bound.
   * @param nonce The nonce.
   * @returns New instance of transaction.
   */


  _createClass(Transaction, [{
    key: "toTrytes",

    /**
     * Convert the transaction to trytes.
     * @returns The transaction as trytes.
     */
    value: function toTrytes() {
      if (!objectHelper_1.ObjectHelper.isType(this.signatureMessageFragment, signatureMessageFragment_1.SignatureMessageFragment)) {
        throw new dataError_1.DataError("The signatureMessageFragment must be set to create transaction trytes", {
          signatureMessageFragment: this.signatureMessageFragment
        });
      }

      if (!objectHelper_1.ObjectHelper.isType(this.address, address_1.Address)) {
        throw new dataError_1.DataError("The address must be set to create transaction trytes", {
          address: this.address
        });
      }

      if (!objectHelper_1.ObjectHelper.isType(this.obsoleteTag, tag_1.Tag)) {
        throw new dataError_1.DataError("The obsoleteTag must be set to create transaction trytes", {
          obsoleteTag: this.obsoleteTag
        });
      }

      if (!objectHelper_1.ObjectHelper.isType(this.bundle, hash_1.Hash)) {
        throw new dataError_1.DataError("The bundle must be set to create transaction trytes", {
          bundle: this.bundle
        });
      }

      if (!objectHelper_1.ObjectHelper.isType(this.trunkTransaction, hash_1.Hash)) {
        throw new dataError_1.DataError("The trunkTransaction must be set to create transaction trytes", {
          trunkTransaction: this.trunkTransaction
        });
      }

      if (!objectHelper_1.ObjectHelper.isType(this.branchTransaction, hash_1.Hash)) {
        throw new dataError_1.DataError("The branchTransaction must be set to create transaction trytes", {
          branchTransaction: this.branchTransaction
        });
      }

      if (!objectHelper_1.ObjectHelper.isType(this.nonce, tag_1.Tag)) {
        throw new dataError_1.DataError("The nonce must be set to create transaction trytes", {
          nonce: this.nonce
        });
      }

      var trytes = this.signatureMessageFragment.toTrytes().toString() + this.address.toTrytes().toString() + (this.value || Transaction.EMPTY_11).toTrytes().toString() + Transaction.CHECK_VALUE + this.obsoleteTag.toTrytes().toString() + (this.timestamp || tryteNumber_1.TryteNumber.EMPTY_9).toTrytes().toString() + (this.currentIndex || tryteNumber_1.TryteNumber.EMPTY_9).toTrytes().toString() + (this.lastIndex || tryteNumber_1.TryteNumber.EMPTY_9).toTrytes().toString() + this.bundle.toTrytes().toString() + this.trunkTransaction.toTrytes().toString() + this.branchTransaction.toTrytes().toString() + (this.tag || this.obsoleteTag).toTrytes().toString() + (this.attachmentTimestamp || tryteNumber_1.TryteNumber.EMPTY_9).toTrytes().toString() + (this.attachmentTimestampLowerBound || tryteNumber_1.TryteNumber.EMPTY_9).toTrytes().toString() + (this.attachmentTimestampUpperBound || tryteNumber_1.TryteNumber.EMPTY_9).toTrytes().toString() + this.nonce.toTrytes().toString();
      var length = trytes.length;

      if (length !== Transaction.LENGTH) {
        throw new dataError_1.DataError("The trytes must be ".concat(Transaction.LENGTH, " in length ").concat(length), {
          length: length
        });
      }

      return trytes_1.Trytes.fromString(trytes);
    }
    /**
     * Get the string view of the object.
     * @returns string view of the object.
     */

  }, {
    key: "toString",
    value: function toString() {
      return "{\n\tsignatureMessageFragment: \"".concat((this.signatureMessageFragment || signatureMessageFragment_1.SignatureMessageFragment.EMPTY).toTrytes().toString(), "\"\n\taddress: \"").concat((this.address || address_1.Address.EMPTY).toTrytes().toString(), "\"\n\tvalue: ").concat((this.value || Transaction.EMPTY_11).toNumber(), "\n\tobsoleteTag: \"").concat((this.obsoleteTag || tag_1.Tag.EMPTY).toTrytes().toString(), "\"\n\ttimestamp: ").concat((this.timestamp || tryteNumber_1.TryteNumber.EMPTY_9).toNumber(), "\n\tcurrentIndex: ").concat((this.currentIndex || tryteNumber_1.TryteNumber.EMPTY_9).toNumber(), "\n\tlastIndex: ").concat((this.lastIndex || tryteNumber_1.TryteNumber.EMPTY_9).toNumber(), "\n\tbundle: \"").concat((this.bundle || hash_1.Hash.EMPTY).toTrytes().toString(), "\"\n\ttrunkTransaction: \"").concat((this.trunkTransaction || hash_1.Hash.EMPTY).toTrytes().toString(), "\"\n\tbranchTransaction: \"").concat((this.branchTransaction || hash_1.Hash.EMPTY).toTrytes().toString(), "\"\n\ttag: \"").concat((this.tag || this.obsoleteTag || tag_1.Tag.EMPTY).toTrytes().toString(), "\"\n\tattachmentTimestamp: ").concat((this.attachmentTimestamp || tryteNumber_1.TryteNumber.EMPTY_9).toNumber(), "\n\tattachmentTimestampLowerBound: ").concat((this.attachmentTimestampLowerBound || tryteNumber_1.TryteNumber.EMPTY_9).toNumber(), "\n\tattachmentTimestampUpperBound: ").concat((this.attachmentTimestampUpperBound || tryteNumber_1.TryteNumber.EMPTY_9).toNumber(), "\n\tnonce: \"").concat((this.nonce || tag_1.Tag.EMPTY).toTrytes().toString(), "\"\n}");
    }
  }], [{
    key: "fromParams",
    value: function fromParams(signatureMessageFragment, address, value, obsoleteTag, timestamp, currentIndex, lastIndex, bundle, trunkTransaction, branchTransaction, tag, attachmentTimestamp, attachmentTimestampLowerBound, attachmentTimestampUpperBound, nonce) {
      var tx = new Transaction();
      tx.signatureMessageFragment = signatureMessageFragment;
      tx.address = address;
      tx.value = tryteNumber_1.TryteNumber.fromNumber(value, 11);
      tx.obsoleteTag = obsoleteTag;
      tx.timestamp = tryteNumber_1.TryteNumber.fromNumber(timestamp);
      tx.currentIndex = tryteNumber_1.TryteNumber.fromNumber(currentIndex);
      tx.lastIndex = tryteNumber_1.TryteNumber.fromNumber(lastIndex);
      tx.bundle = bundle;
      tx.trunkTransaction = trunkTransaction;
      tx.branchTransaction = branchTransaction;
      tx.tag = tag;
      tx.attachmentTimestamp = tryteNumber_1.TryteNumber.fromNumber(attachmentTimestamp);
      tx.attachmentTimestampLowerBound = tryteNumber_1.TryteNumber.fromNumber(attachmentTimestampLowerBound);
      tx.attachmentTimestampUpperBound = tryteNumber_1.TryteNumber.fromNumber(attachmentTimestampUpperBound);
      tx.nonce = nonce;
      return tx;
    }
    /**
     * Create instance of transaction from trytes.
     * @param trytes The trytes for the this.
     * @returns An instance of this.
     */

  }, {
    key: "fromTrytes",
    value: function fromTrytes(trytes) {
      if (!objectHelper_1.ObjectHelper.isType(trytes, trytes_1.Trytes)) {
        throw new dataError_1.DataError("The trytes should be a valid Trytes object");
      }

      var length = trytes.length();

      if (length !== Transaction.LENGTH) {
        throw new dataError_1.DataError("The trytes must be ".concat(Transaction.LENGTH, " in length"), {
          length: length
        });
      }

      var checkIndexStart = 2279;
      var checkIndexLength = 16;
      var check = trytes.sub(checkIndexStart, checkIndexLength).toString();

      if (check !== Transaction.CHECK_VALUE) {
        throw new dataError_1.DataError("The trytes between ".concat(checkIndexStart, " and ").concat(checkIndexStart + checkIndexLength, " should be all 9s"), {
          check: check
        });
      }

      var tx = new Transaction();
      var startPos = 0;
      tx.signatureMessageFragment = signatureMessageFragment_1.SignatureMessageFragment.fromTrytes(trytes.sub(startPos, signatureMessageFragment_1.SignatureMessageFragment.LENGTH));
      startPos += signatureMessageFragment_1.SignatureMessageFragment.LENGTH;
      tx.address = address_1.Address.fromTrytes(trytes.sub(startPos, address_1.Address.LENGTH));
      startPos += address_1.Address.LENGTH;
      tx.value = tryteNumber_1.TryteNumber.fromTrytes(trytes.sub(startPos, 11), 11);
      startPos += 11;
      startPos += Transaction.CHECK_VALUE_LENGTH;
      tx.obsoleteTag = tag_1.Tag.fromTrytes(trytes.sub(startPos, tag_1.Tag.LENGTH));
      startPos += tag_1.Tag.LENGTH;
      tx.timestamp = tryteNumber_1.TryteNumber.fromTrytes(trytes.sub(startPos, tryteNumber_1.TryteNumber.LENGTH_9));
      startPos += tryteNumber_1.TryteNumber.LENGTH_9;
      tx.currentIndex = tryteNumber_1.TryteNumber.fromTrytes(trytes.sub(startPos, tryteNumber_1.TryteNumber.LENGTH_9));
      startPos += tryteNumber_1.TryteNumber.LENGTH_9;
      tx.lastIndex = tryteNumber_1.TryteNumber.fromTrytes(trytes.sub(startPos, tryteNumber_1.TryteNumber.LENGTH_9));
      startPos += tryteNumber_1.TryteNumber.LENGTH_9;
      tx.bundle = hash_1.Hash.fromTrytes(trytes.sub(startPos, hash_1.Hash.LENGTH));
      startPos += hash_1.Hash.LENGTH;
      tx.trunkTransaction = hash_1.Hash.fromTrytes(trytes.sub(startPos, hash_1.Hash.LENGTH));
      startPos += hash_1.Hash.LENGTH;
      tx.branchTransaction = hash_1.Hash.fromTrytes(trytes.sub(startPos, hash_1.Hash.LENGTH));
      startPos += hash_1.Hash.LENGTH;
      tx.tag = tag_1.Tag.fromTrytes(trytes.sub(startPos, tag_1.Tag.LENGTH));
      startPos += tag_1.Tag.LENGTH;
      tx.attachmentTimestamp = tryteNumber_1.TryteNumber.fromTrytes(trytes.sub(startPos, tryteNumber_1.TryteNumber.LENGTH_9));
      startPos += tryteNumber_1.TryteNumber.LENGTH_9;
      tx.attachmentTimestampLowerBound = tryteNumber_1.TryteNumber.fromTrytes(trytes.sub(startPos, tryteNumber_1.TryteNumber.LENGTH_9));
      startPos += tryteNumber_1.TryteNumber.LENGTH_9;
      tx.attachmentTimestampUpperBound = tryteNumber_1.TryteNumber.fromTrytes(trytes.sub(startPos, tryteNumber_1.TryteNumber.LENGTH_9));
      startPos += tryteNumber_1.TryteNumber.LENGTH_9;
      tx.nonce = tag_1.Tag.fromTrytes(trytes.sub(startPos, tag_1.Tag.LENGTH));
      return tx;
    }
  }]);

  return Transaction;
}();
/**
 * The length of a valid transaction (2673).
 */


Transaction.LENGTH = 2673;
/**
 * The length of a valid check value (16).
 */

Transaction.CHECK_VALUE_LENGTH = 16;
/**
 * The check value for bundles all 9s.
 */

Transaction.CHECK_VALUE = "9".repeat(Transaction.CHECK_VALUE_LENGTH);
/* @internal */

Transaction.EMPTY_11 = tryteNumber_1.TryteNumber.fromNumber(0, 11);
exports.Transaction = Transaction;

/***/ }),

/***/ "../data/dist/data/trits.js":
/*!**********************************!*\
  !*** ../data/dist/data/trits.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var arrayHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/arrayHelper */ "../core/dist/helpers/arrayHelper.js");

var numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ "../core/dist/helpers/numberHelper.js");

var objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ "../core/dist/helpers/objectHelper.js");

var dataError_1 = __webpack_require__(/*! ../error/dataError */ "../data/dist/error/dataError.js");

var trytes_1 = __webpack_require__(/*! ./trytes */ "../data/dist/data/trytes.js");
/**
 * A class for handling trits.
 */


var Trits =
/*#__PURE__*/
function () {
  /* @internal */
  function Trits(trits) {
    _classCallCheck(this, Trits);

    this._trits = trits;
  }
  /**
   * Create instance of trits from Int8Array array.
   * @param value Trytes used to create trits.
   * @returns An instance of Trits.
   */


  _createClass(Trits, [{
    key: "toArray",

    /**
     * Get the value of the trits array.
     * @returns Array representation of the trits.
     */
    value: function toArray() {
      return this._trits;
    }
    /**
     * Get the value of the trits array as a number array.
     * @returns Array representation of the trits.
     */

  }, {
    key: "toNumberArray",
    value: function toNumberArray() {
      return Array.from(this._trits);
    }
    /**
     * Get the trits as trytes.
     * @returns Instance of Trytes.
     */

  }, {
    key: "toTrytes",
    value: function toTrytes() {
      var trytes = "";

      for (var i = 0; i < this._trits.length; i += 3) {
        // Iterate over all possible tryte values to find correct trit representation
        for (var j = 0; j < trytes_1.Trytes.ALPHABET.length; j++) {
          if (Trits.TRYTES_TRITS[j][0] === this._trits[i] && Trits.TRYTES_TRITS[j][1] === this._trits[i + 1] && Trits.TRYTES_TRITS[j][2] === this._trits[i + 2]) {
            trytes += trytes_1.Trytes.ALPHABET.charAt(j);
            break;
          }
        }
      }

      return trytes_1.Trytes.fromString(trytes);
    }
    /**
     * Get the trits as a number.
     * @returns The trits converted to a number.
     */

  }, {
    key: "toNumber",
    value: function toNumber() {
      var returnValue = 0;

      for (var i = this._trits.length - 1; i >= 0; i--) {
        returnValue = returnValue * 3 + this._trits[i];
      }

      return returnValue;
    }
    /**
     * What is the length of the trits.
     * @returns Length of the trits.
     */

  }, {
    key: "length",
    value: function length() {
      return this._trits.length;
    }
    /**
     * Get a sub of the trits.
     * @param start The start position to get the sub.
     * @param length The length of the sub.
     * @returns The trits sub.
     */

  }, {
    key: "sub",
    value: function sub(start, length) {
      if (!numberHelper_1.NumberHelper.isInteger(start) || start < 0) {
        throw new dataError_1.DataError("The start must be a number >= 0");
      }

      if (!numberHelper_1.NumberHelper.isInteger(length) || start + length > this._trits.length) {
        throw new dataError_1.DataError("The start + length must <= ".concat(this._trits.length));
      }

      return Trits.fromArray(this._trits.slice(start, start + length));
    }
  }], [{
    key: "fromArray",
    value: function fromArray(value) {
      if (!objectHelper_1.ObjectHelper.isType(value, Int8Array)) {
        throw new dataError_1.DataError("The value does not contain valid trits");
      }

      return new Trits(value);
    }
    /**
     * Create instance of trits from number array.
     * @param value Trytes used to create trits.
     * @returns An instance of Trits.
     */

  }, {
    key: "fromNumberArray",
    value: function fromNumberArray(value) {
      if (!arrayHelper_1.ArrayHelper.isTyped(value, Number)) {
        throw new dataError_1.DataError("The value does not contain valid trits");
      }

      return new Trits(new Int8Array(value));
    }
    /**
     * Create instance of trits from trytes.
     * @param value Trytes used to create trits.
     * @returns An instance of Trits.
     */

  }, {
    key: "fromTrytes",
    value: function fromTrytes(value) {
      if (!objectHelper_1.ObjectHelper.isType(value, trytes_1.Trytes)) {
        throw new dataError_1.DataError("The value should be a valid Trytes object");
      }

      var trytesString = value.toString();
      var trits = new Int8Array(trytesString.length * 3);

      for (var i = 0; i < trytesString.length; i++) {
        var idx = trytes_1.Trytes.ALPHABET.indexOf(trytesString.charAt(i));
        trits[i * 3] = Trits.TRYTES_TRITS[idx][0];
        trits[i * 3 + 1] = Trits.TRYTES_TRITS[idx][1];
        trits[i * 3 + 2] = Trits.TRYTES_TRITS[idx][2];
      }

      return new Trits(trits);
    }
    /**
     * Create instance of trits from number
     * @param value Number used to create trits.
     * @returns An instance of Trits.
     */

  }, {
    key: "fromNumber",
    value: function fromNumber(value) {
      if (!numberHelper_1.NumberHelper.isInteger(value)) {
        throw new dataError_1.DataError("The value is not an integer");
      }

      var trits = [];
      var absoluteValue = value < 0 ? -value : value;

      while (absoluteValue > 0) {
        var remainder = absoluteValue % 3;
        absoluteValue = Math.floor(absoluteValue / 3);

        if (remainder > 1) {
          remainder = -1;
          absoluteValue++;
        }

        trits[trits.length] = remainder;
      }

      if (value < 0) {
        for (var i = 0; i < trits.length; i++) {
          trits[i] = -trits[i];
        }
      }

      return new Trits(new Int8Array(trits));
    }
    /**
     * Add two trits together.
     * @param first The first trit.
     * @param second The second trit.
     * @returns New trit which is the addition of the a + b.
     */

  }, {
    key: "add",
    value: function add(first, second) {
      if (!objectHelper_1.ObjectHelper.isType(first, Trits)) {
        throw new dataError_1.DataError("The first should be a valid Trits object");
      }

      if (!objectHelper_1.ObjectHelper.isType(second, Trits)) {
        throw new dataError_1.DataError("The seconds should be a valid Trits object");
      }

      var out = new Int8Array(Math.max(first._trits.length, second._trits.length));
      var carry = 0;
      var iA;
      var iB;

      for (var i = 0; i < out.length; i++) {
        iA = i < first._trits.length ? first._trits[i] : 0;
        iB = i < second._trits.length ? second._trits[i] : 0;
        var fA = Trits.fullAdd(iA, iB, carry);
        out[i] = fA[0];
        carry = fA[1];
      }

      return Trits.fromArray(out);
    }
    /* @internal */

  }, {
    key: "fullAdd",
    value: function fullAdd(a, b, c) {
      var sA = Trits.sum(a, b);
      var cA = Trits.cons(a, b);
      var cB = Trits.cons(sA, c);
      var cOut = Trits.any(cA, cB);
      var sOUt = Trits.sum(sA, c);
      return new Int8Array([sOUt, cOut]);
    }
    /* @internal */

  }, {
    key: "sum",
    value: function sum(a, b) {
      var s = a + b;

      switch (s) {
        case 2:
          return -1;

        case -2:
          return 1;

        default:
          return s;
      }
    }
    /* @internal */

  }, {
    key: "cons",
    value: function cons(a, b) {
      if (a === b) {
        return a;
      }

      return 0;
    }
    /* @internal */

  }, {
    key: "any",
    value: function any(a, b) {
      var s = a + b;

      if (s > 0) {
        return 1;
      } else if (s < 0) {
        return -1;
      }

      return 0;
    }
  }]);

  return Trits;
}();
/* @internal */


Trits.TRYTES_TRITS = [new Int8Array([0, 0, 0]), new Int8Array([1, 0, 0]), new Int8Array([-1, 1, 0]), new Int8Array([0, 1, 0]), new Int8Array([1, 1, 0]), new Int8Array([-1, -1, 1]), new Int8Array([0, -1, 1]), new Int8Array([1, -1, 1]), new Int8Array([-1, 0, 1]), new Int8Array([0, 0, 1]), new Int8Array([1, 0, 1]), new Int8Array([-1, 1, 1]), new Int8Array([0, 1, 1]), new Int8Array([1, 1, 1]), new Int8Array([-1, -1, -1]), new Int8Array([0, -1, -1]), new Int8Array([1, -1, -1]), new Int8Array([-1, 0, -1]), new Int8Array([0, 0, -1]), new Int8Array([1, 0, -1]), new Int8Array([-1, 1, -1]), new Int8Array([0, 1, -1]), new Int8Array([1, 1, -1]), new Int8Array([-1, -1, 0]), new Int8Array([0, -1, 0]), new Int8Array([1, -1, 0]), new Int8Array([-1, 0, 0])];
exports.Trits = Trits;

/***/ }),

/***/ "../data/dist/data/tryteNumber.js":
/*!****************************************!*\
  !*** ../data/dist/data/tryteNumber.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ "../core/dist/helpers/numberHelper.js");

var objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ "../core/dist/helpers/objectHelper.js");

var dataError_1 = __webpack_require__(/*! ../error/dataError */ "../data/dist/error/dataError.js");

var trits_1 = __webpack_require__(/*! ./trits */ "../data/dist/data/trits.js");

var trytes_1 = __webpack_require__(/*! ./trytes */ "../data/dist/data/trytes.js");
/**
 * A class for handling tryte number.
 */


var TryteNumber =
/*#__PURE__*/
function () {
  /* @internal */
  function TryteNumber(trytes) {
    _classCallCheck(this, TryteNumber);

    this._trytes = trytes;
  }
  /**
   * Create tryte number from number.
   * @param value The number value to create the object from.
   * @param length The tryte length to pad the number with.
   * @returns An instance of TryteNumber.
   */


  _createClass(TryteNumber, [{
    key: "toTrytes",

    /**
     * Convert the tryte number to trytes.
     * @returns Trytes version of the tryte number.
     */
    value: function toTrytes() {
      return trytes_1.Trytes.fromString(this._trytes);
    }
    /**
     * Convert the tryte number to number.
     * @returns number value of the tryte number.
     */

  }, {
    key: "toNumber",
    value: function toNumber() {
      return trits_1.Trits.fromTrytes(trytes_1.Trytes.fromString(this._trytes)).toNumber();
    }
    /**
     * Get the string view of the object.
     * @returns string of the trytes.
     */

  }, {
    key: "toString",
    value: function toString() {
      return this._trytes;
    }
    /**
     * Get the value of the object.
     * @returns string of the trytes.
     */

  }, {
    key: "valueOf",
    value: function valueOf() {
      return this.toNumber();
    }
  }], [{
    key: "fromNumber",
    value: function fromNumber(value) {
      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TryteNumber.LENGTH_9;
      var trytes;

      if (!numberHelper_1.NumberHelper.isInteger(length) || length <= 0) {
        throw new dataError_1.DataError("The length should be a number > 0", {
          length: length
        });
      }

      if (objectHelper_1.ObjectHelper.isEmpty(value)) {
        trytes = "9".repeat(length);
      } else {
        if (!numberHelper_1.NumberHelper.isInteger(value)) {
          throw new dataError_1.DataError("The value is not an integer", {
            value: value
          });
        }

        var trits = trits_1.Trits.fromNumber(value).toNumberArray();

        while (trits.length < length * 3) {
          trits.push(0);
        }

        trytes = trits_1.Trits.fromNumberArray(trits).toTrytes().toString();
      }

      return new TryteNumber(trytes);
    }
    /**
     * Create tryte number from trytes.
     * @param value The number value to create the object from.
     * @param length The tryte length to pad the number with.
     * @returns An instance of TryteNumber.
     */

  }, {
    key: "fromTrytes",
    value: function fromTrytes(value) {
      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TryteNumber.LENGTH_9;

      if (!objectHelper_1.ObjectHelper.isType(value, trytes_1.Trytes)) {
        throw new dataError_1.DataError("The value should be a valid Trytes object");
      }

      var tryteString = value.toString();

      if (!numberHelper_1.NumberHelper.isInteger(length) || length <= 0) {
        throw new dataError_1.DataError("The length should be a number > 0", {
          length: length
        });
      }

      if (tryteString.length > length) {
        throw new dataError_1.DataError("The value contains too many characters", {
          length: tryteString.length
        });
      }

      while (tryteString.length < length) {
        tryteString += "9";
      }

      return new TryteNumber(tryteString);
    }
  }]);

  return TryteNumber;
}();
/**
 * Length of a number that uses 9 trytes.
 */


TryteNumber.LENGTH_9 = 9;
/**
 * An empty 9 length tryte number.
 */

TryteNumber.EMPTY_9 = TryteNumber.fromNumber(0, TryteNumber.LENGTH_9);
exports.TryteNumber = TryteNumber;

/***/ }),

/***/ "../data/dist/data/trytes.js":
/*!***********************************!*\
  !*** ../data/dist/data/trytes.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ "../core/dist/helpers/numberHelper.js");

var stringHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/stringHelper */ "../core/dist/helpers/stringHelper.js");

var dataError_1 = __webpack_require__(/*! ../error/dataError */ "../data/dist/error/dataError.js");
/**
 * A class for handling trytes.
 */


var Trytes =
/*#__PURE__*/
function () {
  /* @internal */
  function Trytes(trytes) {
    _classCallCheck(this, Trytes);

    this._trytes = trytes;
  }
  /**
   * Create trytes from a string.
   * @param value A string to create the trytes from.
   * @param length An optional validation length for the trytes, 0 means ignore length.
   * @returns An instance of Trytes.
   */


  _createClass(Trytes, [{
    key: "toString",

    /**
     * Convert the trytes to a string.
     * @returns String representation of the trytes.
     */
    value: function toString() {
      return this._trytes;
    }
    /**
     * Get the length of the trytes.
     * @returns The length of the trytes.
     */

  }, {
    key: "length",
    value: function length() {
      return this._trytes.length;
    }
    /**
     * Get a sub of the trytes.
     * @param start The start position to get the sub.
     * @param length The length of the sub.
     * @returns The trytes sub.
     */

  }, {
    key: "sub",
    value: function sub(start, length) {
      if (!numberHelper_1.NumberHelper.isInteger(start) || start < 0) {
        throw new dataError_1.DataError("The start must be a number >= 0");
      }

      if (!numberHelper_1.NumberHelper.isInteger(length) || start + length > this._trytes.length) {
        throw new dataError_1.DataError("The start + length must <= ".concat(this._trytes.length));
      }

      return Trytes.fromString(this._trytes.substr(start, length));
    }
  }], [{
    key: "fromString",
    value: function fromString(value) {
      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      if (!stringHelper_1.StringHelper.isString(value)) {
        throw new dataError_1.DataError("The value must be a non empty string");
      }

      if (!numberHelper_1.NumberHelper.isInteger(length) || length < 0) {
        throw new dataError_1.DataError("The length must be >= 0");
      }

      if (!Trytes.isValid(value, length)) {
        throw new dataError_1.DataError("The value and length do not contain valid trytes", {
          value: value,
          length: length
        });
      }

      return new Trytes(value);
    }
    /**
     * Does the value contain valid trytes.
     * @param value A string to validate as trytes.
     * @param length An optional validation length for the trytes, 0 means ignore length.
     * @returns True if the input was valid trytes.
     */

  }, {
    key: "isValid",
    value: function isValid(value) {
      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      if (!stringHelper_1.StringHelper.isString(value)) {
        return false;
      } else {
        return new RegExp("^[9A-Z]{".concat(length ? length : "0,", "}$")).test(value);
      }
    }
  }]);

  return Trytes;
}();
/**
 * All the characters that can be used in trytes.
 */


Trytes.ALPHABET = "9ABCDEFGHIJKLMNOPQRSTUVWXYZ";
exports.Trytes = Trytes;

/***/ }),

/***/ "../data/dist/error/dataError.js":
/*!***************************************!*\
  !*** ../data/dist/error/dataError.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var coreError_1 = __webpack_require__(/*! @iota-pico/core/dist/error/coreError */ "../core/dist/error/coreError.js");
/**
 * A data implementation of an error.
 */


var DataError =
/*#__PURE__*/
function (_coreError_1$CoreErro) {
  _inherits(DataError, _coreError_1$CoreErro);

  /**
   * Create an instance of DataError.
   * @param message The message for the error.
   * @param additional Additional details about the error.
   * @param innerError Add information from inner error if there was one.
   */
  function DataError(message, additional, innerError) {
    var _this;

    _classCallCheck(this, DataError);

    _this = _possibleConstructorReturn(this, (DataError.__proto__ || Object.getPrototypeOf(DataError)).call(this, message, additional, innerError));
    _this.domain = "Data";
    return _this;
  }

  return DataError;
}(coreError_1.CoreError);

exports.DataError = DataError;

/***/ }),

/***/ "./dist/index.js":
/*!***********************!*\
  !*** ./dist/index.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Combined index of all the modules.
 */

__export(__webpack_require__(/*! ./proofOfWorkWasm */ "./dist/proofOfWorkWasm.js"));

/***/ }),

/***/ "./dist/proofOfWorkWasm.js":
/*!*********************************!*\
  !*** ./dist/proofOfWorkWasm.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _next(value) { step("next", value); } function _throw(err) { step("throw", err); } _next(); }); }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return _get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
}); /// <reference types="emscripten" />

var numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ "../core/dist/helpers/numberHelper.js");

var objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ "../core/dist/helpers/objectHelper.js");

var cryptoError_1 = __webpack_require__(/*! @iota-pico/crypto/dist/error/cryptoError */ "../crypto/dist/error/cryptoError.js");

var proofOfWorkBase_1 = __webpack_require__(/*! @iota-pico/crypto/dist/proofOfWork/proofOfWorkBase */ "../crypto/dist/proofOfWork/proofOfWorkBase.js");

var trytes_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trytes */ "../data/dist/data/trytes.js"); // @ts-ignore


var iota_pico_pow_wasm_1 = __importDefault(__webpack_require__(/*! ../wasm/iota-pico-pow-wasm */ "./wasm/iota-pico-pow-wasm.js"));
/**
 * ProofOfWork implementation using WebAssembly.
 */


var ProofOfWorkWasm =
/*#__PURE__*/
function (_proofOfWorkBase_1$Pr) {
  _inherits(ProofOfWorkWasm, _proofOfWorkBase_1$Pr);

  /**
   * Create a new instance of ProofOfWork.
   * @param webPlatform Provides platform specific functions, optional mostly used for testing.
   * @param timeService Service to get the time for attachments.
   */
  function ProofOfWorkWasm(webPlatform, timeService) {
    var _this;

    _classCallCheck(this, ProofOfWorkWasm);

    _this = _possibleConstructorReturn(this, (ProofOfWorkWasm.__proto__ || Object.getPrototypeOf(ProofOfWorkWasm)).call(this, timeService));

    if (objectHelper_1.ObjectHelper.isEmpty(webPlatform)) {
      _this._webPlatform = {
        webAssemblyType: typeof WebAssembly === "undefined" ? "undefined" : _typeof(WebAssembly),
        wasmModuleLoader: iota_pico_pow_wasm_1.default
      };
    } else {
      _this._webPlatform = webPlatform;
    }

    return _this;
  }
  /**
   * Allow the proof of work to perform any initialization.
   * Will throw an exception if the implementation is not supported.
   * @returns Promise.
   */


  _createClass(ProofOfWorkWasm, [{
    key: "initialize",
    value: function () {
      var _initialize = _asyncToGenerator(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee2() {
        var _this2 = this;

        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return _get(ProofOfWorkWasm.prototype.__proto__ || Object.getPrototypeOf(ProofOfWorkWasm.prototype), "initialize", this).call(this);

              case 2:
                return _context2.abrupt("return", new Promise(
                /*#__PURE__*/
                function () {
                  var _ref = _asyncToGenerator(
                  /*#__PURE__*/
                  _regenerator.default.mark(function _callee(resolve, reject) {
                    var module;
                    return _regenerator.default.wrap(function _callee$(_context) {
                      while (1) {
                        switch (_context.prev = _context.next) {
                          case 0:
                            if (objectHelper_1.ObjectHelper.isEmpty(_this2._webPlatform.webAssemblyType) || _this2._webPlatform.webAssemblyType === "undefined") {
                              reject(new cryptoError_1.CryptoError("No WebAssembly support detected"));
                            }

                            module = {};

                            module.onRuntimeInitialized = function () {
                              _this2._ccurlPow = module.cwrap("ccurl_pow", "string", ["string", "number"]);
                              resolve();
                            };

                            try {
                              _this2._webPlatform.wasmModuleLoader(module);
                            } catch (err) {
                              reject(new cryptoError_1.CryptoError("There was a problem intializing the WebAssembly Module", undefined, err));
                            }

                          case 4:
                          case "end":
                            return _context.stop();
                        }
                      }
                    }, _callee, this);
                  }));

                  return function (_x, _x2) {
                    return _ref.apply(this, arguments);
                  };
                }()));

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      return function initialize() {
        return _initialize.apply(this, arguments);
      };
    }()
    /**
     * Perform a proof of work on a single item.
     * @param trytes The trytes to perform the pow on.
     * @param minWeightMagnitude The minimum weight magnitude.
     * @returns The trytes produced by the proof of work.
     */

  }, {
    key: "singlePow",
    value: function () {
      var _singlePow = _asyncToGenerator(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee3(trytes, minWeightMagnitude) {
        var _this3 = this;

        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                return _context3.abrupt("return", new Promise(function (resolve, reject) {
                  if (objectHelper_1.ObjectHelper.isEmpty(_this3._ccurlPow)) {
                    throw new cryptoError_1.CryptoError("WebAssembly not loaded, have you called initialize");
                  }

                  if (!objectHelper_1.ObjectHelper.isType(trytes, trytes_1.Trytes)) {
                    throw new cryptoError_1.CryptoError("The trytes must be an object of type Trytes");
                  }

                  if (!numberHelper_1.NumberHelper.isInteger(minWeightMagnitude) || minWeightMagnitude <= 0) {
                    throw new cryptoError_1.CryptoError("The minWeightMagnitude must be > 0");
                  }

                  try {
                    var result = _this3._ccurlPow(trytes.toString(), minWeightMagnitude);

                    resolve(trytes_1.Trytes.fromString(result));
                  } catch (err) {
                    reject(err);
                  }
                }));

              case 1:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      return function singlePow(_x3, _x4) {
        return _singlePow.apply(this, arguments);
      };
    }()
  }]);

  return ProofOfWorkWasm;
}(proofOfWorkBase_1.ProofOfWorkBase);

exports.ProofOfWorkWasm = ProofOfWorkWasm;

/***/ }),

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! regenerator-runtime */ "./node_modules/regenerator-runtime/runtime-module.js");


/***/ }),

/***/ "./node_modules/node-libs-browser/mock/empty.js":
/*!******************************************************!*\
  !*** ./node_modules/node-libs-browser/mock/empty.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {



/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime-module.js":
/*!************************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime-module.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g = (function() { return this })() || Function("return this")();

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = __webpack_require__(/*! ./runtime */ "./node_modules/regenerator-runtime/runtime.js");

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}


/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  (function() { return this })() || Function("return this")()
);


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./wasm/iota-pico-pow-wasm.js":
/*!************************************!*\
  !*** ./wasm/iota-pico-pow-wasm.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var Module = function Module(_Module) {
  _Module = _Module || {}; // The Module object: Our interface to the outside world. We import
  // and export values on it. There are various ways Module can be used:
  // 1. Not defined. We create it here
  // 2. A function parameter, function(Module) { ..generated code.. }
  // 3. pre-run appended it, var Module = {}; ..generated code..
  // 4. External script tag defines var Module.
  // We need to check if Module already exists (e.g. case 3 above).
  // Substitution will be replaced with actual code on later stage of the build,
  // this way Closure Compiler will not mangle it (e.g. case 4. above).
  // Note that if you want to run closure, and also to use Module
  // after the generated code, you will need to define   var Module = {};
  // before the code. Then that object will be used in the code, and you
  // can continue to use Module afterwards as well.

  var _Module = typeof _Module !== 'undefined' ? _Module : {}; // --pre-jses are emitted after the Module integration code, so that they can
  // refer to Module (if they choose; they can also define Module)
  // {{PRE_JSES}}
  // Sometimes an existing Module object exists with properties
  // meant to overwrite the default module functionality. Here
  // we collect those properties and reapply _after_ we configure
  // the current environment's defaults to avoid having to be so
  // defensive during initialization.


  var moduleOverrides = {};
  var key;

  for (key in _Module) {
    if (_Module.hasOwnProperty(key)) {
      moduleOverrides[key] = _Module[key];
    }
  }

  _Module['arguments'] = [];
  _Module['thisProgram'] = './this.program';

  _Module['quit'] = function (status, toThrow) {
    throw toThrow;
  };

  _Module['preRun'] = [];
  _Module['postRun'] = []; // The environment setup code below is customized to use Module.
  // *** Environment setup code ***

  var ENVIRONMENT_IS_WEB = false;
  var ENVIRONMENT_IS_WORKER = false;
  var ENVIRONMENT_IS_NODE = false;
  var ENVIRONMENT_IS_SHELL = false; // Three configurations we can be running in:
  // 1) We could be the application main() thread running in the main JS UI thread. (ENVIRONMENT_IS_WORKER == false and ENVIRONMENT_IS_PTHREAD == false)
  // 2) We could be the application main() thread proxied to worker. (with Emscripten -s PROXY_TO_WORKER=1) (ENVIRONMENT_IS_WORKER == true, ENVIRONMENT_IS_PTHREAD == false)
  // 3) We could be an application pthread running in a worker. (ENVIRONMENT_IS_WORKER == true and ENVIRONMENT_IS_PTHREAD == true)

  if (_Module['ENVIRONMENT']) {
    if (_Module['ENVIRONMENT'] === 'WEB') {
      ENVIRONMENT_IS_WEB = true;
    } else if (_Module['ENVIRONMENT'] === 'WORKER') {
      ENVIRONMENT_IS_WORKER = true;
    } else if (_Module['ENVIRONMENT'] === 'NODE') {
      ENVIRONMENT_IS_NODE = true;
    } else if (_Module['ENVIRONMENT'] === 'SHELL') {
      ENVIRONMENT_IS_SHELL = true;
    } else {
      throw new Error('Module[\'ENVIRONMENT\'] value is not valid. must be one of: WEB|WORKER|NODE|SHELL.');
    }
  } else {
    ENVIRONMENT_IS_WEB = (typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object';
    ENVIRONMENT_IS_WORKER = typeof importScripts === 'function';
    ENVIRONMENT_IS_NODE = (typeof process === "undefined" ? "undefined" : _typeof(process)) === 'object' && "function" === 'function' && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER;
    ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;
  }

  if (ENVIRONMENT_IS_NODE) {
    // Expose functionality in the same simple way that the shells work
    // Note that we pollute the global namespace here, otherwise we break in node
    var nodeFS;
    var nodePath;

    _Module['read'] = function shell_read(filename, binary) {
      var ret;
      ret = tryParseAsDataURI(filename);

      if (!ret) {
        if (!nodeFS) nodeFS = __webpack_require__(/*! fs */ "./node_modules/node-libs-browser/mock/empty.js");
        if (!nodePath) nodePath = __webpack_require__(/*! path */ "./node_modules/node-libs-browser/mock/empty.js");
        filename = nodePath['normalize'](filename);
        ret = nodeFS['readFileSync'](filename);
      }

      return binary ? ret : ret.toString();
    };

    _Module['readBinary'] = function readBinary(filename) {
      var ret = _Module['read'](filename, true);

      if (!ret.buffer) {
        ret = new Uint8Array(ret);
      }

      assert(ret.buffer);
      return ret;
    };

    if (process['argv'].length > 1) {
      _Module['thisProgram'] = process['argv'][1].replace(/\\/g, '/');
    }

    _Module['arguments'] = process['argv'].slice(2); // MODULARIZE will export the module in the proper place outside, we don't need to export here

    process['on']('uncaughtException', function (ex) {
      // suppress ExitStatus exceptions from showing an error
      if (!(ex instanceof ExitStatus)) {
        throw ex;
      }
    }); // Currently node will swallow unhandled rejections, but this behavior is
    // deprecated, and in the future it will exit with error status.

    process['on']('unhandledRejection', function (reason, p) {
      _Module['printErr']('node.js exiting due to unhandled promise rejection');

      process['exit'](1);
    });

    _Module['inspect'] = function () {
      return '[Emscripten Module object]';
    };
  } else if (ENVIRONMENT_IS_SHELL) {
    if (typeof read != 'undefined') {
      _Module['read'] = function shell_read(f) {
        var data = tryParseAsDataURI(f);

        if (data) {
          return intArrayToString(data);
        }

        return read(f);
      };
    }

    _Module['readBinary'] = function readBinary(f) {
      var data;
      data = tryParseAsDataURI(f);

      if (data) {
        return data;
      }

      if (typeof readbuffer === 'function') {
        return new Uint8Array(readbuffer(f));
      }

      data = read(f, 'binary');
      assert(_typeof(data) === 'object');
      return data;
    };

    if (typeof scriptArgs != 'undefined') {
      _Module['arguments'] = scriptArgs;
    } else if (typeof arguments != 'undefined') {
      _Module['arguments'] = arguments;
    }

    if (typeof quit === 'function') {
      _Module['quit'] = function (status, toThrow) {
        quit(status);
      };
    }
  } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
    _Module['read'] = function shell_read(url) {
      try {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, false);
        xhr.send(null);
        return xhr.responseText;
      } catch (err) {
        var data = tryParseAsDataURI(url);

        if (data) {
          return intArrayToString(data);
        }

        throw err;
      }
    };

    if (ENVIRONMENT_IS_WORKER) {
      _Module['readBinary'] = function readBinary(url) {
        try {
          var xhr = new XMLHttpRequest();
          xhr.open('GET', url, false);
          xhr.responseType = 'arraybuffer';
          xhr.send(null);
          return new Uint8Array(xhr.response);
        } catch (err) {
          var data = tryParseAsDataURI(url);

          if (data) {
            return data;
          }

          throw err;
        }
      };
    }

    _Module['readAsync'] = function readAsync(url, onload, onerror) {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', url, true);
      xhr.responseType = 'arraybuffer';

      xhr.onload = function xhr_onload() {
        if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
          // file URLs can return 0
          onload(xhr.response);
          return;
        }

        var data = tryParseAsDataURI(url);

        if (data) {
          onload(data.buffer);
          return;
        }

        onerror();
      };

      xhr.onerror = onerror;
      xhr.send(null);
    };

    if (typeof arguments != 'undefined') {
      _Module['arguments'] = arguments;
    }

    _Module['setWindowTitle'] = function (title) {
      document.title = title;
    };
  } else {
    // Unreachable because SHELL is dependent on the others
    throw new Error('unknown runtime environment');
  } // console.log is checked first, as 'print' on the web will open a print dialogue
  // printErr is preferable to console.warn (works better in shells)


  _Module['print'] = typeof console !== 'undefined' ? console.log : typeof print !== 'undefined' ? print : null;
  _Module['printErr'] = typeof printErr !== 'undefined' ? printErr : typeof console !== 'undefined' && console.warn || _Module['print']; // *** Environment setup code ***
  // Closure helpers

  _Module.print = _Module['print'];
  _Module.printErr = _Module['printErr']; // Merge back in the overrides

  for (key in moduleOverrides) {
    if (moduleOverrides.hasOwnProperty(key)) {
      _Module[key] = moduleOverrides[key];
    }
  } // Free the object hierarchy contained in the overrides, this lets the GC
  // reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.


  moduleOverrides = undefined; // {{PREAMBLE_ADDITIONS}}

  var STACK_ALIGN = 16; // stack management, and other functionality that is provided by the compiled code,
  // should not be used before it is ready

  _stackSave = _stackRestore = stackAlloc = setTempRet0 = getTempRet0 = function getTempRet0() {
    abort('cannot use the stack before compiled code is ready to run, and has provided stack access');
  };

  function staticAlloc(size) {
    assert(!staticSealed);
    var ret = STATICTOP;
    STATICTOP = STATICTOP + size + 15 & -16;
    return ret;
  }

  function dynamicAlloc(size) {
    assert(DYNAMICTOP_PTR);
    var ret = HEAP32[DYNAMICTOP_PTR >> 2];
    var end = ret + size + 15 & -16;
    HEAP32[DYNAMICTOP_PTR >> 2] = end;

    if (end >= TOTAL_MEMORY) {
      var success = enlargeMemory();

      if (!success) {
        HEAP32[DYNAMICTOP_PTR >> 2] = ret;
        return 0;
      }
    }

    return ret;
  }

  function alignMemory(size, factor) {
    if (!factor) factor = STACK_ALIGN; // stack alignment (16-byte) by default

    var ret = size = Math.ceil(size / factor) * factor;
    return ret;
  }

  function getNativeTypeSize(type) {
    switch (type) {
      case 'i1':
      case 'i8':
        return 1;

      case 'i16':
        return 2;

      case 'i32':
        return 4;

      case 'i64':
        return 8;

      case 'float':
        return 4;

      case 'double':
        return 8;

      default:
        {
          if (type[type.length - 1] === '*') {
            return 4; // A pointer
          } else if (type[0] === 'i') {
            var bits = parseInt(type.substr(1));
            assert(bits % 8 === 0);
            return bits / 8;
          } else {
            return 0;
          }
        }
    }
  }

  function warnOnce(text) {
    if (!warnOnce.shown) warnOnce.shown = {};

    if (!warnOnce.shown[text]) {
      warnOnce.shown[text] = 1;

      _Module.printErr(text);
    }
  }

  var functionPointers = new Array(0);

  function addFunction(func) {
    for (var i = 0; i < functionPointers.length; i++) {
      if (!functionPointers[i]) {
        functionPointers[i] = func;
        return 1 + i;
      }
    }

    throw 'Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS.';
  }

  function removeFunction(index) {
    functionPointers[index - 1] = null;
  }

  var funcWrappers = {};

  function getFuncWrapper(func, sig) {
    if (!func) return; // on null pointer, return undefined

    assert(sig);

    if (!funcWrappers[sig]) {
      funcWrappers[sig] = {};
    }

    var sigCache = funcWrappers[sig];

    if (!sigCache[func]) {
      // optimize away arguments usage in common cases
      if (sig.length === 1) {
        sigCache[func] = function dynCall_wrapper() {
          return dynCall(sig, func);
        };
      } else if (sig.length === 2) {
        sigCache[func] = function dynCall_wrapper(arg) {
          return dynCall(sig, func, [arg]);
        };
      } else {
        // general case
        sigCache[func] = function dynCall_wrapper() {
          return dynCall(sig, func, Array.prototype.slice.call(arguments));
        };
      }
    }

    return sigCache[func];
  }

  function makeBigInt(low, high, unsigned) {
    return unsigned ? +(low >>> 0) + +(high >>> 0) * 4294967296.0 : +(low >>> 0) + +(high | 0) * 4294967296.0;
  }

  function dynCall(sig, ptr, args) {
    if (args && args.length) {
      assert(args.length == sig.length - 1);
      assert('dynCall_' + sig in _Module, 'bad function pointer type - no table for sig \'' + sig + '\'');
      return _Module['dynCall_' + sig].apply(null, [ptr].concat(args));
    } else {
      assert(sig.length == 1);
      assert('dynCall_' + sig in _Module, 'bad function pointer type - no table for sig \'' + sig + '\'');
      return _Module['dynCall_' + sig].call(null, ptr);
    }
  }

  function getCompilerSetting(name) {
    throw 'You must build with -s RETAIN_COMPILER_SETTINGS=1 for getCompilerSetting or emscripten_get_compiler_setting to work';
  }

  var Runtime = {
    // FIXME backwards compatibility layer for ports. Support some Runtime.*
    //       for now, fix it there, then remove it from here. That way we
    //       can minimize any period of breakage.
    dynCall: dynCall,
    // for SDL2 port
    // helpful errors
    getTempRet0: function getTempRet0() {
      abort('getTempRet0() is now a top-level function, after removing the Runtime object. Remove "Runtime."');
    },
    staticAlloc: function staticAlloc() {
      abort('staticAlloc() is now a top-level function, after removing the Runtime object. Remove "Runtime."');
    },
    stackAlloc: function stackAlloc() {
      abort('stackAlloc() is now a top-level function, after removing the Runtime object. Remove "Runtime."');
    }
  }; // The address globals begin at. Very low in memory, for code size and optimization opportunities.
  // Above 0 is static memory, starting with globals.
  // Then the stack.
  // Then 'dynamic' memory for sbrk.

  var GLOBAL_BASE = 1024; // === Preamble library stuff ===
  // Documentation for the public APIs defined in this file must be updated in:
  //    site/source/docs/api_reference/preamble.js.rst
  // A prebuilt local version of the documentation is available at:
  //    site/build/text/docs/api_reference/preamble.js.txt
  // You can also build docs locally as HTML or other formats in site/
  // An online HTML version (which may be of a different version of Emscripten)
  //    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html
  //========================================
  // Runtime essentials
  //========================================

  var ABORT = 0; // whether we are quitting the application. no code should run after this. set in exit() and abort()

  var EXITSTATUS = 0;
  /** @type {function(*, string=)} */

  function assert(condition, text) {
    if (!condition) {
      abort('Assertion failed: ' + text);
    }
  }

  var globalScope = this; // Returns the C function with a specified identifier (for C++, you need to do manual name mangling)

  function getCFunc(ident) {
    var func = _Module['_' + ident]; // closure exported function

    assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');
    return func;
  }

  var JSfuncs = {
    // Helpers for cwrap -- it can't refer to Runtime directly because it might
    // be renamed by closure, instead it calls JSfuncs['stackSave'].body to find
    // out what the minified function name is.
    'stackSave': function stackSave() {
      _stackSave();
    },
    'stackRestore': function stackRestore() {
      _stackRestore();
    },
    // type conversion from js to c
    'arrayToC': function arrayToC(arr) {
      var ret = stackAlloc(arr.length);
      writeArrayToMemory(arr, ret);
      return ret;
    },
    'stringToC': function stringToC(str) {
      var ret = 0;

      if (str !== null && str !== undefined && str !== 0) {
        // null string
        // at most 4 bytes per UTF-8 code point, +1 for the trailing '\0'
        var len = (str.length << 2) + 1;
        ret = stackAlloc(len);
        stringToUTF8(str, ret, len);
      }

      return ret;
    }
  }; // For fast lookup of conversion functions

  var toC = {
    'string': JSfuncs['stringToC'],
    'array': JSfuncs['arrayToC']
  }; // C calling interface.

  function ccall(ident, returnType, argTypes, args, opts) {
    var func = getCFunc(ident);
    var cArgs = [];
    var stack = 0;
    assert(returnType !== 'array', 'Return type should not be "array".');

    if (args) {
      for (var i = 0; i < args.length; i++) {
        var converter = toC[argTypes[i]];

        if (converter) {
          if (stack === 0) stack = _stackSave();
          cArgs[i] = converter(args[i]);
        } else {
          cArgs[i] = args[i];
        }
      }
    }

    var ret = func.apply(null, cArgs);
    if (returnType === 'string') ret = Pointer_stringify(ret);

    if (stack !== 0) {
      _stackRestore(stack);
    }

    return ret;
  }

  function cwrap(ident, returnType, argTypes) {
    argTypes = argTypes || [];
    var cfunc = getCFunc(ident); // When the function takes numbers and returns a number, we can just return
    // the original function

    var numericArgs = argTypes.every(function (type) {
      return type === 'number';
    });
    var numericRet = returnType !== 'string';

    if (numericRet && numericArgs) {
      return cfunc;
    }

    return function () {
      return ccall(ident, returnType, argTypes, arguments);
    };
  }
  /** @type {function(number, number, string, boolean=)} */


  function setValue(ptr, value, type, noSafe) {
    type = type || 'i8';
    if (type.charAt(type.length - 1) === '*') type = 'i32'; // pointers are 32-bit

    switch (type) {
      case 'i1':
        HEAP8[ptr >> 0] = value;
        break;

      case 'i8':
        HEAP8[ptr >> 0] = value;
        break;

      case 'i16':
        HEAP16[ptr >> 1] = value;
        break;

      case 'i32':
        HEAP32[ptr >> 2] = value;
        break;

      case 'i64':
        tempI64 = [value >>> 0, (tempDouble = value, +Math_abs(tempDouble) >= 1.0 ? tempDouble > 0.0 ? (Math_min(+Math_floor(tempDouble / 4294967296.0), 4294967295.0) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0) >>> 0 : 0)], HEAP32[ptr >> 2] = tempI64[0], HEAP32[ptr + 4 >> 2] = tempI64[1];
        break;

      case 'float':
        HEAPF32[ptr >> 2] = value;
        break;

      case 'double':
        HEAPF64[ptr >> 3] = value;
        break;

      default:
        abort('invalid type for setValue: ' + type);
    }
  }
  /** @type {function(number, string, boolean=)} */


  function getValue(ptr, type, noSafe) {
    type = type || 'i8';
    if (type.charAt(type.length - 1) === '*') type = 'i32'; // pointers are 32-bit

    switch (type) {
      case 'i1':
        return HEAP8[ptr >> 0];

      case 'i8':
        return HEAP8[ptr >> 0];

      case 'i16':
        return HEAP16[ptr >> 1];

      case 'i32':
        return HEAP32[ptr >> 2];

      case 'i64':
        return HEAP32[ptr >> 2];

      case 'float':
        return HEAPF32[ptr >> 2];

      case 'double':
        return HEAPF64[ptr >> 3];

      default:
        abort('invalid type for getValue: ' + type);
    }

    return null;
  }

  var ALLOC_NORMAL = 0; // Tries to use _malloc()

  var ALLOC_STACK = 1; // Lives for the duration of the current function call

  var ALLOC_STATIC = 2; // Cannot be freed

  var ALLOC_DYNAMIC = 3; // Cannot be freed except through sbrk

  var ALLOC_NONE = 4; // Do not allocate
  // allocate(): This is for internal use. You can use it yourself as well, but the interface
  //             is a little tricky (see docs right below). The reason is that it is optimized
  //             for multiple syntaxes to save space in generated code. So you should
  //             normally not use allocate(), and instead allocate memory using _malloc(),
  //             initialize it with setValue(), and so forth.
  // @slab: An array of data, or a number. If a number, then the size of the block to allocate,
  //        in *bytes* (note that this is sometimes confusing: the next parameter does not
  //        affect this!)
  // @types: Either an array of types, one for each byte (or 0 if no type at that position),
  //         or a single type which is used for the entire block. This only matters if there
  //         is initial data - if @slab is a number, then this does not matter at all and is
  //         ignored.
  // @allocator: How to allocate memory, see ALLOC_*

  /** @type {function((TypedArray|Array<number>|number), string, number, number=)} */

  function allocate(slab, types, allocator, ptr) {
    var zeroinit, size;

    if (typeof slab === 'number') {
      zeroinit = true;
      size = slab;
    } else {
      zeroinit = false;
      size = slab.length;
    }

    var singleType = typeof types === 'string' ? types : null;
    var ret;

    if (allocator == ALLOC_NONE) {
      ret = ptr;
    } else {
      ret = [typeof _malloc === 'function' ? _malloc : staticAlloc, stackAlloc, staticAlloc, dynamicAlloc][allocator === undefined ? ALLOC_STATIC : allocator](Math.max(size, singleType ? 1 : types.length));
    }

    if (zeroinit) {
      var stop;
      ptr = ret;
      assert((ret & 3) == 0);
      stop = ret + (size & ~3);

      for (; ptr < stop; ptr += 4) {
        HEAP32[ptr >> 2] = 0;
      }

      stop = ret + size;

      while (ptr < stop) {
        HEAP8[ptr++ >> 0] = 0;
      }

      return ret;
    }

    if (singleType === 'i8') {
      if (slab.subarray || slab.slice) {
        HEAPU8.set(
        /** @type {!Uint8Array} */
        slab, ret);
      } else {
        HEAPU8.set(new Uint8Array(slab), ret);
      }

      return ret;
    }

    var i = 0,
        type,
        typeSize,
        previousType;

    while (i < size) {
      var curr = slab[i];
      type = singleType || types[i];

      if (type === 0) {
        i++;
        continue;
      }

      assert(type, 'Must know what type to store in allocate!');
      if (type == 'i64') type = 'i32'; // special case: we have one i32 here, and one i32 later

      setValue(ret + i, curr, type); // no need to look up size unless type changes, so cache it

      if (previousType !== type) {
        typeSize = getNativeTypeSize(type);
        previousType = type;
      }

      i += typeSize;
    }

    return ret;
  } // Allocate memory during any stage of startup - static memory early on, dynamic memory later, malloc when ready


  function getMemory(size) {
    if (!staticSealed) return staticAlloc(size);
    if (!runtimeInitialized) return dynamicAlloc(size);
    return _malloc(size);
  }
  /** @type {function(number, number=)} */


  function Pointer_stringify(ptr, length) {
    if (length === 0 || !ptr) return ''; // TODO: use TextDecoder
    // Find the length, and check for UTF while doing so

    var hasUtf = 0;
    var t;
    var i = 0;

    while (1) {
      assert(ptr + i < TOTAL_MEMORY);
      t = HEAPU8[ptr + i >> 0];
      hasUtf |= t;
      if (t == 0 && !length) break;
      i++;
      if (length && i == length) break;
    }

    if (!length) length = i;
    var ret = '';

    if (hasUtf < 128) {
      var MAX_CHUNK = 1024; // split up into chunks, because .apply on a huge string can overflow the stack

      var curr;

      while (length > 0) {
        curr = String.fromCharCode.apply(String, HEAPU8.subarray(ptr, ptr + Math.min(length, MAX_CHUNK)));
        ret = ret ? ret + curr : curr;
        ptr += MAX_CHUNK;
        length -= MAX_CHUNK;
      }

      return ret;
    }

    return UTF8ToString(ptr);
  } // Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns
  // a copy of that string as a Javascript String object.


  function AsciiToString(ptr) {
    var str = '';

    while (1) {
      var ch = HEAP8[ptr++ >> 0];
      if (!ch) return str;
      str += String.fromCharCode(ch);
    }
  } // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
  // null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.


  function stringToAscii(str, outPtr) {
    return writeAsciiToMemory(str, outPtr, false);
  } // Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns
  // a copy of that string as a Javascript String object.


  var UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined;

  function UTF8ArrayToString(u8Array, idx) {
    var endPtr = idx; // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
    // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.

    while (u8Array[endPtr]) {
      ++endPtr;
    }

    if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {
      return UTF8Decoder.decode(u8Array.subarray(idx, endPtr));
    } else {
      var u0, u1, u2, u3, u4, u5;
      var str = '';

      while (1) {
        // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629
        u0 = u8Array[idx++];
        if (!u0) return str;

        if (!(u0 & 0x80)) {
          str += String.fromCharCode(u0);
          continue;
        }

        u1 = u8Array[idx++] & 63;

        if ((u0 & 0xE0) == 0xC0) {
          str += String.fromCharCode((u0 & 31) << 6 | u1);
          continue;
        }

        u2 = u8Array[idx++] & 63;

        if ((u0 & 0xF0) == 0xE0) {
          u0 = (u0 & 15) << 12 | u1 << 6 | u2;
        } else {
          u3 = u8Array[idx++] & 63;

          if ((u0 & 0xF8) == 0xF0) {
            u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | u3;
          } else {
            u4 = u8Array[idx++] & 63;

            if ((u0 & 0xFC) == 0xF8) {
              u0 = (u0 & 3) << 24 | u1 << 18 | u2 << 12 | u3 << 6 | u4;
            } else {
              u5 = u8Array[idx++] & 63;
              u0 = (u0 & 1) << 30 | u1 << 24 | u2 << 18 | u3 << 12 | u4 << 6 | u5;
            }
          }
        }

        if (u0 < 0x10000) {
          str += String.fromCharCode(u0);
        } else {
          var ch = u0 - 0x10000;
          str += String.fromCharCode(0xD800 | ch >> 10, 0xDC00 | ch & 0x3FF);
        }
      }
    }
  } // Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns
  // a copy of that string as a Javascript String object.


  function UTF8ToString(ptr) {
    return UTF8ArrayToString(HEAPU8, ptr);
  } // Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',
  // encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.
  // Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
  // Parameters:
  //   str: the Javascript string to copy.
  //   outU8Array: the array to copy to. Each index in this array is assumed to be one 8-byte element.
  //   outIdx: The starting offset in the array to begin the copying.
  //   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
  //                    terminator, i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.
  //                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.
  // Returns the number of bytes written, EXCLUDING the null terminator.


  function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {
    if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.
      return 0;
    var startIdx = outIdx;
    var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.

    for (var i = 0; i < str.length; ++i) {
      // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
      // See http://unicode.org/faq/utf_bom.html#utf16-3
      // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629
      var u = str.charCodeAt(i); // possibly a lead surrogate

      if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | str.charCodeAt(++i) & 0x3FF;

      if (u <= 0x7F) {
        if (outIdx >= endIdx) break;
        outU8Array[outIdx++] = u;
      } else if (u <= 0x7FF) {
        if (outIdx + 1 >= endIdx) break;
        outU8Array[outIdx++] = 0xC0 | u >> 6;
        outU8Array[outIdx++] = 0x80 | u & 63;
      } else if (u <= 0xFFFF) {
        if (outIdx + 2 >= endIdx) break;
        outU8Array[outIdx++] = 0xE0 | u >> 12;
        outU8Array[outIdx++] = 0x80 | u >> 6 & 63;
        outU8Array[outIdx++] = 0x80 | u & 63;
      } else if (u <= 0x1FFFFF) {
        if (outIdx + 3 >= endIdx) break;
        outU8Array[outIdx++] = 0xF0 | u >> 18;
        outU8Array[outIdx++] = 0x80 | u >> 12 & 63;
        outU8Array[outIdx++] = 0x80 | u >> 6 & 63;
        outU8Array[outIdx++] = 0x80 | u & 63;
      } else if (u <= 0x3FFFFFF) {
        if (outIdx + 4 >= endIdx) break;
        outU8Array[outIdx++] = 0xF8 | u >> 24;
        outU8Array[outIdx++] = 0x80 | u >> 18 & 63;
        outU8Array[outIdx++] = 0x80 | u >> 12 & 63;
        outU8Array[outIdx++] = 0x80 | u >> 6 & 63;
        outU8Array[outIdx++] = 0x80 | u & 63;
      } else {
        if (outIdx + 5 >= endIdx) break;
        outU8Array[outIdx++] = 0xFC | u >> 30;
        outU8Array[outIdx++] = 0x80 | u >> 24 & 63;
        outU8Array[outIdx++] = 0x80 | u >> 18 & 63;
        outU8Array[outIdx++] = 0x80 | u >> 12 & 63;
        outU8Array[outIdx++] = 0x80 | u >> 6 & 63;
        outU8Array[outIdx++] = 0x80 | u & 63;
      }
    } // Null-terminate the pointer to the buffer.


    outU8Array[outIdx] = 0;
    return outIdx - startIdx;
  } // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
  // null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.
  // Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
  // Returns the number of bytes written, EXCLUDING the null terminator.


  function stringToUTF8(str, outPtr, maxBytesToWrite) {
    assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
    return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
  } // Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.


  function lengthBytesUTF8(str) {
    var len = 0;

    for (var i = 0; i < str.length; ++i) {
      // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
      // See http://unicode.org/faq/utf_bom.html#utf16-3
      var u = str.charCodeAt(i); // possibly a lead surrogate

      if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | str.charCodeAt(++i) & 0x3FF;

      if (u <= 0x7F) {
        ++len;
      } else if (u <= 0x7FF) {
        len += 2;
      } else if (u <= 0xFFFF) {
        len += 3;
      } else if (u <= 0x1FFFFF) {
        len += 4;
      } else if (u <= 0x3FFFFFF) {
        len += 5;
      } else {
        len += 6;
      }
    }

    return len;
  } // Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns
  // a copy of that string as a Javascript String object.


  var UTF16Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-16le') : undefined;

  function UTF16ToString(ptr) {
    assert(ptr % 2 == 0, 'Pointer passed to UTF16ToString must be aligned to two bytes!');
    var endPtr = ptr; // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
    // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.

    var idx = endPtr >> 1;

    while (HEAP16[idx]) {
      ++idx;
    }

    endPtr = idx << 1;

    if (endPtr - ptr > 32 && UTF16Decoder) {
      return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));
    } else {
      var i = 0;
      var str = '';

      while (1) {
        var codeUnit = HEAP16[ptr + i * 2 >> 1];
        if (codeUnit == 0) return str;
        ++i; // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.

        str += String.fromCharCode(codeUnit);
      }
    }
  } // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
  // null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.
  // Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.
  // Parameters:
  //   str: the Javascript string to copy.
  //   outPtr: Byte address in Emscripten HEAP where to write the string to.
  //   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
  //                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.
  //                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.
  // Returns the number of bytes written, EXCLUDING the null terminator.


  function stringToUTF16(str, outPtr, maxBytesToWrite) {
    assert(outPtr % 2 == 0, 'Pointer passed to stringToUTF16 must be aligned to two bytes!');
    assert(typeof maxBytesToWrite == 'number', 'stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!'); // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.

    if (maxBytesToWrite === undefined) {
      maxBytesToWrite = 0x7FFFFFFF;
    }

    if (maxBytesToWrite < 2) return 0;
    maxBytesToWrite -= 2; // Null terminator.

    var startPtr = outPtr;
    var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;

    for (var i = 0; i < numCharsToWrite; ++i) {
      // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.
      var codeUnit = str.charCodeAt(i); // possibly a lead surrogate

      HEAP16[outPtr >> 1] = codeUnit;
      outPtr += 2;
    } // Null-terminate the pointer to the HEAP.


    HEAP16[outPtr >> 1] = 0;
    return outPtr - startPtr;
  } // Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.


  function lengthBytesUTF16(str) {
    return str.length * 2;
  }

  function UTF32ToString(ptr) {
    assert(ptr % 4 == 0, 'Pointer passed to UTF32ToString must be aligned to four bytes!');
    var i = 0;
    var str = '';

    while (1) {
      var utf32 = HEAP32[ptr + i * 4 >> 2];
      if (utf32 == 0) return str;
      ++i; // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.
      // See http://unicode.org/faq/utf_bom.html#utf16-3

      if (utf32 >= 0x10000) {
        var ch = utf32 - 0x10000;
        str += String.fromCharCode(0xD800 | ch >> 10, 0xDC00 | ch & 0x3FF);
      } else {
        str += String.fromCharCode(utf32);
      }
    }
  } // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
  // null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.
  // Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.
  // Parameters:
  //   str: the Javascript string to copy.
  //   outPtr: Byte address in Emscripten HEAP where to write the string to.
  //   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
  //                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.
  //                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.
  // Returns the number of bytes written, EXCLUDING the null terminator.


  function stringToUTF32(str, outPtr, maxBytesToWrite) {
    assert(outPtr % 4 == 0, 'Pointer passed to stringToUTF32 must be aligned to four bytes!');
    assert(typeof maxBytesToWrite == 'number', 'stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!'); // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.

    if (maxBytesToWrite === undefined) {
      maxBytesToWrite = 0x7FFFFFFF;
    }

    if (maxBytesToWrite < 4) return 0;
    var startPtr = outPtr;
    var endPtr = startPtr + maxBytesToWrite - 4;

    for (var i = 0; i < str.length; ++i) {
      // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
      // See http://unicode.org/faq/utf_bom.html#utf16-3
      var codeUnit = str.charCodeAt(i); // possibly a lead surrogate

      if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {
        var trailSurrogate = str.charCodeAt(++i);
        codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | trailSurrogate & 0x3FF;
      }

      HEAP32[outPtr >> 2] = codeUnit;
      outPtr += 4;
      if (outPtr + 4 > endPtr) break;
    } // Null-terminate the pointer to the HEAP.


    HEAP32[outPtr >> 2] = 0;
    return outPtr - startPtr;
  } // Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.


  function lengthBytesUTF32(str) {
    var len = 0;

    for (var i = 0; i < str.length; ++i) {
      // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
      // See http://unicode.org/faq/utf_bom.html#utf16-3
      var codeUnit = str.charCodeAt(i);
      if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.

      len += 4;
    }

    return len;
  } // Allocate heap space for a JS string, and write it there.
  // It is the responsibility of the caller to free() that memory.


  function allocateUTF8(str) {
    var size = lengthBytesUTF8(str) + 1;

    var ret = _malloc(size);

    if (ret) stringToUTF8Array(str, HEAP8, ret, size);
    return ret;
  } // Allocate stack space for a JS string, and write it there.


  function allocateUTF8OnStack(str) {
    var size = lengthBytesUTF8(str) + 1;
    var ret = stackAlloc(size);
    stringToUTF8Array(str, HEAP8, ret, size);
    return ret;
  }

  function demangle(func) {
    warnOnce('warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling');
    return func;
  }

  function demangleAll(text) {
    var regex = /__Z[\w\d_]+/g;
    return text.replace(regex, function (x) {
      var y = demangle(x);
      return x === y ? x : x + ' [' + y + ']';
    });
  }

  function jsStackTrace() {
    var err = new Error();

    if (!err.stack) {
      // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,
      // so try that as a special-case.
      try {
        throw new Error(0);
      } catch (e) {
        err = e;
      }

      if (!err.stack) {
        return '(no stack trace available)';
      }
    }

    return err.stack.toString();
  }

  function stackTrace() {
    var js = jsStackTrace();
    if (_Module['extraStackTrace']) js += '\n' + _Module['extraStackTrace']();
    return demangleAll(js);
  } // Memory management


  var PAGE_SIZE = 16384;
  var WASM_PAGE_SIZE = 65536;
  var ASMJS_PAGE_SIZE = 16777216;
  var MIN_TOTAL_MEMORY = 16777216;

  function alignUp(x, multiple) {
    if (x % multiple > 0) {
      x += multiple - x % multiple;
    }

    return x;
  }

  var HEAP,
  /** @type {ArrayBuffer} */
  buffer,
  /** @type {Int8Array} */
  HEAP8,
  /** @type {Uint8Array} */
  HEAPU8,
  /** @type {Int16Array} */
  HEAP16,
  /** @type {Uint16Array} */
  HEAPU16,
  /** @type {Int32Array} */
  HEAP32,
  /** @type {Uint32Array} */
  HEAPU32,
  /** @type {Float32Array} */
  HEAPF32,
  /** @type {Float64Array} */
  HEAPF64;

  function updateGlobalBuffer(buf) {
    _Module['buffer'] = buffer = buf;
  }

  function updateGlobalBufferViews() {
    _Module['HEAP8'] = HEAP8 = new Int8Array(buffer);
    _Module['HEAP16'] = HEAP16 = new Int16Array(buffer);
    _Module['HEAP32'] = HEAP32 = new Int32Array(buffer);
    _Module['HEAPU8'] = HEAPU8 = new Uint8Array(buffer);
    _Module['HEAPU16'] = HEAPU16 = new Uint16Array(buffer);
    _Module['HEAPU32'] = HEAPU32 = new Uint32Array(buffer);
    _Module['HEAPF32'] = HEAPF32 = new Float32Array(buffer);
    _Module['HEAPF64'] = HEAPF64 = new Float64Array(buffer);
  }

  var STATIC_BASE, STATICTOP, staticSealed; // static area

  var STACK_BASE, STACKTOP, STACK_MAX; // stack area

  var DYNAMIC_BASE, DYNAMICTOP_PTR; // dynamic area handled by sbrk

  STATIC_BASE = STATICTOP = STACK_BASE = STACKTOP = STACK_MAX = DYNAMIC_BASE = DYNAMICTOP_PTR = 0;
  staticSealed = false; // Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.

  function writeStackCookie() {
    assert((STACK_MAX & 3) == 0);
    HEAPU32[(STACK_MAX >> 2) - 1] = 0x02135467;
    HEAPU32[(STACK_MAX >> 2) - 2] = 0x89BACDFE;
  }

  function checkStackCookie() {
    if (HEAPU32[(STACK_MAX >> 2) - 1] != 0x02135467 || HEAPU32[(STACK_MAX >> 2) - 2] != 0x89BACDFE) {
      abort('Stack overflow! Stack cookie has been overwritten, expected hex dwords 0x89BACDFE and 0x02135467, but received 0x' + HEAPU32[(STACK_MAX >> 2) - 2].toString(16) + ' ' + HEAPU32[(STACK_MAX >> 2) - 1].toString(16));
    } // Also test the global address 0 for integrity. This check is not compatible with SAFE_SPLIT_MEMORY though, since that mode already tests all address 0 accesses on its own.


    if (HEAP32[0] !== 0x63736d65
    /* 'emsc' */
    ) throw 'Runtime error: The application has corrupted its heap memory area (address zero)!';
  }

  function abortStackOverflow(allocSize) {
    abort('Stack overflow! Attempted to allocate ' + allocSize + ' bytes on the stack, but stack has only ' + (STACK_MAX - _stackSave() + allocSize) + ' bytes available!');
  }

  function abortOnCannotGrowMemory() {
    abort('Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value ' + TOTAL_MEMORY + ', (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ');
  }

  function enlargeMemory() {
    abortOnCannotGrowMemory();
  }

  var TOTAL_STACK = _Module['TOTAL_STACK'] || 5242880;
  var TOTAL_MEMORY = _Module['TOTAL_MEMORY'] || 16777216;
  if (TOTAL_MEMORY < TOTAL_STACK) _Module.printErr('TOTAL_MEMORY should be larger than TOTAL_STACK, was ' + TOTAL_MEMORY + '! (TOTAL_STACK=' + TOTAL_STACK + ')'); // Initialize the runtime's memory
  // check for full engine support (use string 'subarray' to avoid closure compiler confusion)

  assert(typeof Int32Array !== 'undefined' && typeof Float64Array !== 'undefined' && Int32Array.prototype.subarray !== undefined && Int32Array.prototype.set !== undefined, 'JS engine does not provide full typed array support'); // Use a provided buffer, if there is one, or else allocate a new one

  if (_Module['buffer']) {
    buffer = _Module['buffer'];
    assert(buffer.byteLength === TOTAL_MEMORY, 'provided buffer should be ' + TOTAL_MEMORY + ' bytes, but it is ' + buffer.byteLength);
  } else {
    // Use a WebAssembly memory where available
    if ((typeof WebAssembly === "undefined" ? "undefined" : _typeof(WebAssembly)) === 'object' && typeof WebAssembly.Memory === 'function') {
      assert(TOTAL_MEMORY % WASM_PAGE_SIZE === 0);
      _Module['wasmMemory'] = new WebAssembly.Memory({
        'initial': TOTAL_MEMORY / WASM_PAGE_SIZE,
        'maximum': TOTAL_MEMORY / WASM_PAGE_SIZE
      });
      buffer = _Module['wasmMemory'].buffer;
    } else {
      buffer = new ArrayBuffer(TOTAL_MEMORY);
    }

    assert(buffer.byteLength === TOTAL_MEMORY);
    _Module['buffer'] = buffer;
  }

  updateGlobalBufferViews();

  function getTotalMemory() {
    return TOTAL_MEMORY;
  } // Endianness check (note: assumes compiler arch was little-endian)


  HEAP32[0] = 0x63736d65;
  /* 'emsc' */

  HEAP16[1] = 0x6373;
  if (HEAPU8[2] !== 0x73 || HEAPU8[3] !== 0x63) throw 'Runtime error: expected the system to be little-endian!';

  function callRuntimeCallbacks(callbacks) {
    while (callbacks.length > 0) {
      var callback = callbacks.shift();

      if (typeof callback == 'function') {
        callback();
        continue;
      }

      var func = callback.func;

      if (typeof func === 'number') {
        if (callback.arg === undefined) {
          _Module['dynCall_v'](func);
        } else {
          _Module['dynCall_vi'](func, callback.arg);
        }
      } else {
        func(callback.arg === undefined ? null : callback.arg);
      }
    }
  }

  var __ATPRERUN__ = []; // functions called before the runtime is initialized

  var __ATINIT__ = []; // functions called during startup

  var __ATMAIN__ = []; // functions called when main() is to be run

  var __ATEXIT__ = []; // functions called during shutdown

  var __ATPOSTRUN__ = []; // functions called after the runtime has exited

  var runtimeInitialized = false;
  var runtimeExited = false;

  function preRun() {
    // compatibility - merge in anything from Module['preRun'] at this time
    if (_Module['preRun']) {
      if (typeof _Module['preRun'] == 'function') _Module['preRun'] = [_Module['preRun']];

      while (_Module['preRun'].length) {
        addOnPreRun(_Module['preRun'].shift());
      }
    }

    callRuntimeCallbacks(__ATPRERUN__);
  }

  function ensureInitRuntime() {
    checkStackCookie();
    if (runtimeInitialized) return;
    runtimeInitialized = true;
    callRuntimeCallbacks(__ATINIT__);
  }

  function preMain() {
    checkStackCookie();
    callRuntimeCallbacks(__ATMAIN__);
  }

  function exitRuntime() {
    checkStackCookie();
    callRuntimeCallbacks(__ATEXIT__);
    runtimeExited = true;
  }

  function postRun() {
    checkStackCookie(); // compatibility - merge in anything from Module['postRun'] at this time

    if (_Module['postRun']) {
      if (typeof _Module['postRun'] == 'function') _Module['postRun'] = [_Module['postRun']];

      while (_Module['postRun'].length) {
        addOnPostRun(_Module['postRun'].shift());
      }
    }

    callRuntimeCallbacks(__ATPOSTRUN__);
  }

  function addOnPreRun(cb) {
    __ATPRERUN__.unshift(cb);
  }

  function addOnInit(cb) {
    __ATINIT__.unshift(cb);
  }

  function addOnPreMain(cb) {
    __ATMAIN__.unshift(cb);
  }

  function addOnExit(cb) {
    __ATEXIT__.unshift(cb);
  }

  function addOnPostRun(cb) {
    __ATPOSTRUN__.unshift(cb);
  } // Deprecated: This function should not be called because it is unsafe and does not provide
  // a maximum length limit of how many bytes it is allowed to write. Prefer calling the
  // function stringToUTF8Array() instead, which takes in a maximum length that can be used
  // to be secure from out of bounds writes.

  /** @deprecated */


  function writeStringToMemory(string, buffer, dontAddNull) {
    warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');
    var
    /** @type {number} */
    lastChar,
    /** @type {number} */
    end;

    if (dontAddNull) {
      // stringToUTF8Array always appends null. If we don't want to do that, remember the
      // character that existed at the location where the null will be placed, and restore
      // that after the write (below).
      end = buffer + lengthBytesUTF8(string);
      lastChar = HEAP8[end];
    }

    stringToUTF8(string, buffer, Infinity);
    if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.
  }

  function writeArrayToMemory(array, buffer) {
    assert(array.length >= 0, 'writeArrayToMemory array must have a length (should be an array or typed array)');
    HEAP8.set(array, buffer);
  }

  function writeAsciiToMemory(str, buffer, dontAddNull) {
    for (var i = 0; i < str.length; ++i) {
      assert(str.charCodeAt(i) === str.charCodeAt(i) & 0xff);
      HEAP8[buffer++ >> 0] = str.charCodeAt(i);
    } // Null-terminate the pointer to the HEAP.


    if (!dontAddNull) HEAP8[buffer >> 0] = 0;
  }

  function unSign(value, bits, ignore) {
    if (value >= 0) {
      return value;
    }

    return bits <= 32 ? 2 * Math.abs(1 << bits - 1) + value // Need some trickery, since if bits == 32, we are right at the limit of the bits JS uses in bitshifts
    : Math.pow(2, bits) + value;
  }

  function reSign(value, bits, ignore) {
    if (value <= 0) {
      return value;
    }

    var half = bits <= 32 ? Math.abs(1 << bits - 1) // abs is needed if bits == 32
    : Math.pow(2, bits - 1);

    if (value >= half && (bits <= 32 || value > half)) {
      // for huge values, we can hit the precision limit and always get true here. so don't do that
      // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors
      // TODO: In i64 mode 1, resign the two parts separately and safely
      value = -2 * half + value; // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts
    }

    return value;
  }

  assert(Math['imul'] && Math['fround'] && Math['clz32'] && Math['trunc'], 'this is a legacy browser, build with LEGACY_VM_SUPPORT');
  var Math_abs = Math.abs;
  var Math_cos = Math.cos;
  var Math_sin = Math.sin;
  var Math_tan = Math.tan;
  var Math_acos = Math.acos;
  var Math_asin = Math.asin;
  var Math_atan = Math.atan;
  var Math_atan2 = Math.atan2;
  var Math_exp = Math.exp;
  var Math_log = Math.log;
  var Math_sqrt = Math.sqrt;
  var Math_ceil = Math.ceil;
  var Math_floor = Math.floor;
  var Math_pow = Math.pow;
  var Math_imul = Math.imul;
  var Math_fround = Math.fround;
  var Math_round = Math.round;
  var Math_min = Math.min;
  var Math_max = Math.max;
  var Math_clz32 = Math.clz32;
  var Math_trunc = Math.trunc; // A counter of dependencies for calling run(). If we need to
  // do asynchronous work before running, increment this and
  // decrement it. Incrementing must happen in a place like
  // PRE_RUN_ADDITIONS (used by emcc to add file preloading).
  // Note that you can add dependencies in preRun, even though
  // it happens right before run - run will be postponed until
  // the dependencies are met.

  var runDependencies = 0;
  var runDependencyWatcher = null;
  var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled

  var runDependencyTracking = {};

  function getUniqueRunDependency(id) {
    var orig = id;

    while (1) {
      if (!runDependencyTracking[id]) return id;
      id = orig + Math.random();
    }

    return id;
  }

  function addRunDependency(id) {
    runDependencies++;

    if (_Module['monitorRunDependencies']) {
      _Module['monitorRunDependencies'](runDependencies);
    }

    if (id) {
      assert(!runDependencyTracking[id]);
      runDependencyTracking[id] = 1;

      if (runDependencyWatcher === null && typeof setInterval !== 'undefined') {
        // Check for missing dependencies every few seconds
        runDependencyWatcher = setInterval(function () {
          if (ABORT) {
            clearInterval(runDependencyWatcher);
            runDependencyWatcher = null;
            return;
          }

          var shown = false;

          for (var dep in runDependencyTracking) {
            if (!shown) {
              shown = true;

              _Module.printErr('still waiting on run dependencies:');
            }

            _Module.printErr('dependency: ' + dep);
          }

          if (shown) {
            _Module.printErr('(end of list)');
          }
        }, 10000);
      }
    } else {
      _Module.printErr('warning: run dependency added without ID');
    }
  }

  function removeRunDependency(id) {
    runDependencies--;

    if (_Module['monitorRunDependencies']) {
      _Module['monitorRunDependencies'](runDependencies);
    }

    if (id) {
      assert(runDependencyTracking[id]);
      delete runDependencyTracking[id];
    } else {
      _Module.printErr('warning: run dependency removed without ID');
    }

    if (runDependencies == 0) {
      if (runDependencyWatcher !== null) {
        clearInterval(runDependencyWatcher);
        runDependencyWatcher = null;
      }

      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback(); // can add another dependenciesFulfilled
      }
    }
  }

  _Module["preloadedImages"] = {}; // maps url to image data

  _Module["preloadedAudios"] = {}; // maps url to audio data

  var memoryInitializer = null;
  var
  /* show errors on likely calls to FS when it was not included */
  FS = {
    error: function error() {
      abort('Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with  -s FORCE_FILESYSTEM=1');
    },
    init: function init() {
      FS.error();
    },
    createDataFile: function createDataFile() {
      FS.error();
    },
    createPreloadedFile: function createPreloadedFile() {
      FS.error();
    },
    createLazyFile: function createLazyFile() {
      FS.error();
    },
    open: function open() {
      FS.error();
    },
    mkdev: function mkdev() {
      FS.error();
    },
    registerDevice: function registerDevice() {
      FS.error();
    },
    analyzePath: function analyzePath() {
      FS.error();
    },
    loadFilesFromDB: function loadFilesFromDB() {
      FS.error();
    },
    ErrnoError: function ErrnoError() {
      FS.error();
    }
  };
  _Module['FS_createDataFile'] = FS.createDataFile;
  _Module['FS_createPreloadedFile'] = FS.createPreloadedFile; // Prefix of data URIs emitted by SINGLE_FILE and related options.

  var dataURIPrefix = 'data:application/octet-stream;base64,'; // Indicates whether filename is a base64 data URI.

  function isDataURI(filename) {
    return String.prototype.startsWith ? filename.startsWith(dataURIPrefix) : filename.indexOf(dataURIPrefix) === 0;
  }

  function integrateWasmJS() {
    // wasm.js has several methods for creating the compiled code module here:
    //  * 'native-wasm' : use native WebAssembly support in the browser
    //  * 'interpret-s-expr': load s-expression code from a .wast and interpret
    //  * 'interpret-binary': load binary wasm and interpret
    //  * 'interpret-asm2wasm': load asm.js code, translate to wasm, and interpret
    //  * 'asmjs': no wasm, just load the asm.js code and use that (good for testing)
    // The method is set at compile time (BINARYEN_METHOD)
    // The method can be a comma-separated list, in which case, we will try the
    // options one by one. Some of them can fail gracefully, and then we can try
    // the next.
    // inputs
    var method = 'native-wasm';
    var wasmTextFile = '';
    var wasmBinaryFile = 'data:application/octet-stream;base64,AGFzbQEAAAABchJgA39/fwF/YAF/AX9gAAF/YAF/AGACf38Bf2AEf39/fwF/YAJ/fwBgA39/fwBgBH9/f38AYAN/f38BfmAAAGAFf39/f38Bf2ADfn9/AX9gAn5/AX9gBX9/f39/AGAGf3x/f39/AX9gAXwBfmACfH8BfAKXBSEDZW52Bm1lbW9yeQIBgAKAAgNlbnYFdGFibGUBcAEQEANlbnYKbWVtb3J5QmFzZQN/AANlbnYJdGFibGVCYXNlA38AA2Vudg5EWU5BTUlDVE9QX1BUUgN/AANlbnYNdGVtcERvdWJsZVB0cgN/AANlbnYFQUJPUlQDfwADZW52CFNUQUNLVE9QA38AA2VudglTVEFDS19NQVgDfwADZW52B2N0dHpfaTgDfwAGZ2xvYmFsA05hTgN8AAZnbG9iYWwISW5maW5pdHkDfAADZW52DWVubGFyZ2VNZW1vcnkAAgNlbnYOZ2V0VG90YWxNZW1vcnkAAgNlbnYXYWJvcnRPbkNhbm5vdEdyb3dNZW1vcnkAAgNlbnYSYWJvcnRTdGFja092ZXJmbG93AAMDZW52C251bGxGdW5jX2lpAAMDZW52DW51bGxGdW5jX2lpaWkAAwNlbnYHX19fbG9jawADA2VudgtfX19zZXRFcnJObwADA2Vudg1fX19zeXNjYWxsMTQwAAQDZW52DV9fX3N5c2NhbGwxNDYABANlbnYMX19fc3lzY2FsbDU0AAQDZW52C19fX3N5c2NhbGw2AAQDZW52CV9fX3VubG9jawADA2VudiFfZW1zY3JpcHRlbl9oYXNfdGhyZWFkaW5nX3N1cHBvcnQAAgNlbnYWX2Vtc2NyaXB0ZW5fbWVtY3B5X2JpZwAAA2VudhJfbGx2bV9zdGFja3Jlc3RvcmUAAwNlbnYPX2xsdm1fc3RhY2tzYXZlAAIDZW52D19wdGhyZWFkX2NyZWF0ZQAFA2Vudg1fcHRocmVhZF9qb2luAAQDZW52E19wdGhyZWFkX211dGV4X2luaXQABANlbnYIX3N5c2NvbmYAAQNSUQECAwYGAwIEAwcDCAcBCAAICQQACgYBAwEAAAECAQAEAAsBAwcBBwwNDQEADgQPEBERAAICAgQEBAAEAAEEAQQEAgoBAQAKAQAAAQEBBAUBAAZyFH8BIwILfwEjAwt/ASMEC38BIwULfwEj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IQQgBA8L9BEDC38EfgV8Iw0hDCAAvSEPIA9CNIghECAQp0H//wNxIQkgCUH/D3EhCgJAAkACQAJAIApBEHRBEHVBAGsOgBAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAQILAkAgAEQAAAAAAAAAAGIhBCAEBEAgAEQAAAAAAADwQ6IhFCAUIAEQRiEVIAEoAgAhBSAFQUBqIQYgFSESIAYhCAUgACESQQAhCAsgASAINgIAIBIhEQwDAAsACwJAIAAhEQwCAAsACwJAIBCnIQcgB0H/D3EhAiACQYJ4aiEDIAEgAzYCACAPQv////////+HgH+DIQ0gDUKAgICAgICA8D+EIQ4gDr8hEyATIRELCyARDwvkBAE7fyMNIT0gAEEARiEYAkAgGARAQQEhAwUgAUGAAUkhIyAjBEAgAUH/AXEhLiAAIC46AABBASEDDAILEEghNyA3QbwBaiE4IDgoAgAhOSA5KAIAITogOkEARiEEIAQEQCABQYB/cSEFIAVBgL8DRiEGIAYEQCABQf8BcSEIIAAgCDoAAEEBIQMMAwUQMSEHIAdB1AA2AgBBfyEDDAMLAAsgAUGAEEkhCSAJBEAgAUEGdiEKIApBwAFyIQsgC0H/AXEhDCAAQQFqIQ0gACAMOgAAIAFBP3EhDiAOQYABciEPIA9B/wFxIRAgDSAQOgAAQQIhAwwCCyABQYCwA0khESABQYBAcSESIBJBgMADRiETIBEgE3IhOyA7BEAgAUEMdiEUIBRB4AFyIRUgFUH/AXEhFiAAQQFqIRcgACAWOgAAIAFBBnYhGSAZQT9xIRogGkGAAXIhGyAbQf8BcSEcIABBAmohHSAXIBw6AAAgAUE/cSEeIB5BgAFyIR8gH0H/AXEhICAdICA6AABBAyED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ADYCACAPQQA2AgAgAkEANgIAIAVBADYCACADQQA2AgBBACEBCyABDws3AQR/Iw0hBiMNQRBqJA0jDSMOTgRAQRAQAwsgBiEDIAMgAjYCACAAIAEgAxA1IQQgBiQNIAQPCwMAAQssACAAQf8BcUEYdCAAQQh1Qf8BcUEQdHIgAEEQdUH/AXFBCHRyIABBGHZyDwvkBAEEfyACQYDAAE4EQCAAIAEgAhAODwsgACEDIAAgAmohBiAAQQNxIAFBA3FGBEADQAJAIABBA3FFBEAMAQsCQCACQQBGBEAgAw8LIAAgASwAADoAACAAQQFqIQAgAUEBaiEBIAJBAWshAgsMAQsLIAZBfHEhBCAEQcAAayEFA0ACQCAAIAVMRQRADAELAkAgACABKAIANgIAIABBBGogAUEEaigCADYCACAAQQhqIAFBCGooAgA2AgAgAEEMaiABQQxqKAIANgIAIABBEGogAUEQaigCADYCACAAQRRqIAFBFGooAgA2AgAgAEEYaiABQRhqKAIANgIAIABBHGogAUEcaigCADYCACAAQSBqIAFBIGooAgA2AgAgAEEkaiABQSRqKAIANgIAIABBKGogAUEoaigCADYCACAAQSxqIAFBLGooAgA2AgAgAEEwaiABQTBqKAIANgIAIABBNGogAUE0aigCADYCACAAQThqIAFBOGooAgA2AgAgAEE8aiABQTxqKAIANgIAIABBwABqIQAgAUHAAGohAQsMAQsLA0ACQCAAIARIRQRADAELAkAgACABKAIANgIAIABBBGohACABQQRqIQELDAELCwUgBkEEayEEA0ACQCAAIARIRQRADAELAkAgACABLAAAOgAAIABBAWogAUEBaiwAADoAACAAQQJqIAFBAmosAAA6AAAgAEEDaiABQQNqLAAAOgAAIABBBGohACABQQRqIQELDAELCwsDQAJAIAAgBkhFBEAMAQsCQCAAIAEsAAA6AAAgAEEBaiEAIAFBAWohAQsMAQsLIAMPC/ECAQR/IAAgAmohAyABQf8BcSEBIAJBwwBOBEADQAJAIABBA3FBAEdFBEAMAQsCQCAAIAE6AAAgAEEBaiEACwwBCwsgA0F8cSEEIARBwABrIQUgASABQQh0ciABQRB0ciABQRh0ciEGA0ACQCAAIAVMRQRADAELAkAgACAGNgIAIABBBGogBjYCACAA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ExQVGggWBygkFxgJCg4bHyUjg4J9JiorPD0+P0NHSk1YWVpbXF1eX2BhY2RlZmdpamtscnN0eXp7fABJbGxlZ2FsIGJ5dGUgc2VxdWVuY2UARG9tYWluIGVycm9yAFJlc3VsdCBub3QgcmVwcmVzZW50YWJsZQBOb3QgYSB0dHkAUGVybWlzc2lvbiBkZW5pZWQAT3BlcmF0aW9uIG5vdCBwZXJtaXR0ZWQATm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeQBObyBzdWNoIHByb2Nlc3MARmlsZSBleGlzdHMAVmFsdWUgdG9vIGxhcmdlIGZvciBkYXRhIHR5cGUATm8gc3BhY2UgbGVmdCBvbiBkZXZpY2UAT3V0IG9mIG1lbW9yeQBSZXNvdXJjZSBidXN5AEludGVycnVwdGVkIHN5c3RlbSBjYWxsAFJlc291cmNlIHRlbXBvcmFyaWx5IHVuYXZhaWxhYmxlAEludmFsaWQgc2VlawBDcm9zcy1kZXZpY2UgbGluawBSZWFkLW9ubHkgZmlsZSBzeXN0ZW0ARGlyZWN0b3J5IG5vdCBlbXB0eQBDb25uZWN0aW9uIHJlc2V0IGJ5IHBlZXIAT3BlcmF0aW9uIHRpbWVkIG91dABDb25uZWN0aW9uIHJlZnVzZWQASG9zdCBpcyBkb3duAEhvc3QgaXMgdW5yZWFjaGFibGUAQWRkcmVzcyBpbiB1c2UAQnJva2VuIHBpcGUASS9PIGVycm9yAE5vIHN1Y2ggZGV2aWNlIG9yIGFkZHJlc3MAQmxvY2sgZGV2aWNlIHJlcXVpcmVkAE5vIHN1Y2ggZGV2aWNlAE5vdCBhIGRpcmVjdG9yeQBJcyBhIGRpcmVjdG9yeQBUZXh0IGZpbGUgYnVzeQBFeGVjIGZvcm1hdCBlcnJvcgBJbnZhbGlkIGFyZ3VtZW50AEFyZ3VtZW50IGxpc3QgdG9vIGxvbmcAU3ltYm9saWMgbGluayBsb29wAEZpbGVuYW1lIHRvbyBsb25nAFRvbyBtYW55IG9wZW4gZmlsZXMgaW4gc3lzdGVtAE5vIGZpbGUgZGVzY3JpcHRvcnMgYXZhaWxhYmxlAEJhZCBmaWxlIGRlc2NyaXB0b3IATm8gY2hpbGQgcHJvY2VzcwBCYWQgYWRkcmVzcwBGaWxlIHRvbyBsYXJnZQBUb28gbWFueSBsaW5rcwBObyBsb2NrcyBhdmFpbGFibGUAUmVzb3VyY2UgZGVhZGxvY2sgd291bGQgb2NjdXIAU3RhdGUgbm90IHJlY292ZXJhYmxlAFByZXZpb3VzIG93bmVyIGRpZWQAT3BlcmF0aW9uIGNhbmNlbGVkAEZ1bmN0aW9uIG5vdCBpbXBsZW1lbnRlZABObyBtZXNzYWdlIG9mIGRlc2lyZWQgdHlwZQBJZGVudGlmaWVyIHJlbW92ZWQARGV2aWNlIG5vdCBhIHN0cmVhbQBObyBkYXRhIGF2YWlsYWJsZQBEZXZpY2UgdGltZW91dABPdXQgb2Ygc3RyZWFtcyByZXNvdXJjZXMATGluayBoYXMgYmVlbiBzZXZlcmVkAFByb3RvY29sIGVycm9yAEJhZCBtZXNzYWdlAEZpbGUgZGVzY3JpcHRvciBpbiBiYWQgc3RhdGUATm90IGEgc29ja2V0AERlc3RpbmF0aW9uIGFkZHJlc3MgcmVxdWlyZWQATWVzc2FnZSB0b28gbGFyZ2UAUHJvdG9jb2wgd3JvbmcgdHlwZSBmb3Igc29ja2V0AFByb3RvY29sIG5vdCBhdmFpbGFibGUAUHJvdG9jb2wgbm90IHN1cHBvcnRlZABTb2NrZXQgdHlwZSBub3Qgc3VwcG9ydGVkAE5vdCBzdXBwb3J0ZWQAUHJvdG9jb2wgZmFtaWx5IG5vdCBzdXBwb3J0ZWQAQWRkcmVzcyBmYW1pbHkgbm90IHN1cHBvcnRlZCBieSBwcm90b2NvbABBZGRyZXNzIG5vdCBhdmFpbGFibGUATmV0d29yayBpcyBkb3duAE5ldHdvcmsgdW5yZWFjaGFibGUAQ29ubmVjdGlvbiByZXNldCBieSBuZXR3b3JrAENvbm5lY3Rpb24gYWJvcnRlZABObyBidWZmZXIgc3BhY2UgYXZhaWxhYmxlAFNvY2tldCBpcyBjb25uZWN0ZWQAU29ja2V0IG5vdCBjb25uZWN0ZWQAQ2Fubm90IHNlbmQgYWZ0ZXIgc29ja2V0IHNodXRkb3duAE9wZXJhdGlvbiBhbHJlYWR5IGluIHByb2dyZXNzAE9wZXJhdGlvbiBpbiBwcm9ncmVzcwBTdGFsZSBmaWxlIGhhbmRsZQBSZW1vdGUgSS9PIGVycm9yAFF1b3RhIGV4Y2VlZGVkAE5vIG1lZGl1bSBmb3VuZABXcm9uZyBtZWRpdW0gdHlwZQBObyBlcnJvciBpbmZvcm1hdGlvbg==';
    var asmjsCodeFile = '';

    if (typeof _Module['locateFile'] === 'function') {
      if (!isDataURI(wasmTextFile)) {
        wasmTextFile = _Module['locateFile'](wasmTextFile);
      }

      if (!isDataURI(wasmBinaryFile)) {
        wasmBinaryFile = _Module['locateFile'](wasmBinaryFile);
      }

      if (!isDataURI(asmjsCodeFile)) {
        asmjsCodeFile = _Module['locateFile'](asmjsCodeFile);
      }
    } // utilities


    var wasmPageSize = 64 * 1024;
    var info = {
      'global': null,
      'env': null,
      'asm2wasm': {
        // special asm2wasm imports
        "f64-rem": function f64Rem(x, y) {
          return x % y;
        },
        "debugger": function _debugger() {
          debugger;
        }
      },
      'parent': _Module // Module inside wasm-js.cpp refers to wasm-js.cpp; this allows access to the outside program.

    };
    var exports = null;

    function mergeMemory(newBuffer) {
      // The wasm instance creates its memory. But static init code might have written to
      // buffer already, including the mem init file, and we must copy it over in a proper merge.
      // TODO: avoid this copy, by avoiding such static init writes
      // TODO: in shorter term, just copy up to the last static init write
      var oldBuffer = _Module['buffer'];

      if (newBuffer.byteLength < oldBuffer.byteLength) {
        _Module['printErr']('the new buffer in mergeMemory is smaller than the previous one. in native wasm, we should grow memory here');
      }

      var oldView = new Int8Array(oldBuffer);
      var newView = new Int8Array(newBuffer);
      newView.set(oldView);
      updateGlobalBuffer(newBuffer);
      updateGlobalBufferViews();
    }

    function fixImports(imports) {
      return imports;
    }

    function getBinary() {
      try {
        if (_Module['wasmBinary']) {
          return new Uint8Array(_Module['wasmBinary']);
        }

        var binary = tryParseAsDataURI(wasmBinaryFile);

        if (binary) {
          return binary;
        }

        if (_Module['readBinary']) {
          return _Module['readBinary'](wasmBinaryFile);
        } else {
          throw "on the web, we need the wasm binary to be preloaded and set on Module['wasmBinary']. emcc.py will do that for you when generating HTML (but not JS)";
        }
      } catch (err) {
        abort(err);
      }
    }

    function getBinaryPromise() {
      // if we don't have the binary yet, and have the Fetch api, use that
      // in some environments, like Electron's render process, Fetch api may be present, but have a different context than expected, let's only use it on the Web
      if (!_Module['wasmBinary'] && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === 'function') {
        return fetch(wasmBinaryFile, {
          credentials: 'same-origin'
        }).then(function (response) {
          if (!response['ok']) {
            throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
          }

          return response['arrayBuffer']();
        }).catch(function () {
          return getBinary();
        });
      } // Otherwise, getBinary should be able to get it synchronously


      return new Promise(function (resolve, reject) {
        resolve(getBinary());
      });
    } // do-method functions


    function doNativeWasm(global, env, providedBuffer) {
      if ((typeof WebAssembly === "undefined" ? "undefined" : _typeof(WebAssembly)) !== 'object') {
        _Module['printErr']('no native wasm support detected');

        return false;
      } // prepare memory import


      if (!(_Module['wasmMemory'] instanceof WebAssembly.Memory)) {
        _Module['printErr']('no native wasm Memory in use');

        return false;
      }

      env['memory'] = _Module['wasmMemory']; // Load the wasm module and create an instance of using native support in the JS engine.

      info['global'] = {
        'NaN': NaN,
        'Infinity': Infinity
      };
      info['global.Math'] = Math;
      info['env'] = env; // handle a generated wasm instance, receiving its exports and
      // performing other necessary setup

      function receiveInstance(instance, module) {
        exports = instance.exports;
        if (exports.memory) mergeMemory(exports.memory);
        _Module['asm'] = exports;
        _Module["usingWasm"] = true;
        removeRunDependency('wasm-instantiate');
      }

      addRunDependency('wasm-instantiate'); // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback
      // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel
      // to any other async startup actions they are performing.

      if (_Module['instantiateWasm']) {
        try {
          return _Module['instantiateWasm'](info, receiveInstance);
        } catch (e) {
          _Module['printErr']('Module.instantiateWasm callback failed with error: ' + e);

          return false;
        }
      } // Async compilation can be confusing when an error on the page overwrites Module
      // (for example, if the order of elements is wrong, and the one defining Module is
      // later), so we save Module and check it later.


      var trueModule = _Module;

      function receiveInstantiatedSource(output) {
        // 'output' is a WebAssemblyInstantiatedSource object which has both the module and instance.
        // receiveInstance() will swap in the exports (to Module.asm) so they can be called
        assert(_Module === trueModule, 'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?');
        trueModule = null;
        receiveInstance(output['instance'], output['module']);
      }

      function instantiateArrayBuffer(receiver) {
        getBinaryPromise().then(function (binary) {
          return WebAssembly.instantiate(binary, info);
        }).then(receiver).catch(function (reason) {
          _Module['printErr']('failed to asynchronously prepare wasm: ' + reason);

          abort(reason);
        });
      } // Prefer streaming instantiation if available.


      if (!_Module['wasmBinary'] && typeof WebAssembly.instantiateStreaming === 'function' && !isDataURI(wasmBinaryFile) && typeof fetch === 'function') {
        WebAssembly.instantiateStreaming(fetch(wasmBinaryFile, {
          credentials: 'same-origin'
        }), info).then(receiveInstantiatedSource).catch(function (reason) {
          // We expect the most common failure cause to be a bad MIME type for the binary,
          // in which case falling back to ArrayBuffer instantiation should work.
          _Module['printErr']('wasm streaming compile failed: ' + reason);

          _Module['printErr']('falling back to ArrayBuffer instantiation');

          instantiateArrayBuffer(receiveInstantiatedSource);
        });
      } else {
        instantiateArrayBuffer(receiveInstantiatedSource);
      }

      return {}; // no exports yet; we'll fill them in later
    } // We may have a preloaded value in Module.asm, save it


    _Module['asmPreload'] = _Module['asm']; // Memory growth integration code

    var asmjsReallocBuffer = _Module['reallocBuffer'];

    var wasmReallocBuffer = function wasmReallocBuffer(size) {
      var PAGE_MULTIPLE = _Module["usingWasm"] ? WASM_PAGE_SIZE : ASMJS_PAGE_SIZE; // In wasm, heap size must be a multiple of 64KB. In asm.js, they need to be multiples of 16MB.

      size = alignUp(size, PAGE_MULTIPLE); // round up to wasm page size

      var old = _Module['buffer'];
      var oldSize = old.byteLength;

      if (_Module["usingWasm"]) {
        // native wasm support
        try {
          var result = _Module['wasmMemory'].grow((size - oldSize) / wasmPageSize); // .grow() takes a delta compared to the previous size


          if (result !== (-1 | 0)) {
            // success in native wasm memory growth, get the buffer from the memory
            return _Module['buffer'] = _Module['wasmMemory'].buffer;
          } else {
            return null;
          }
        } catch (e) {
          console.error('Module.reallocBuffer: Attempted to grow from ' + oldSize + ' bytes to ' + size + ' bytes, but got error: ' + e);
          return null;
        }
      }
    };

    _Module['reallocBuffer'] = function (size) {
      if (finalMethod === 'asmjs') {
        return asmjsReallocBuffer(size);
      } else {
        return wasmReallocBuffer(size);
      }
    }; // we may try more than one; this is the final one, that worked and we are using


    var finalMethod = ''; // Provide an "asm.js function" for the application, called to "link" the asm.js module. We instantiate
    // the wasm module at that time, and it receives imports and provides exports and so forth, the app
    // doesn't need to care that it is wasm or olyfilled wasm or asm.js.

    _Module['asm'] = function (global, env, providedBuffer) {
      env = fixImports(env); // import table

      if (!env['table']) {
        var TABLE_SIZE = _Module['wasmTableSize'];
        if (TABLE_SIZE === undefined) TABLE_SIZE = 1024; // works in binaryen interpreter at least

        var MAX_TABLE_SIZE = _Module['wasmMaxTableSize'];

        if ((typeof WebAssembly === "undefined" ? "undefined" : _typeof(WebAssembly)) === 'object' && typeof WebAssembly.Table === 'function') {
          if (MAX_TABLE_SIZE !== undefined) {
            env['table'] = new WebAssembly.Table({
              'initial': TABLE_SIZE,
              'maximum': MAX_TABLE_SIZE,
              'element': 'anyfunc'
            });
          } else {
            env['table'] = new WebAssembly.Table({
              'initial': TABLE_SIZE,
              element: 'anyfunc'
            });
          }
        } else {
          env['table'] = new Array(TABLE_SIZE); // works in binaryen interpreter at least
        }

        _Module['wasmTable'] = env['table'];
      }

      if (!env['memoryBase']) {
        env['memoryBase'] = _Module['STATIC_BASE']; // tell the memory segments where to place themselves
      }

      if (!env['tableBase']) {
        env['tableBase'] = 0; // table starts at 0 by default, in dynamic linking this will change
      } // try the methods. each should return the exports if it succeeded


      var exports;
      exports = doNativeWasm(global, env, providedBuffer);
      if (!exports) abort('no binaryen method succeeded. consider enabling more options, like interpreting, if you want that: https://github.com/kripken/emscripten/wiki/WebAssembly#binaryen-methods');
      return exports;
    };

    var methodHandler = _Module['asm']; // note our method handler, as we may modify Module['asm'] later
  }

  integrateWasmJS(); // === Body ===

  var ASM_CONSTS = [];
  STATIC_BASE = GLOBAL_BASE;
  STATICTOP = STATIC_BASE + 9888;
  /* global initializers */

  __ATINIT__.push();

  var STATIC_BUMP = 9888;
  _Module["STATIC_BASE"] = STATIC_BASE;
  _Module["STATIC_BUMP"] = STATIC_BUMP;
  /* no memory initializer */

  var tempDoublePtr = STATICTOP;
  STATICTOP += 16;
  assert(tempDoublePtr % 8 == 0);

  function copyTempFloat(ptr) {
    // functions, because inlining this code increases code size too much
    HEAP8[tempDoublePtr] = HEAP8[ptr];
    HEAP8[tempDoublePtr + 1] = HEAP8[ptr + 1];
    HEAP8[tempDoublePtr + 2] = HEAP8[ptr + 2];
    HEAP8[tempDoublePtr + 3] = HEAP8[ptr + 3];
  }

  function copyTempDouble(ptr) {
    HEAP8[tempDoublePtr] = HEAP8[ptr];
    HEAP8[tempDoublePtr + 1] = HEAP8[ptr + 1];
    HEAP8[tempDoublePtr + 2] = HEAP8[ptr + 2];
    HEAP8[tempDoublePtr + 3] = HEAP8[ptr + 3];
    HEAP8[tempDoublePtr + 4] = HEAP8[ptr + 4];
    HEAP8[tempDoublePtr + 5] = HEAP8[ptr + 5];
    HEAP8[tempDoublePtr + 6] = HEAP8[ptr + 6];
    HEAP8[tempDoublePtr + 7] = HEAP8[ptr + 7];
  } // {{PRE_LIBRARY}}


  function ___lock() {}

  var SYSCALLS = {
    varargs: 0,
    get: function get(varargs) {
      SYSCALLS.varargs += 4;
      var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];
      return ret;
    },
    getStr: function getStr() {
      var ret = Pointer_stringify(SYSCALLS.get());
      return ret;
    },
    get64: function get64() {
      var low = SYSCALLS.get(),
          high = SYSCALLS.get();
      if (low >= 0) assert(high === 0);else assert(high === -1);
      return low;
    },
    getZero: function getZero() {
      assert(SYSCALLS.get() === 0);
    }
  };

  function ___syscall140(which, varargs) {
    SYSCALLS.varargs = varargs;

    try {
      // llseek
      var stream = SYSCALLS.getStreamFromFD(),
          offset_high = SYSCALLS.get(),
          offset_low = SYSCALLS.get(),
          result = SYSCALLS.get(),
          whence = SYSCALLS.get(); // NOTE: offset_high is unused - Emscripten's off_t is 32-bit

      var offset = offset_low;
      FS.llseek(stream, offset, whence);
      HEAP32[result >> 2] = stream.position;
      if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state

      return 0;
    } catch (e) {
      if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
      return -e.errno;
    }
  }

  function flush_NO_FILESYSTEM() {
    // flush anything remaining in the buffers during shutdown
    var fflush = _Module["_fflush"];
    if (fflush) fflush(0);
    var printChar = ___syscall146.printChar;
    if (!printChar) return;
    var buffers = ___syscall146.buffers;
    if (buffers[1].length) printChar(1, 10);
    if (buffers[2].length) printChar(2, 10);
  }

  function ___syscall146(which, varargs) {
    SYSCALLS.varargs = varargs;

    try {
      // writev
      // hack to support printf in NO_FILESYSTEM
      var stream = SYSCALLS.get(),
          iov = SYSCALLS.get(),
          iovcnt = SYSCALLS.get();
      var ret = 0;

      if (!___syscall146.buffers) {
        ___syscall146.buffers = [null, [], []]; // 1 => stdout, 2 => stderr

        ___syscall146.printChar = function (stream, curr) {
          var buffer = ___syscall146.buffers[stream];
          assert(buffer);

          if (curr === 0 || curr === 10) {
            (stream === 1 ? _Module['print'] : _Module['printErr'])(UTF8ArrayToString(buffer, 0));
            buffer.length = 0;
          } else {
            buffer.push(curr);
          }
        };
      }

      for (var i = 0; i < iovcnt; i++) {
        var ptr = HEAP32[iov + i * 8 >> 2];
        var len = HEAP32[iov + (i * 8 + 4) >> 2];

        for (var j = 0; j < len; j++) {
          ___syscall146.printChar(stream, HEAPU8[ptr + j]);
        }

        ret += len;
      }

      return ret;
    } catch (e) {
      if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
      return -e.errno;
    }
  }

  function ___syscall54(which, varargs) {
    SYSCALLS.varargs = varargs;

    try {
      // ioctl
      return 0;
    } catch (e) {
      if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
      return -e.errno;
    }
  }

  function ___syscall6(which, varargs) {
    SYSCALLS.varargs = varargs;

    try {
      // close
      var stream = SYSCALLS.getStreamFromFD();
      FS.close(stream);
      return 0;
    } catch (e) {
      if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
      return -e.errno;
    }
  }

  function ___unlock() {}

  function _emscripten_has_threading_support() {
    return 0;
  }

  var cttz_i8 = allocate([8, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0], "i8", ALLOC_STATIC);

  function _llvm_cttz_i32(x) {
    x = x | 0;
    var ret = 0;
    ret = HEAP8[cttz_i8 + (x & 0xff) >> 0] | 0;
    if ((ret | 0) < 8) return ret | 0;
    ret = HEAP8[cttz_i8 + (x >> 8 & 0xff) >> 0] | 0;
    if ((ret | 0) < 8) return ret + 8 | 0;
    ret = HEAP8[cttz_i8 + (x >> 16 & 0xff) >> 0] | 0;
    if ((ret | 0) < 8) return ret + 16 | 0;
    return (HEAP8[cttz_i8 + (x >>> 24) >> 0] | 0) + 24 | 0;
  }

  function _llvm_cttz_i64(l, h) {
    var ret = _llvm_cttz_i32(l);

    if (ret == 32) ret += _llvm_cttz_i32(h);
    return (setTempRet0(0), ret) | 0;
  }

  function _llvm_stackrestore(p) {
    var self = _llvm_stacksave;
    var ret = self.LLVM_SAVEDSTACKS[p];
    self.LLVM_SAVEDSTACKS.splice(p, 1);

    _stackRestore(ret);
  }

  function _llvm_stacksave() {
    var self = _llvm_stacksave;

    if (!self.LLVM_SAVEDSTACKS) {
      self.LLVM_SAVEDSTACKS = [];
    }

    self.LLVM_SAVEDSTACKS.push(_stackSave());
    return self.LLVM_SAVEDSTACKS.length - 1;
  }

  function _emscripten_memcpy_big(dest, src, num) {
    HEAPU8.set(HEAPU8.subarray(src, src + num), dest);
    return dest;
  }

  function _pthread_create() {
    return 11;
  }

  function _pthread_join() {}

  function _pthread_mutex_init() {}

  function ___setErrNo(value) {
    if (_Module['___errno_location']) HEAP32[_Module['___errno_location']() >> 2] = value;else _Module.printErr('failed to set errno from JS');
    return value;
  }

  var ERRNO_CODES = {
    EPERM: 1,
    ENOENT: 2,
    ESRCH: 3,
    EINTR: 4,
    EIO: 5,
    ENXIO: 6,
    E2BIG: 7,
    ENOEXEC: 8,
    EBADF: 9,
    ECHILD: 10,
    EAGAIN: 11,
    EWOULDBLOCK: 11,
    ENOMEM: 12,
    EACCES: 13,
    EFAULT: 14,
    ENOTBLK: 15,
    EBUSY: 16,
    EEXIST: 17,
    EXDEV: 18,
    ENODEV: 19,
    ENOTDIR: 20,
    EISDIR: 21,
    EINVAL: 22,
    ENFILE: 23,
    EMFILE: 24,
    ENOTTY: 25,
    ETXTBSY: 26,
    EFBIG: 27,
    ENOSPC: 28,
    ESPIPE: 29,
    EROFS: 30,
    EMLINK: 31,
    EPIPE: 32,
    EDOM: 33,
    ERANGE: 34,
    ENOMSG: 42,
    EIDRM: 43,
    ECHRNG: 44,
    EL2NSYNC: 45,
    EL3HLT: 46,
    EL3RST: 47,
    ELNRNG: 48,
    EUNATCH: 49,
    ENOCSI: 50,
    EL2HLT: 51,
    EDEADLK: 35,
    ENOLCK: 37,
    EBADE: 52,
    EBADR: 53,
    EXFULL: 54,
    ENOANO: 55,
    EBADRQC: 56,
    EBADSLT: 57,
    EDEADLOCK: 35,
    EBFONT: 59,
    ENOSTR: 60,
    ENODATA: 61,
    ETIME: 62,
    ENOSR: 63,
    ENONET: 64,
    ENOPKG: 65,
    EREMOTE: 66,
    ENOLINK: 67,
    EADV: 68,
    ESRMNT: 69,
    ECOMM: 70,
    EPROTO: 71,
    EMULTIHOP: 72,
    EDOTDOT: 73,
    EBADMSG: 74,
    ENOTUNIQ: 76,
    EBADFD: 77,
    EREMCHG: 78,
    ELIBACC: 79,
    ELIBBAD: 80,
    ELIBSCN: 81,
    ELIBMAX: 82,
    ELIBEXEC: 83,
    ENOSYS: 38,
    ENOTEMPTY: 39,
    ENAMETOOLONG: 36,
    ELOOP: 40,
    EOPNOTSUPP: 95,
    EPFNOSUPPORT: 96,
    ECONNRESET: 104,
    ENOBUFS: 105,
    EAFNOSUPPORT: 97,
    EPROTOTYPE: 91,
    ENOTSOCK: 88,
    ENOPROTOOPT: 92,
    ESHUTDOWN: 108,
    ECONNREFUSED: 111,
    EADDRINUSE: 98,
    ECONNABORTED: 103,
    ENETUNREACH: 101,
    ENETDOWN: 100,
    ETIMEDOUT: 110,
    EHOSTDOWN: 112,
    EHOSTUNREACH: 113,
    EINPROGRESS: 115,
    EALREADY: 114,
    EDESTADDRREQ: 89,
    EMSGSIZE: 90,
    EPROTONOSUPPORT: 93,
    ESOCKTNOSUPPORT: 94,
    EADDRNOTAVAIL: 99,
    ENETRESET: 102,
    EISCONN: 106,
    ENOTCONN: 107,
    ETOOMANYREFS: 109,
    EUSERS: 87,
    EDQUOT: 122,
    ESTALE: 116,
    ENOTSUP: 95,
    ENOMEDIUM: 123,
    EILSEQ: 84,
    EOVERFLOW: 75,
    ECANCELED: 125,
    ENOTRECOVERABLE: 131,
    EOWNERDEAD: 130,
    ESTRPIPE: 86
  };

  function _sysconf(name) {
    // long sysconf(int name);
    // http://pubs.opengroup.org/onlinepubs/009695399/functions/sysconf.html
    switch (name) {
      case 30:
        return PAGE_SIZE;

      case 85:
        var maxHeapSize = 2 * 1024 * 1024 * 1024 - 65536;
        maxHeapSize = HEAPU8.length;
        return maxHeapSize / PAGE_SIZE;

      case 132:
      case 133:
      case 12:
      case 137:
      case 138:
      case 15:
      case 235:
      case 16:
      case 17:
      case 18:
      case 19:
      case 20:
      case 149:
      case 13:
      case 10:
      case 236:
      case 153:
      case 9:
      case 21:
      case 22:
      case 159:
      case 154:
      case 14:
      case 77:
      case 78:
      case 139:
      case 80:
      case 81:
      case 82:
      case 68:
      case 67:
      case 164:
      case 11:
      case 29:
      case 47:
      case 48:
      case 95:
      case 52:
      case 51:
      case 46:
        return 200809;

      case 79:
        return 0;

      case 27:
      case 246:
      case 127:
      case 128:
      case 23:
      case 24:
      case 160:
      case 161:
      case 181:
      case 182:
      case 242:
      case 183:
      case 184:
      case 243:
      case 244:
      case 245:
      case 165:
      case 178:
      case 179:
      case 49:
      case 50:
      case 168:
      case 169:
      case 175:
      case 170:
      case 171:
      case 172:
      case 97:
      case 76:
      case 32:
      case 173:
      case 35:
        return -1;

      case 176:
      case 177:
      case 7:
      case 155:
      case 8:
      case 157:
      case 125:
      case 126:
      case 92:
      case 93:
      case 129:
      case 130:
      case 131:
      case 94:
      case 91:
        return 1;

      case 74:
      case 60:
      case 69:
      case 70:
      case 4:
        return 1024;

      case 31:
      case 42:
      case 72:
        return 32;

      case 87:
      case 26:
      case 33:
        return 2147483647;

      case 34:
      case 1:
        return 47839;

      case 38:
      case 36:
        return 99;

      case 43:
      case 37:
        return 2048;

      case 0:
        return 2097152;

      case 3:
        return 65536;

      case 28:
        return 32768;

      case 44:
        return 32767;

      case 75:
        return 16384;

      case 39:
        return 1000;

      case 89:
        return 700;

      case 71:
        return 256;

      case 40:
        return 255;

      case 2:
        return 100;

      case 180:
        return 64;

      case 25:
        return 20;

      case 5:
        return 16;

      case 6:
        return 6;

      case 73:
        return 4;

      case 84:
        {
          if ((typeof navigator === "undefined" ? "undefined" : _typeof(navigator)) === 'object') return navigator['hardwareConcurrency'] || 1;
          return 1;
        }
    }

    ___setErrNo(ERRNO_CODES.EINVAL);

    return -1;
  }

  DYNAMICTOP_PTR = staticAlloc(4);
  STACK_BASE = STACKTOP = alignMemory(STATICTOP);
  STACK_MAX = STACK_BASE + TOTAL_STACK;
  DYNAMIC_BASE = alignMemory(STACK_MAX);
  HEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;
  staticSealed = true; // seal the static portion of memory

  assert(DYNAMIC_BASE < TOTAL_MEMORY, "TOTAL_MEMORY not big enough for stack");
  var ASSERTIONS = true;
  /** @type {function(string, boolean=, number=)} */

  function intArrayFromString(stringy, dontAddNull, length) {
    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
    var u8array = new Array(len);
    var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
    if (dontAddNull) u8array.length = numBytesWritten;
    return u8array;
  }

  function intArrayToString(array) {
    var ret = [];

    for (var i = 0; i < array.length; i++) {
      var chr = array[i];

      if (chr > 0xFF) {
        if (ASSERTIONS) {
          assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');
        }

        chr &= 0xFF;
      }

      ret.push(String.fromCharCode(chr));
    }

    return ret.join('');
  } // Copied from https://github.com/strophe/strophejs/blob/e06d027/src/polyfills.js#L149
  // This code was written by Tyler Akins and has been placed in the
  // public domain.  It would be nice if you left this header intact.
  // Base64 code from Tyler Akins -- http://rumkin.com

  /**
   * Decodes a base64 string.
   * @param {String} input The string to decode.
   */


  var decodeBase64 = typeof atob === 'function' ? atob : function (input) {
    var keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    var output = '';
    var chr1, chr2, chr3;
    var enc1, enc2, enc3, enc4;
    var i = 0; // remove all characters that are not A-Z, a-z, 0-9, +, /, or =

    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');

    do {
      enc1 = keyStr.indexOf(input.charAt(i++));
      enc2 = keyStr.indexOf(input.charAt(i++));
      enc3 = keyStr.indexOf(input.charAt(i++));
      enc4 = keyStr.indexOf(input.charAt(i++));
      chr1 = enc1 << 2 | enc2 >> 4;
      chr2 = (enc2 & 15) << 4 | enc3 >> 2;
      chr3 = (enc3 & 3) << 6 | enc4;
      output = output + String.fromCharCode(chr1);

      if (enc3 !== 64) {
        output = output + String.fromCharCode(chr2);
      }

      if (enc4 !== 64) {
        output = output + String.fromCharCode(chr3);
      }
    } while (i < input.length);

    return output;
  }; // Converts a string of base64 into a byte array.
  // Throws error on invalid input.

  function intArrayFromBase64(s) {
    if (typeof ENVIRONMENT_IS_NODE === 'boolean' && ENVIRONMENT_IS_NODE) {
      var buf;

      try {
        buf = Buffer.from(s, 'base64');
      } catch (_) {
        buf = new Buffer(s, 'base64');
      }

      return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
    }

    try {
      var decoded = decodeBase64(s);
      var bytes = new Uint8Array(decoded.length);

      for (var i = 0; i < decoded.length; ++i) {
        bytes[i] = decoded.charCodeAt(i);
      }

      return bytes;
    } catch (_) {
      throw new Error('Converting base64 string to bytes failed.');
    }
  } // If filename is a base64 data URI, parses and returns data (Buffer on node,
  // Uint8Array otherwise). If filename is not a base64 data URI, returns undefined.


  function tryParseAsDataURI(filename) {
    if (!isDataURI(filename)) {
      return;
    }

    return intArrayFromBase64(filename.slice(dataURIPrefix.length));
  }

  function nullFunc_ii(x) {
    _Module["printErr"]("Invalid function pointer called with signature 'ii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");

    _Module["printErr"]("Build with ASSERTIONS=2 for more info.");

    abort(x);
  }

  function nullFunc_iiii(x) {
    _Module["printErr"]("Invalid function pointer called with signature 'iiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");

    _Module["printErr"]("Build with ASSERTIONS=2 for more info.");

    abort(x);
  }

  _Module['wasmTableSize'] = 16;
  _Module['wasmMaxTableSize'] = 16;

  function invoke_ii(index, a1) {
    try {
      return _Module["dynCall_ii"](index, a1);
    } catch (e) {
      if (typeof e !== 'number' && e !== 'longjmp') throw e;

      _Module["setThrew"](1, 0);
    }
  }

  function invoke_iiii(index, a1, a2, a3) {
    try {
      return _Module["dynCall_iiii"](index, a1, a2, a3);
    } catch (e) {
      if (typeof e !== 'number' && e !== 'longjmp') throw e;

      _Module["setThrew"](1, 0);
    }
  }

  _Module.asmGlobalArg = {};
  _Module.asmLibraryArg = {
    "abort": abort,
    "assert": assert,
    "enlargeMemory": enlargeMemory,
    "getTotalMemory": getTotalMemory,
    "abortOnCannotGrowMemory": abortOnCannotGrowMemory,
    "abortStackOverflow": abortStackOverflow,
    "nullFunc_ii": nullFunc_ii,
    "nullFunc_iiii": nullFunc_iiii,
    "invoke_ii": invoke_ii,
    "invoke_iiii": invoke_iiii,
    "___lock": ___lock,
    "___setErrNo": ___setErrNo,
    "___syscall140": ___syscall140,
    "___syscall146": ___syscall146,
    "___syscall54": ___syscall54,
    "___syscall6": ___syscall6,
    "___unlock": ___unlock,
    "_emscripten_has_threading_support": _emscripten_has_threading_support,
    "_emscripten_memcpy_big": _emscripten_memcpy_big,
    "_llvm_cttz_i32": _llvm_cttz_i32,
    "_llvm_cttz_i64": _llvm_cttz_i64,
    "_llvm_stackrestore": _llvm_stackrestore,
    "_llvm_stacksave": _llvm_stacksave,
    "_pthread_create": _pthread_create,
    "_pthread_join": _pthread_join,
    "_pthread_mutex_init": _pthread_mutex_init,
    "_sysconf": _sysconf,
    "flush_NO_FILESYSTEM": flush_NO_FILESYSTEM,
    "DYNAMICTOP_PTR": DYNAMICTOP_PTR,
    "tempDoublePtr": tempDoublePtr,
    "ABORT": ABORT,
    "STACKTOP": STACKTOP,
    "STACK_MAX": STACK_MAX,
    "cttz_i8": cttz_i8
  }; // EMSCRIPTEN_START_ASM

  var asm = _Module["asm"] // EMSCRIPTEN_END_ASM
  (_Module.asmGlobalArg, _Module.asmLibraryArg, buffer);

  var real____errno_location = asm["___errno_location"];

  asm["___errno_location"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real____errno_location.apply(null, arguments);
  };

  var real__ccurl_pow = asm["_ccurl_pow"];

  asm["_ccurl_pow"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__ccurl_pow.apply(null, arguments);
  };

  var real__fflush = asm["_fflush"];

  asm["_fflush"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__fflush.apply(null, arguments);
  };

  var real__free = asm["_free"];

  asm["_free"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__free.apply(null, arguments);
  };

  var real__llvm_bswap_i32 = asm["_llvm_bswap_i32"];

  asm["_llvm_bswap_i32"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__llvm_bswap_i32.apply(null, arguments);
  };

  var real__malloc = asm["_malloc"];

  asm["_malloc"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__malloc.apply(null, arguments);
  };

  var real__pthread_mutex_lock = asm["_pthread_mutex_lock"];

  asm["_pthread_mutex_lock"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__pthread_mutex_lock.apply(null, arguments);
  };

  var real__pthread_mutex_unlock = asm["_pthread_mutex_unlock"];

  asm["_pthread_mutex_unlock"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__pthread_mutex_unlock.apply(null, arguments);
  };

  var real__sbrk = asm["_sbrk"];

  asm["_sbrk"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__sbrk.apply(null, arguments);
  };

  var real_establishStackSpace = asm["establishStackSpace"];

  asm["establishStackSpace"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real_establishStackSpace.apply(null, arguments);
  };

  var real_getTempRet0 = asm["getTempRet0"];

  asm["getTempRet0"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real_getTempRet0.apply(null, arguments);
  };

  var real_setTempRet0 = asm["setTempRet0"];

  asm["setTempRet0"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real_setTempRet0.apply(null, arguments);
  };

  var real_setThrew = asm["setThrew"];

  asm["setThrew"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real_setThrew.apply(null, arguments);
  };

  var real_stackAlloc = asm["stackAlloc"];

  asm["stackAlloc"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real_stackAlloc.apply(null, arguments);
  };

  var real_stackRestore = asm["stackRestore"];

  asm["stackRestore"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real_stackRestore.apply(null, arguments);
  };

  var real_stackSave = asm["stackSave"];

  asm["stackSave"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real_stackSave.apply(null, arguments);
  };

  _Module["asm"] = asm;

  var ___errno_location = _Module["___errno_location"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return _Module["asm"]["___errno_location"].apply(null, arguments);
  };

  var _ccurl_pow = _Module["_ccurl_pow"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return _Module["asm"]["_ccurl_pow"].apply(null, arguments);
  };

  var _fflush = _Module["_fflush"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return _Module["asm"]["_fflush"].apply(null, arguments);
  };

  var _free = _Module["_free"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return _Module["asm"]["_free"].apply(null, arguments);
  };

  var _llvm_bswap_i32 = _Module["_llvm_bswap_i32"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return _Module["asm"]["_llvm_bswap_i32"].apply(null, arguments);
  };

  var _malloc = _Module["_malloc"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return _Module["asm"]["_malloc"].apply(null, arguments);
  };

  var _memcpy = _Module["_memcpy"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return _Module["asm"]["_memcpy"].apply(null, arguments);
  };

  var _memset = _Module["_memset"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return _Module["asm"]["_memset"].apply(null, arguments);
  };

  var _pthread_mutex_lock = _Module["_pthread_mutex_lock"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return _Module["asm"]["_pthread_mutex_lock"].apply(null, arguments);
  };

  var _pthread_mutex_unlock = _Module["_pthread_mutex_unlock"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return _Module["asm"]["_pthread_mutex_unlock"].apply(null, arguments);
  };

  var _sbrk = _Module["_sbrk"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return _Module["asm"]["_sbrk"].apply(null, arguments);
  };

  var establishStackSpace = _Module["establishStackSpace"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return _Module["asm"]["establishStackSpace"].apply(null, arguments);
  };

  var getTempRet0 = _Module["getTempRet0"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return _Module["asm"]["getTempRet0"].apply(null, arguments);
  };

  var runPostSets = _Module["runPostSets"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return _Module["asm"]["runPostSets"].apply(null, arguments);
  };

  var setTempRet0 = _Module["setTempRet0"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return _Module["asm"]["setTempRet0"].apply(null, arguments);
  };

  var setThrew = _Module["setThrew"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return _Module["asm"]["setThrew"].apply(null, arguments);
  };

  var stackAlloc = _Module["stackAlloc"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return _Module["asm"]["stackAlloc"].apply(null, arguments);
  };

  var _stackRestore = _Module["stackRestore"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return _Module["asm"]["stackRestore"].apply(null, arguments);
  };

  var _stackSave = _Module["stackSave"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return _Module["asm"]["stackSave"].apply(null, arguments);
  };

  var dynCall_ii = _Module["dynCall_ii"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return _Module["asm"]["dynCall_ii"].apply(null, arguments);
  };

  var dynCall_iiii = _Module["dynCall_iiii"] = function () {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return _Module["asm"]["dynCall_iiii"].apply(null, arguments);
  };

  ; // === Auto-generated postamble setup entry stuff ===

  _Module['asm'] = asm;
  if (!_Module["intArrayFromString"]) _Module["intArrayFromString"] = function () {
    abort("'intArrayFromString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["intArrayToString"]) _Module["intArrayToString"] = function () {
    abort("'intArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  _Module["ccall"] = ccall;
  _Module["cwrap"] = cwrap;
  if (!_Module["setValue"]) _Module["setValue"] = function () {
    abort("'setValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["getValue"]) _Module["getValue"] = function () {
    abort("'getValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["allocate"]) _Module["allocate"] = function () {
    abort("'allocate' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["getMemory"]) _Module["getMemory"] = function () {
    abort("'getMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you");
  };
  if (!_Module["Pointer_stringify"]) _Module["Pointer_stringify"] = function () {
    abort("'Pointer_stringify' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["AsciiToString"]) _Module["AsciiToString"] = function () {
    abort("'AsciiToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["stringToAscii"]) _Module["stringToAscii"] = function () {
    abort("'stringToAscii' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["UTF8ArrayToString"]) _Module["UTF8ArrayToString"] = function () {
    abort("'UTF8ArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["UTF8ToString"]) _Module["UTF8ToString"] = function () {
    abort("'UTF8ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["stringToUTF8Array"]) _Module["stringToUTF8Array"] = function () {
    abort("'stringToUTF8Array' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["stringToUTF8"]) _Module["stringToUTF8"] = function () {
    abort("'stringToUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["lengthBytesUTF8"]) _Module["lengthBytesUTF8"] = function () {
    abort("'lengthBytesUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["UTF16ToString"]) _Module["UTF16ToString"] = function () {
    abort("'UTF16ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["stringToUTF16"]) _Module["stringToUTF16"] = function () {
    abort("'stringToUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["lengthBytesUTF16"]) _Module["lengthBytesUTF16"] = function () {
    abort("'lengthBytesUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["UTF32ToString"]) _Module["UTF32ToString"] = function () {
    abort("'UTF32ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["stringToUTF32"]) _Module["stringToUTF32"] = function () {
    abort("'stringToUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["lengthBytesUTF32"]) _Module["lengthBytesUTF32"] = function () {
    abort("'lengthBytesUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["allocateUTF8"]) _Module["allocateUTF8"] = function () {
    abort("'allocateUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["stackTrace"]) _Module["stackTrace"] = function () {
    abort("'stackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["addOnPreRun"]) _Module["addOnPreRun"] = function () {
    abort("'addOnPreRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["addOnInit"]) _Module["addOnInit"] = function () {
    abort("'addOnInit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["addOnPreMain"]) _Module["addOnPreMain"] = function () {
    abort("'addOnPreMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["addOnExit"]) _Module["addOnExit"] = function () {
    abort("'addOnExit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["addOnPostRun"]) _Module["addOnPostRun"] = function () {
    abort("'addOnPostRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["writeStringToMemory"]) _Module["writeStringToMemory"] = function () {
    abort("'writeStringToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["writeArrayToMemory"]) _Module["writeArrayToMemory"] = function () {
    abort("'writeArrayToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["writeAsciiToMemory"]) _Module["writeAsciiToMemory"] = function () {
    abort("'writeAsciiToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["addRunDependency"]) _Module["addRunDependency"] = function () {
    abort("'addRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you");
  };
  if (!_Module["removeRunDependency"]) _Module["removeRunDependency"] = function () {
    abort("'removeRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you");
  };
  if (!_Module["FS"]) _Module["FS"] = function () {
    abort("'FS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["FS_createFolder"]) _Module["FS_createFolder"] = function () {
    abort("'FS_createFolder' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you");
  };
  if (!_Module["FS_createPath"]) _Module["FS_createPath"] = function () {
    abort("'FS_createPath' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you");
  };
  if (!_Module["FS_createDataFile"]) _Module["FS_createDataFile"] = function () {
    abort("'FS_createDataFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you");
  };
  if (!_Module["FS_createPreloadedFile"]) _Module["FS_createPreloadedFile"] = function () {
    abort("'FS_createPreloadedFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you");
  };
  if (!_Module["FS_createLazyFile"]) _Module["FS_createLazyFile"] = function () {
    abort("'FS_createLazyFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you");
  };
  if (!_Module["FS_createLink"]) _Module["FS_createLink"] = function () {
    abort("'FS_createLink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you");
  };
  if (!_Module["FS_createDevice"]) _Module["FS_createDevice"] = function () {
    abort("'FS_createDevice' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you");
  };
  if (!_Module["FS_unlink"]) _Module["FS_unlink"] = function () {
    abort("'FS_unlink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you");
  };
  if (!_Module["GL"]) _Module["GL"] = function () {
    abort("'GL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["staticAlloc"]) _Module["staticAlloc"] = function () {
    abort("'staticAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["dynamicAlloc"]) _Module["dynamicAlloc"] = function () {
    abort("'dynamicAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["warnOnce"]) _Module["warnOnce"] = function () {
    abort("'warnOnce' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["loadDynamicLibrary"]) _Module["loadDynamicLibrary"] = function () {
    abort("'loadDynamicLibrary' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["loadWebAssemblyModule"]) _Module["loadWebAssemblyModule"] = function () {
    abort("'loadWebAssemblyModule' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["getLEB"]) _Module["getLEB"] = function () {
    abort("'getLEB' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["getFunctionTables"]) _Module["getFunctionTables"] = function () {
    abort("'getFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["alignFunctionTables"]) _Module["alignFunctionTables"] = function () {
    abort("'alignFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["registerFunctions"]) _Module["registerFunctions"] = function () {
    abort("'registerFunctions' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["addFunction"]) _Module["addFunction"] = function () {
    abort("'addFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["removeFunction"]) _Module["removeFunction"] = function () {
    abort("'removeFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["getFuncWrapper"]) _Module["getFuncWrapper"] = function () {
    abort("'getFuncWrapper' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["prettyPrint"]) _Module["prettyPrint"] = function () {
    abort("'prettyPrint' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["makeBigInt"]) _Module["makeBigInt"] = function () {
    abort("'makeBigInt' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["dynCall"]) _Module["dynCall"] = function () {
    abort("'dynCall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["getCompilerSetting"]) _Module["getCompilerSetting"] = function () {
    abort("'getCompilerSetting' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["intArrayFromBase64"]) _Module["intArrayFromBase64"] = function () {
    abort("'intArrayFromBase64' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["tryParseAsDataURI"]) _Module["tryParseAsDataURI"] = function () {
    abort("'tryParseAsDataURI' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
  };
  if (!_Module["ALLOC_NORMAL"]) Object.defineProperty(_Module, "ALLOC_NORMAL", {
    get: function get() {
      abort("'ALLOC_NORMAL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
    }
  });
  if (!_Module["ALLOC_STACK"]) Object.defineProperty(_Module, "ALLOC_STACK", {
    get: function get() {
      abort("'ALLOC_STACK' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
    }
  });
  if (!_Module["ALLOC_STATIC"]) Object.defineProperty(_Module, "ALLOC_STATIC", {
    get: function get() {
      abort("'ALLOC_STATIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
    }
  });
  if (!_Module["ALLOC_DYNAMIC"]) Object.defineProperty(_Module, "ALLOC_DYNAMIC", {
    get: function get() {
      abort("'ALLOC_DYNAMIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
    }
  });
  if (!_Module["ALLOC_NONE"]) Object.defineProperty(_Module, "ALLOC_NONE", {
    get: function get() {
      abort("'ALLOC_NONE' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
    }
  }); // Modularize mode returns a function, which can be called to
  // create instances. The instances provide a then() method,
  // must like a Promise, that receives a callback. The callback
  // is called when the module is ready to run, with the module
  // as a parameter. (Like a Promise, it also returns the module
  // so you can use the output of .then(..)).

  _Module['then'] = function (func) {
    // We may already be ready to run code at this time. if
    // so, just queue a call to the callback.
    if (_Module['calledRun']) {
      func(_Module);
    } else {
      // we are not ready to call then() yet. we must call it
      // at the same time we would call onRuntimeInitialized.
      var old = _Module['onRuntimeInitialized'];

      _Module['onRuntimeInitialized'] = function () {
        if (old) old();
        func(_Module);
      };
    }

    return _Module;
  };
  /**
   * @constructor
   * @extends {Error}
   * @this {ExitStatus}
   */


  function ExitStatus(status) {
    this.name = "ExitStatus";
    this.message = "Program terminated with exit(" + status + ")";
    this.status = status;
  }

  ;
  ExitStatus.prototype = new Error();
  ExitStatus.prototype.constructor = ExitStatus;
  var initialStackTop;
  var calledMain = false;

  dependenciesFulfilled = function runCaller() {
    // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)
    if (!_Module['calledRun']) run();
    if (!_Module['calledRun']) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled
  };
  /** @type {function(Array=)} */


  function run(args) {
    args = args || _Module['arguments'];

    if (runDependencies > 0) {
      return;
    }

    writeStackCookie();
    preRun();
    if (runDependencies > 0) return; // a preRun added a dependency, run will be called later

    if (_Module['calledRun']) return; // run may have just been called through dependencies being fulfilled just in this very frame

    function doRun() {
      if (_Module['calledRun']) return; // run may have just been called while the async setStatus time below was happening

      _Module['calledRun'] = true;
      if (ABORT) return;
      ensureInitRuntime();
      preMain();
      if (_Module['onRuntimeInitialized']) _Module['onRuntimeInitialized']();
      assert(!_Module['_main'], 'compiled without a main, but one is present. if you added it from JS, use Module["onRuntimeInitialized"]');
      postRun();
    }

    if (_Module['setStatus']) {
      _Module['setStatus']('Running...');

      setTimeout(function () {
        setTimeout(function () {
          _Module['setStatus']('');
        }, 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }

    checkStackCookie();
  }

  _Module['run'] = run;

  function checkUnflushedContent() {
    // Compiler settings do not allow exiting the runtime, so flushing
    // the streams is not possible. but in ASSERTIONS mode we check
    // if there was something to flush, and if so tell the user they
    // should request that the runtime be exitable.
    // Normally we would not even include flush() at all, but in ASSERTIONS
    // builds we do so just for this check, and here we see if there is any
    // content to flush, that is, we check if there would have been
    // something a non-ASSERTIONS build would have not seen.
    // How we flush the streams depends on whether we are in NO_FILESYSTEM
    // mode (which has its own special function for this; otherwise, all
    // the code is inside libc)
    var print = _Module['print'];
    var printErr = _Module['printErr'];
    var has = false;

    _Module['print'] = _Module['printErr'] = function (x) {
      has = true;
    };

    try {
      // it doesn't matter if it fails
      var flush = flush_NO_FILESYSTEM;
      if (flush) flush(0);
    } catch (e) {}

    _Module['print'] = print;
    _Module['printErr'] = printErr;

    if (has) {
      warnOnce('stdio streams had content in them that was not flushed. you should set NO_EXIT_RUNTIME to 0 (see the FAQ), or make sure to emit a newline when you printf etc.');
    }
  }

  function exit(status, implicit) {
    checkUnflushedContent(); // if this is just main exit-ing implicitly, and the status is 0, then we
    // don't need to do anything here and can just leave. if the status is
    // non-zero, though, then we need to report it.
    // (we may have warned about this earlier, if a situation justifies doing so)

    if (implicit && _Module['noExitRuntime'] && status === 0) {
      return;
    }

    if (_Module['noExitRuntime']) {
      // if exit() was called, we may warn the user if the runtime isn't actually being shut down
      if (!implicit) {
        _Module.printErr('exit(' + status + ') called, but NO_EXIT_RUNTIME is set, so halting execution but not exiting the runtime or preventing further async execution (build with NO_EXIT_RUNTIME=0, if you want a true shutdown)');
      }
    } else {
      ABORT = true;
      EXITSTATUS = status;
      STACKTOP = initialStackTop;
      exitRuntime();
      if (_Module['onExit']) _Module['onExit'](status);
    }

    if (ENVIRONMENT_IS_NODE) {
      process['exit'](status);
    }

    _Module['quit'](status, new ExitStatus(status));
  }

  _Module['exit'] = exit;
  var abortDecorators = [];

  function abort(what) {
    if (_Module['onAbort']) {
      _Module['onAbort'](what);
    }

    if (what !== undefined) {
      _Module.print(what);

      _Module.printErr(what);

      what = JSON.stringify(what);
    } else {
      what = '';
    }

    ABORT = true;
    EXITSTATUS = 1;
    var extra = '';
    var output = 'abort(' + what + ') at ' + stackTrace() + extra;

    if (abortDecorators) {
      abortDecorators.forEach(function (decorator) {
        output = decorator(output, what);
      });
    }

    throw output;
  }

  _Module['abort'] = abort; // {{PRE_RUN_ADDITIONS}}

  if (_Module['preInit']) {
    if (typeof _Module['preInit'] == 'function') _Module['preInit'] = [_Module['preInit']];

    while (_Module['preInit'].length > 0) {
      _Module['preInit'].pop()();
    }
  }

  _Module["noExitRuntime"] = true;
  run(); // {{POST_RUN_ADDITIONS}}
  // {{MODULE_ADDITIONS}}

  return _Module;
};

if (( false ? undefined : _typeof(exports)) === 'object' && ( false ? undefined : _typeof(module)) === 'object') module.exports = Module;else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  return Module;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ })

/******/ });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Jb3RhUGljb1Bvd1dhc20vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL0lvdGFQaWNvUG93V2FzbS93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9Jb3RhUGljb1Bvd1dhc20vLi4vLi4vc3JjL2Vycm9yL2NvcmVFcnJvci50cyIsIndlYnBhY2s6Ly9Jb3RhUGljb1Bvd1dhc20vLi4vLi4vc3JjL2ZhY3Rvcmllcy9mYWN0b3J5QmFzZS50cyIsIndlYnBhY2s6Ly9Jb3RhUGljb1Bvd1dhc20vLi4vLi4vc3JjL2hlbHBlcnMvYXJyYXlIZWxwZXIudHMiLCJ3ZWJwYWNrOi8vSW90YVBpY29Qb3dXYXNtLy4uLy4uL3NyYy9oZWxwZXJzL2pzb25IZWxwZXIudHMiLCJ3ZWJwYWNrOi8vSW90YVBpY29Qb3dXYXNtLy4uLy4uL3NyYy9oZWxwZXJzL251bWJlckhlbHBlci50cyIsIndlYnBhY2s6Ly9Jb3RhUGljb1Bvd1dhc20vLi4vLi4vc3JjL2hlbHBlcnMvb2JqZWN0SGVscGVyLnRzIiwid2VicGFjazovL0lvdGFQaWNvUG93V2FzbS8uLi8uLi9zcmMvaGVscGVycy9zdHJpbmdIZWxwZXIudHMiLCJ3ZWJwYWNrOi8vSW90YVBpY29Qb3dXYXNtLy4uLy4uL3NyYy9zZXJ2aWNlcy90aW1lU2VydmljZS50cyIsIndlYnBhY2s6Ly9Jb3RhUGljb1Bvd1dhc20vLi4vLi4vc3JjL2RpZ2VzdHMvc2hhMy50cyIsIndlYnBhY2s6Ly9Jb3RhUGljb1Bvd1dhc20vLi4vLi4vc3JjL2Vycm9yL2NyeXB0b0Vycm9yLnRzIiwid2VicGFjazovL0lvdGFQaWNvUG93V2FzbS8uLi8uLi9zcmMvZmFjdG9yaWVzL3Nwb25nZUZhY3RvcnkudHMiLCJ3ZWJwYWNrOi8vSW90YVBpY29Qb3dXYXNtLy4uLy4uL3NyYy9oZWxwZXJzL2JpZ0ludGVnZXJIZWxwZXIudHMiLCJ3ZWJwYWNrOi8vSW90YVBpY29Qb3dXYXNtLy4uLy4uL3NyYy9oZWxwZXJzL3RyYW5zYWN0aW9uSGVscGVyLnRzIiwid2VicGFjazovL0lvdGFQaWNvUG93V2FzbS8uLi8uLi9zcmMvcHJvb2ZPZldvcmsvcHJvb2ZPZldvcmtCYXNlLnRzIiwid2VicGFjazovL0lvdGFQaWNvUG93V2FzbS8uLi8uLi9zcmMvc3Bvbmdlcy9jdXJsLnRzIiwid2VicGFjazovL0lvdGFQaWNvUG93V2FzbS8uLi8uLi9zcmMvc3Bvbmdlcy9rZXJsLnRzIiwid2VicGFjazovL0lvdGFQaWNvUG93V2FzbS8uLi9jcnlwdG8vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzIiwid2VicGFjazovL0lvdGFQaWNvUG93V2FzbS8uLi9jcnlwdG8vbm9kZV9tb2R1bGVzL2JpZy1pbnRlZ2VyL0JpZ0ludGVnZXIuanMiLCJ3ZWJwYWNrOi8vSW90YVBpY29Qb3dXYXNtLy4uL2NyeXB0by9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLW1vZHVsZS5qcyIsIndlYnBhY2s6Ly9Jb3RhUGljb1Bvd1dhc20vLi4vY3J5cHRvL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vSW90YVBpY29Qb3dXYXNtLy4uLy4uL3NyYy9kYXRhL2FkZHJlc3MudHMiLCJ3ZWJwYWNrOi8vSW90YVBpY29Qb3dXYXNtLy4uLy4uL3NyYy9kYXRhL2hhc2gudHMiLCJ3ZWJwYWNrOi8vSW90YVBpY29Qb3dXYXNtLy4uLy4uL3NyYy9kYXRhL3NpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudC50cyIsIndlYnBhY2s6Ly9Jb3RhUGljb1Bvd1dhc20vLi4vLi4vc3JjL2RhdGEvdGFnLnRzIiwid2VicGFjazovL0lvdGFQaWNvUG93V2FzbS8uLi8uLi9zcmMvZGF0YS90cmFuc2FjdGlvbi50cyIsIndlYnBhY2s6Ly9Jb3RhUGljb1Bvd1dhc20vLi4vLi4vc3JjL2RhdGEvdHJpdHMudHMiLCJ3ZWJwYWNrOi8vSW90YVBpY29Qb3dXYXNtLy4uLy4uL3NyYy9kYXRhL3RyeXRlTnVtYmVyLnRzIiwid2VicGFjazovL0lvdGFQaWNvUG93V2FzbS8uLi8uLi9zcmMvZGF0YS90cnl0ZXMudHMiLCJ3ZWJwYWNrOi8vSW90YVBpY29Qb3dXYXNtLy4uLy4uL3NyYy9lcnJvci9kYXRhRXJyb3IudHMiLCJ3ZWJwYWNrOi8vSW90YVBpY29Qb3dXYXNtLy4uL3NyYy9pbmRleC50cyIsIndlYnBhY2s6Ly9Jb3RhUGljb1Bvd1dhc20vLi4vc3JjL3Byb29mT2ZXb3JrV2FzbS50cyIsIndlYnBhY2s6Ly9Jb3RhUGljb1Bvd1dhc20vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vSW90YVBpY29Qb3dXYXNtLy4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS1tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vSW90YVBpY29Qb3dXYXNtLy4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcyIsIndlYnBhY2s6Ly9Jb3RhUGljb1Bvd1dhc20vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovL0lvdGFQaWNvUG93V2FzbS8uL3dhc20vaW90YS1waWNvLXBvdy13YXNtLmpzIl0sIm5hbWVzIjpbIk1vZHVsZSIsIm1vZHVsZU92ZXJyaWRlcyIsImtleSIsImhhc093blByb3BlcnR5Iiwic3RhdHVzIiwidG9UaHJvdyIsIkVOVklST05NRU5UX0lTX1dFQiIsIkVOVklST05NRU5UX0lTX1dPUktFUiIsIkVOVklST05NRU5UX0lTX05PREUiLCJFTlZJUk9OTUVOVF9JU19TSEVMTCIsIkVycm9yIiwid2luZG93IiwiaW1wb3J0U2NyaXB0cyIsInByb2Nlc3MiLCJub2RlRlMiLCJub2RlUGF0aCIsInNoZWxsX3JlYWQiLCJmaWxlbmFtZSIsImJpbmFyeSIsInJldCIsInRyeVBhcnNlQXNEYXRhVVJJIiwicmVxdWlyZSIsInRvU3RyaW5nIiwicmVhZEJpbmFyeSIsImJ1ZmZlciIsIlVpbnQ4QXJyYXkiLCJhc3NlcnQiLCJsZW5ndGgiLCJyZXBsYWNlIiwic2xpY2UiLCJleCIsIkV4aXRTdGF0dXMiLCJyZWFzb24iLCJwIiwicmVhZCIsImYiLCJkYXRhIiwiaW50QXJyYXlUb1N0cmluZyIsInJlYWRidWZmZXIiLCJzY3JpcHRBcmdzIiwiYXJndW1lbnRzIiwicXVpdCIsInVybCIsInhociIsIlhNTEh0dHBSZXF1ZXN0Iiwib3BlbiIsInNlbmQiLCJyZXNwb25zZVRleHQiLCJlcnIiLCJyZXNwb25zZVR5cGUiLCJyZXNwb25zZSIsInJlYWRBc3luYyIsIm9ubG9hZCIsIm9uZXJyb3IiLCJ4aHJfb25sb2FkIiwidGl0bGUiLCJkb2N1bWVudCIsImNvbnNvbGUiLCJsb2ciLCJwcmludCIsInByaW50RXJyIiwid2FybiIsInVuZGVmaW5lZCIsIlNUQUNLX0FMSUdOIiwic3RhY2tTYXZlIiwic3RhY2tSZXN0b3JlIiwic3RhY2tBbGxvYyIsInNldFRlbXBSZXQwIiwiZ2V0VGVtcFJldDAiLCJhYm9ydCIsInN0YXRpY0FsbG9jIiwic2l6ZSIsInN0YXRpY1NlYWxlZCIsIlNUQVRJQ1RPUCIsImR5bmFtaWNBbGxvYyIsIkRZTkFNSUNUT1BfUFRSIiwiSEVBUDMyIiwiZW5kIiwiVE9UQUxfTUVNT1JZIiwic3VjY2VzcyIsImVubGFyZ2VNZW1vcnkiLCJhbGlnbk1lbW9yeSIsImZhY3RvciIsIk1hdGgiLCJjZWlsIiwiZ2V0TmF0aXZlVHlwZVNpemUiLCJ0eXBlIiwiYml0cyIsInBhcnNlSW50Iiwic3Vic3RyIiwid2Fybk9uY2UiLCJ0ZXh0Iiwic2hvd24iLCJmdW5jdGlvblBvaW50ZXJzIiwiQXJyYXkiLCJhZGRGdW5jdGlvbiIsImZ1bmMiLCJpIiwicmVtb3ZlRnVuY3Rpb24iLCJpbmRleCIsImZ1bmNXcmFwcGVycyIsImdldEZ1bmNXcmFwcGVyIiwic2lnIiwic2lnQ2FjaGUiLCJkeW5DYWxsX3dyYXBwZXIiLCJkeW5DYWxsIiwiYXJnIiwicHJvdG90eXBlIiwiY2FsbCIsIm1ha2VCaWdJbnQiLCJsb3ciLCJoaWdoIiwidW5zaWduZWQiLCJwdHIiLCJhcmdzIiwiYXBwbHkiLCJjb25jYXQiLCJnZXRDb21waWxlclNldHRpbmciLCJuYW1lIiwiUnVudGltZSIsIkdMT0JBTF9CQVNFIiwiQUJPUlQiLCJFWElUU1RBVFVTIiwiY29uZGl0aW9uIiwiZ2xvYmFsU2NvcGUiLCJnZXRDRnVuYyIsImlkZW50IiwiSlNmdW5jcyIsImFyciIsIndyaXRlQXJyYXlUb01lbW9yeSIsInN0ciIsImxlbiIsInN0cmluZ1RvVVRGOCIsInRvQyIsImNjYWxsIiwicmV0dXJuVHlwZSIsImFyZ1R5cGVzIiwib3B0cyIsImNBcmdzIiwic3RhY2siLCJjb252ZXJ0ZXIiLCJQb2ludGVyX3N0cmluZ2lmeSIsImN3cmFwIiwiY2Z1bmMiLCJudW1lcmljQXJncyIsImV2ZXJ5IiwibnVtZXJpY1JldCIsInNldFZhbHVlIiwidmFsdWUiLCJub1NhZmUiLCJjaGFyQXQiLCJIRUFQOCIsIkhFQVAxNiIsInRlbXBJNjQiLCJ0ZW1wRG91YmxlIiwiTWF0aF9hYnMiLCJNYXRoX21pbiIsIk1hdGhfZmxvb3IiLCJNYXRoX2NlaWwiLCJIRUFQRjMyIiwiSEVBUEY2NCIsImdldFZhbHVlIiwiQUxMT0NfTk9STUFMIiwiQUxMT0NfU1RBQ0siLCJBTExPQ19TVEFUSUMiLCJBTExPQ19EWU5BTUlDIiwiQUxMT0NfTk9ORSIsImFsbG9jYXRlIiwic2xhYiIsInR5cGVzIiwiYWxsb2NhdG9yIiwiemVyb2luaXQiLCJzaW5nbGVUeXBlIiwiX21hbGxvYyIsIm1heCIsInN0b3AiLCJzdWJhcnJheSIsIkhFQVBVOCIsInNldCIsInR5cGVTaXplIiwicHJldmlvdXNUeXBlIiwiY3VyciIsImdldE1lbW9yeSIsInJ1bnRpbWVJbml0aWFsaXplZCIsImhhc1V0ZiIsInQiLCJNQVhfQ0hVTksiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJtaW4iLCJVVEY4VG9TdHJpbmciLCJBc2NpaVRvU3RyaW5nIiwiY2giLCJzdHJpbmdUb0FzY2lpIiwib3V0UHRyIiwid3JpdGVBc2NpaVRvTWVtb3J5IiwiVVRGOERlY29kZXIiLCJUZXh0RGVjb2RlciIsIlVURjhBcnJheVRvU3RyaW5nIiwidThBcnJheSIsImlkeCIsImVuZFB0ciIsImRlY29kZSIsInUwIiwidTEiLCJ1MiIsInUzIiwidTQiLCJ1NSIsInN0cmluZ1RvVVRGOEFycmF5Iiwib3V0VThBcnJheSIsIm91dElkeCIsIm1heEJ5dGVzVG9Xcml0ZSIsInN0YXJ0SWR4IiwiZW5kSWR4IiwidSIsImNoYXJDb2RlQXQiLCJsZW5ndGhCeXRlc1VURjgiLCJVVEYxNkRlY29kZXIiLCJVVEYxNlRvU3RyaW5nIiwiY29kZVVuaXQiLCJzdHJpbmdUb1VURjE2Iiwic3RhcnRQdHIiLCJudW1DaGFyc1RvV3JpdGUiLCJsZW5ndGhCeXRlc1VURjE2IiwiVVRGMzJUb1N0cmluZyIsInV0ZjMyIiwic3RyaW5nVG9VVEYzMiIsInRyYWlsU3Vycm9nYXRlIiwibGVuZ3RoQnl0ZXNVVEYzMiIsImFsbG9jYXRlVVRGOCIsImFsbG9jYXRlVVRGOE9uU3RhY2siLCJkZW1hbmdsZSIsImRlbWFuZ2xlQWxsIiwicmVnZXgiLCJ4IiwieSIsImpzU3RhY2tUcmFjZSIsImUiLCJzdGFja1RyYWNlIiwianMiLCJQQUdFX1NJWkUiLCJXQVNNX1BBR0VfU0laRSIsIkFTTUpTX1BBR0VfU0laRSIsIk1JTl9UT1RBTF9NRU1PUlkiLCJhbGlnblVwIiwibXVsdGlwbGUiLCJIRUFQIiwiSEVBUFUxNiIsIkhFQVBVMzIiLCJ1cGRhdGVHbG9iYWxCdWZmZXIiLCJidWYiLCJ1cGRhdGVHbG9iYWxCdWZmZXJWaWV3cyIsIkludDhBcnJheSIsIkludDE2QXJyYXkiLCJJbnQzMkFycmF5IiwiVWludDE2QXJyYXkiLCJVaW50MzJBcnJheSIsIkZsb2F0MzJBcnJheSIsIkZsb2F0NjRBcnJheSIsIlNUQVRJQ19CQVNFIiwiU1RBQ0tfQkFTRSIsIlNUQUNLVE9QIiwiU1RBQ0tfTUFYIiwiRFlOQU1JQ19CQVNFIiwid3JpdGVTdGFja0Nvb2tpZSIsImNoZWNrU3RhY2tDb29raWUiLCJhYm9ydFN0YWNrT3ZlcmZsb3ciLCJhbGxvY1NpemUiLCJhYm9ydE9uQ2Fubm90R3Jvd01lbW9yeSIsIlRPVEFMX1NUQUNLIiwiYnl0ZUxlbmd0aCIsIldlYkFzc2VtYmx5IiwiTWVtb3J5IiwiQXJyYXlCdWZmZXIiLCJnZXRUb3RhbE1lbW9yeSIsImNhbGxSdW50aW1lQ2FsbGJhY2tzIiwiY2FsbGJhY2tzIiwiY2FsbGJhY2siLCJzaGlmdCIsIl9fQVRQUkVSVU5fXyIsIl9fQVRJTklUX18iLCJfX0FUTUFJTl9fIiwiX19BVEVYSVRfXyIsIl9fQVRQT1NUUlVOX18iLCJydW50aW1lRXhpdGVkIiwicHJlUnVuIiwiYWRkT25QcmVSdW4iLCJlbnN1cmVJbml0UnVudGltZSIsInByZU1haW4iLCJleGl0UnVudGltZSIsInBvc3RSdW4iLCJhZGRPblBvc3RSdW4iLCJjYiIsInVuc2hpZnQiLCJhZGRPbkluaXQiLCJhZGRPblByZU1haW4iLCJhZGRPbkV4aXQiLCJ3cml0ZVN0cmluZ1RvTWVtb3J5Iiwic3RyaW5nIiwiZG9udEFkZE51bGwiLCJsYXN0Q2hhciIsIkluZmluaXR5IiwiYXJyYXkiLCJ1blNpZ24iLCJpZ25vcmUiLCJhYnMiLCJwb3ciLCJyZVNpZ24iLCJoYWxmIiwiTWF0aF9jb3MiLCJjb3MiLCJNYXRoX3NpbiIsInNpbiIsIk1hdGhfdGFuIiwidGFuIiwiTWF0aF9hY29zIiwiYWNvcyIsIk1hdGhfYXNpbiIsImFzaW4iLCJNYXRoX2F0YW4iLCJhdGFuIiwiTWF0aF9hdGFuMiIsImF0YW4yIiwiTWF0aF9leHAiLCJleHAiLCJNYXRoX2xvZyIsIk1hdGhfc3FydCIsInNxcnQiLCJmbG9vciIsIk1hdGhfcG93IiwiTWF0aF9pbXVsIiwiaW11bCIsIk1hdGhfZnJvdW5kIiwiZnJvdW5kIiwiTWF0aF9yb3VuZCIsInJvdW5kIiwiTWF0aF9tYXgiLCJNYXRoX2NsejMyIiwiY2x6MzIiLCJNYXRoX3RydW5jIiwidHJ1bmMiLCJydW5EZXBlbmRlbmNpZXMiLCJydW5EZXBlbmRlbmN5V2F0Y2hlciIsImRlcGVuZGVuY2llc0Z1bGZpbGxlZCIsInJ1bkRlcGVuZGVuY3lUcmFja2luZyIsImdldFVuaXF1ZVJ1bkRlcGVuZGVuY3kiLCJpZCIsIm9yaWciLCJyYW5kb20iLCJhZGRSdW5EZXBlbmRlbmN5Iiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwiZGVwIiwicmVtb3ZlUnVuRGVwZW5kZW5jeSIsIm1lbW9yeUluaXRpYWxpemVyIiwiRlMiLCJlcnJvciIsImluaXQiLCJjcmVhdGVEYXRhRmlsZSIsImNyZWF0ZVByZWxvYWRlZEZpbGUiLCJjcmVhdGVMYXp5RmlsZSIsIm1rZGV2IiwicmVnaXN0ZXJEZXZpY2UiLCJhbmFseXplUGF0aCIsImxvYWRGaWxlc0Zyb21EQiIsIkVycm5vRXJyb3IiLCJkYXRhVVJJUHJlZml4IiwiaXNEYXRhVVJJIiwic3RhcnRzV2l0aCIsImluZGV4T2YiLCJpbnRlZ3JhdGVXYXNtSlMiLCJtZXRob2QiLCJ3YXNtVGV4dEZpbGUiLCJ3YXNtQmluYXJ5RmlsZSIsImFzbWpzQ29kZUZpbGUiLCJ3YXNtUGFnZVNpemUiLCJpbmZvIiwiZXhwb3J0cyIsIm1lcmdlTWVtb3J5IiwibmV3QnVmZmVyIiwib2xkQnVmZmVyIiwib2xkVmlldyIsIm5ld1ZpZXciLCJmaXhJbXBvcnRzIiwiaW1wb3J0cyIsImdldEJpbmFyeSIsImdldEJpbmFyeVByb21pc2UiLCJmZXRjaCIsImNyZWRlbnRpYWxzIiwidGhlbiIsImNhdGNoIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJkb05hdGl2ZVdhc20iLCJnbG9iYWwiLCJlbnYiLCJwcm92aWRlZEJ1ZmZlciIsIk5hTiIsInJlY2VpdmVJbnN0YW5jZSIsImluc3RhbmNlIiwibW9kdWxlIiwibWVtb3J5IiwidHJ1ZU1vZHVsZSIsInJlY2VpdmVJbnN0YW50aWF0ZWRTb3VyY2UiLCJvdXRwdXQiLCJpbnN0YW50aWF0ZUFycmF5QnVmZmVyIiwicmVjZWl2ZXIiLCJpbnN0YW50aWF0ZSIsImluc3RhbnRpYXRlU3RyZWFtaW5nIiwiYXNtanNSZWFsbG9jQnVmZmVyIiwid2FzbVJlYWxsb2NCdWZmZXIiLCJQQUdFX01VTFRJUExFIiwib2xkIiwib2xkU2l6ZSIsInJlc3VsdCIsImdyb3ciLCJmaW5hbE1ldGhvZCIsIlRBQkxFX1NJWkUiLCJNQVhfVEFCTEVfU0laRSIsIlRhYmxlIiwiZWxlbWVudCIsIm1ldGhvZEhhbmRsZXIiLCJBU01fQ09OU1RTIiwicHVzaCIsIlNUQVRJQ19CVU1QIiwidGVtcERvdWJsZVB0ciIsImNvcHlUZW1wRmxvYXQiLCJjb3B5VGVtcERvdWJsZSIsIl9fX2xvY2siLCJTWVNDQUxMUyIsInZhcmFyZ3MiLCJnZXQiLCJnZXRTdHIiLCJnZXQ2NCIsImdldFplcm8iLCJfX19zeXNjYWxsMTQwIiwid2hpY2giLCJzdHJlYW0iLCJnZXRTdHJlYW1Gcm9tRkQiLCJvZmZzZXRfaGlnaCIsIm9mZnNldF9sb3ciLCJ3aGVuY2UiLCJvZmZzZXQiLCJsbHNlZWsiLCJwb3NpdGlvbiIsImdldGRlbnRzIiwiZXJybm8iLCJmbHVzaF9OT19GSUxFU1lTVEVNIiwiZmZsdXNoIiwicHJpbnRDaGFyIiwiX19fc3lzY2FsbDE0NiIsImJ1ZmZlcnMiLCJpb3YiLCJpb3ZjbnQiLCJqIiwiX19fc3lzY2FsbDU0IiwiX19fc3lzY2FsbDYiLCJjbG9zZSIsIl9fX3VubG9jayIsIl9lbXNjcmlwdGVuX2hhc190aHJlYWRpbmdfc3VwcG9ydCIsImN0dHpfaTgiLCJfbGx2bV9jdHR6X2kzMiIsIl9sbHZtX2N0dHpfaTY0IiwibCIsImgiLCJfbGx2bV9zdGFja3Jlc3RvcmUiLCJzZWxmIiwiX2xsdm1fc3RhY2tzYXZlIiwiTExWTV9TQVZFRFNUQUNLUyIsInNwbGljZSIsIl9lbXNjcmlwdGVuX21lbWNweV9iaWciLCJkZXN0Iiwic3JjIiwibnVtIiwiX3B0aHJlYWRfY3JlYXRlIiwiX3B0aHJlYWRfam9pbiIsIl9wdGhyZWFkX211dGV4X2luaXQiLCJfX19zZXRFcnJObyIsIkVSUk5PX0NPREVTIiwiRVBFUk0iLCJFTk9FTlQiLCJFU1JDSCIsIkVJTlRSIiwiRUlPIiwiRU5YSU8iLCJFMkJJRyIsIkVOT0VYRUMiLCJFQkFERiIsIkVDSElMRCIsIkVBR0FJTiIsIkVXT1VMREJMT0NLIiwiRU5PTUVNIiwiRUFDQ0VTIiwiRUZBVUxUIiwiRU5PVEJMSyIsIkVCVVNZIiwiRUVYSVNUIiwiRVhERVYiLCJFTk9ERVYiLCJFTk9URElSIiwiRUlTRElSIiwiRUlOVkFMIiwiRU5GSUxFIiwiRU1GSUxFIiwiRU5PVFRZIiwiRVRYVEJTWSIsIkVGQklHIiwiRU5PU1BDIiwiRVNQSVBFIiwiRVJPRlMiLCJFTUxJTksiLCJFUElQRSIsIkVET00iLCJFUkFOR0UiLCJFTk9NU0ciLCJFSURSTSIsIkVDSFJORyIsIkVMMk5TWU5DIiwiRUwzSExUIiwiRUwzUlNUIiwiRUxOUk5HIiwiRVVOQVRDSCIsIkVOT0NTSSIsIkVMMkhMVCIsIkVERUFETEsiLCJFTk9MQ0siLCJFQkFERSIsIkVCQURSIiwiRVhGVUxMIiwiRU5PQU5PIiwiRUJBRFJRQyIsIkVCQURTTFQiLCJFREVBRExPQ0siLCJFQkZPTlQiLCJFTk9TVFIiLCJFTk9EQVRBIiwiRVRJTUUiLCJFTk9TUiIsIkVOT05FVCIsIkVOT1BLRyIsIkVSRU1PVEUiLCJFTk9MSU5LIiwiRUFEViIsIkVTUk1OVCIsIkVDT01NIiwiRVBST1RPIiwiRU1VTFRJSE9QIiwiRURPVERPVCIsIkVCQURNU0ciLCJFTk9UVU5JUSIsIkVCQURGRCIsIkVSRU1DSEciLCJFTElCQUNDIiwiRUxJQkJBRCIsIkVMSUJTQ04iLCJFTElCTUFYIiwiRUxJQkVYRUMiLCJFTk9TWVMiLCJFTk9URU1QVFkiLCJFTkFNRVRPT0xPTkciLCJFTE9PUCIsIkVPUE5PVFNVUFAiLCJFUEZOT1NVUFBPUlQiLCJFQ09OTlJFU0VUIiwiRU5PQlVGUyIsIkVBRk5PU1VQUE9SVCIsIkVQUk9UT1RZUEUiLCJFTk9UU09DSyIsIkVOT1BST1RPT1BUIiwiRVNIVVRET1dOIiwiRUNPTk5SRUZVU0VEIiwiRUFERFJJTlVTRSIsIkVDT05OQUJPUlRFRCIsIkVORVRVTlJFQUNIIiwiRU5FVERPV04iLCJFVElNRURPVVQiLCJFSE9TVERPV04iLCJFSE9TVFVOUkVBQ0giLCJFSU5QUk9HUkVTUyIsIkVBTFJFQURZIiwiRURFU1RBRERSUkVRIiwiRU1TR1NJWkUiLCJFUFJPVE9OT1NVUFBPUlQiLCJFU09DS1ROT1NVUFBPUlQiLCJFQUREUk5PVEFWQUlMIiwiRU5FVFJFU0VUIiwiRUlTQ09OTiIsIkVOT1RDT05OIiwiRVRPT01BTllSRUZTIiwiRVVTRVJTIiwiRURRVU9UIiwiRVNUQUxFIiwiRU5PVFNVUCIsIkVOT01FRElVTSIsIkVJTFNFUSIsIkVPVkVSRkxPVyIsIkVDQU5DRUxFRCIsIkVOT1RSRUNPVkVSQUJMRSIsIkVPV05FUkRFQUQiLCJFU1RSUElQRSIsIl9zeXNjb25mIiwibWF4SGVhcFNpemUiLCJuYXZpZ2F0b3IiLCJBU1NFUlRJT05TIiwiaW50QXJyYXlGcm9tU3RyaW5nIiwic3RyaW5neSIsInU4YXJyYXkiLCJudW1CeXRlc1dyaXR0ZW4iLCJjaHIiLCJqb2luIiwiZGVjb2RlQmFzZTY0IiwiYXRvYiIsImlucHV0Iiwia2V5U3RyIiwiY2hyMSIsImNocjIiLCJjaHIzIiwiZW5jMSIsImVuYzIiLCJlbmMzIiwiZW5jNCIsImludEFycmF5RnJvbUJhc2U2NCIsInMiLCJCdWZmZXIiLCJmcm9tIiwiXyIsImJ5dGVPZmZzZXQiLCJkZWNvZGVkIiwiYnl0ZXMiLCJudWxsRnVuY19paSIsIm51bGxGdW5jX2lpaWkiLCJpbnZva2VfaWkiLCJhMSIsImludm9rZV9paWlpIiwiYTIiLCJhMyIsImFzbUdsb2JhbEFyZyIsImFzbUxpYnJhcnlBcmciLCJhc20iLCJyZWFsX19fX2Vycm5vX2xvY2F0aW9uIiwicmVhbF9fY2N1cmxfcG93IiwicmVhbF9fZmZsdXNoIiwicmVhbF9fZnJlZSIsInJlYWxfX2xsdm1fYnN3YXBfaTMyIiwicmVhbF9fbWFsbG9jIiwicmVhbF9fcHRocmVhZF9tdXRleF9sb2NrIiwicmVhbF9fcHRocmVhZF9tdXRleF91bmxvY2siLCJyZWFsX19zYnJrIiwicmVhbF9lc3RhYmxpc2hTdGFja1NwYWNlIiwicmVhbF9nZXRUZW1wUmV0MCIsInJlYWxfc2V0VGVtcFJldDAiLCJyZWFsX3NldFRocmV3IiwicmVhbF9zdGFja0FsbG9jIiwicmVhbF9zdGFja1Jlc3RvcmUiLCJyZWFsX3N0YWNrU2F2ZSIsIl9fX2Vycm5vX2xvY2F0aW9uIiwiX2NjdXJsX3BvdyIsIl9mZmx1c2giLCJfZnJlZSIsIl9sbHZtX2Jzd2FwX2kzMiIsIl9tZW1jcHkiLCJfbWVtc2V0IiwiX3B0aHJlYWRfbXV0ZXhfbG9jayIsIl9wdGhyZWFkX211dGV4X3VubG9jayIsIl9zYnJrIiwiZXN0YWJsaXNoU3RhY2tTcGFjZSIsInJ1blBvc3RTZXRzIiwic2V0VGhyZXciLCJkeW5DYWxsX2lpIiwiZHluQ2FsbF9paWlpIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJtZXNzYWdlIiwiY29uc3RydWN0b3IiLCJpbml0aWFsU3RhY2tUb3AiLCJjYWxsZWRNYWluIiwicnVuQ2FsbGVyIiwicnVuIiwiZG9SdW4iLCJzZXRUaW1lb3V0IiwiY2hlY2tVbmZsdXNoZWRDb250ZW50IiwiaGFzIiwiZmx1c2giLCJleGl0IiwiaW1wbGljaXQiLCJhYm9ydERlY29yYXRvcnMiLCJ3aGF0IiwiSlNPTiIsInN0cmluZ2lmeSIsImV4dHJhIiwiZm9yRWFjaCIsImRlY29yYXRvciIsInBvcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87QUNWQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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O0FBQ3hDLGFBQUksRUFBRyxLQUFJLEVBQUksTUFBSSxFQUFJLE1BQUksRUFBSSxNQUFJLEVBQUs7QUFFekMsWUFBUSxNQUFJLE1BQVMsQ0FBWixHQUFlLE9BQVU7QUFDbEMsWUFBUSxNQUFJLE1BQVMsQ0FBWixHQUFlLE9BQVU7QUFDbEMsVUFBRyxNQUFNO0FBQ1QsVUFBRyxNQUFNO0FBQ1QsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsWUFBUSxNQUFJLE1BQVMsQ0FBWixHQUFlLE9BQVU7QUFDbEMsWUFBUSxNQUFJLE1BQVMsQ0FBWixHQUFlLE9BQVU7QUFDbEMsVUFBRyxNQUFNO0FBQ1QsVUFBRyxNQUFNO0FBQ1QsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsWUFBUSxNQUFJLE1BQVMsQ0FBWixHQUFlLE9BQVU7QUFDbEMsWUFBUSxNQUFJLE1BQVMsQ0FBWixHQUFlLE9BQVU7QUFDbEMsVUFBRyxNQUFNO0FBQ1QsVUFBRyxNQUFNO0FBQ1QsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsWUFBUSxNQUFJLE1BQVMsQ0FBWixHQUFlLE9BQVU7QUFDbEMsWUFBUSxNQUFJLE1BQVMsQ0FBWixHQUFlLE9BQVU7QUFDbEMsVUFBRyxNQUFNO0FBQ1QsVUFBRyxNQUFNO0FBQ1QsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFN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LENBQUcsS0FBTztBQUN0QixVQUFJLE1BQVMsTUFBQyxDQUFJLE1BQVE7QUFDMUIsVUFBSSxNQUFTLE1BQUMsQ0FBSSxNQUFRO0FBQzFCLFVBQUksTUFBUyxNQUFDLENBQUksTUFBUTtBQUMxQixVQUFJLE1BQVMsTUFBQyxDQUFJLE1BQVE7QUFDMUIsVUFBSSxNQUFTLE1BQUMsQ0FBSSxNQUFRO0FBQzFCLFVBQUksTUFBUyxNQUFDLENBQUksTUFBUTtBQUMxQixVQUFJLE1BQVMsTUFBQyxDQUFJLE1BQVE7QUFDMUIsVUFBSSxNQUFTLE1BQUMsQ0FBSSxNQUFRO0FBQzFCLFVBQUcsS0FBUSxLQUFDLENBQUcsS0FBTztBQUN0QixVQUFHLEtBQVEsS0FBQyxDQUFHLEtBQU87QUFDdEIsVUFBSSxNQUFTLE1BQUMsQ0FBSSxNQUFRO0FBQzFCLFVBQUksTUFBUyxNQUFDLENBQUksTUFBUTtBQUMxQixVQUFJLE1BQVMsTUFBQyxDQUFJLE1BQVE7QUFDMUIsVUFBSSxNQUFTLE1BQUMsQ0FBSSxNQUFRO0FBQzFCLFVBQUksTUFBUyxNQUFDLENBQUksTUFBUTtBQUMxQixVQUFJLE1BQVMsTUFBQyxDQUFJLE1BQVE7QUFDMUIsVUFBSSxNQUFTLE1BQUMsQ0FBSSxNQUFRO0FBQzFCLFVBQUksTUFBUyxNQUFDLENBQUksTUFBUTtBQUMxQixVQUFHLEtBQVEsS0FBQyxDQUFHLEtBQU87QUFDdEIsVUFBRyxLQUFRLEtBQUMsQ0FBRyxLQUFPO0FBQ3RCLFVBQUksTUFBUyxNQUFDLENBQUksTUFBUTtBQUMxQixVQUFJLE1BQVMsTUFBQyxDQUFJLE1BQVE7QUFDMUIsVUFBSSxNQUFTLE1BQUMsQ0FBSSxNQUFRO0FBQzFCLFVBQUksTUFBUyxNQUFDLENBQUksTUFBUTtBQUMxQixVQUFJLE1BQVMsTUFBQyxDQUFJLE1BQVE7QUFDMUIsVUFBSSxNQUFTLE1BQUMsQ0FBSSxNQUFRO0FBQzFCLFVBQUksTUFBUyxNQUFDLENBQUksTUFBUTtBQUMxQixVQUFJLE1BQVMsTUFBQyxDQUFJLE1BQVE7QUFDMUIsVUFBRyxLQUFRLEtBQUMsQ0FBRyxLQUFPO0FBQ3RCLFVBQUcsS0FBUSxLQUFDLENBQUcsS0FBTztBQUN0QixVQUFJLE1BQVMsTUFBQyxDQUFJLE1BQVE7QUFDMUIsVUFBSSxNQUFTLE1BQUMsQ0FBSSxNQUFRO0FBQzFCLFVBQUksTUFBUyxNQUFDLENBQUksTUFBUTtBQUMxQixVQUFJLE1BQVMsTUFBQyxDQUFJLE1BQVE7QUFDMUIsVUFBSSxNQUFTLE1BQUMsQ0FBSSxNQUFRO0FBQzFCLFVBQUksTUFBUyxNQUFDLENBQUksTUFBUTtBQUMxQixVQUFJLE1BQVMsTUFBQyxDQUFJLE1BQVE7QUFDMUIsVUFBSSxNQUFTLE1BQUMsQ0FBSSxNQUFRO0FBRTFCLFVBQUcsTUFBUSxLQUFnQixnQkFBSTtBQUMvQixVQUFHLE1BQVEsS0FBZ0IsZ0JBQUUsSUFBTTtBQUU1QztBQUFDOzs7OztBQWhWOEI7OztBQUNSLEtBQWMsaUJBQWdCLElBQWUsWUFBQyxDQUFFLEdBQUssS0FBTyxPQUFhO0FBQ2pGOztBQUNTLEtBQUssUUFBZSxJQUFjLFdBQUMsQ0FBRSxHQUFHLEdBQUksSUFBTztBQUM1RDs7QUFDUyxLQUFlLGtCQUFnQixJQUFlLFlBQUMsQ0FBRSxHQUFHLEdBQU8sT0FBRyxHQUFPLE9BQVksWUFBWSxZQUFZLFlBQU8sT0FBRyxHQUFZLFlBQ2xKLEdBQVksWUFBWSxZQUFPLE9BQVksWUFBSyxLQUFHLEdBQUssS0FBRyxHQUFZLFlBQUcsR0FDakUsWUFBRyxHQUFZLFlBQUcsR0FBSyxLQUFZLFlBQU8sT0FBWSxZQUFPLE9BQzdELFlBQU8sT0FBWSxZQUFLLEtBQVksWUFBTyxPQUFHLEdBQVksWUFBWSxZQUN0RSxZQUFZLFlBQU8sT0FBWSxZQUFZLFlBQUcsR0FBWSxZQUFlO0FBVjNGLGVBa1ZDLEs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4VkQsc0NBQWlFO0FBS2pFOzs7OztJQUF5Qjs7Ozs7QUFNbEI7Ozs7OztBQUNILHVCQUEyQixTQUFvQyxZQUFvQjs7Ozs7QUFDMUUsc0hBQVEsU0FBWSxZQUFjO0FBQ25DLFVBQU8sU0FDZjs7QUFDSDs7O0VBWGdDLFlBQVM7O0FBQTFDLHNCQVdDLFk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaEJELHdDQUF5RTs7QUFFekUsaUNBQXVDOztBQUN2QyxpQ0FBdUM7QUFLdkM7Ozs7O0lBQTJCOzs7OztBQU9wQjs7OztBQUNIO0FBRUE7OztBQUFDO0FBTXFCOzs7Ozs7Ozs7QUFZRDs7QUFDakIsYUFBb0IsY0FDeEI7QUFDSDs7OztBQWRPLFVBQUksQ0FBYyxjQUFVLFdBQUU7QUFDYixzQkFBVSxZQUFHLElBQW9COztBQUNqQyxzQkFBVSxVQUFTLFNBQU87QUFBRztBQUFZOzs7b0RBQUksT0FBSyxvQkFBVTs7O0FBQzVELHNCQUFVLFVBQVMsU0FBUztBQUFjLGlCQUFDLElBQUksT0FBSSxLQUFNOzs7QUFDekQsc0JBQVUsVUFBUyxTQUFTO0FBQWMsaUJBQUMsSUFBSSxPQUFJLEtBQU07OztBQUN6RCxzQkFBVSxVQUFTLFNBQU87QUFBYyxpQkFBQyxJQUFJLE9BQVE7O0FBQ3JFOztBQUNELGFBQW9CLGNBQ3hCO0FBQUM7Ozs7RUF6QjhCLGNBQW9COztBQUF2RCx3QkErQkMsYzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdkNELHlDQUF5RTs7QUFDekUseUNBQXlFLDBGQUNsQzs7O0FBQ3ZDLHdEQUFpQzs7QUFDakMsd0NBQW1EO0FBTW5EOzs7Ozs7Ozs7Ozs7Ozs7O0FBb0JtQzs7Ozs7OztzQ0FBaUIsT0FBZ0IsUUFBZ0I7QUFDNUUsVUFBSSxDQUFDLGVBQVksYUFBTyxPQUFNLE9BQVksY0FBUyxNQUFPLFdBQU0sR0FBRTtBQUM5RCxjQUFNLElBQUksY0FBVyxZQUE0QztBQUNwRTs7QUFFRCxVQUFJLENBQUMsZUFBWSxhQUFVLFVBQVEsV0FBVSxTQUFJLEdBQUU7QUFDL0MsY0FBTSxJQUFJLGNBQVcsWUFBcUM7QUFDN0Q7O0FBRUQsVUFBSSxDQUFDLGVBQVksYUFBVSxVQUFRLFdBQVUsVUFBSyxHQUFFO0FBQ2hELGNBQU0sSUFBSSxjQUFXLFlBQW9DO0FBQzVEOztBQUVELFVBQVUsU0FBUyxTQUFRLE1BQU8sUUFBRTtBQUNoQyxjQUFNLElBQUksY0FBVyxZQUEwRDtBQUNsRjs7QUFFRCxVQUFTLFFBQUcsY0FBTSxRQUFNOztBQUV4QixXQUFLLElBQUssSUFBUyxTQUFJLEdBQUcsS0FBSyxHQUFLLEtBQUU7QUFDN0IsZ0JBQVEsTUFBUyxTQUFpQixpQkFBTyxPQUFJLElBQUMsY0FBTSxRQUFNLE1BQU8sU0FBUTtBQUNqRjs7QUFFRCxhQUNKO0FBQUM7QUFTOEI7Ozs7Ozs7Ozs7c0NBQXlCLE9BQWtCLE9BQWdCLFFBQWdCO0FBQ3RHLFVBQUksQ0FBQyxlQUFZLGFBQU8sT0FBTSxPQUFFLGNBQU8sVUFBRTtBQUNyQyxjQUFNLElBQUksY0FBVyxZQUF3QztBQUNoRTs7QUFFRCxVQUFJLENBQUMsZUFBWSxhQUFPLE9BQU0sT0FBWSxZQUFFO0FBQ3hDLGNBQU0sSUFBSSxjQUFXLFlBQW1DO0FBQzNEOztBQUVELFVBQUksQ0FBQyxlQUFZLGFBQVUsVUFBUSxXQUFVLFNBQUksR0FBRTtBQUMvQyxjQUFNLElBQUksY0FBVyxZQUFxQztBQUM3RDs7QUFFRCxVQUFJLENBQUMsZUFBWSxhQUFVLFVBQVEsV0FBVSxVQUFLLEdBQUU7QUFDaEQsY0FBTSxJQUFJLGNBQVcsWUFBb0M7QUFDNUQ7O0FBRUQsVUFBVSxTQUFTLFNBQVEsTUFBTyxRQUFFO0FBQ2hDLGNBQU0sSUFBSSxjQUFXLFlBQTBEO0FBQ2xGOztBQUVELFVBQWlCLGdCQUFRLE1BQVUsVUFBQyxjQUFNLFFBQU0sUUFBTSxJQUFNLE1BQVcsV0FBTzs7QUFFOUUsV0FBSyxJQUFLLElBQUksR0FBRyxJQUFTLFFBQUssS0FBRTtBQUM3QixZQUFrQixlQUFnQixjQUFPLE9BQWlCLGlCQUFRO0FBQ3JELHdCQUFlLGFBQVU7QUFDdEMsWUFBYSxZQUFlLGFBQVc7O0FBRXZDLFlBQWEsWUFBbUIsaUJBQWUsZ0JBQUU7QUFDcEMsc0JBQW1CLGlCQUFnQjtBQUMvQiwwQkFBZ0IsY0FBSSxJQUFDLGNBQU0sUUFBTztBQUNsRDs7QUFDSSxjQUFPLFNBQUssS0FBWSxVQUFjO0FBQzlDOztBQUVELFVBQVMsTUFBVSxVQUFDLGNBQU0sUUFBTSxRQUFJLEdBQUU7QUFDbEMsYUFBSyxJQUFLLEtBQUksR0FBRyxLQUFTLFFBQUssTUFBRTtBQUNQO0FBQ2pCLGdCQUFPLFNBQUssTUFBUSxNQUFPLFNBQUssUUFBUSxJQUFJLElBQUMsQ0FBTSxNQUFPLFNBQU07QUFDeEU7QUFFVDtBQUFDO0FBUThCOzs7Ozs7Ozs7c0NBQXlCLE9BQTBCLGFBQWdCO0FBQzlGLFVBQUksQ0FBQyxlQUFZLGFBQU8sT0FBTSxPQUFFLGNBQU8sVUFBRTtBQUNyQyxjQUFNLElBQUksY0FBVyxZQUF3QztBQUNoRTs7QUFFRCxVQUFJLENBQUMsZUFBWSxhQUFPLE9BQVksYUFBYyxnQkFBZSxZQUFXLGVBQU0sR0FBRTtBQUNoRixjQUFNLElBQUksY0FBVyxZQUFxQztBQUM3RDs7QUFFRCxVQUFJLENBQUMsZUFBWSxhQUFVLFVBQVEsV0FBVSxTQUFJLEdBQUU7QUFDL0MsY0FBTSxJQUFJLGNBQVcsWUFBcUM7QUFDN0Q7O0FBRUQsVUFBZSxZQUFXLGFBQVMsU0FBbUIsaUJBQWlCLGtCQUFFO0FBQ3JFLGNBQU0sSUFBSSxjQUFZLDhFQUEyRSxpQkFBcUI7QUFDekgsUUFFc0M7OztBQUN2QyxVQUFXLFFBQVEsTUFBZSxlQUFDLENBQUksSUFBRztBQUUxQyxVQUFhLFlBQVEsTUFBUyxTQUFLOztBQUVuQyxVQUFTLFVBQUssQ0FBRSxHQUFFO0FBQ1U7QUFDZixvQkFBWSxVQUFNLE1BQUk7QUFDbEMsUUFDbUU7OztBQUNwRSxVQUFhLFVBQU8sU0FBSSxNQUFNLEdBQUU7QUFDaEIsK0JBQWdCO0FBQy9COztBQUNELFVBQWEsVUFBWSxVQUFNLE1BQWlCLGlCQUVuQjs7QUFDN0IsVUFBaUIsa0JBQWdCLGtCQUN6QjtBQUFPLGVBQVUscUJBQVUsTUFBUTtPQURGLENBQXJCOztBQUdwQixVQUFTLFVBQUssQ0FBRSxHQUFFO0FBQ0UseUJBQWUsZUFBYztBQUNoRDs7QUFFRCxVQUFjLFdBQUcsSUFBWSxTQUFjLGNBRU07O0FBQ2pELFVBQUssSUFBVTs7QUFDZixhQUFRLElBQWMsWUFBTyxTQUFtQixpQkFBaUIsa0JBQUU7QUFDdkQsaUJBQVEsUUFBSSxLQUFTO0FBQ2hDLFFBQzhCOzs7QUFDL0IsV0FBSyxJQUFLLElBQWMsWUFBTyxRQUFLLE1BQUksSUFBRztBQUMvQixpQkFBUSxRQUFJLEtBQWEsWUFBWSxZQUFPLFNBQUksSUFBTztBQUV2RTtBQUFDO0FBUzhCOzs7Ozs7Ozs7O3NDQUFvQixRQUFnQixRQUFnQjtBQUMvRSxVQUFJLENBQUMsZUFBWSxhQUFPLE9BQU8sUUFBYyxnQkFBVSxPQUFXLGVBQU0sR0FBRTtBQUN0RSxjQUFNLElBQUksY0FBVyxZQUFnRDtBQUN4RTs7QUFFRCxVQUFJLENBQUMsZUFBWSxhQUFVLFVBQVEsV0FBVSxTQUFJLEdBQUU7QUFDL0MsY0FBTSxJQUFJLGNBQVcsWUFBcUM7QUFDN0Q7O0FBRUQsVUFBSSxDQUFDLGVBQVksYUFBVSxVQUFRLFdBQVUsVUFBSyxHQUFFO0FBQ2hELGNBQU0sSUFBSSxjQUFXLFlBQW9DO0FBQzVEOztBQUVELFVBQVUsT0FBVyxhQUFTLFNBQW1CLGlCQUFpQixrQkFBRTtBQUNoRSxjQUFNLElBQUksY0FBWSx5RUFBc0UsaUJBQXFCO0FBQ3BIOztBQUVELFVBQWMsV0FBRyxJQUFZLFNBQVM7QUFFdEMsVUFBZSxjQUFHLElBQWEsVUFBUyxTQUFhOztBQUNyRCxXQUFLLElBQUssSUFBSSxHQUFHLElBQVcsU0FBVyxZQUFLLEtBQUU7QUFDL0Isb0JBQUcsS0FBVyxTQUFRLFFBQUUsSUFBVztBQUNqRCxRQUVzRDs7O0FBQ3ZELFVBQWlCLGdCQUFLO0FBQ3RCLFVBQWUsWUFBYyxZQUFJO0FBQ2pDLFVBQVcsUUFBWSxZQUFLLEdBRWdEO0FBQ25DOztBQUN6QyxVQUFhLGNBQU0sS0FBYSxjQUFLLENBQUU7QUFDbkMsZUFBa0IsWUFBZSxtQkFBYyxhQUFpQixnQkFBYyxZQUFPLFNBQUksR0FBRTtBQUN2RTtBQUNuQixTQUhvQyxDQUlqQjs7O0FBQ1Qsc0JBQWMsWUFBTSxNQUFnQjtBQUNsRDs7QUFFRCxVQUFTLE9BQUU7QUFDUyx5QkFBZSxlQUFjO0FBQ2hEOztBQUVELFVBQWEsWUFBVSxRQUFNLE1BQUk7QUFDakMsVUFBUSxLQUFHLElBQVksU0FBWSxZQUFTOztBQUM1QyxXQUFLLElBQUssSUFBSSxHQUFHLElBQUssR0FBVyxZQUFLLEtBQUU7QUFDM0IscUJBQUksWUFBTyxHQUFTLFNBQUcsR0FBUyxTQUFNLEtBQU0sTUFBQyxDQUFJO0FBQzdEOztBQUVELGFBQU8sY0FBTSxRQUFVLFdBQzNCO0FBQUM7QUFHNEI7Ozs7bUNBQXVCO0FBQ1Q7QUFDZTtBQUNaO0FBQzFDLFdBQUssSUFBSyxJQUFJLEdBQUcsSUFBYyxZQUFPLFFBQUssS0FBRTtBQUM5QixvQkFBRyxLQUFHLENBQVksWUFBSTtBQUNwQyxRQUMrRDs7O0FBQ2hFLFVBQUssSUFBYyxZQUFPLFNBQUs7O0FBQy9CLFNBQUc7QUFDWSxvQkFBTTtBQUNwQixlQUFtQixZQUFLLFNBQU0sS0FBSyxJQUN4QztBQUFDOzs7OztBQWxPYzs7O0FBQ1MsaUJBQUssUUFBc0IsY0FBTSxRQUFJO0FBQzlDOztBQUNTLGlCQUFjLGlCQUFzQyxpQkFBTSxNQUFNLE1BQUcsR0FBTyxPQUFJO0FBQ3ZGOztBQUNTLGlCQUFjLGlCQUFzQyxpQkFBZSxlQUFVO0FBRXRGOztBQUNTLGlCQUFlLGtCQUFlO0FBQ3ZDOztBQUNTLGlCQUFnQixtQkFBMkIsaUJBQWdCLGtCQUFLO0FBWDVGLDJCQW9PQyxpQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOU9ELHlDQUF5RTs7QUFDekUsaUNBQXNEOztBQUN0RCx3Q0FBb0U7O0FBQ3BFLGtDQUF3RDs7QUFDeEQsd0NBQW1EOztBQUNuRCwwQ0FBMkQ7QUFNM0Q7Ozs7Ozs7Ozs7Ozs7Ozs7QUFNc0I7Ozs7O3lCQUF5QjtBQUN2QyxVQUFJLENBQUMsZUFBWSxhQUFPLE9BQVksYUFBRSxjQUFZLGNBQUU7QUFDaEQsY0FBTSxJQUFJLGNBQVcsWUFBZ0Q7QUFDeEU7O0FBRUQsVUFBVSxPQUFHLGdCQUFhLGNBQVcsV0FBTyxPQUFTO0FBQ3JELFVBQXNCLG1CQUFHLFFBQUssTUFBVyxXQUFZLFlBQVksWUFBVztBQUV4RSxXQUFjO0FBQ2QsV0FBTyxPQUFpQixrQkFBRyxHQUFrQixpQkFBUztBQUUxRCxVQUFlLFlBQUcsSUFBYSxVQUFLLEtBQVksWUFBaUI7QUFDN0QsV0FBUSxRQUFVLFdBQUcsR0FBVyxVQUFTO0FBRTdDLGFBQU8sT0FBSSxLQUFXLFdBQUMsUUFBSyxNQUFVLFVBQVcsV0FDckQ7QUFDSDs7Ozs7O0FBdEJELDRCQXNCQyxrQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDakNELHdDQUF1RTs7QUFDdkUseUNBQXlFOztBQUN6RSx5Q0FBeUU7O0FBRXpFLHdDQUF3RTs7QUFDeEUsaUNBQXNEOztBQUN0RCxnQ0FBb0Q7O0FBQ3BELHdDQUFvRTs7QUFDcEUsd0NBQW9FOztBQUNwRSxtQ0FBMEQ7O0FBQzFELHdDQUFtRDs7QUFDbkQsOENBQWlFO0FBTWpFOzs7Ozs7OztBQVlPOzs7O0FBQ0gsMkJBQXNDOzs7QUFDOUIsU0FBYSxlQUFjLGVBQUksSUFBSSxjQUMzQztBQUFDO0FBUUc7Ozs7Ozs7Ozs7Ozs7Ozs7O2lEQUFjLFFBQ2pCOzs7Ozs7Ozs7Ozs7OztBQVVlOzs7Ozs7Ozs7Ozs7OztrREFBdUIsa0JBQXlCLG1CQUFrQixRQUMxRTs7Ozs7O29CQUFDLGVBQVksYUFBTyxPQUFpQixrQkFBRSxPQUN2Qzs7Ozs7c0JBQU0sSUFBSSxjQUFXLFlBRXJCOzs7b0JBQUMsZUFBWSxhQUFPLE9BQWtCLG1CQUFFLE9BQ3hDOzs7OztzQkFBTSxJQUFJLGNBQVcsWUFFckI7OztvQkFBQyxjQUFXLFlBQVEsUUFBTyxRQUFFLFNBQzdCOzs7OztzQkFBTSxJQUFJLGNBQVcsWUFFekI7OztzQkFBSSxDQUFDLGVBQVksYUFBVSxVQUFvQix1QkFBc0Isc0JBQ2pFOzs7OztzQkFBTSxJQUFJLGNBQVcsWUFHekI7OztBQUFpQiw4QkFJWjtBQUFLLG9CQUFJOzs7c0JBQUcsSUFBUyxPQUFPOzs7OztBQUNaLDhCQUFHLGNBQVcsWUFBVyxXQUFPLE9BQUssS0FFbEI7QUFDdUI7QUFDRDtBQUM5Qjs7QUFDakIsNEJBQW9CLHNCQUFHLGNBQVcsWUFBVyxXQUFLLEtBQWEsYUFBaUI7QUFDaEYsNEJBQThCLGdDQUFHLGNBQVcsWUFBVyxXQUFJO0FBQzNELDRCQUE4QixnQ0FBRyxjQUFXLFlBQVcsV0FBZ0IsZ0JBQXNCLHNCQUVwRDtBQUNFO0FBR3REOztxQkFBSSxlQUFZLGFBQVEsUUFFcEI7Ozs7O3NCQUFlLFlBQVUsVUFBVyxlQUFnQixZQUFhLGFBQzdEOzs7OztzQkFBTSxJQUFJLGNBQVcsWUFDeEI7OztBQUNVLDRCQUFpQixtQkFBb0I7QUFDckMsNEJBQWtCLG9CQUMxQjs7Ozs7QUFDUSw0QkFBaUIsbUJBQTJCO0FBQzVDLDRCQUFrQixvQkFHakM7OztBQUFlLDRCQUFjLFlBRTdCOzt1QkFBK0IsS0FBVSxVQUFVLFdBQXNCOzs7QUFBcEQ7QUFFViw0QkFBTSxRQUFHLE1BQUcsSUFBVyxXQUFhLGFBQUksSUFBQyxjQUFXLFlBQU8sU0FBRyxNQUFHLElBQU8sUUFBRSxNQUFHLElBQVUsVUFHbEc7O0FBQXVCLG9DQUFHLGNBQVcsWUFBVyxXQUFlO0FBQ3hDLDBDQUFHLG9CQUFpQixrQkFBSyxLQUFvQjtBQUV6RCw0QkFBSyxLQUdwQjs7O0FBdkNJOzs7Ozs4REF1Q3dCLFVBQUk7QUFBZSx5QkFBWSxZQUM5RDtpQkFEcUI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXpGbkI7Ozs7O0FBQ29CLGdCQUFtQixzQkFBVyxDQUFLLEtBQUksSUFBRSxHQUFLLE1BQUssS0FBSztBQUpuRiwwQkFzR0MsZ0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZIRCx5Q0FBeUU7O0FBQ3pFLHlDQUF5RTs7QUFDekUsd0NBQW1EO0FBT25EOzs7Ozs7Ozs7QUFnQk87Ozs7QUFDSDtRQUFZLDZFQUFxQixLQUFpQjs7OztBQUMxQyxTQUFnQixrQkFDeEI7QUFBQztBQU9pQjs7Ozs7Ozs7O2dDQUFhO0FBQzNCLGNBQWM7QUFDVixhQUF3QjtBQUFDO0FBQ3JCLG1CQUFXLEtBQWlCO0FBQy9COztBQUNELGFBQW1CO0FBQ25CLGFBQW1CO0FBQ25CO0FBQ0ksbUJBQVcsS0FBTztBQUNyQjs7QUFDTztBQUFDLGdCQUFNLElBQUksY0FBWSxpREFFdkM7O0FBQUM7QUFNYzs7Ozs7Ozs7QUFDWCxhQUFXLEtBQ2Y7QUFBQztBQU1nQjs7Ozs7OzsrQkFBa0I7QUFDL0IsVUFBUyxPQUFFO0FBQ0gsYUFBTyxTQUFTO0FBQ3ZCLGFBQU07QUFDQyxhQUFPLFNBQUcsSUFBYSxVQUFLLEtBQWU7QUFFdkQ7QUFBQztBQUtXOzs7Ozs7O0FBQ0osV0FDUjtBQUFDO0FBUVk7Ozs7Ozs7OzsyQkFBaUIsT0FBZ0IsUUFBZ0I7QUFDMUQsVUFBSSxDQUFDLGVBQVksYUFBTyxPQUFNLE9BQVksY0FBUyxNQUFPLFdBQU0sR0FBRTtBQUM5RCxjQUFNLElBQUksY0FBVyxZQUF3QztBQUNoRTs7QUFDRCxVQUFJLENBQUMsZUFBWSxhQUFVLFVBQVEsV0FBVSxTQUFJLEdBQUU7QUFDL0MsY0FBTSxJQUFJLGNBQVcsWUFBaUM7QUFDekQ7O0FBQ0QsVUFBSSxDQUFDLGVBQVksYUFBVSxVQUFRLFdBQVUsU0FBSSxHQUFFO0FBQy9DLGNBQU0sSUFBSSxjQUFXLFlBQWlDO0FBQ3pEOztBQUNELFVBQVUsU0FBUyxTQUFRLE1BQU8sUUFBRTtBQUNoQyxjQUFNLElBQUksY0FBVyxZQUEwRDtBQUNsRjs7QUFFRCxVQUFlLGNBQVU7QUFDekIsVUFBZSxjQUFVOztBQUV6QixTQUFHO0FBQ0MsWUFBSyxJQUFLO0FBQ1YsWUFBVyxRQUFjLGNBQU8sS0FBYyxjQUFjLGNBQUssS0FBYTs7QUFFOUUsZUFBUSxJQUFRLE9BQUU7QUFDVixlQUFPLE9BQUssT0FBUSxNQUFnQjtBQUMzQzs7QUFFRyxhQUFhO0FBRU4sdUJBQVEsS0FBYTtBQUNuQyxlQUFtQixjQUN4QjtBQUFDO0FBUWE7Ozs7Ozs7Ozs0QkFBaUIsT0FBZ0IsUUFBZ0I7QUFDM0QsVUFBSSxDQUFDLGVBQVksYUFBTyxPQUFNLE9BQVksY0FBUyxNQUFPLFdBQU0sR0FBRTtBQUM5RCxjQUFNLElBQUksY0FBVyxZQUF3QztBQUNoRTs7QUFDRCxVQUFJLENBQUMsZUFBWSxhQUFVLFVBQVEsV0FBVSxTQUFJLEdBQUU7QUFDL0MsY0FBTSxJQUFJLGNBQVcsWUFBaUM7QUFDekQ7O0FBQ0QsVUFBSSxDQUFDLGVBQVksYUFBVSxVQUFRLFdBQVUsU0FBSSxHQUFFO0FBQy9DLGNBQU0sSUFBSSxjQUFXLFlBQWlDO0FBQ3pEOztBQUNELFVBQVUsU0FBUyxTQUFRLE1BQU8sUUFBRTtBQUNoQyxjQUFNLElBQUksY0FBVyxZQUEwRDtBQUNsRjs7QUFFRCxVQUFlLGNBQVU7QUFDekIsVUFBZSxjQUFVOztBQUV6QixTQUFHO0FBRUMsWUFBSyxJQUFLO0FBQ1YsWUFBVyxRQUFjLGNBQU8sS0FBYyxjQUFTLFNBQUssS0FBYTs7QUFFekUsZUFBUSxJQUFRLE9BQUU7QUFDVCxnQkFBZSxpQkFBTyxLQUFPLE9BQU07QUFDM0M7O0FBRUcsYUFBYTtBQUVOLHVCQUFRLEtBQWE7QUFDbkMsZUFBbUIsY0FDeEI7QUFBQztBQU1nQjs7Ozs7Ozs7QUFDYixVQUF5QjtBQUN6QixVQUFTLFFBQUs7O0FBRWQsV0FBSyxJQUFTLFFBQUksR0FBTyxRQUFPLEtBQWdCLGlCQUFTLFNBQUU7QUFDOUMsb0JBQUcsSUFBYSxVQUFLLEtBQU8sT0FBVTs7QUFFL0MsYUFBSyxJQUFLLElBQUksR0FBRyxJQUFPLEtBQWEsY0FBSyxLQUFFO0FBRXBDLGVBQU8sT0FBRyxLQUFPLEtBQVksWUFBVSxVQUFVLFVBQVUsVUFBVSxTQUFNLFFBQVEsTUFBTSxNQUFDLENBQU0sUUFBTSxLQUFNO0FBQ25IO0FBRVQ7QUFBQzs7Ozs7O0FBN0pzQixLQUFXLGNBQWU7QUFDMUIsS0FBZ0IsbUJBQWM7QUFDOUIsS0FBWSxlQUFlLEtBQVksY0FBSztBQUVwRDs7QUFDUyxLQUFXLGNBQWMsSUFBYSxVQUFDLENBQUUsR0FBRyxHQUFFLENBQUUsR0FBRyxHQUFHLEdBQUUsQ0FBRSxHQUFHLEdBQUcsR0FBRSxDQUFFLEdBQUcsR0FBTTtBQU56RyxlQStKQyxLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4S0QseUNBQXlFOztBQUN6RSx5Q0FBeUU7O0FBQ3pFLGlDQUF1Qzs7QUFDdkMsd0NBQW1EOztBQUNuRCw2Q0FBK0Q7QUFPL0Q7Ozs7Ozs7OztBQWFPOzs7QUFDSDs7O0FBQ1EsU0FBUSxVQUFHLElBQUksT0FBSSxLQUFJLEtBQUUsT0FBSSxLQUFlLGdCQUNwRDtBQUFDO0FBT2lCOzs7Ozs7Ozs7Z0NBQWE7QUFDM0IsY0FBYztBQUNWLGFBQW1CO0FBQ25CLGFBQXVCO0FBQ3ZCLGFBQXVCO0FBQ3ZCO0FBQ0ksbUJBQVcsS0FBTztBQUNyQjs7QUFDTztBQUFDLGdCQUFNLElBQUksY0FBWSxpREFFdkM7O0FBQUM7QUFNYzs7Ozs7Ozs7QUFDWCxhQUNKO0FBQUM7QUFNZ0I7Ozs7Ozs7K0JBQWtCLE9BQ25DLENBQUM7QUFLVzs7Ozs7OztBQUNKLFdBQVEsUUFDaEI7QUFBQztBQVFZOzs7Ozs7Ozs7MkJBQWlCLE9BQWdCLFFBQWdCO0FBQzFELFVBQUksQ0FBQyxlQUFZLGFBQU8sT0FBTSxPQUFZLGNBQVMsTUFBTyxXQUFNLEdBQUU7QUFDOUQsY0FBTSxJQUFJLGNBQVcsWUFBd0M7QUFDaEU7O0FBQ0QsVUFBSSxDQUFDLGVBQVksYUFBVSxVQUFRLFdBQVUsU0FBSSxHQUFFO0FBQy9DLGNBQU0sSUFBSSxjQUFXLFlBQWlDO0FBQ3pEOztBQUNELFVBQUksQ0FBQyxlQUFZLGFBQVUsVUFBUSxXQUFVLFNBQUksR0FBRTtBQUMvQyxjQUFNLElBQUksY0FBVyxZQUFpQztBQUN6RDs7QUFDRCxVQUFVLFNBQVMsU0FBUSxNQUFPLFFBQUU7QUFDaEMsY0FBTSxJQUFJLGNBQVcsWUFBMEQ7QUFDbEY7O0FBQ0QsVUFBVSxTQUFNLFFBQU0sR0FBRTtBQUNwQixrQkFBVSxjQUFZLG1EQUFvQyxLQUFjO0FBQWM7QUFBWixTQUFwRTtBQUNUOztBQUVELFVBQWUsY0FBVTtBQUN6QixVQUFlLGNBQVU7O0FBRXpCLFNBQUc7QUFDQyxZQUFlLFlBQVEsTUFBTSxNQUFZLGFBQWEsY0FBTyxLQUFjO0FBRWxFLGtCQUFLLEtBQVksY0FBSyxLQUFLO0FBQ3BDLFlBQVksU0FBRyxtQkFBZ0IsaUJBQWtCLGtCQUFVLFdBQUcsR0FBVyxVQUFTO0FBQ2xGLFlBQWUsWUFBRyxJQUFlLFlBQUssS0FBbUI7QUFDekQsMkJBQWdCLGlCQUFrQixrQkFBTyxRQUFXLFdBQUs7O0FBRXJELGFBQVEsUUFBTyxPQUFZOztBQUVwQix1QkFBUSxLQUFhO0FBQ3JCLHVCQUFRLEtBQWE7QUFDbkMsZUFBbUIsY0FDeEI7QUFBQztBQVFhOzs7Ozs7Ozs7NEJBQWlCLE9BQWdCLFFBQWdCO0FBQzNELFVBQUksQ0FBQyxlQUFZLGFBQU8sT0FBTSxPQUFZLGNBQVMsTUFBTyxXQUFNLEdBQUU7QUFDOUQsY0FBTSxJQUFJLGNBQVcsWUFBd0M7QUFDaEU7O0FBQ0QsVUFBSSxDQUFDLGVBQVksYUFBVSxVQUFRLFdBQVUsU0FBSSxHQUFFO0FBQy9DLGNBQU0sSUFBSSxjQUFXLFlBQWlDO0FBQ3pEOztBQUNELFVBQUksQ0FBQyxlQUFZLGFBQVUsVUFBUSxXQUFVLFNBQUksR0FBRTtBQUMvQyxjQUFNLElBQUksY0FBVyxZQUFpQztBQUN6RDs7QUFDRCxVQUFVLFNBQVMsU0FBUSxNQUFPLFFBQUU7QUFDaEMsY0FBTSxJQUFJLGNBQVcsWUFBMEQ7QUFDbEY7O0FBQ0QsVUFBVSxTQUFNLFFBQU0sR0FBRTtBQUNwQixrQkFBVSxjQUFZLG1EQUFvQyxLQUFjO0FBQWM7QUFBWixTQUFwRTtBQUNUOztBQUVELFVBQWUsY0FBVTtBQUN6QixVQUFlLGNBQVU7O0FBRXpCLFNBQUc7QUFDQyxZQUFxQixrQkFBTyxLQUFRLFFBQVU7O0FBRTlDLFlBQVksU0FBRyxtQkFBZ0IsaUJBQWtCLGtCQUFnQixpQkFBRyxHQUFNLEtBQW1CO0FBRTdGLFlBQWUsWUFBYyxJQUFhLFVBQUssS0FBYztBQUM3RCwyQkFBZ0IsaUJBQWtCLGtCQUFPLFFBQVcsV0FBRyxHQUFNLEtBQWM7QUFFbEUsa0JBQUssS0FBWSxjQUFLLEtBQUs7QUFFcEMsWUFBSyxJQUFLOztBQUNWLGVBQVEsSUFBTyxLQUFZLGFBQUU7QUFDcEIsZ0JBQWUsaUJBQVksVUFBTTtBQUN6Qzs7QUFFRCxZQUFRLEtBQUcsSUFBWSxTQUFrQjs7QUFDekMsYUFBTSxJQUFJLEdBQUcsSUFBSyxHQUFXLFlBQUssS0FBRTtBQUM5QixhQUFTLFNBQUUsR0FBSSxHQUFTLFNBQUcsS0FBUztBQUN6Qzs7QUFFRyxhQUFRLFFBQU8sT0FBa0I7O0FBRTFCLHVCQUFRLEtBQWE7QUFDbkMsZUFBbUIsY0FDeEI7QUFBQzs7Ozs7QUFuSmM7OztBQUNTLEtBQVcsY0FBZTtBQUNuQzs7QUFDUyxLQUFlLGtCQUFlO0FBQ3ZDOztBQUNTLEtBQWdCLG1CQUFlLEtBQWdCLGtCQUFLO0FBTmhGLGVBcUpDLEs7Ozs7Ozs7Ozs7O0FDaEtEOzs7Ozs7Ozs7Ozs7OENDQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsWUFBWTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0EsaUNBQWlDLHVCQUF1QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNB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RztBQUNIO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLEtBQUs7QUFDTCxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7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QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsS0FBSztBQUNMLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7Ozs7Ozs7Ozs7OztBQ3R0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3JCQSxJQUFJQSxTQUFTLGdCQUFTQSxPQUFULEVBQWlCO0FBQzVCQSxZQUFTQSxXQUFVLEVBQW5CLENBRDRCLENBRzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLE1BQUlBLFVBQVMsT0FBT0EsT0FBUCxLQUFrQixXQUFsQixHQUFnQ0EsT0FBaEMsR0FBeUMsRUFBdEQsQ0FoQjhCLENBa0I5QjtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxNQUFJQyxrQkFBa0IsRUFBdEI7QUFDQSxNQUFJQyxHQUFKOztBQUNBLE9BQUtBLEdBQUwsSUFBWUYsT0FBWixFQUFvQjtBQUNsQixRQUFJQSxRQUFPRyxjQUFQLENBQXNCRCxHQUF0QixDQUFKLEVBQWdDO0FBQzlCRCxzQkFBZ0JDLEdBQWhCLElBQXVCRixRQUFPRSxHQUFQLENBQXZCO0FBQ0Q7QUFDRjs7QUFFREYsVUFBTyxXQUFQLElBQXNCLEVBQXRCO0FBQ0FBLFVBQU8sYUFBUCxJQUF3QixnQkFBeEI7O0FBQ0FBLFVBQU8sTUFBUCxJQUFpQixVQUFTSSxNQUFULEVBQWlCQyxPQUFqQixFQUEwQjtBQUN6QyxVQUFNQSxPQUFOO0FBQ0QsR0FGRDs7QUFHQUwsVUFBTyxRQUFQLElBQW1CLEVBQW5CO0FBQ0FBLFVBQU8sU0FBUCxJQUFvQixFQUFwQixDQXpDOEIsQ0EyQzlCO0FBQ0E7O0FBQ0EsTUFBSU0scUJBQXFCLEtBQXpCO0FBQ0EsTUFBSUMsd0JBQXdCLEtBQTVCO0FBQ0EsTUFBSUMsc0JBQXNCLEtBQTFCO0FBQ0EsTUFBSUMsdUJBQXVCLEtBQTNCLENBaEQ4QixDQWtEOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBSVQsUUFBTyxhQUFQLENBQUosRUFBMkI7QUFDekIsUUFBSUEsUUFBTyxhQUFQLE1BQTBCLEtBQTlCLEVBQXFDO0FBQ25DTSwyQkFBcUIsSUFBckI7QUFDRCxLQUZELE1BRU8sSUFBSU4sUUFBTyxhQUFQLE1BQTBCLFFBQTlCLEVBQXdDO0FBQzdDTyw4QkFBd0IsSUFBeEI7QUFDRCxLQUZNLE1BRUEsSUFBSVAsUUFBTyxhQUFQLE1BQTBCLE1BQTlCLEVBQXNDO0FBQzNDUSw0QkFBc0IsSUFBdEI7QUFDRCxLQUZNLE1BRUEsSUFBSVIsUUFBTyxhQUFQLE1BQTBCLE9BQTlCLEVBQXVDO0FBQzVDUyw2QkFBdUIsSUFBdkI7QUFDRCxLQUZNLE1BRUE7QUFDTCxZQUFNLElBQUlDLEtBQUosQ0FBVSxvRkFBVixDQUFOO0FBQ0Q7QUFDRixHQVpELE1BWU87QUFDTEoseUJBQXFCLFFBQU9LLE1BQVAseUNBQU9BLE1BQVAsT0FBa0IsUUFBdkM7QUFDQUosNEJBQXdCLE9BQU9LLGFBQVAsS0FBeUIsVUFBakQ7QUFDQUosMEJBQXNCLFFBQU9LLE9BQVAseUNBQU9BLE9BQVAsT0FBbUIsUUFBbkIsSUFBK0IsZUFBbUIsVUFBbEQsSUFBZ0UsQ0FBQ1Asa0JBQWpFLElBQXVGLENBQUNDLHFCQUE5RztBQUNBRSwyQkFBdUIsQ0FBQ0gsa0JBQUQsSUFBdUIsQ0FBQ0UsbUJBQXhCLElBQStDLENBQUNELHFCQUF2RTtBQUNEOztBQUdELE1BQUlDLG1CQUFKLEVBQXlCO0FBQ3ZCO0FBQ0E7QUFDQSxRQUFJTSxNQUFKO0FBQ0EsUUFBSUMsUUFBSjs7QUFFQWYsWUFBTyxNQUFQLElBQWlCLFNBQVNnQixVQUFULENBQW9CQyxRQUFwQixFQUE4QkMsTUFBOUIsRUFBc0M7QUFDckQsVUFBSUMsR0FBSjtBQUNBQSxZQUFNQyxrQkFBa0JILFFBQWxCLENBQU47O0FBQ0EsVUFBSSxDQUFDRSxHQUFMLEVBQVU7QUFDUixZQUFJLENBQUNMLE1BQUwsRUFBYUEsU0FBUyxtQkFBQU8sQ0FBUSwwREFBUixDQUFUO0FBQ2IsWUFBSSxDQUFDTixRQUFMLEVBQWVBLFdBQVcsbUJBQUFNLENBQVEsNERBQVIsQ0FBWDtBQUNmSixtQkFBV0YsU0FBUyxXQUFULEVBQXNCRSxRQUF0QixDQUFYO0FBQ0FFLGNBQU1MLE9BQU8sY0FBUCxFQUF1QkcsUUFBdkIsQ0FBTjtBQUNEOztBQUNELGFBQU9DLFNBQVNDLEdBQVQsR0FBZUEsSUFBSUcsUUFBSixFQUF0QjtBQUNELEtBVkQ7O0FBWUF0QixZQUFPLFlBQVAsSUFBdUIsU0FBU3VCLFVBQVQsQ0FBb0JOLFFBQXBCLEVBQThCO0FBQ25ELFVBQUlFLE1BQU1uQixRQUFPLE1BQVAsRUFBZWlCLFFBQWYsRUFBeUIsSUFBekIsQ0FBVjs7QUFDQSxVQUFJLENBQUNFLElBQUlLLE1BQVQsRUFBaUI7QUFDZkwsY0FBTSxJQUFJTSxVQUFKLENBQWVOLEdBQWYsQ0FBTjtBQUNEOztBQUNETyxhQUFPUCxJQUFJSyxNQUFYO0FBQ0EsYUFBT0wsR0FBUDtBQUNELEtBUEQ7O0FBU0EsUUFBSU4sUUFBUSxNQUFSLEVBQWdCYyxNQUFoQixHQUF5QixDQUE3QixFQUFnQztBQUM5QjNCLGNBQU8sYUFBUCxJQUF3QmEsUUFBUSxNQUFSLEVBQWdCLENBQWhCLEVBQW1CZSxPQUFuQixDQUEyQixLQUEzQixFQUFrQyxHQUFsQyxDQUF4QjtBQUNEOztBQUVENUIsWUFBTyxXQUFQLElBQXNCYSxRQUFRLE1BQVIsRUFBZ0JnQixLQUFoQixDQUFzQixDQUF0QixDQUF0QixDQS9CdUIsQ0FpQ3ZCOztBQUVBaEIsWUFBUSxJQUFSLEVBQWMsbUJBQWQsRUFBbUMsVUFBU2lCLEVBQVQsRUFBYTtBQUM5QztBQUNBLFVBQUksRUFBRUEsY0FBY0MsVUFBaEIsQ0FBSixFQUFpQztBQUMvQixjQUFNRCxFQUFOO0FBQ0Q7QUFDRixLQUxELEVBbkN1QixDQXlDdkI7QUFDQTs7QUFDQWpCLFlBQVEsSUFBUixFQUFjLG9CQUFkLEVBQW9DLFVBQVNtQixNQUFULEVBQWlCQyxDQUFqQixFQUFvQjtBQUN0RGpDLGNBQU8sVUFBUCxFQUFtQixvREFBbkI7O0FBQ0FhLGNBQVEsTUFBUixFQUFnQixDQUFoQjtBQUNELEtBSEQ7O0FBS0FiLFlBQU8sU0FBUCxJQUFvQixZQUFZO0FBQUUsYUFBTyw0QkFBUDtBQUFzQyxLQUF4RTtBQUNELEdBakRELE1Ba0RLLElBQUlTLG9CQUFKLEVBQTBCO0FBQzdCLFFBQUksT0FBT3lCLElBQVAsSUFBZSxXQUFuQixFQUFnQztBQUM5QmxDLGNBQU8sTUFBUCxJQUFpQixTQUFTZ0IsVUFBVCxDQUFvQm1CLENBQXBCLEVBQXVCO0FBQ3RDLFlBQUlDLE9BQU9oQixrQkFBa0JlLENBQWxCLENBQVg7O0FBQ0EsWUFBSUMsSUFBSixFQUFVO0FBQ1IsaUJBQU9DLGlCQUFpQkQsSUFBakIsQ0FBUDtBQUNEOztBQUNELGVBQU9GLEtBQUtDLENBQUwsQ0FBUDtBQUNELE9BTkQ7QUFPRDs7QUFFRG5DLFlBQU8sWUFBUCxJQUF1QixTQUFTdUIsVUFBVCxDQUFvQlksQ0FBcEIsRUFBdUI7QUFDNUMsVUFBSUMsSUFBSjtBQUNBQSxhQUFPaEIsa0JBQWtCZSxDQUFsQixDQUFQOztBQUNBLFVBQUlDLElBQUosRUFBVTtBQUNSLGVBQU9BLElBQVA7QUFDRDs7QUFDRCxVQUFJLE9BQU9FLFVBQVAsS0FBc0IsVUFBMUIsRUFBc0M7QUFDcEMsZUFBTyxJQUFJYixVQUFKLENBQWVhLFdBQVdILENBQVgsQ0FBZixDQUFQO0FBQ0Q7O0FBQ0RDLGFBQU9GLEtBQUtDLENBQUwsRUFBUSxRQUFSLENBQVA7QUFDQVQsYUFBTyxRQUFPVSxJQUFQLE1BQWdCLFFBQXZCO0FBQ0EsYUFBT0EsSUFBUDtBQUNELEtBWkQ7O0FBY0EsUUFBSSxPQUFPRyxVQUFQLElBQXFCLFdBQXpCLEVBQXNDO0FBQ3BDdkMsY0FBTyxXQUFQLElBQXNCdUMsVUFBdEI7QUFDRCxLQUZELE1BRU8sSUFBSSxPQUFPQyxTQUFQLElBQW9CLFdBQXhCLEVBQXFDO0FBQzFDeEMsY0FBTyxXQUFQLElBQXNCd0MsU0FBdEI7QUFDRDs7QUFFRCxRQUFJLE9BQU9DLElBQVAsS0FBZ0IsVUFBcEIsRUFBZ0M7QUFDOUJ6QyxjQUFPLE1BQVAsSUFBaUIsVUFBU0ksTUFBVCxFQUFpQkMsT0FBakIsRUFBMEI7QUFDekNvQyxhQUFLckMsTUFBTDtBQUNELE9BRkQ7QUFHRDtBQUNGLEdBcENJLE1BcUNBLElBQUlFLHNCQUFzQkMscUJBQTFCLEVBQWlEO0FBQ3BEUCxZQUFPLE1BQVAsSUFBaUIsU0FBU2dCLFVBQVQsQ0FBb0IwQixHQUFwQixFQUF5QjtBQUN4QyxVQUFJO0FBQ0YsWUFBSUMsTUFBTSxJQUFJQyxjQUFKLEVBQVY7QUFDQUQsWUFBSUUsSUFBSixDQUFTLEtBQVQsRUFBZ0JILEdBQWhCLEVBQXFCLEtBQXJCO0FBQ0FDLFlBQUlHLElBQUosQ0FBUyxJQUFUO0FBQ0EsZUFBT0gsSUFBSUksWUFBWDtBQUNELE9BTEQsQ0FLRSxPQUFPQyxHQUFQLEVBQVk7QUFDWixZQUFJWixPQUFPaEIsa0JBQWtCc0IsR0FBbEIsQ0FBWDs7QUFDQSxZQUFJTixJQUFKLEVBQVU7QUFDUixpQkFBT0MsaUJBQWlCRCxJQUFqQixDQUFQO0FBQ0Q7O0FBQ0QsY0FBTVksR0FBTjtBQUNEO0FBQ0YsS0FiRDs7QUFlQSxRQUFJekMscUJBQUosRUFBMkI7QUFDekJQLGNBQU8sWUFBUCxJQUF1QixTQUFTdUIsVUFBVCxDQUFvQm1CLEdBQXBCLEVBQXlCO0FBQzlDLFlBQUk7QUFDRixjQUFJQyxNQUFNLElBQUlDLGNBQUosRUFBVjtBQUNBRCxjQUFJRSxJQUFKLENBQVMsS0FBVCxFQUFnQkgsR0FBaEIsRUFBcUIsS0FBckI7QUFDQUMsY0FBSU0sWUFBSixHQUFtQixhQUFuQjtBQUNBTixjQUFJRyxJQUFKLENBQVMsSUFBVDtBQUNBLGlCQUFPLElBQUlyQixVQUFKLENBQWVrQixJQUFJTyxRQUFuQixDQUFQO0FBQ0QsU0FORCxDQU1FLE9BQU9GLEdBQVAsRUFBWTtBQUNaLGNBQUlaLE9BQU9oQixrQkFBa0JzQixHQUFsQixDQUFYOztBQUNBLGNBQUlOLElBQUosRUFBVTtBQUNSLG1CQUFPQSxJQUFQO0FBQ0Q7O0FBQ0QsZ0JBQU1ZLEdBQU47QUFDRDtBQUNGLE9BZEQ7QUFlRDs7QUFFRGhELFlBQU8sV0FBUCxJQUFzQixTQUFTbUQsU0FBVCxDQUFtQlQsR0FBbkIsRUFBd0JVLE1BQXhCLEVBQWdDQyxPQUFoQyxFQUF5QztBQUM3RCxVQUFJVixNQUFNLElBQUlDLGNBQUosRUFBVjtBQUNBRCxVQUFJRSxJQUFKLENBQVMsS0FBVCxFQUFnQkgsR0FBaEIsRUFBcUIsSUFBckI7QUFDQUMsVUFBSU0sWUFBSixHQUFtQixhQUFuQjs7QUFDQU4sVUFBSVMsTUFBSixHQUFhLFNBQVNFLFVBQVQsR0FBc0I7QUFDakMsWUFBSVgsSUFBSXZDLE1BQUosSUFBYyxHQUFkLElBQXNCdUMsSUFBSXZDLE1BQUosSUFBYyxDQUFkLElBQW1CdUMsSUFBSU8sUUFBakQsRUFBNEQ7QUFBRTtBQUM1REUsaUJBQU9ULElBQUlPLFFBQVg7QUFDQTtBQUNEOztBQUNELFlBQUlkLE9BQU9oQixrQkFBa0JzQixHQUFsQixDQUFYOztBQUNBLFlBQUlOLElBQUosRUFBVTtBQUNSZ0IsaUJBQU9oQixLQUFLWixNQUFaO0FBQ0E7QUFDRDs7QUFDRDZCO0FBQ0QsT0FYRDs7QUFZQVYsVUFBSVUsT0FBSixHQUFjQSxPQUFkO0FBQ0FWLFVBQUlHLElBQUosQ0FBUyxJQUFUO0FBQ0QsS0FsQkQ7O0FBb0JBLFFBQUksT0FBT04sU0FBUCxJQUFvQixXQUF4QixFQUFxQztBQUNuQ3hDLGNBQU8sV0FBUCxJQUFzQndDLFNBQXRCO0FBQ0Q7O0FBRUR4QyxZQUFPLGdCQUFQLElBQTJCLFVBQVN1RCxLQUFULEVBQWdCO0FBQUVDLGVBQVNELEtBQVQsR0FBaUJBLEtBQWpCO0FBQXdCLEtBQXJFO0FBQ0QsR0EzREksTUE0REE7QUFDSDtBQUNBLFVBQU0sSUFBSTdDLEtBQUosQ0FBVSw2QkFBVixDQUFOO0FBQ0QsR0FqTzZCLENBbU85QjtBQUNBOzs7QUFDQVYsVUFBTyxPQUFQLElBQWtCLE9BQU95RCxPQUFQLEtBQW1CLFdBQW5CLEdBQWlDQSxRQUFRQyxHQUF6QyxHQUFnRCxPQUFPQyxLQUFQLEtBQWlCLFdBQWpCLEdBQStCQSxLQUEvQixHQUF1QyxJQUF6RztBQUNBM0QsVUFBTyxVQUFQLElBQXFCLE9BQU80RCxRQUFQLEtBQW9CLFdBQXBCLEdBQWtDQSxRQUFsQyxHQUErQyxPQUFPSCxPQUFQLEtBQW1CLFdBQW5CLElBQWtDQSxRQUFRSSxJQUEzQyxJQUFvRDdELFFBQU8sT0FBUCxDQUF2SCxDQXRPOEIsQ0F3TzlCO0FBRUE7O0FBQ0FBLFVBQU8yRCxLQUFQLEdBQWUzRCxRQUFPLE9BQVAsQ0FBZjtBQUNBQSxVQUFPNEQsUUFBUCxHQUFrQjVELFFBQU8sVUFBUCxDQUFsQixDQTVPOEIsQ0E4TzlCOztBQUNBLE9BQUtFLEdBQUwsSUFBWUQsZUFBWixFQUE2QjtBQUMzQixRQUFJQSxnQkFBZ0JFLGNBQWhCLENBQStCRCxHQUEvQixDQUFKLEVBQXlDO0FBQ3ZDRixjQUFPRSxHQUFQLElBQWNELGdCQUFnQkMsR0FBaEIsQ0FBZDtBQUNEO0FBQ0YsR0FuUDZCLENBb1A5QjtBQUNBOzs7QUFDQUQsb0JBQWtCNkQsU0FBbEIsQ0F0UDhCLENBMFA5Qjs7QUFFQSxNQUFJQyxjQUFjLEVBQWxCLENBNVA4QixDQThQOUI7QUFDQTs7QUFDQUMsZUFBWUMsZ0JBQWVDLGFBQWFDLGNBQWNDLGNBQWMsdUJBQVc7QUFDN0VDLFVBQU0sMEZBQU47QUFDRCxHQUZEOztBQUlBLFdBQVNDLFdBQVQsQ0FBcUJDLElBQXJCLEVBQTJCO0FBQ3pCN0MsV0FBTyxDQUFDOEMsWUFBUjtBQUNBLFFBQUlyRCxNQUFNc0QsU0FBVjtBQUNBQSxnQkFBYUEsWUFBWUYsSUFBWixHQUFtQixFQUFwQixHQUEwQixDQUFDLEVBQXZDO0FBQ0EsV0FBT3BELEdBQVA7QUFDRDs7QUFFRCxXQUFTdUQsWUFBVCxDQUFzQkgsSUFBdEIsRUFBNEI7QUFDMUI3QyxXQUFPaUQsY0FBUDtBQUNBLFFBQUl4RCxNQUFNeUQsT0FBT0Qsa0JBQWdCLENBQXZCLENBQVY7QUFDQSxRQUFJRSxNQUFPMUQsTUFBTW9ELElBQU4sR0FBYSxFQUFkLEdBQW9CLENBQUMsRUFBL0I7QUFDQUssV0FBT0Qsa0JBQWdCLENBQXZCLElBQTRCRSxHQUE1Qjs7QUFDQSxRQUFJQSxPQUFPQyxZQUFYLEVBQXlCO0FBQ3ZCLFVBQUlDLFVBQVVDLGVBQWQ7O0FBQ0EsVUFBSSxDQUFDRCxPQUFMLEVBQWM7QUFDWkgsZUFBT0Qsa0JBQWdCLENBQXZCLElBQTRCeEQsR0FBNUI7QUFDQSxlQUFPLENBQVA7QUFDRDtBQUNGOztBQUNELFdBQU9BLEdBQVA7QUFDRDs7QUFFRCxXQUFTOEQsV0FBVCxDQUFxQlYsSUFBckIsRUFBMkJXLE1BQTNCLEVBQW1DO0FBQ2pDLFFBQUksQ0FBQ0EsTUFBTCxFQUFhQSxTQUFTbkIsV0FBVCxDQURvQixDQUNFOztBQUNuQyxRQUFJNUMsTUFBTW9ELE9BQU9ZLEtBQUtDLElBQUwsQ0FBVWIsT0FBT1csTUFBakIsSUFBMkJBLE1BQTVDO0FBQ0EsV0FBTy9ELEdBQVA7QUFDRDs7QUFFRCxXQUFTa0UsaUJBQVQsQ0FBMkJDLElBQTNCLEVBQWlDO0FBQy9CLFlBQVFBLElBQVI7QUFDRSxXQUFLLElBQUw7QUFBVyxXQUFLLElBQUw7QUFBVyxlQUFPLENBQVA7O0FBQ3RCLFdBQUssS0FBTDtBQUFZLGVBQU8sQ0FBUDs7QUFDWixXQUFLLEtBQUw7QUFBWSxlQUFPLENBQVA7O0FBQ1osV0FBSyxLQUFMO0FBQVksZUFBTyxDQUFQOztBQUNaLFdBQUssT0FBTDtBQUFjLGVBQU8sQ0FBUDs7QUFDZCxXQUFLLFFBQUw7QUFBZSxlQUFPLENBQVA7O0FBQ2Y7QUFBUztBQUNQLGNBQUlBLEtBQUtBLEtBQUszRCxNQUFMLEdBQVksQ0FBakIsTUFBd0IsR0FBNUIsRUFBaUM7QUFDL0IsbUJBQU8sQ0FBUCxDQUQrQixDQUNyQjtBQUNYLFdBRkQsTUFFTyxJQUFJMkQsS0FBSyxDQUFMLE1BQVksR0FBaEIsRUFBcUI7QUFDMUIsZ0JBQUlDLE9BQU9DLFNBQVNGLEtBQUtHLE1BQUwsQ0FBWSxDQUFaLENBQVQsQ0FBWDtBQUNBL0QsbUJBQU82RCxPQUFPLENBQVAsS0FBYSxDQUFwQjtBQUNBLG1CQUFPQSxPQUFPLENBQWQ7QUFDRCxXQUpNLE1BSUE7QUFDTCxtQkFBTyxDQUFQO0FBQ0Q7QUFDRjtBQWpCSDtBQW1CRDs7QUFFRCxXQUFTRyxRQUFULENBQWtCQyxJQUFsQixFQUF3QjtBQUN0QixRQUFJLENBQUNELFNBQVNFLEtBQWQsRUFBcUJGLFNBQVNFLEtBQVQsR0FBaUIsRUFBakI7O0FBQ3JCLFFBQUksQ0FBQ0YsU0FBU0UsS0FBVCxDQUFlRCxJQUFmLENBQUwsRUFBMkI7QUFDekJELGVBQVNFLEtBQVQsQ0FBZUQsSUFBZixJQUF1QixDQUF2Qjs7QUFDQTNGLGNBQU80RCxRQUFQLENBQWdCK0IsSUFBaEI7QUFDRDtBQUNGOztBQUlELE1BQUlFLG1CQUFtQixJQUFJQyxLQUFKLENBQVUsQ0FBVixDQUF2Qjs7QUFFQSxXQUFTQyxXQUFULENBQXFCQyxJQUFyQixFQUEyQjtBQUN6QixTQUFLLElBQUlDLElBQUksQ0FBYixFQUFnQkEsSUFBSUosaUJBQWlCbEUsTUFBckMsRUFBNkNzRSxHQUE3QyxFQUFrRDtBQUNoRCxVQUFJLENBQUNKLGlCQUFpQkksQ0FBakIsQ0FBTCxFQUEwQjtBQUN4QkoseUJBQWlCSSxDQUFqQixJQUFzQkQsSUFBdEI7QUFDQSxlQUFPLElBQUlDLENBQVg7QUFDRDtBQUNGOztBQUNELFVBQU0sZ0dBQU47QUFDRDs7QUFFRCxXQUFTQyxjQUFULENBQXdCQyxLQUF4QixFQUErQjtBQUM3Qk4scUJBQWlCTSxRQUFNLENBQXZCLElBQTRCLElBQTVCO0FBQ0Q7O0FBRUQsTUFBSUMsZUFBZSxFQUFuQjs7QUFFQSxXQUFTQyxjQUFULENBQXdCTCxJQUF4QixFQUE4Qk0sR0FBOUIsRUFBbUM7QUFDakMsUUFBSSxDQUFDTixJQUFMLEVBQVcsT0FEc0IsQ0FDZDs7QUFDbkJ0RSxXQUFPNEUsR0FBUDs7QUFDQSxRQUFJLENBQUNGLGFBQWFFLEdBQWIsQ0FBTCxFQUF3QjtBQUN0QkYsbUJBQWFFLEdBQWIsSUFBb0IsRUFBcEI7QUFDRDs7QUFDRCxRQUFJQyxXQUFXSCxhQUFhRSxHQUFiLENBQWY7O0FBQ0EsUUFBSSxDQUFDQyxTQUFTUCxJQUFULENBQUwsRUFBcUI7QUFDbkI7QUFDQSxVQUFJTSxJQUFJM0UsTUFBSixLQUFlLENBQW5CLEVBQXNCO0FBQ3BCNEUsaUJBQVNQLElBQVQsSUFBaUIsU0FBU1EsZUFBVCxHQUEyQjtBQUMxQyxpQkFBT0MsUUFBUUgsR0FBUixFQUFhTixJQUFiLENBQVA7QUFDRCxTQUZEO0FBR0QsT0FKRCxNQUlPLElBQUlNLElBQUkzRSxNQUFKLEtBQWUsQ0FBbkIsRUFBc0I7QUFDM0I0RSxpQkFBU1AsSUFBVCxJQUFpQixTQUFTUSxlQUFULENBQXlCRSxHQUF6QixFQUE4QjtBQUM3QyxpQkFBT0QsUUFBUUgsR0FBUixFQUFhTixJQUFiLEVBQW1CLENBQUNVLEdBQUQsQ0FBbkIsQ0FBUDtBQUNELFNBRkQ7QUFHRCxPQUpNLE1BSUE7QUFDTDtBQUNBSCxpQkFBU1AsSUFBVCxJQUFpQixTQUFTUSxlQUFULEdBQTJCO0FBQzFDLGlCQUFPQyxRQUFRSCxHQUFSLEVBQWFOLElBQWIsRUFBbUJGLE1BQU1hLFNBQU4sQ0FBZ0I5RSxLQUFoQixDQUFzQitFLElBQXRCLENBQTJCcEUsU0FBM0IsQ0FBbkIsQ0FBUDtBQUNELFNBRkQ7QUFHRDtBQUNGOztBQUNELFdBQU8rRCxTQUFTUCxJQUFULENBQVA7QUFDRDs7QUFHRCxXQUFTYSxVQUFULENBQW9CQyxHQUFwQixFQUF5QkMsSUFBekIsRUFBK0JDLFFBQS9CLEVBQXlDO0FBQ3ZDLFdBQU9BLFdBQWEsRUFBR0YsUUFBTSxDQUFULENBQUQsR0FBaUIsRUFBR0MsU0FBTyxDQUFWLENBQUQsR0FBZ0IsWUFBNUMsR0FBK0QsRUFBR0QsUUFBTSxDQUFULENBQUQsR0FBaUIsRUFBR0MsT0FBSyxDQUFSLENBQUQsR0FBYyxZQUFuRztBQUNEOztBQUVELFdBQVNOLE9BQVQsQ0FBaUJILEdBQWpCLEVBQXNCVyxHQUF0QixFQUEyQkMsSUFBM0IsRUFBaUM7QUFDL0IsUUFBSUEsUUFBUUEsS0FBS3ZGLE1BQWpCLEVBQXlCO0FBQ3ZCRCxhQUFPd0YsS0FBS3ZGLE1BQUwsSUFBZTJFLElBQUkzRSxNQUFKLEdBQVcsQ0FBakM7QUFDQUQsYUFBUSxhQUFhNEUsR0FBZCxJQUFzQnRHLE9BQTdCLEVBQXFDLG9EQUFvRHNHLEdBQXBELEdBQTBELElBQS9GO0FBQ0EsYUFBT3RHLFFBQU8sYUFBYXNHLEdBQXBCLEVBQXlCYSxLQUF6QixDQUErQixJQUEvQixFQUFxQyxDQUFDRixHQUFELEVBQU1HLE1BQU4sQ0FBYUYsSUFBYixDQUFyQyxDQUFQO0FBQ0QsS0FKRCxNQUlPO0FBQ0x4RixhQUFPNEUsSUFBSTNFLE1BQUosSUFBYyxDQUFyQjtBQUNBRCxhQUFRLGFBQWE0RSxHQUFkLElBQXNCdEcsT0FBN0IsRUFBcUMsb0RBQW9Ec0csR0FBcEQsR0FBMEQsSUFBL0Y7QUFDQSxhQUFPdEcsUUFBTyxhQUFhc0csR0FBcEIsRUFBeUJNLElBQXpCLENBQThCLElBQTlCLEVBQW9DSyxHQUFwQyxDQUFQO0FBQ0Q7QUFDRjs7QUFHRCxXQUFTSSxrQkFBVCxDQUE0QkMsSUFBNUIsRUFBa0M7QUFDaEMsVUFBTSxxSEFBTjtBQUNEOztBQUVELE1BQUlDLFVBQVU7QUFDWjtBQUNBO0FBQ0E7QUFDQWQsYUFBU0EsT0FKRztBQUlNO0FBQ2xCO0FBQ0FyQyxpQkFBYSx1QkFBVztBQUFFQyxZQUFNLGlHQUFOO0FBQTBHLEtBTnhIO0FBT1pDLGlCQUFhLHVCQUFXO0FBQUVELFlBQU0saUdBQU47QUFBMEcsS0FQeEg7QUFRWkgsZ0JBQVksc0JBQVc7QUFBRUcsWUFBTSxnR0FBTjtBQUF5RztBQVJ0SCxHQUFkLENBblk4QixDQThZOUI7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsTUFBSW1ELGNBQWMsSUFBbEIsQ0FsWjhCLENBc1o5QjtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBOztBQUVBLE1BQUlDLFFBQVEsQ0FBWixDQXRhOEIsQ0FzYWY7O0FBQ2YsTUFBSUMsYUFBYSxDQUFqQjtBQUVBOztBQUNBLFdBQVNoRyxNQUFULENBQWdCaUcsU0FBaEIsRUFBMkJoQyxJQUEzQixFQUFpQztBQUMvQixRQUFJLENBQUNnQyxTQUFMLEVBQWdCO0FBQ2R0RCxZQUFNLHVCQUF1QnNCLElBQTdCO0FBQ0Q7QUFDRjs7QUFFRCxNQUFJaUMsY0FBYyxJQUFsQixDQWhiOEIsQ0FrYjlCOztBQUNBLFdBQVNDLFFBQVQsQ0FBa0JDLEtBQWxCLEVBQXlCO0FBQ3ZCLFFBQUk5QixPQUFPaEcsUUFBTyxNQUFNOEgsS0FBYixDQUFYLENBRHVCLENBQ1M7O0FBQ2hDcEcsV0FBT3NFLElBQVAsRUFBYSxrQ0FBa0M4QixLQUFsQyxHQUEwQyw0QkFBdkQ7QUFDQSxXQUFPOUIsSUFBUDtBQUNEOztBQUVELE1BQUkrQixVQUFVO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsaUJBQWEscUJBQVc7QUFDdEIvRDtBQUNELEtBTlc7QUFPWixvQkFBZ0Isd0JBQVc7QUFDekJDO0FBQ0QsS0FUVztBQVVaO0FBQ0EsZ0JBQWEsa0JBQVMrRCxHQUFULEVBQWM7QUFDekIsVUFBSTdHLE1BQU0rQyxXQUFXOEQsSUFBSXJHLE1BQWYsQ0FBVjtBQUNBc0cseUJBQW1CRCxHQUFuQixFQUF3QjdHLEdBQXhCO0FBQ0EsYUFBT0EsR0FBUDtBQUNELEtBZlc7QUFnQlosaUJBQWMsbUJBQVMrRyxHQUFULEVBQWM7QUFDMUIsVUFBSS9HLE1BQU0sQ0FBVjs7QUFDQSxVQUFJK0csUUFBUSxJQUFSLElBQWdCQSxRQUFRcEUsU0FBeEIsSUFBcUNvRSxRQUFRLENBQWpELEVBQW9EO0FBQUU7QUFDcEQ7QUFDQSxZQUFJQyxNQUFNLENBQUNELElBQUl2RyxNQUFKLElBQWMsQ0FBZixJQUFvQixDQUE5QjtBQUNBUixjQUFNK0MsV0FBV2lFLEdBQVgsQ0FBTjtBQUNBQyxxQkFBYUYsR0FBYixFQUFrQi9HLEdBQWxCLEVBQXVCZ0gsR0FBdkI7QUFDRDs7QUFDRCxhQUFPaEgsR0FBUDtBQUNEO0FBekJXLEdBQWQsQ0F6YjhCLENBb2Q5Qjs7QUFDQSxNQUFJa0gsTUFBTTtBQUFDLGNBQVdOLFFBQVEsV0FBUixDQUFaO0FBQWtDLGFBQVVBLFFBQVEsVUFBUjtBQUE1QyxHQUFWLENBcmQ4QixDQXVkOUI7O0FBQ0EsV0FBU08sS0FBVCxDQUFnQlIsS0FBaEIsRUFBdUJTLFVBQXZCLEVBQW1DQyxRQUFuQyxFQUE2Q3RCLElBQTdDLEVBQW1EdUIsSUFBbkQsRUFBeUQ7QUFDdkQsUUFBSXpDLE9BQU82QixTQUFTQyxLQUFULENBQVg7QUFDQSxRQUFJWSxRQUFRLEVBQVo7QUFDQSxRQUFJQyxRQUFRLENBQVo7QUFDQWpILFdBQU82RyxlQUFlLE9BQXRCLEVBQStCLG9DQUEvQjs7QUFDQSxRQUFJckIsSUFBSixFQUFVO0FBQ1IsV0FBSyxJQUFJakIsSUFBSSxDQUFiLEVBQWdCQSxJQUFJaUIsS0FBS3ZGLE1BQXpCLEVBQWlDc0UsR0FBakMsRUFBc0M7QUFDcEMsWUFBSTJDLFlBQVlQLElBQUlHLFNBQVN2QyxDQUFULENBQUosQ0FBaEI7O0FBQ0EsWUFBSTJDLFNBQUosRUFBZTtBQUNiLGNBQUlELFVBQVUsQ0FBZCxFQUFpQkEsUUFBUTNFLFlBQVI7QUFDakIwRSxnQkFBTXpDLENBQU4sSUFBVzJDLFVBQVUxQixLQUFLakIsQ0FBTCxDQUFWLENBQVg7QUFDRCxTQUhELE1BR087QUFDTHlDLGdCQUFNekMsQ0FBTixJQUFXaUIsS0FBS2pCLENBQUwsQ0FBWDtBQUNEO0FBQ0Y7QUFDRjs7QUFDRCxRQUFJOUUsTUFBTTZFLEtBQUttQixLQUFMLENBQVcsSUFBWCxFQUFpQnVCLEtBQWpCLENBQVY7QUFDQSxRQUFJSCxlQUFlLFFBQW5CLEVBQTZCcEgsTUFBTTBILGtCQUFrQjFILEdBQWxCLENBQU47O0FBQzdCLFFBQUl3SCxVQUFVLENBQWQsRUFBaUI7QUFDZjFFLG9CQUFhMEUsS0FBYjtBQUNEOztBQUNELFdBQU94SCxHQUFQO0FBQ0Q7O0FBRUQsV0FBUzJILEtBQVQsQ0FBZ0JoQixLQUFoQixFQUF1QlMsVUFBdkIsRUFBbUNDLFFBQW5DLEVBQTZDO0FBQzNDQSxlQUFXQSxZQUFZLEVBQXZCO0FBQ0EsUUFBSU8sUUFBUWxCLFNBQVNDLEtBQVQsQ0FBWixDQUYyQyxDQUczQztBQUNBOztBQUNBLFFBQUlrQixjQUFjUixTQUFTUyxLQUFULENBQWUsVUFBUzNELElBQVQsRUFBYztBQUFFLGFBQU9BLFNBQVMsUUFBaEI7QUFBeUIsS0FBeEQsQ0FBbEI7QUFDQSxRQUFJNEQsYUFBYVgsZUFBZSxRQUFoQzs7QUFDQSxRQUFJVyxjQUFjRixXQUFsQixFQUErQjtBQUM3QixhQUFPRCxLQUFQO0FBQ0Q7O0FBQ0QsV0FBTyxZQUFXO0FBQ2hCLGFBQU9ULE1BQU1SLEtBQU4sRUFBYVMsVUFBYixFQUF5QkMsUUFBekIsRUFBbUNoRyxTQUFuQyxDQUFQO0FBQ0QsS0FGRDtBQUdEO0FBRUQ7OztBQUNBLFdBQVMyRyxRQUFULENBQWtCbEMsR0FBbEIsRUFBdUJtQyxLQUF2QixFQUE4QjlELElBQTlCLEVBQW9DK0QsTUFBcEMsRUFBNEM7QUFDMUMvRCxXQUFPQSxRQUFRLElBQWY7QUFDQSxRQUFJQSxLQUFLZ0UsTUFBTCxDQUFZaEUsS0FBSzNELE1BQUwsR0FBWSxDQUF4QixNQUErQixHQUFuQyxFQUF3QzJELE9BQU8sS0FBUCxDQUZFLENBRVk7O0FBQ3BELFlBQU9BLElBQVA7QUFDRSxXQUFLLElBQUw7QUFBV2lFLGNBQVF0QyxHQUFELElBQU8sQ0FBZCxJQUFrQm1DLEtBQWxCO0FBQXlCOztBQUNwQyxXQUFLLElBQUw7QUFBV0csY0FBUXRDLEdBQUQsSUFBTyxDQUFkLElBQWtCbUMsS0FBbEI7QUFBeUI7O0FBQ3BDLFdBQUssS0FBTDtBQUFZSSxlQUFTdkMsR0FBRCxJQUFPLENBQWYsSUFBbUJtQyxLQUFuQjtBQUEwQjs7QUFDdEMsV0FBSyxLQUFMO0FBQVl4RSxlQUFTcUMsR0FBRCxJQUFPLENBQWYsSUFBbUJtQyxLQUFuQjtBQUEwQjs7QUFDdEMsV0FBSyxLQUFMO0FBQWFLLGtCQUFVLENBQUNMLFVBQVEsQ0FBVCxHQUFZTSxhQUFXTixLQUFYLEVBQWtCLENBQUVPLFNBQVNELFVBQVQsQ0FBSCxJQUE2QixHQUE3QixHQUFvQ0EsYUFBYSxHQUFiLEdBQW1CLENBQUVFLFNBQVUsQ0FBRUMsV0FBWUgsVUFBRCxHQUFhLFlBQXhCLENBQVosRUFBcUQsWUFBckQsQ0FBRCxHQUFxRSxDQUF0RSxNQUEyRSxDQUE5RixHQUFtRyxDQUFDLENBQUcsQ0FBRUksVUFBVSxDQUFDSixhQUFhLEVBQUksQ0FBQyxDQUFFQSxVQUFMLEtBQXFCLENBQXZCLENBQWQsSUFBeUMsWUFBbkQsQ0FBUCxLQUE4RSxDQUFwTixHQUF5TixDQUF0UCxFQUFWLEVBQW9ROUUsT0FBU3FDLEdBQUQsSUFBTyxDQUFmLElBQW1Cd0MsUUFBUSxDQUFSLENBQXZSLEVBQWtTN0UsT0FBVXFDLEdBQUQsR0FBTyxDQUFSLElBQWEsQ0FBckIsSUFBeUJ3QyxRQUFRLENBQVIsQ0FBNVQ7QUFBeVU7O0FBQ3JWLFdBQUssT0FBTDtBQUFjTSxnQkFBVTlDLEdBQUQsSUFBTyxDQUFoQixJQUFvQm1DLEtBQXBCO0FBQTJCOztBQUN6QyxXQUFLLFFBQUw7QUFBZVksZ0JBQVUvQyxHQUFELElBQU8sQ0FBaEIsSUFBb0JtQyxLQUFwQjtBQUEyQjs7QUFDMUM7QUFBUy9FLGNBQU0sZ0NBQWdDaUIsSUFBdEM7QUFSWDtBQVVIO0FBRUQ7OztBQUNBLFdBQVMyRSxRQUFULENBQWtCaEQsR0FBbEIsRUFBdUIzQixJQUF2QixFQUE2QitELE1BQTdCLEVBQXFDO0FBQ25DL0QsV0FBT0EsUUFBUSxJQUFmO0FBQ0EsUUFBSUEsS0FBS2dFLE1BQUwsQ0FBWWhFLEtBQUszRCxNQUFMLEdBQVksQ0FBeEIsTUFBK0IsR0FBbkMsRUFBd0MyRCxPQUFPLEtBQVAsQ0FGTCxDQUVtQjs7QUFDcEQsWUFBT0EsSUFBUDtBQUNFLFdBQUssSUFBTDtBQUFXLGVBQU9pRSxNQUFRdEMsR0FBRCxJQUFPLENBQWQsQ0FBUDs7QUFDWCxXQUFLLElBQUw7QUFBVyxlQUFPc0MsTUFBUXRDLEdBQUQsSUFBTyxDQUFkLENBQVA7O0FBQ1gsV0FBSyxLQUFMO0FBQVksZUFBT3VDLE9BQVN2QyxHQUFELElBQU8sQ0FBZixDQUFQOztBQUNaLFdBQUssS0FBTDtBQUFZLGVBQU9yQyxPQUFTcUMsR0FBRCxJQUFPLENBQWYsQ0FBUDs7QUFDWixXQUFLLEtBQUw7QUFBWSxlQUFPckMsT0FBU3FDLEdBQUQsSUFBTyxDQUFmLENBQVA7O0FBQ1osV0FBSyxPQUFMO0FBQWMsZUFBTzhDLFFBQVU5QyxHQUFELElBQU8sQ0FBaEIsQ0FBUDs7QUFDZCxXQUFLLFFBQUw7QUFBZSxlQUFPK0MsUUFBVS9DLEdBQUQsSUFBTyxDQUFoQixDQUFQOztBQUNmO0FBQVM1QyxjQUFNLGdDQUFnQ2lCLElBQXRDO0FBUlg7O0FBVUYsV0FBTyxJQUFQO0FBQ0Q7O0FBRUQsTUFBSTRFLGVBQWUsQ0FBbkIsQ0FoaUI4QixDQWdpQlI7O0FBQ3RCLE1BQUlDLGNBQWMsQ0FBbEIsQ0FqaUI4QixDQWlpQlQ7O0FBQ3JCLE1BQUlDLGVBQWUsQ0FBbkIsQ0FsaUI4QixDQWtpQlI7O0FBQ3RCLE1BQUlDLGdCQUFnQixDQUFwQixDQW5pQjhCLENBbWlCUDs7QUFDdkIsTUFBSUMsYUFBYSxDQUFqQixDQXBpQjhCLENBb2lCVjtBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQSxXQUFTQyxRQUFULENBQWtCQyxJQUFsQixFQUF3QkMsS0FBeEIsRUFBK0JDLFNBQS9CLEVBQTBDekQsR0FBMUMsRUFBK0M7QUFDN0MsUUFBSTBELFFBQUosRUFBY3BHLElBQWQ7O0FBQ0EsUUFBSSxPQUFPaUcsSUFBUCxLQUFnQixRQUFwQixFQUE4QjtBQUM1QkcsaUJBQVcsSUFBWDtBQUNBcEcsYUFBT2lHLElBQVA7QUFDRCxLQUhELE1BR087QUFDTEcsaUJBQVcsS0FBWDtBQUNBcEcsYUFBT2lHLEtBQUs3SSxNQUFaO0FBQ0Q7O0FBRUQsUUFBSWlKLGFBQWEsT0FBT0gsS0FBUCxLQUFpQixRQUFqQixHQUE0QkEsS0FBNUIsR0FBb0MsSUFBckQ7QUFFQSxRQUFJdEosR0FBSjs7QUFDQSxRQUFJdUosYUFBYUosVUFBakIsRUFBNkI7QUFDM0JuSixZQUFNOEYsR0FBTjtBQUNELEtBRkQsTUFFTztBQUNMOUYsWUFBTSxDQUFDLE9BQU8wSixPQUFQLEtBQW1CLFVBQW5CLEdBQWdDQSxPQUFoQyxHQUEwQ3ZHLFdBQTNDLEVBQXdESixVQUF4RCxFQUFvRUksV0FBcEUsRUFBaUZJLFlBQWpGLEVBQStGZ0csY0FBYzVHLFNBQWQsR0FBMEJzRyxZQUExQixHQUF5Q00sU0FBeEksRUFBbUp2RixLQUFLMkYsR0FBTCxDQUFTdkcsSUFBVCxFQUFlcUcsYUFBYSxDQUFiLEdBQWlCSCxNQUFNOUksTUFBdEMsQ0FBbkosQ0FBTjtBQUNEOztBQUVELFFBQUlnSixRQUFKLEVBQWM7QUFDWixVQUFJSSxJQUFKO0FBQ0E5RCxZQUFNOUYsR0FBTjtBQUNBTyxhQUFPLENBQUNQLE1BQU0sQ0FBUCxLQUFhLENBQXBCO0FBQ0E0SixhQUFPNUosT0FBT29ELE9BQU8sQ0FBQyxDQUFmLENBQVA7O0FBQ0EsYUFBTzBDLE1BQU04RCxJQUFiLEVBQW1COUQsT0FBTyxDQUExQixFQUE2QjtBQUMzQnJDLGVBQVNxQyxHQUFELElBQU8sQ0FBZixJQUFtQixDQUFuQjtBQUNEOztBQUNEOEQsYUFBTzVKLE1BQU1vRCxJQUFiOztBQUNBLGFBQU8wQyxNQUFNOEQsSUFBYixFQUFtQjtBQUNqQnhCLGNBQVF0QyxLQUFELElBQVMsQ0FBaEIsSUFBb0IsQ0FBcEI7QUFDRDs7QUFDRCxhQUFPOUYsR0FBUDtBQUNEOztBQUVELFFBQUl5SixlQUFlLElBQW5CLEVBQXlCO0FBQ3ZCLFVBQUlKLEtBQUtRLFFBQUwsSUFBaUJSLEtBQUszSSxLQUExQixFQUFpQztBQUMvQm9KLGVBQU9DLEdBQVA7QUFBVztBQUE0QlYsWUFBdkMsRUFBOENySixHQUE5QztBQUNELE9BRkQsTUFFTztBQUNMOEosZUFBT0MsR0FBUCxDQUFXLElBQUl6SixVQUFKLENBQWUrSSxJQUFmLENBQVgsRUFBaUNySixHQUFqQztBQUNEOztBQUNELGFBQU9BLEdBQVA7QUFDRDs7QUFFRCxRQUFJOEUsSUFBSSxDQUFSO0FBQUEsUUFBV1gsSUFBWDtBQUFBLFFBQWlCNkYsUUFBakI7QUFBQSxRQUEyQkMsWUFBM0I7O0FBQ0EsV0FBT25GLElBQUkxQixJQUFYLEVBQWlCO0FBQ2YsVUFBSThHLE9BQU9iLEtBQUt2RSxDQUFMLENBQVg7QUFFQVgsYUFBT3NGLGNBQWNILE1BQU14RSxDQUFOLENBQXJCOztBQUNBLFVBQUlYLFNBQVMsQ0FBYixFQUFnQjtBQUNkVztBQUNBO0FBQ0Q7O0FBQ0R2RSxhQUFPNEQsSUFBUCxFQUFhLDJDQUFiO0FBRUEsVUFBSUEsUUFBUSxLQUFaLEVBQW1CQSxPQUFPLEtBQVAsQ0FWSixDQVVrQjs7QUFFakM2RCxlQUFTaEksTUFBSThFLENBQWIsRUFBZ0JvRixJQUFoQixFQUFzQi9GLElBQXRCLEVBWmUsQ0FjZjs7QUFDQSxVQUFJOEYsaUJBQWlCOUYsSUFBckIsRUFBMkI7QUFDekI2RixtQkFBVzlGLGtCQUFrQkMsSUFBbEIsQ0FBWDtBQUNBOEYsdUJBQWU5RixJQUFmO0FBQ0Q7O0FBQ0RXLFdBQUtrRixRQUFMO0FBQ0Q7O0FBRUQsV0FBT2hLLEdBQVA7QUFDRCxHQXZuQjZCLENBeW5COUI7OztBQUNBLFdBQVNtSyxTQUFULENBQW1CL0csSUFBbkIsRUFBeUI7QUFDdkIsUUFBSSxDQUFDQyxZQUFMLEVBQW1CLE9BQU9GLFlBQVlDLElBQVosQ0FBUDtBQUNuQixRQUFJLENBQUNnSCxrQkFBTCxFQUF5QixPQUFPN0csYUFBYUgsSUFBYixDQUFQO0FBQ3pCLFdBQU9zRyxRQUFRdEcsSUFBUixDQUFQO0FBQ0Q7QUFFRDs7O0FBQ0EsV0FBU3NFLGlCQUFULENBQTJCNUIsR0FBM0IsRUFBZ0N0RixNQUFoQyxFQUF3QztBQUN0QyxRQUFJQSxXQUFXLENBQVgsSUFBZ0IsQ0FBQ3NGLEdBQXJCLEVBQTBCLE9BQU8sRUFBUCxDQURZLENBRXRDO0FBQ0E7O0FBQ0EsUUFBSXVFLFNBQVMsQ0FBYjtBQUNBLFFBQUlDLENBQUo7QUFDQSxRQUFJeEYsSUFBSSxDQUFSOztBQUNBLFdBQU8sQ0FBUCxFQUFVO0FBQ1J2RSxhQUFPdUYsTUFBTWhCLENBQU4sR0FBVW5CLFlBQWpCO0FBQ0EyRyxVQUFJUixPQUFVaEUsR0FBRCxHQUFPaEIsQ0FBUixJQUFhLENBQXJCLENBQUo7QUFDQXVGLGdCQUFVQyxDQUFWO0FBQ0EsVUFBSUEsS0FBSyxDQUFMLElBQVUsQ0FBQzlKLE1BQWYsRUFBdUI7QUFDdkJzRTtBQUNBLFVBQUl0RSxVQUFVc0UsS0FBS3RFLE1BQW5CLEVBQTJCO0FBQzVCOztBQUNELFFBQUksQ0FBQ0EsTUFBTCxFQUFhQSxTQUFTc0UsQ0FBVDtBQUViLFFBQUk5RSxNQUFNLEVBQVY7O0FBRUEsUUFBSXFLLFNBQVMsR0FBYixFQUFrQjtBQUNoQixVQUFJRSxZQUFZLElBQWhCLENBRGdCLENBQ007O0FBQ3RCLFVBQUlMLElBQUo7O0FBQ0EsYUFBTzFKLFNBQVMsQ0FBaEIsRUFBbUI7QUFDakIwSixlQUFPTSxPQUFPQyxZQUFQLENBQW9CekUsS0FBcEIsQ0FBMEJ3RSxNQUExQixFQUFrQ1YsT0FBT0QsUUFBUCxDQUFnQi9ELEdBQWhCLEVBQXFCQSxNQUFNOUIsS0FBSzBHLEdBQUwsQ0FBU2xLLE1BQVQsRUFBaUIrSixTQUFqQixDQUEzQixDQUFsQyxDQUFQO0FBQ0F2SyxjQUFNQSxNQUFNQSxNQUFNa0ssSUFBWixHQUFtQkEsSUFBekI7QUFDQXBFLGVBQU95RSxTQUFQO0FBQ0EvSixrQkFBVStKLFNBQVY7QUFDRDs7QUFDRCxhQUFPdkssR0FBUDtBQUNEOztBQUNELFdBQU8ySyxhQUFhN0UsR0FBYixDQUFQO0FBQ0QsR0FocUI2QixDQWtxQjlCO0FBQ0E7OztBQUVBLFdBQVM4RSxhQUFULENBQXVCOUUsR0FBdkIsRUFBNEI7QUFDMUIsUUFBSWlCLE1BQU0sRUFBVjs7QUFDQSxXQUFPLENBQVAsRUFBVTtBQUNSLFVBQUk4RCxLQUFLekMsTUFBUXRDLEtBQUQsSUFBUyxDQUFoQixDQUFUO0FBQ0EsVUFBSSxDQUFDK0UsRUFBTCxFQUFTLE9BQU85RCxHQUFQO0FBQ1RBLGFBQU95RCxPQUFPQyxZQUFQLENBQW9CSSxFQUFwQixDQUFQO0FBQ0Q7QUFDRixHQTVxQjZCLENBOHFCOUI7QUFDQTs7O0FBRUEsV0FBU0MsYUFBVCxDQUF1Qi9ELEdBQXZCLEVBQTRCZ0UsTUFBNUIsRUFBb0M7QUFDbEMsV0FBT0MsbUJBQW1CakUsR0FBbkIsRUFBd0JnRSxNQUF4QixFQUFnQyxLQUFoQyxDQUFQO0FBQ0QsR0FuckI2QixDQXFyQjlCO0FBQ0E7OztBQUVBLE1BQUlFLGNBQWMsT0FBT0MsV0FBUCxLQUF1QixXQUF2QixHQUFxQyxJQUFJQSxXQUFKLENBQWdCLE1BQWhCLENBQXJDLEdBQStEdkksU0FBakY7O0FBQ0EsV0FBU3dJLGlCQUFULENBQTJCQyxPQUEzQixFQUFvQ0MsR0FBcEMsRUFBeUM7QUFDdkMsUUFBSUMsU0FBU0QsR0FBYixDQUR1QyxDQUV2QztBQUNBOztBQUNBLFdBQU9ELFFBQVFFLE1BQVIsQ0FBUDtBQUF3QixRQUFFQSxNQUFGO0FBQXhCOztBQUVBLFFBQUlBLFNBQVNELEdBQVQsR0FBZSxFQUFmLElBQXFCRCxRQUFRdkIsUUFBN0IsSUFBeUNvQixXQUE3QyxFQUEwRDtBQUN4RCxhQUFPQSxZQUFZTSxNQUFaLENBQW1CSCxRQUFRdkIsUUFBUixDQUFpQndCLEdBQWpCLEVBQXNCQyxNQUF0QixDQUFuQixDQUFQO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsVUFBSUUsRUFBSixFQUFRQyxFQUFSLEVBQVlDLEVBQVosRUFBZ0JDLEVBQWhCLEVBQW9CQyxFQUFwQixFQUF3QkMsRUFBeEI7QUFFQSxVQUFJOUUsTUFBTSxFQUFWOztBQUNBLGFBQU8sQ0FBUCxFQUFVO0FBQ1I7QUFDQXlFLGFBQUtKLFFBQVFDLEtBQVIsQ0FBTDtBQUNBLFlBQUksQ0FBQ0csRUFBTCxFQUFTLE9BQU96RSxHQUFQOztBQUNULFlBQUksRUFBRXlFLEtBQUssSUFBUCxDQUFKLEVBQWtCO0FBQUV6RSxpQkFBT3lELE9BQU9DLFlBQVAsQ0FBb0JlLEVBQXBCLENBQVA7QUFBZ0M7QUFBVzs7QUFDL0RDLGFBQUtMLFFBQVFDLEtBQVIsSUFBaUIsRUFBdEI7O0FBQ0EsWUFBSSxDQUFDRyxLQUFLLElBQU4sS0FBZSxJQUFuQixFQUF5QjtBQUFFekUsaUJBQU95RCxPQUFPQyxZQUFQLENBQXFCLENBQUNlLEtBQUssRUFBTixLQUFhLENBQWQsR0FBbUJDLEVBQXZDLENBQVA7QUFBbUQ7QUFBVzs7QUFDekZDLGFBQUtOLFFBQVFDLEtBQVIsSUFBaUIsRUFBdEI7O0FBQ0EsWUFBSSxDQUFDRyxLQUFLLElBQU4sS0FBZSxJQUFuQixFQUF5QjtBQUN2QkEsZUFBTSxDQUFDQSxLQUFLLEVBQU4sS0FBYSxFQUFkLEdBQXFCQyxNQUFNLENBQTNCLEdBQWdDQyxFQUFyQztBQUNELFNBRkQsTUFFTztBQUNMQyxlQUFLUCxRQUFRQyxLQUFSLElBQWlCLEVBQXRCOztBQUNBLGNBQUksQ0FBQ0csS0FBSyxJQUFOLEtBQWUsSUFBbkIsRUFBeUI7QUFDdkJBLGlCQUFNLENBQUNBLEtBQUssQ0FBTixLQUFZLEVBQWIsR0FBb0JDLE1BQU0sRUFBMUIsR0FBaUNDLE1BQU0sQ0FBdkMsR0FBNENDLEVBQWpEO0FBQ0QsV0FGRCxNQUVPO0FBQ0xDLGlCQUFLUixRQUFRQyxLQUFSLElBQWlCLEVBQXRCOztBQUNBLGdCQUFJLENBQUNHLEtBQUssSUFBTixLQUFlLElBQW5CLEVBQXlCO0FBQ3ZCQSxtQkFBTSxDQUFDQSxLQUFLLENBQU4sS0FBWSxFQUFiLEdBQW9CQyxNQUFNLEVBQTFCLEdBQWlDQyxNQUFNLEVBQXZDLEdBQThDQyxNQUFNLENBQXBELEdBQXlEQyxFQUE5RDtBQUNELGFBRkQsTUFFTztBQUNMQyxtQkFBS1QsUUFBUUMsS0FBUixJQUFpQixFQUF0QjtBQUNBRyxtQkFBTSxDQUFDQSxLQUFLLENBQU4sS0FBWSxFQUFiLEdBQW9CQyxNQUFNLEVBQTFCLEdBQWlDQyxNQUFNLEVBQXZDLEdBQThDQyxNQUFNLEVBQXBELEdBQTJEQyxNQUFNLENBQWpFLEdBQXNFQyxFQUEzRTtBQUNEO0FBQ0Y7QUFDRjs7QUFDRCxZQUFJTCxLQUFLLE9BQVQsRUFBa0I7QUFDaEJ6RSxpQkFBT3lELE9BQU9DLFlBQVAsQ0FBb0JlLEVBQXBCLENBQVA7QUFDRCxTQUZELE1BRU87QUFDTCxjQUFJWCxLQUFLVyxLQUFLLE9BQWQ7QUFDQXpFLGlCQUFPeUQsT0FBT0MsWUFBUCxDQUFvQixTQUFVSSxNQUFNLEVBQXBDLEVBQXlDLFNBQVVBLEtBQUssS0FBeEQsQ0FBUDtBQUNEO0FBQ0Y7QUFDRjtBQUNGLEdBcnVCNkIsQ0F1dUI5QjtBQUNBOzs7QUFFQSxXQUFTRixZQUFULENBQXNCN0UsR0FBdEIsRUFBMkI7QUFDekIsV0FBT3FGLGtCQUFrQnJCLE1BQWxCLEVBQXlCaEUsR0FBekIsQ0FBUDtBQUNELEdBNXVCNkIsQ0E4dUI5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQSxXQUFTZ0csaUJBQVQsQ0FBMkIvRSxHQUEzQixFQUFnQ2dGLFVBQWhDLEVBQTRDQyxNQUE1QyxFQUFvREMsZUFBcEQsRUFBcUU7QUFDbkUsUUFBSSxFQUFFQSxrQkFBa0IsQ0FBcEIsQ0FBSixFQUE0QjtBQUMxQixhQUFPLENBQVA7QUFFRixRQUFJQyxXQUFXRixNQUFmO0FBQ0EsUUFBSUcsU0FBU0gsU0FBU0MsZUFBVCxHQUEyQixDQUF4QyxDQUxtRSxDQUt4Qjs7QUFDM0MsU0FBSyxJQUFJbkgsSUFBSSxDQUFiLEVBQWdCQSxJQUFJaUMsSUFBSXZHLE1BQXhCLEVBQWdDLEVBQUVzRSxDQUFsQyxFQUFxQztBQUNuQztBQUNBO0FBQ0E7QUFDQSxVQUFJc0gsSUFBSXJGLElBQUlzRixVQUFKLENBQWV2SCxDQUFmLENBQVIsQ0FKbUMsQ0FJUjs7QUFDM0IsVUFBSXNILEtBQUssTUFBTCxJQUFlQSxLQUFLLE1BQXhCLEVBQWdDQSxJQUFJLFdBQVcsQ0FBQ0EsSUFBSSxLQUFMLEtBQWUsRUFBMUIsSUFBaUNyRixJQUFJc0YsVUFBSixDQUFlLEVBQUV2SCxDQUFqQixJQUFzQixLQUEzRDs7QUFDaEMsVUFBSXNILEtBQUssSUFBVCxFQUFlO0FBQ2IsWUFBSUosVUFBVUcsTUFBZCxFQUFzQjtBQUN0QkosbUJBQVdDLFFBQVgsSUFBdUJJLENBQXZCO0FBQ0QsT0FIRCxNQUdPLElBQUlBLEtBQUssS0FBVCxFQUFnQjtBQUNyQixZQUFJSixTQUFTLENBQVQsSUFBY0csTUFBbEIsRUFBMEI7QUFDMUJKLG1CQUFXQyxRQUFYLElBQXVCLE9BQVFJLEtBQUssQ0FBcEM7QUFDQUwsbUJBQVdDLFFBQVgsSUFBdUIsT0FBUUksSUFBSSxFQUFuQztBQUNELE9BSk0sTUFJQSxJQUFJQSxLQUFLLE1BQVQsRUFBaUI7QUFDdEIsWUFBSUosU0FBUyxDQUFULElBQWNHLE1BQWxCLEVBQTBCO0FBQzFCSixtQkFBV0MsUUFBWCxJQUF1QixPQUFRSSxLQUFLLEVBQXBDO0FBQ0FMLG1CQUFXQyxRQUFYLElBQXVCLE9BQVNJLEtBQUssQ0FBTixHQUFXLEVBQTFDO0FBQ0FMLG1CQUFXQyxRQUFYLElBQXVCLE9BQVFJLElBQUksRUFBbkM7QUFDRCxPQUxNLE1BS0EsSUFBSUEsS0FBSyxRQUFULEVBQW1CO0FBQ3hCLFlBQUlKLFNBQVMsQ0FBVCxJQUFjRyxNQUFsQixFQUEwQjtBQUMxQkosbUJBQVdDLFFBQVgsSUFBdUIsT0FBUUksS0FBSyxFQUFwQztBQUNBTCxtQkFBV0MsUUFBWCxJQUF1QixPQUFTSSxLQUFLLEVBQU4sR0FBWSxFQUEzQztBQUNBTCxtQkFBV0MsUUFBWCxJQUF1QixPQUFTSSxLQUFLLENBQU4sR0FBVyxFQUExQztBQUNBTCxtQkFBV0MsUUFBWCxJQUF1QixPQUFRSSxJQUFJLEVBQW5DO0FBQ0QsT0FOTSxNQU1BLElBQUlBLEtBQUssU0FBVCxFQUFvQjtBQUN6QixZQUFJSixTQUFTLENBQVQsSUFBY0csTUFBbEIsRUFBMEI7QUFDMUJKLG1CQUFXQyxRQUFYLElBQXVCLE9BQVFJLEtBQUssRUFBcEM7QUFDQUwsbUJBQVdDLFFBQVgsSUFBdUIsT0FBU0ksS0FBSyxFQUFOLEdBQVksRUFBM0M7QUFDQUwsbUJBQVdDLFFBQVgsSUFBdUIsT0FBU0ksS0FBSyxFQUFOLEdBQVksRUFBM0M7QUFDQUwsbUJBQVdDLFFBQVgsSUFBdUIsT0FBU0ksS0FBSyxDQUFOLEdBQVcsRUFBMUM7QUFDQUwsbUJBQVdDLFFBQVgsSUFBdUIsT0FBUUksSUFBSSxFQUFuQztBQUNELE9BUE0sTUFPQTtBQUNMLFlBQUlKLFNBQVMsQ0FBVCxJQUFjRyxNQUFsQixFQUEwQjtBQUMxQkosbUJBQVdDLFFBQVgsSUFBdUIsT0FBUUksS0FBSyxFQUFwQztBQUNBTCxtQkFBV0MsUUFBWCxJQUF1QixPQUFTSSxLQUFLLEVBQU4sR0FBWSxFQUEzQztBQUNBTCxtQkFBV0MsUUFBWCxJQUF1QixPQUFTSSxLQUFLLEVBQU4sR0FBWSxFQUEzQztBQUNBTCxtQkFBV0MsUUFBWCxJQUF1QixPQUFTSSxLQUFLLEVBQU4sR0FBWSxFQUEzQztBQUNBTCxtQkFBV0MsUUFBWCxJQUF1QixPQUFTSSxLQUFLLENBQU4sR0FBVyxFQUExQztBQUNBTCxtQkFBV0MsUUFBWCxJQUF1QixPQUFRSSxJQUFJLEVBQW5DO0FBQ0Q7QUFDRixLQTlDa0UsQ0ErQ25FOzs7QUFDQUwsZUFBV0MsTUFBWCxJQUFxQixDQUFyQjtBQUNBLFdBQU9BLFNBQVNFLFFBQWhCO0FBQ0QsR0E1eUI2QixDQTh5QjlCO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQSxXQUFTakYsWUFBVCxDQUFzQkYsR0FBdEIsRUFBMkJnRSxNQUEzQixFQUFtQ2tCLGVBQW5DLEVBQW9EO0FBQ2xEMUwsV0FBTyxPQUFPMEwsZUFBUCxJQUEwQixRQUFqQyxFQUEyQywySEFBM0M7QUFDQSxXQUFPSCxrQkFBa0IvRSxHQUFsQixFQUF1QitDLE1BQXZCLEVBQThCaUIsTUFBOUIsRUFBc0NrQixlQUF0QyxDQUFQO0FBQ0QsR0F0ekI2QixDQXd6QjlCOzs7QUFFQSxXQUFTSyxlQUFULENBQXlCdkYsR0FBekIsRUFBOEI7QUFDNUIsUUFBSUMsTUFBTSxDQUFWOztBQUNBLFNBQUssSUFBSWxDLElBQUksQ0FBYixFQUFnQkEsSUFBSWlDLElBQUl2RyxNQUF4QixFQUFnQyxFQUFFc0UsQ0FBbEMsRUFBcUM7QUFDbkM7QUFDQTtBQUNBLFVBQUlzSCxJQUFJckYsSUFBSXNGLFVBQUosQ0FBZXZILENBQWYsQ0FBUixDQUhtQyxDQUdSOztBQUMzQixVQUFJc0gsS0FBSyxNQUFMLElBQWVBLEtBQUssTUFBeEIsRUFBZ0NBLElBQUksV0FBVyxDQUFDQSxJQUFJLEtBQUwsS0FBZSxFQUExQixJQUFpQ3JGLElBQUlzRixVQUFKLENBQWUsRUFBRXZILENBQWpCLElBQXNCLEtBQTNEOztBQUNoQyxVQUFJc0gsS0FBSyxJQUFULEVBQWU7QUFDYixVQUFFcEYsR0FBRjtBQUNELE9BRkQsTUFFTyxJQUFJb0YsS0FBSyxLQUFULEVBQWdCO0FBQ3JCcEYsZUFBTyxDQUFQO0FBQ0QsT0FGTSxNQUVBLElBQUlvRixLQUFLLE1BQVQsRUFBaUI7QUFDdEJwRixlQUFPLENBQVA7QUFDRCxPQUZNLE1BRUEsSUFBSW9GLEtBQUssUUFBVCxFQUFtQjtBQUN4QnBGLGVBQU8sQ0FBUDtBQUNELE9BRk0sTUFFQSxJQUFJb0YsS0FBSyxTQUFULEVBQW9CO0FBQ3pCcEYsZUFBTyxDQUFQO0FBQ0QsT0FGTSxNQUVBO0FBQ0xBLGVBQU8sQ0FBUDtBQUNEO0FBQ0Y7O0FBQ0QsV0FBT0EsR0FBUDtBQUNELEdBaDFCNkIsQ0FrMUI5QjtBQUNBOzs7QUFFQSxNQUFJdUYsZUFBZSxPQUFPckIsV0FBUCxLQUF1QixXQUF2QixHQUFxQyxJQUFJQSxXQUFKLENBQWdCLFVBQWhCLENBQXJDLEdBQW1FdkksU0FBdEY7O0FBQ0EsV0FBUzZKLGFBQVQsQ0FBdUIxRyxHQUF2QixFQUE0QjtBQUMxQnZGLFdBQU91RixNQUFNLENBQU4sSUFBVyxDQUFsQixFQUFxQiwrREFBckI7QUFDQSxRQUFJd0YsU0FBU3hGLEdBQWIsQ0FGMEIsQ0FHMUI7QUFDQTs7QUFDQSxRQUFJdUYsTUFBTUMsVUFBVSxDQUFwQjs7QUFDQSxXQUFPakQsT0FBT2dELEdBQVAsQ0FBUDtBQUFvQixRQUFFQSxHQUFGO0FBQXBCOztBQUNBQyxhQUFTRCxPQUFPLENBQWhCOztBQUVBLFFBQUlDLFNBQVN4RixHQUFULEdBQWUsRUFBZixJQUFxQnlHLFlBQXpCLEVBQXVDO0FBQ3JDLGFBQU9BLGFBQWFoQixNQUFiLENBQW9CekIsT0FBT0QsUUFBUCxDQUFnQi9ELEdBQWhCLEVBQXFCd0YsTUFBckIsQ0FBcEIsQ0FBUDtBQUNELEtBRkQsTUFFTztBQUNMLFVBQUl4RyxJQUFJLENBQVI7QUFFQSxVQUFJaUMsTUFBTSxFQUFWOztBQUNBLGFBQU8sQ0FBUCxFQUFVO0FBQ1IsWUFBSTBGLFdBQVdwRSxPQUFVdkMsR0FBRCxHQUFPaEIsSUFBRSxDQUFWLElBQWUsQ0FBdkIsQ0FBZjtBQUNBLFlBQUkySCxZQUFZLENBQWhCLEVBQW1CLE9BQU8xRixHQUFQO0FBQ25CLFVBQUVqQyxDQUFGLENBSFEsQ0FJUjs7QUFDQWlDLGVBQU95RCxPQUFPQyxZQUFQLENBQW9CZ0MsUUFBcEIsQ0FBUDtBQUNEO0FBQ0Y7QUFDRixHQTcyQjZCLENBKzJCOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBLFdBQVNDLGFBQVQsQ0FBdUIzRixHQUF2QixFQUE0QmdFLE1BQTVCLEVBQW9Da0IsZUFBcEMsRUFBcUQ7QUFDbkQxTCxXQUFPd0ssU0FBUyxDQUFULElBQWMsQ0FBckIsRUFBd0IsK0RBQXhCO0FBQ0F4SyxXQUFPLE9BQU8wTCxlQUFQLElBQTBCLFFBQWpDLEVBQTJDLDRIQUEzQyxFQUZtRCxDQUduRDs7QUFDQSxRQUFJQSxvQkFBb0J0SixTQUF4QixFQUFtQztBQUNqQ3NKLHdCQUFrQixVQUFsQjtBQUNEOztBQUNELFFBQUlBLGtCQUFrQixDQUF0QixFQUF5QixPQUFPLENBQVA7QUFDekJBLHVCQUFtQixDQUFuQixDQVJtRCxDQVE3Qjs7QUFDdEIsUUFBSVUsV0FBVzVCLE1BQWY7QUFDQSxRQUFJNkIsa0JBQW1CWCxrQkFBa0JsRixJQUFJdkcsTUFBSixHQUFXLENBQTlCLEdBQW9DeUwsa0JBQWtCLENBQXRELEdBQTJEbEYsSUFBSXZHLE1BQXJGOztBQUNBLFNBQUssSUFBSXNFLElBQUksQ0FBYixFQUFnQkEsSUFBSThILGVBQXBCLEVBQXFDLEVBQUU5SCxDQUF2QyxFQUEwQztBQUN4QztBQUNBLFVBQUkySCxXQUFXMUYsSUFBSXNGLFVBQUosQ0FBZXZILENBQWYsQ0FBZixDQUZ3QyxDQUVOOztBQUNsQ3VELGFBQVMwQyxNQUFELElBQVUsQ0FBbEIsSUFBc0IwQixRQUF0QjtBQUNBMUIsZ0JBQVUsQ0FBVjtBQUNELEtBaEJrRCxDQWlCbkQ7OztBQUNBMUMsV0FBUzBDLE1BQUQsSUFBVSxDQUFsQixJQUFzQixDQUF0QjtBQUNBLFdBQU9BLFNBQVM0QixRQUFoQjtBQUNELEdBOTRCNkIsQ0FnNUI5Qjs7O0FBRUEsV0FBU0UsZ0JBQVQsQ0FBMEI5RixHQUExQixFQUErQjtBQUM3QixXQUFPQSxJQUFJdkcsTUFBSixHQUFXLENBQWxCO0FBQ0Q7O0FBRUQsV0FBU3NNLGFBQVQsQ0FBdUJoSCxHQUF2QixFQUE0QjtBQUMxQnZGLFdBQU91RixNQUFNLENBQU4sSUFBVyxDQUFsQixFQUFxQixnRUFBckI7QUFDQSxRQUFJaEIsSUFBSSxDQUFSO0FBRUEsUUFBSWlDLE1BQU0sRUFBVjs7QUFDQSxXQUFPLENBQVAsRUFBVTtBQUNSLFVBQUlnRyxRQUFRdEosT0FBVXFDLEdBQUQsR0FBT2hCLElBQUUsQ0FBVixJQUFlLENBQXZCLENBQVo7QUFDQSxVQUFJaUksU0FBUyxDQUFiLEVBQ0UsT0FBT2hHLEdBQVA7QUFDRixRQUFFakMsQ0FBRixDQUpRLENBS1I7QUFDQTs7QUFDQSxVQUFJaUksU0FBUyxPQUFiLEVBQXNCO0FBQ3BCLFlBQUlsQyxLQUFLa0MsUUFBUSxPQUFqQjtBQUNBaEcsZUFBT3lELE9BQU9DLFlBQVAsQ0FBb0IsU0FBVUksTUFBTSxFQUFwQyxFQUF5QyxTQUFVQSxLQUFLLEtBQXhELENBQVA7QUFDRCxPQUhELE1BR087QUFDTDlELGVBQU95RCxPQUFPQyxZQUFQLENBQW9Cc0MsS0FBcEIsQ0FBUDtBQUNEO0FBQ0Y7QUFDRixHQXo2QjZCLENBMjZCOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBLFdBQVNDLGFBQVQsQ0FBdUJqRyxHQUF2QixFQUE0QmdFLE1BQTVCLEVBQW9Da0IsZUFBcEMsRUFBcUQ7QUFDbkQxTCxXQUFPd0ssU0FBUyxDQUFULElBQWMsQ0FBckIsRUFBd0IsZ0VBQXhCO0FBQ0F4SyxXQUFPLE9BQU8wTCxlQUFQLElBQTBCLFFBQWpDLEVBQTJDLDRIQUEzQyxFQUZtRCxDQUduRDs7QUFDQSxRQUFJQSxvQkFBb0J0SixTQUF4QixFQUFtQztBQUNqQ3NKLHdCQUFrQixVQUFsQjtBQUNEOztBQUNELFFBQUlBLGtCQUFrQixDQUF0QixFQUF5QixPQUFPLENBQVA7QUFDekIsUUFBSVUsV0FBVzVCLE1BQWY7QUFDQSxRQUFJTyxTQUFTcUIsV0FBV1YsZUFBWCxHQUE2QixDQUExQzs7QUFDQSxTQUFLLElBQUluSCxJQUFJLENBQWIsRUFBZ0JBLElBQUlpQyxJQUFJdkcsTUFBeEIsRUFBZ0MsRUFBRXNFLENBQWxDLEVBQXFDO0FBQ25DO0FBQ0E7QUFDQSxVQUFJMkgsV0FBVzFGLElBQUlzRixVQUFKLENBQWV2SCxDQUFmLENBQWYsQ0FIbUMsQ0FHRDs7QUFDbEMsVUFBSTJILFlBQVksTUFBWixJQUFzQkEsWUFBWSxNQUF0QyxFQUE4QztBQUM1QyxZQUFJUSxpQkFBaUJsRyxJQUFJc0YsVUFBSixDQUFlLEVBQUV2SCxDQUFqQixDQUFyQjtBQUNBMkgsbUJBQVcsV0FBVyxDQUFDQSxXQUFXLEtBQVosS0FBc0IsRUFBakMsSUFBd0NRLGlCQUFpQixLQUFwRTtBQUNEOztBQUNEeEosYUFBU3NILE1BQUQsSUFBVSxDQUFsQixJQUFzQjBCLFFBQXRCO0FBQ0ExQixnQkFBVSxDQUFWO0FBQ0EsVUFBSUEsU0FBUyxDQUFULEdBQWFPLE1BQWpCLEVBQXlCO0FBQzFCLEtBckJrRCxDQXNCbkQ7OztBQUNBN0gsV0FBU3NILE1BQUQsSUFBVSxDQUFsQixJQUFzQixDQUF0QjtBQUNBLFdBQU9BLFNBQVM0QixRQUFoQjtBQUNELEdBLzhCNkIsQ0FpOUI5Qjs7O0FBRUEsV0FBU08sZ0JBQVQsQ0FBMEJuRyxHQUExQixFQUErQjtBQUM3QixRQUFJQyxNQUFNLENBQVY7O0FBQ0EsU0FBSyxJQUFJbEMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJaUMsSUFBSXZHLE1BQXhCLEVBQWdDLEVBQUVzRSxDQUFsQyxFQUFxQztBQUNuQztBQUNBO0FBQ0EsVUFBSTJILFdBQVcxRixJQUFJc0YsVUFBSixDQUFldkgsQ0FBZixDQUFmO0FBQ0EsVUFBSTJILFlBQVksTUFBWixJQUFzQkEsWUFBWSxNQUF0QyxFQUE4QyxFQUFFM0gsQ0FBRixDQUpYLENBSWdCOztBQUNuRGtDLGFBQU8sQ0FBUDtBQUNEOztBQUVELFdBQU9BLEdBQVA7QUFDRCxHQTk5QjZCLENBZytCOUI7QUFDQTs7O0FBQ0EsV0FBU21HLFlBQVQsQ0FBc0JwRyxHQUF0QixFQUEyQjtBQUN6QixRQUFJM0QsT0FBT2tKLGdCQUFnQnZGLEdBQWhCLElBQXVCLENBQWxDOztBQUNBLFFBQUkvRyxNQUFNMEosUUFBUXRHLElBQVIsQ0FBVjs7QUFDQSxRQUFJcEQsR0FBSixFQUFTOEwsa0JBQWtCL0UsR0FBbEIsRUFBdUJxQixLQUF2QixFQUE4QnBJLEdBQTlCLEVBQW1Db0QsSUFBbkM7QUFDVCxXQUFPcEQsR0FBUDtBQUNELEdBditCNkIsQ0F5K0I5Qjs7O0FBQ0EsV0FBU29OLG1CQUFULENBQTZCckcsR0FBN0IsRUFBa0M7QUFDaEMsUUFBSTNELE9BQU9rSixnQkFBZ0J2RixHQUFoQixJQUF1QixDQUFsQztBQUNBLFFBQUkvRyxNQUFNK0MsV0FBV0ssSUFBWCxDQUFWO0FBQ0EwSSxzQkFBa0IvRSxHQUFsQixFQUF1QnFCLEtBQXZCLEVBQThCcEksR0FBOUIsRUFBbUNvRCxJQUFuQztBQUNBLFdBQU9wRCxHQUFQO0FBQ0Q7O0FBRUQsV0FBU3FOLFFBQVQsQ0FBa0J4SSxJQUFsQixFQUF3QjtBQUN0Qk4sYUFBUyw2RUFBVDtBQUNBLFdBQU9NLElBQVA7QUFDRDs7QUFFRCxXQUFTeUksV0FBVCxDQUFxQjlJLElBQXJCLEVBQTJCO0FBQ3pCLFFBQUkrSSxRQUNGLGNBREY7QUFFQSxXQUFPL0ksS0FBSy9ELE9BQUwsQ0FBYThNLEtBQWIsRUFDTCxVQUFTQyxDQUFULEVBQVk7QUFDVixVQUFJQyxJQUFJSixTQUFTRyxDQUFULENBQVI7QUFDQSxhQUFPQSxNQUFNQyxDQUFOLEdBQVVELENBQVYsR0FBZUEsSUFBSSxJQUFKLEdBQVdDLENBQVgsR0FBZSxHQUFyQztBQUNELEtBSkksQ0FBUDtBQUtEOztBQUVELFdBQVNDLFlBQVQsR0FBd0I7QUFDdEIsUUFBSTdMLE1BQU0sSUFBSXRDLEtBQUosRUFBVjs7QUFDQSxRQUFJLENBQUNzQyxJQUFJMkYsS0FBVCxFQUFnQjtBQUNkO0FBQ0E7QUFDQSxVQUFJO0FBQ0YsY0FBTSxJQUFJakksS0FBSixDQUFVLENBQVYsQ0FBTjtBQUNELE9BRkQsQ0FFRSxPQUFNb08sQ0FBTixFQUFTO0FBQ1Q5TCxjQUFNOEwsQ0FBTjtBQUNEOztBQUNELFVBQUksQ0FBQzlMLElBQUkyRixLQUFULEVBQWdCO0FBQ2QsZUFBTyw0QkFBUDtBQUNEO0FBQ0Y7O0FBQ0QsV0FBTzNGLElBQUkyRixLQUFKLENBQVVySCxRQUFWLEVBQVA7QUFDRDs7QUFFRCxXQUFTeU4sVUFBVCxHQUFzQjtBQUNwQixRQUFJQyxLQUFLSCxjQUFUO0FBQ0EsUUFBSTdPLFFBQU8saUJBQVAsQ0FBSixFQUErQmdQLE1BQU0sT0FBT2hQLFFBQU8saUJBQVAsR0FBYjtBQUMvQixXQUFPeU8sWUFBWU8sRUFBWixDQUFQO0FBQ0QsR0FyaEM2QixDQXVoQzlCOzs7QUFFQSxNQUFJQyxZQUFZLEtBQWhCO0FBQ0EsTUFBSUMsaUJBQWlCLEtBQXJCO0FBQ0EsTUFBSUMsa0JBQWtCLFFBQXRCO0FBQ0EsTUFBSUMsbUJBQW1CLFFBQXZCOztBQUVBLFdBQVNDLE9BQVQsQ0FBaUJWLENBQWpCLEVBQW9CVyxRQUFwQixFQUE4QjtBQUM1QixRQUFJWCxJQUFJVyxRQUFKLEdBQWUsQ0FBbkIsRUFBc0I7QUFDcEJYLFdBQUtXLFdBQVlYLElBQUlXLFFBQXJCO0FBQ0Q7O0FBQ0QsV0FBT1gsQ0FBUDtBQUNEOztBQUVELE1BQUlZLElBQUo7QUFDQTtBQUNFL04sUUFGRjtBQUdBO0FBQ0UrSCxPQUpGO0FBS0E7QUFDRTBCLFFBTkY7QUFPQTtBQUNFekIsUUFSRjtBQVNBO0FBQ0VnRyxTQVZGO0FBV0E7QUFDRTVLLFFBWkY7QUFhQTtBQUNFNkssU0FkRjtBQWVBO0FBQ0UxRixTQWhCRjtBQWlCQTtBQUNFQyxTQWxCRjs7QUFvQkEsV0FBUzBGLGtCQUFULENBQTRCQyxHQUE1QixFQUFpQztBQUMvQjNQLFlBQU8sUUFBUCxJQUFtQndCLFNBQVNtTyxHQUE1QjtBQUNEOztBQUVELFdBQVNDLHVCQUFULEdBQW1DO0FBQ2pDNVAsWUFBTyxPQUFQLElBQWtCdUosUUFBUSxJQUFJc0csU0FBSixDQUFjck8sTUFBZCxDQUExQjtBQUNBeEIsWUFBTyxRQUFQLElBQW1Cd0osU0FBUyxJQUFJc0csVUFBSixDQUFldE8sTUFBZixDQUE1QjtBQUNBeEIsWUFBTyxRQUFQLElBQW1CNEUsU0FBUyxJQUFJbUwsVUFBSixDQUFldk8sTUFBZixDQUE1QjtBQUNBeEIsWUFBTyxRQUFQLElBQW1CaUwsU0FBUyxJQUFJeEosVUFBSixDQUFlRCxNQUFmLENBQTVCO0FBQ0F4QixZQUFPLFNBQVAsSUFBb0J3UCxVQUFVLElBQUlRLFdBQUosQ0FBZ0J4TyxNQUFoQixDQUE5QjtBQUNBeEIsWUFBTyxTQUFQLElBQW9CeVAsVUFBVSxJQUFJUSxXQUFKLENBQWdCek8sTUFBaEIsQ0FBOUI7QUFDQXhCLFlBQU8sU0FBUCxJQUFvQitKLFVBQVUsSUFBSW1HLFlBQUosQ0FBaUIxTyxNQUFqQixDQUE5QjtBQUNBeEIsWUFBTyxTQUFQLElBQW9CZ0ssVUFBVSxJQUFJbUcsWUFBSixDQUFpQjNPLE1BQWpCLENBQTlCO0FBQ0Q7O0FBRUQsTUFBSTRPLFdBQUosRUFBaUIzTCxTQUFqQixFQUE0QkQsWUFBNUIsQ0F4a0M4QixDQXdrQ1k7O0FBQzFDLE1BQUk2TCxVQUFKLEVBQWdCQyxRQUFoQixFQUEwQkMsU0FBMUIsQ0F6a0M4QixDQXlrQ087O0FBQ3JDLE1BQUlDLFlBQUosRUFBa0I3TCxjQUFsQixDQTFrQzhCLENBMGtDSTs7QUFFaEN5TCxnQkFBYzNMLFlBQVk0TCxhQUFhQyxXQUFXQyxZQUFZQyxlQUFlN0wsaUJBQWlCLENBQTlGO0FBQ0FILGlCQUFlLEtBQWYsQ0E3a0M0QixDQWdsQzlCOztBQUNBLFdBQVNpTSxnQkFBVCxHQUE0QjtBQUMxQi9PLFdBQU8sQ0FBQzZPLFlBQVksQ0FBYixLQUFtQixDQUExQjtBQUNBZCxZQUFRLENBQUNjLGFBQWEsQ0FBZCxJQUFpQixDQUF6QixJQUE4QixVQUE5QjtBQUNBZCxZQUFRLENBQUNjLGFBQWEsQ0FBZCxJQUFpQixDQUF6QixJQUE4QixVQUE5QjtBQUNEOztBQUVELFdBQVNHLGdCQUFULEdBQTRCO0FBQzFCLFFBQUlqQixRQUFRLENBQUNjLGFBQWEsQ0FBZCxJQUFpQixDQUF6QixLQUErQixVQUEvQixJQUE2Q2QsUUFBUSxDQUFDYyxhQUFhLENBQWQsSUFBaUIsQ0FBekIsS0FBK0IsVUFBaEYsRUFBNEY7QUFDMUZsTSxZQUFNLHNIQUFzSG9MLFFBQVEsQ0FBQ2MsYUFBYSxDQUFkLElBQWlCLENBQXpCLEVBQTRCalAsUUFBNUIsQ0FBcUMsRUFBckMsQ0FBdEgsR0FBaUssR0FBakssR0FBdUttTyxRQUFRLENBQUNjLGFBQWEsQ0FBZCxJQUFpQixDQUF6QixFQUE0QmpQLFFBQTVCLENBQXFDLEVBQXJDLENBQTdLO0FBQ0QsS0FIeUIsQ0FJMUI7OztBQUNBLFFBQUlzRCxPQUFPLENBQVAsTUFBYztBQUFXO0FBQTdCLE1BQTJDLE1BQU0sbUZBQU47QUFDNUM7O0FBRUQsV0FBUytMLGtCQUFULENBQTRCQyxTQUE1QixFQUF1QztBQUNyQ3ZNLFVBQU0sMkNBQTJDdU0sU0FBM0MsR0FBdUQsMENBQXZELElBQXFHTCxZQUFZdk0sWUFBWixHQUEwQjRNLFNBQS9ILElBQTRJLG1CQUFsSjtBQUNEOztBQUVELFdBQVNDLHVCQUFULEdBQW1DO0FBQ2pDeE0sVUFBTSxvSEFBb0hTLFlBQXBILEdBQW1JLG9NQUF6STtBQUNEOztBQUdELFdBQVNFLGFBQVQsR0FBeUI7QUFDdkI2TDtBQUNEOztBQUdELE1BQUlDLGNBQWM5USxRQUFPLGFBQVAsS0FBeUIsT0FBM0M7QUFDQSxNQUFJOEUsZUFBZTlFLFFBQU8sY0FBUCxLQUEwQixRQUE3QztBQUNBLE1BQUk4RSxlQUFlZ00sV0FBbkIsRUFBZ0M5USxRQUFPNEQsUUFBUCxDQUFnQix5REFBeURrQixZQUF6RCxHQUF3RSxpQkFBeEUsR0FBNEZnTSxXQUE1RixHQUEwRyxHQUExSCxFQS9tQ0YsQ0FpbkM5QjtBQUNBOztBQUNBcFAsU0FBTyxPQUFPcU8sVUFBUCxLQUFzQixXQUF0QixJQUFxQyxPQUFPSSxZQUFQLEtBQXdCLFdBQTdELElBQTRFSixXQUFXcEosU0FBWCxDQUFxQnFFLFFBQXJCLEtBQWtDbEgsU0FBOUcsSUFBMkhpTSxXQUFXcEosU0FBWCxDQUFxQnVFLEdBQXJCLEtBQTZCcEgsU0FBL0osRUFDTyxxREFEUCxFQW5uQzhCLENBd25DOUI7O0FBQ0EsTUFBSTlELFFBQU8sUUFBUCxDQUFKLEVBQXNCO0FBQ3BCd0IsYUFBU3hCLFFBQU8sUUFBUCxDQUFUO0FBQ0EwQixXQUFPRixPQUFPdVAsVUFBUCxLQUFzQmpNLFlBQTdCLEVBQTJDLCtCQUErQkEsWUFBL0IsR0FBOEMsb0JBQTlDLEdBQXFFdEQsT0FBT3VQLFVBQXZIO0FBQ0QsR0FIRCxNQUdPO0FBQ0w7QUFDQSxRQUFJLFFBQU9DLFdBQVAseUNBQU9BLFdBQVAsT0FBdUIsUUFBdkIsSUFBbUMsT0FBT0EsWUFBWUMsTUFBbkIsS0FBOEIsVUFBckUsRUFBaUY7QUFDL0V2UCxhQUFPb0QsZUFBZW9LLGNBQWYsS0FBa0MsQ0FBekM7QUFDQWxQLGNBQU8sWUFBUCxJQUF1QixJQUFJZ1IsWUFBWUMsTUFBaEIsQ0FBdUI7QUFBRSxtQkFBV25NLGVBQWVvSyxjQUE1QjtBQUE0QyxtQkFBV3BLLGVBQWVvSztBQUF0RSxPQUF2QixDQUF2QjtBQUNBMU4sZUFBU3hCLFFBQU8sWUFBUCxFQUFxQndCLE1BQTlCO0FBQ0QsS0FKRCxNQUtBO0FBQ0VBLGVBQVMsSUFBSTBQLFdBQUosQ0FBZ0JwTSxZQUFoQixDQUFUO0FBQ0Q7O0FBQ0RwRCxXQUFPRixPQUFPdVAsVUFBUCxLQUFzQmpNLFlBQTdCO0FBQ0E5RSxZQUFPLFFBQVAsSUFBbUJ3QixNQUFuQjtBQUNEOztBQUNEb087O0FBR0EsV0FBU3VCLGNBQVQsR0FBMEI7QUFDeEIsV0FBT3JNLFlBQVA7QUFDRCxHQTlvQzZCLENBZ3BDOUI7OztBQUNFRixTQUFPLENBQVAsSUFBWSxVQUFaO0FBQXdCOztBQUMxQjRFLFNBQU8sQ0FBUCxJQUFZLE1BQVo7QUFDQSxNQUFJeUIsT0FBTyxDQUFQLE1BQWMsSUFBZCxJQUFzQkEsT0FBTyxDQUFQLE1BQWMsSUFBeEMsRUFBOEMsTUFBTSx5REFBTjs7QUFFOUMsV0FBU21HLG9CQUFULENBQThCQyxTQUE5QixFQUF5QztBQUN2QyxXQUFNQSxVQUFVMVAsTUFBVixHQUFtQixDQUF6QixFQUE0QjtBQUMxQixVQUFJMlAsV0FBV0QsVUFBVUUsS0FBVixFQUFmOztBQUNBLFVBQUksT0FBT0QsUUFBUCxJQUFtQixVQUF2QixFQUFtQztBQUNqQ0E7QUFDQTtBQUNEOztBQUNELFVBQUl0TCxPQUFPc0wsU0FBU3RMLElBQXBCOztBQUNBLFVBQUksT0FBT0EsSUFBUCxLQUFnQixRQUFwQixFQUE4QjtBQUM1QixZQUFJc0wsU0FBUzVLLEdBQVQsS0FBaUI1QyxTQUFyQixFQUFnQztBQUM5QjlELGtCQUFPLFdBQVAsRUFBb0JnRyxJQUFwQjtBQUNELFNBRkQsTUFFTztBQUNMaEcsa0JBQU8sWUFBUCxFQUFxQmdHLElBQXJCLEVBQTJCc0wsU0FBUzVLLEdBQXBDO0FBQ0Q7QUFDRixPQU5ELE1BTU87QUFDTFYsYUFBS3NMLFNBQVM1SyxHQUFULEtBQWlCNUMsU0FBakIsR0FBNkIsSUFBN0IsR0FBb0N3TixTQUFTNUssR0FBbEQ7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsTUFBSThLLGVBQWdCLEVBQXBCLENBenFDOEIsQ0F5cUNOOztBQUN4QixNQUFJQyxhQUFnQixFQUFwQixDQTFxQzhCLENBMHFDTjs7QUFDeEIsTUFBSUMsYUFBZ0IsRUFBcEIsQ0EzcUM4QixDQTJxQ047O0FBQ3hCLE1BQUlDLGFBQWdCLEVBQXBCLENBNXFDOEIsQ0E0cUNOOztBQUN4QixNQUFJQyxnQkFBZ0IsRUFBcEIsQ0E3cUM4QixDQTZxQ047O0FBRXhCLE1BQUlyRyxxQkFBcUIsS0FBekI7QUFDQSxNQUFJc0csZ0JBQWdCLEtBQXBCOztBQUdBLFdBQVNDLE1BQVQsR0FBa0I7QUFDaEI7QUFDQSxRQUFJOVIsUUFBTyxRQUFQLENBQUosRUFBc0I7QUFDcEIsVUFBSSxPQUFPQSxRQUFPLFFBQVAsQ0FBUCxJQUEyQixVQUEvQixFQUEyQ0EsUUFBTyxRQUFQLElBQW1CLENBQUNBLFFBQU8sUUFBUCxDQUFELENBQW5COztBQUMzQyxhQUFPQSxRQUFPLFFBQVAsRUFBaUIyQixNQUF4QixFQUFnQztBQUM5Qm9RLG9CQUFZL1IsUUFBTyxRQUFQLEVBQWlCdVIsS0FBakIsRUFBWjtBQUNEO0FBQ0Y7O0FBQ0RILHlCQUFxQkksWUFBckI7QUFDRDs7QUFFRCxXQUFTUSxpQkFBVCxHQUE2QjtBQUMzQnRCO0FBQ0EsUUFBSW5GLGtCQUFKLEVBQXdCO0FBQ3hCQSx5QkFBcUIsSUFBckI7QUFDQTZGLHlCQUFxQkssVUFBckI7QUFDRDs7QUFFRCxXQUFTUSxPQUFULEdBQW1CO0FBQ2pCdkI7QUFDQVUseUJBQXFCTSxVQUFyQjtBQUNEOztBQUVELFdBQVNRLFdBQVQsR0FBdUI7QUFDckJ4QjtBQUNBVSx5QkFBcUJPLFVBQXJCO0FBQ0FFLG9CQUFnQixJQUFoQjtBQUNEOztBQUVELFdBQVNNLE9BQVQsR0FBbUI7QUFDakJ6Qix1QkFEaUIsQ0FFakI7O0FBQ0EsUUFBSTFRLFFBQU8sU0FBUCxDQUFKLEVBQXVCO0FBQ3JCLFVBQUksT0FBT0EsUUFBTyxTQUFQLENBQVAsSUFBNEIsVUFBaEMsRUFBNENBLFFBQU8sU0FBUCxJQUFvQixDQUFDQSxRQUFPLFNBQVAsQ0FBRCxDQUFwQjs7QUFDNUMsYUFBT0EsUUFBTyxTQUFQLEVBQWtCMkIsTUFBekIsRUFBaUM7QUFDL0J5USxxQkFBYXBTLFFBQU8sU0FBUCxFQUFrQnVSLEtBQWxCLEVBQWI7QUFDRDtBQUNGOztBQUNESCx5QkFBcUJRLGFBQXJCO0FBQ0Q7O0FBRUQsV0FBU0csV0FBVCxDQUFxQk0sRUFBckIsRUFBeUI7QUFDdkJiLGlCQUFhYyxPQUFiLENBQXFCRCxFQUFyQjtBQUNEOztBQUVELFdBQVNFLFNBQVQsQ0FBbUJGLEVBQW5CLEVBQXVCO0FBQ3JCWixlQUFXYSxPQUFYLENBQW1CRCxFQUFuQjtBQUNEOztBQUVELFdBQVNHLFlBQVQsQ0FBc0JILEVBQXRCLEVBQTBCO0FBQ3hCWCxlQUFXWSxPQUFYLENBQW1CRCxFQUFuQjtBQUNEOztBQUVELFdBQVNJLFNBQVQsQ0FBbUJKLEVBQW5CLEVBQXVCO0FBQ3JCVixlQUFXVyxPQUFYLENBQW1CRCxFQUFuQjtBQUNEOztBQUVELFdBQVNELFlBQVQsQ0FBc0JDLEVBQXRCLEVBQTBCO0FBQ3hCVCxrQkFBY1UsT0FBZCxDQUFzQkQsRUFBdEI7QUFDRCxHQTl1QzZCLENBZ3ZDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7OztBQUNBLFdBQVNLLG1CQUFULENBQTZCQyxNQUE3QixFQUFxQ25SLE1BQXJDLEVBQTZDb1IsV0FBN0MsRUFBMEQ7QUFDeERsTixhQUFTLHlGQUFUO0FBRUE7QUFBSTtBQUFzQm1OLFlBQTFCO0FBQW9DO0FBQXNCaE8sT0FBMUQ7O0FBQ0EsUUFBSStOLFdBQUosRUFBaUI7QUFDZjtBQUNBO0FBQ0E7QUFDQS9OLFlBQU1yRCxTQUFTaU0sZ0JBQWdCa0YsTUFBaEIsQ0FBZjtBQUNBRSxpQkFBV3RKLE1BQU0xRSxHQUFOLENBQVg7QUFDRDs7QUFDRHVELGlCQUFhdUssTUFBYixFQUFxQm5SLE1BQXJCLEVBQTZCc1IsUUFBN0I7QUFDQSxRQUFJRixXQUFKLEVBQWlCckosTUFBTTFFLEdBQU4sSUFBYWdPLFFBQWIsQ0FadUMsQ0FZaEI7QUFDekM7O0FBRUQsV0FBUzVLLGtCQUFULENBQTRCOEssS0FBNUIsRUFBbUN2UixNQUFuQyxFQUEyQztBQUN6Q0UsV0FBT3FSLE1BQU1wUixNQUFOLElBQWdCLENBQXZCLEVBQTBCLGlGQUExQjtBQUNBNEgsVUFBTTJCLEdBQU4sQ0FBVTZILEtBQVYsRUFBaUJ2UixNQUFqQjtBQUNEOztBQUVELFdBQVMySyxrQkFBVCxDQUE0QmpFLEdBQTVCLEVBQWlDMUcsTUFBakMsRUFBeUNvUixXQUF6QyxFQUFzRDtBQUNwRCxTQUFLLElBQUkzTSxJQUFJLENBQWIsRUFBZ0JBLElBQUlpQyxJQUFJdkcsTUFBeEIsRUFBZ0MsRUFBRXNFLENBQWxDLEVBQXFDO0FBQ25DdkUsYUFBT3dHLElBQUlzRixVQUFKLENBQWV2SCxDQUFmLE1BQXNCaUMsSUFBSXNGLFVBQUosQ0FBZXZILENBQWYsQ0FBdEIsR0FBd0MsSUFBL0M7QUFDQXNELFlBQVEvSCxRQUFELElBQVksQ0FBbkIsSUFBdUIwRyxJQUFJc0YsVUFBSixDQUFldkgsQ0FBZixDQUF2QjtBQUNELEtBSm1ELENBS3BEOzs7QUFDQSxRQUFJLENBQUMyTSxXQUFMLEVBQWtCckosTUFBUS9ILE1BQUQsSUFBVSxDQUFqQixJQUFxQixDQUFyQjtBQUNuQjs7QUFFRCxXQUFTd1IsTUFBVCxDQUFnQjVKLEtBQWhCLEVBQXVCN0QsSUFBdkIsRUFBNkIwTixNQUE3QixFQUFxQztBQUNuQyxRQUFJN0osU0FBUyxDQUFiLEVBQWdCO0FBQ2QsYUFBT0EsS0FBUDtBQUNEOztBQUNELFdBQU83RCxRQUFRLEVBQVIsR0FBYSxJQUFFSixLQUFLK04sR0FBTCxDQUFTLEtBQU0zTixPQUFLLENBQXBCLENBQUYsR0FBNEI2RCxLQUF6QyxDQUErQztBQUEvQyxNQUNhakUsS0FBS2dPLEdBQUwsQ0FBUyxDQUFULEVBQVk1TixJQUFaLElBQTRCNkQsS0FEaEQ7QUFFRDs7QUFDRCxXQUFTZ0ssTUFBVCxDQUFnQmhLLEtBQWhCLEVBQXVCN0QsSUFBdkIsRUFBNkIwTixNQUE3QixFQUFxQztBQUNuQyxRQUFJN0osU0FBUyxDQUFiLEVBQWdCO0FBQ2QsYUFBT0EsS0FBUDtBQUNEOztBQUNELFFBQUlpSyxPQUFPOU4sUUFBUSxFQUFSLEdBQWFKLEtBQUsrTixHQUFMLENBQVMsS0FBTTNOLE9BQUssQ0FBcEIsQ0FBYixDQUFxQztBQUFyQyxNQUNhSixLQUFLZ08sR0FBTCxDQUFTLENBQVQsRUFBWTVOLE9BQUssQ0FBakIsQ0FEeEI7O0FBRUEsUUFBSTZELFNBQVNpSyxJQUFULEtBQWtCOU4sUUFBUSxFQUFSLElBQWM2RCxRQUFRaUssSUFBeEMsQ0FBSixFQUFtRDtBQUFFO0FBQ0E7QUFDQTtBQUNuRGpLLGNBQVEsQ0FBQyxDQUFELEdBQUdpSyxJQUFILEdBQVVqSyxLQUFsQixDQUhpRCxDQUd4QjtBQUMxQjs7QUFDRCxXQUFPQSxLQUFQO0FBQ0Q7O0FBRUQxSCxTQUFPeUQsS0FBSyxNQUFMLEtBQWdCQSxLQUFLLFFBQUwsQ0FBaEIsSUFBa0NBLEtBQUssT0FBTCxDQUFsQyxJQUFtREEsS0FBSyxPQUFMLENBQTFELEVBQXlFLHdEQUF6RTtBQUVBLE1BQUl3RSxXQUFXeEUsS0FBSytOLEdBQXBCO0FBQ0EsTUFBSUksV0FBV25PLEtBQUtvTyxHQUFwQjtBQUNBLE1BQUlDLFdBQVdyTyxLQUFLc08sR0FBcEI7QUFDQSxNQUFJQyxXQUFXdk8sS0FBS3dPLEdBQXBCO0FBQ0EsTUFBSUMsWUFBWXpPLEtBQUswTyxJQUFyQjtBQUNBLE1BQUlDLFlBQVkzTyxLQUFLNE8sSUFBckI7QUFDQSxNQUFJQyxZQUFZN08sS0FBSzhPLElBQXJCO0FBQ0EsTUFBSUMsYUFBYS9PLEtBQUtnUCxLQUF0QjtBQUNBLE1BQUlDLFdBQVdqUCxLQUFLa1AsR0FBcEI7QUFDQSxNQUFJQyxXQUFXblAsS0FBS3pCLEdBQXBCO0FBQ0EsTUFBSTZRLFlBQVlwUCxLQUFLcVAsSUFBckI7QUFDQSxNQUFJMUssWUFBWTNFLEtBQUtDLElBQXJCO0FBQ0EsTUFBSXlFLGFBQWExRSxLQUFLc1AsS0FBdEI7QUFDQSxNQUFJQyxXQUFXdlAsS0FBS2dPLEdBQXBCO0FBQ0EsTUFBSXdCLFlBQVl4UCxLQUFLeVAsSUFBckI7QUFDQSxNQUFJQyxjQUFjMVAsS0FBSzJQLE1BQXZCO0FBQ0EsTUFBSUMsYUFBYTVQLEtBQUs2UCxLQUF0QjtBQUNBLE1BQUlwTCxXQUFXekUsS0FBSzBHLEdBQXBCO0FBQ0EsTUFBSW9KLFdBQVc5UCxLQUFLMkYsR0FBcEI7QUFDQSxNQUFJb0ssYUFBYS9QLEtBQUtnUSxLQUF0QjtBQUNBLE1BQUlDLGFBQWFqUSxLQUFLa1EsS0FBdEIsQ0E3ekM4QixDQSt6QzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLE1BQUlDLGtCQUFrQixDQUF0QjtBQUNBLE1BQUlDLHVCQUF1QixJQUEzQjtBQUNBLE1BQUlDLHdCQUF3QixJQUE1QixDQXgwQzhCLENBdzBDSTs7QUFDbEMsTUFBSUMsd0JBQXdCLEVBQTVCOztBQUVBLFdBQVNDLHNCQUFULENBQWdDQyxFQUFoQyxFQUFvQztBQUNsQyxRQUFJQyxPQUFPRCxFQUFYOztBQUNBLFdBQU8sQ0FBUCxFQUFVO0FBQ1IsVUFBSSxDQUFDRixzQkFBc0JFLEVBQXRCLENBQUwsRUFBZ0MsT0FBT0EsRUFBUDtBQUNoQ0EsV0FBS0MsT0FBT3pRLEtBQUswUSxNQUFMLEVBQVo7QUFDRDs7QUFDRCxXQUFPRixFQUFQO0FBQ0Q7O0FBRUQsV0FBU0csZ0JBQVQsQ0FBMEJILEVBQTFCLEVBQThCO0FBQzVCTDs7QUFDQSxRQUFJdFYsUUFBTyx3QkFBUCxDQUFKLEVBQXNDO0FBQ3BDQSxjQUFPLHdCQUFQLEVBQWlDc1YsZUFBakM7QUFDRDs7QUFDRCxRQUFJSyxFQUFKLEVBQVE7QUFDTmpVLGFBQU8sQ0FBQytULHNCQUFzQkUsRUFBdEIsQ0FBUjtBQUNBRiw0QkFBc0JFLEVBQXRCLElBQTRCLENBQTVCOztBQUNBLFVBQUlKLHlCQUF5QixJQUF6QixJQUFpQyxPQUFPUSxXQUFQLEtBQXVCLFdBQTVELEVBQXlFO0FBQ3ZFO0FBQ0FSLCtCQUF1QlEsWUFBWSxZQUFXO0FBQzVDLGNBQUl0TyxLQUFKLEVBQVc7QUFDVHVPLDBCQUFjVCxvQkFBZDtBQUNBQSxtQ0FBdUIsSUFBdkI7QUFDQTtBQUNEOztBQUNELGNBQUkzUCxRQUFRLEtBQVo7O0FBQ0EsZUFBSyxJQUFJcVEsR0FBVCxJQUFnQlIscUJBQWhCLEVBQXVDO0FBQ3JDLGdCQUFJLENBQUM3UCxLQUFMLEVBQVk7QUFDVkEsc0JBQVEsSUFBUjs7QUFDQTVGLHNCQUFPNEQsUUFBUCxDQUFnQixvQ0FBaEI7QUFDRDs7QUFDRDVELG9CQUFPNEQsUUFBUCxDQUFnQixpQkFBaUJxUyxHQUFqQztBQUNEOztBQUNELGNBQUlyUSxLQUFKLEVBQVc7QUFDVDVGLG9CQUFPNEQsUUFBUCxDQUFnQixlQUFoQjtBQUNEO0FBQ0YsU0FqQnNCLEVBaUJwQixLQWpCb0IsQ0FBdkI7QUFrQkQ7QUFDRixLQXhCRCxNQXdCTztBQUNMNUQsY0FBTzRELFFBQVAsQ0FBZ0IsMENBQWhCO0FBQ0Q7QUFDRjs7QUFFRCxXQUFTc1MsbUJBQVQsQ0FBNkJQLEVBQTdCLEVBQWlDO0FBQy9CTDs7QUFDQSxRQUFJdFYsUUFBTyx3QkFBUCxDQUFKLEVBQXNDO0FBQ3BDQSxjQUFPLHdCQUFQLEVBQWlDc1YsZUFBakM7QUFDRDs7QUFDRCxRQUFJSyxFQUFKLEVBQVE7QUFDTmpVLGFBQU8rVCxzQkFBc0JFLEVBQXRCLENBQVA7QUFDQSxhQUFPRixzQkFBc0JFLEVBQXRCLENBQVA7QUFDRCxLQUhELE1BR087QUFDTDNWLGNBQU80RCxRQUFQLENBQWdCLDRDQUFoQjtBQUNEOztBQUNELFFBQUkwUixtQkFBbUIsQ0FBdkIsRUFBMEI7QUFDeEIsVUFBSUMseUJBQXlCLElBQTdCLEVBQW1DO0FBQ2pDUyxzQkFBY1Qsb0JBQWQ7QUFDQUEsK0JBQXVCLElBQXZCO0FBQ0Q7O0FBQ0QsVUFBSUMscUJBQUosRUFBMkI7QUFDekIsWUFBSWxFLFdBQVdrRSxxQkFBZjtBQUNBQSxnQ0FBd0IsSUFBeEI7QUFDQWxFLG1CQUh5QixDQUdiO0FBQ2I7QUFDRjtBQUNGOztBQUVEdFIsVUFBTyxpQkFBUCxJQUE0QixFQUE1QixDQTk0QzhCLENBODRDRTs7QUFDaENBLFVBQU8saUJBQVAsSUFBNEIsRUFBNUIsQ0EvNEM4QixDQSs0Q0U7O0FBSWhDLE1BQUltVyxvQkFBb0IsSUFBeEI7QUFJQTtBQUFJO0FBQWlFQyxPQUFLO0FBQ3hFQyxXQUFPLGlCQUFXO0FBQ2hCaFMsWUFBTSxrUEFBTjtBQUNELEtBSHVFO0FBSXhFaVMsVUFBTSxnQkFBVztBQUFFRixTQUFHQyxLQUFIO0FBQVksS0FKeUM7QUFLeEVFLG9CQUFnQiwwQkFBVztBQUFFSCxTQUFHQyxLQUFIO0FBQVksS0FMK0I7QUFNeEVHLHlCQUFxQiwrQkFBVztBQUFFSixTQUFHQyxLQUFIO0FBQVksS0FOMEI7QUFPeEVJLG9CQUFnQiwwQkFBVztBQUFFTCxTQUFHQyxLQUFIO0FBQVksS0FQK0I7QUFReEV4VCxVQUFNLGdCQUFXO0FBQUV1VCxTQUFHQyxLQUFIO0FBQVksS0FSeUM7QUFTeEVLLFdBQU8saUJBQVc7QUFBRU4sU0FBR0MsS0FBSDtBQUFZLEtBVHdDO0FBVXhFTSxvQkFBZ0IsMEJBQVc7QUFBRVAsU0FBR0MsS0FBSDtBQUFZLEtBVitCO0FBV3hFTyxpQkFBYSx1QkFBVztBQUFFUixTQUFHQyxLQUFIO0FBQVksS0FYa0M7QUFZeEVRLHFCQUFpQiwyQkFBVztBQUFFVCxTQUFHQyxLQUFIO0FBQVksS0FaOEI7QUFjeEVTLGdCQUFZLFNBQVNBLFVBQVQsR0FBc0I7QUFBRVYsU0FBR0MsS0FBSDtBQUFZO0FBZHdCLEdBQTFFO0FBZ0JBclcsVUFBTyxtQkFBUCxJQUE4Qm9XLEdBQUdHLGNBQWpDO0FBQ0F2VyxVQUFPLHdCQUFQLElBQW1Db1csR0FBR0ksbUJBQXRDLENBeDZDOEIsQ0E0NkM5Qjs7QUFDQSxNQUFJTyxnQkFBZ0IsdUNBQXBCLENBNzZDOEIsQ0ErNkM5Qjs7QUFDQSxXQUFTQyxTQUFULENBQW1CL1YsUUFBbkIsRUFBNkI7QUFDM0IsV0FBTzBLLE9BQU9oRixTQUFQLENBQWlCc1EsVUFBakIsR0FDSGhXLFNBQVNnVyxVQUFULENBQW9CRixhQUFwQixDQURHLEdBRUg5VixTQUFTaVcsT0FBVCxDQUFpQkgsYUFBakIsTUFBb0MsQ0FGeEM7QUFHRDs7QUFLRCxXQUFTSSxlQUFULEdBQTJCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQSxRQUFJQyxTQUFTLGFBQWI7QUFFQSxRQUFJQyxlQUFlLEVBQW5CO0FBQ0EsUUFBSUMsaUJBQWlCLDJtdkVBQXJCO0FBQ0EsUUFBSUMsZ0JBQWdCLEVBQXBCOztBQUVBLFFBQUksT0FBT3ZYLFFBQU8sWUFBUCxDQUFQLEtBQWdDLFVBQXBDLEVBQWdEO0FBQzlDLFVBQUksQ0FBQ2dYLFVBQVVLLFlBQVYsQ0FBTCxFQUE4QjtBQUM1QkEsdUJBQWVyWCxRQUFPLFlBQVAsRUFBcUJxWCxZQUFyQixDQUFmO0FBQ0Q7O0FBQ0QsVUFBSSxDQUFDTCxVQUFVTSxjQUFWLENBQUwsRUFBZ0M7QUFDOUJBLHlCQUFpQnRYLFFBQU8sWUFBUCxFQUFxQnNYLGNBQXJCLENBQWpCO0FBQ0Q7O0FBQ0QsVUFBSSxDQUFDTixVQUFVTyxhQUFWLENBQUwsRUFBK0I7QUFDN0JBLHdCQUFnQnZYLFFBQU8sWUFBUCxFQUFxQnVYLGFBQXJCLENBQWhCO0FBQ0Q7QUFDRixLQTlCd0IsQ0FnQ3pCOzs7QUFFQSxRQUFJQyxlQUFlLEtBQUcsSUFBdEI7QUFFQSxRQUFJQyxPQUFPO0FBQ1QsZ0JBQVUsSUFERDtBQUVULGFBQU8sSUFGRTtBQUdULGtCQUFZO0FBQUU7QUFDWixtQkFBVyxnQkFBUzlJLENBQVQsRUFBWUMsQ0FBWixFQUFlO0FBQ3hCLGlCQUFPRCxJQUFJQyxDQUFYO0FBQ0QsU0FIUztBQUlWLG9CQUFZLHFCQUFXO0FBQ3JCO0FBQ0Q7QUFOUyxPQUhIO0FBV1QsZ0JBQVU1TyxPQVhELENBV1E7O0FBWFIsS0FBWDtBQWNBLFFBQUkwWCxVQUFVLElBQWQ7O0FBR0EsYUFBU0MsV0FBVCxDQUFxQkMsU0FBckIsRUFBZ0M7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFJQyxZQUFZN1gsUUFBTyxRQUFQLENBQWhCOztBQUNBLFVBQUk0WCxVQUFVN0csVUFBVixHQUF1QjhHLFVBQVU5RyxVQUFyQyxFQUFpRDtBQUMvQy9RLGdCQUFPLFVBQVAsRUFBbUIsNEdBQW5CO0FBQ0Q7O0FBQ0QsVUFBSThYLFVBQVUsSUFBSWpJLFNBQUosQ0FBY2dJLFNBQWQsQ0FBZDtBQUNBLFVBQUlFLFVBQVUsSUFBSWxJLFNBQUosQ0FBYytILFNBQWQsQ0FBZDtBQUdBRyxjQUFRN00sR0FBUixDQUFZNE0sT0FBWjtBQUNBcEkseUJBQW1Ca0ksU0FBbkI7QUFDQWhJO0FBQ0Q7O0FBRUQsYUFBU29JLFVBQVQsQ0FBb0JDLE9BQXBCLEVBQTZCO0FBQzNCLGFBQU9BLE9BQVA7QUFDRDs7QUFFRCxhQUFTQyxTQUFULEdBQXFCO0FBQ25CLFVBQUk7QUFDRixZQUFJbFksUUFBTyxZQUFQLENBQUosRUFBMEI7QUFDeEIsaUJBQU8sSUFBSXlCLFVBQUosQ0FBZXpCLFFBQU8sWUFBUCxDQUFmLENBQVA7QUFDRDs7QUFDRCxZQUFJa0IsU0FBU0Usa0JBQWtCa1csY0FBbEIsQ0FBYjs7QUFDQSxZQUFJcFcsTUFBSixFQUFZO0FBQ1YsaUJBQU9BLE1BQVA7QUFDRDs7QUFDRCxZQUFJbEIsUUFBTyxZQUFQLENBQUosRUFBMEI7QUFDeEIsaUJBQU9BLFFBQU8sWUFBUCxFQUFxQnNYLGNBQXJCLENBQVA7QUFDRCxTQUZELE1BRU87QUFDTCxnQkFBTSxxSkFBTjtBQUNEO0FBQ0YsT0FiRCxDQWNBLE9BQU90VSxHQUFQLEVBQVk7QUFDVnFCLGNBQU1yQixHQUFOO0FBQ0Q7QUFDRjs7QUFFRCxhQUFTbVYsZ0JBQVQsR0FBNEI7QUFDMUI7QUFDQTtBQUNBLFVBQUksQ0FBQ25ZLFFBQU8sWUFBUCxDQUFELEtBQTBCTSxzQkFBc0JDLHFCQUFoRCxLQUEwRSxPQUFPNlgsS0FBUCxLQUFpQixVQUEvRixFQUEyRztBQUN6RyxlQUFPQSxNQUFNZCxjQUFOLEVBQXNCO0FBQUVlLHVCQUFhO0FBQWYsU0FBdEIsRUFBc0RDLElBQXRELENBQTJELFVBQVNwVixRQUFULEVBQW1CO0FBQ25GLGNBQUksQ0FBQ0EsU0FBUyxJQUFULENBQUwsRUFBcUI7QUFDbkIsa0JBQU0seUNBQXlDb1UsY0FBekMsR0FBMEQsR0FBaEU7QUFDRDs7QUFDRCxpQkFBT3BVLFNBQVMsYUFBVCxHQUFQO0FBQ0QsU0FMTSxFQUtKcVYsS0FMSSxDQUtFLFlBQVk7QUFDbkIsaUJBQU9MLFdBQVA7QUFDRCxTQVBNLENBQVA7QUFRRCxPQVp5QixDQWExQjs7O0FBQ0EsYUFBTyxJQUFJTSxPQUFKLENBQVksVUFBU0MsT0FBVCxFQUFrQkMsTUFBbEIsRUFBMEI7QUFDM0NELGdCQUFRUCxXQUFSO0FBQ0QsT0FGTSxDQUFQO0FBR0QsS0FoSHdCLENBa0h6Qjs7O0FBR0EsYUFBU1MsWUFBVCxDQUFzQkMsTUFBdEIsRUFBOEJDLEdBQTlCLEVBQW1DQyxjQUFuQyxFQUFtRDtBQUNqRCxVQUFJLFFBQU85SCxXQUFQLHlDQUFPQSxXQUFQLE9BQXVCLFFBQTNCLEVBQXFDO0FBQ25DaFIsZ0JBQU8sVUFBUCxFQUFtQixpQ0FBbkI7O0FBQ0EsZUFBTyxLQUFQO0FBQ0QsT0FKZ0QsQ0FLakQ7OztBQUNBLFVBQUksRUFBRUEsUUFBTyxZQUFQLGFBQWdDZ1IsWUFBWUMsTUFBOUMsQ0FBSixFQUEyRDtBQUN6RGpSLGdCQUFPLFVBQVAsRUFBbUIsOEJBQW5COztBQUNBLGVBQU8sS0FBUDtBQUNEOztBQUNENlksVUFBSSxRQUFKLElBQWdCN1ksUUFBTyxZQUFQLENBQWhCLENBVmlELENBV2pEOztBQUNBeVgsV0FBSyxRQUFMLElBQWlCO0FBQ2YsZUFBT3NCLEdBRFE7QUFFZixvQkFBWWpHO0FBRkcsT0FBakI7QUFJQTJFLFdBQUssYUFBTCxJQUFzQnRTLElBQXRCO0FBQ0FzUyxXQUFLLEtBQUwsSUFBY29CLEdBQWQsQ0FqQmlELENBa0JqRDtBQUNBOztBQUNBLGVBQVNHLGVBQVQsQ0FBeUJDLFFBQXpCLEVBQW1DQyxNQUFuQyxFQUEyQztBQUN6Q3hCLGtCQUFVdUIsU0FBU3ZCLE9BQW5CO0FBQ0EsWUFBSUEsUUFBUXlCLE1BQVosRUFBb0J4QixZQUFZRCxRQUFReUIsTUFBcEI7QUFDcEJuWixnQkFBTyxLQUFQLElBQWdCMFgsT0FBaEI7QUFDQTFYLGdCQUFPLFdBQVAsSUFBc0IsSUFBdEI7QUFDQWtXLDRCQUFvQixrQkFBcEI7QUFDRDs7QUFDREosdUJBQWlCLGtCQUFqQixFQTNCaUQsQ0E2QmpEO0FBQ0E7QUFDQTs7QUFDQSxVQUFJOVYsUUFBTyxpQkFBUCxDQUFKLEVBQStCO0FBQzdCLFlBQUk7QUFDRixpQkFBT0EsUUFBTyxpQkFBUCxFQUEwQnlYLElBQTFCLEVBQWdDdUIsZUFBaEMsQ0FBUDtBQUNELFNBRkQsQ0FFRSxPQUFNbEssQ0FBTixFQUFTO0FBQ1Q5TyxrQkFBTyxVQUFQLEVBQW1CLHdEQUF3RDhPLENBQTNFOztBQUNBLGlCQUFPLEtBQVA7QUFDRDtBQUNGLE9BdkNnRCxDQXlDakQ7QUFDQTtBQUNBOzs7QUFDQSxVQUFJc0ssYUFBYXBaLE9BQWpCOztBQUNBLGVBQVNxWix5QkFBVCxDQUFtQ0MsTUFBbkMsRUFBMkM7QUFDekM7QUFDQTtBQUNBNVgsZUFBTzFCLFlBQVdvWixVQUFsQixFQUE4QixrSEFBOUI7QUFDQUEscUJBQWEsSUFBYjtBQUNBSix3QkFBZ0JNLE9BQU8sVUFBUCxDQUFoQixFQUFvQ0EsT0FBTyxRQUFQLENBQXBDO0FBQ0Q7O0FBQ0QsZUFBU0Msc0JBQVQsQ0FBZ0NDLFFBQWhDLEVBQTBDO0FBQ3hDckIsMkJBQW1CRyxJQUFuQixDQUF3QixVQUFTcFgsTUFBVCxFQUFpQjtBQUN2QyxpQkFBTzhQLFlBQVl5SSxXQUFaLENBQXdCdlksTUFBeEIsRUFBZ0N1VyxJQUFoQyxDQUFQO0FBQ0QsU0FGRCxFQUVHYSxJQUZILENBRVFrQixRQUZSLEVBRWtCakIsS0FGbEIsQ0FFd0IsVUFBU3ZXLE1BQVQsRUFBaUI7QUFDdkNoQyxrQkFBTyxVQUFQLEVBQW1CLDRDQUE0Q2dDLE1BQS9EOztBQUNBcUMsZ0JBQU1yQyxNQUFOO0FBQ0QsU0FMRDtBQU1ELE9BM0RnRCxDQTREakQ7OztBQUNBLFVBQUksQ0FBQ2hDLFFBQU8sWUFBUCxDQUFELElBQ0EsT0FBT2dSLFlBQVkwSSxvQkFBbkIsS0FBNEMsVUFENUMsSUFFQSxDQUFDMUMsVUFBVU0sY0FBVixDQUZELElBR0EsT0FBT2MsS0FBUCxLQUFpQixVQUhyQixFQUdpQztBQUMvQnBILG9CQUFZMEksb0JBQVosQ0FBaUN0QixNQUFNZCxjQUFOLEVBQXNCO0FBQUVlLHVCQUFhO0FBQWYsU0FBdEIsQ0FBakMsRUFBd0ZaLElBQXhGLEVBQ0dhLElBREgsQ0FDUWUseUJBRFIsRUFFR2QsS0FGSCxDQUVTLFVBQVN2VyxNQUFULEVBQWlCO0FBQ3RCO0FBQ0E7QUFDQWhDLGtCQUFPLFVBQVAsRUFBbUIsb0NBQW9DZ0MsTUFBdkQ7O0FBQ0FoQyxrQkFBTyxVQUFQLEVBQW1CLDJDQUFuQjs7QUFDQXVaLGlDQUF1QkYseUJBQXZCO0FBQ0QsU0FSSDtBQVNELE9BYkQsTUFhTztBQUNMRSwrQkFBdUJGLHlCQUF2QjtBQUNEOztBQUNELGFBQU8sRUFBUCxDQTdFaUQsQ0E2RXRDO0FBQ1osS0FuTXdCLENBc016Qjs7O0FBQ0FyWixZQUFPLFlBQVAsSUFBdUJBLFFBQU8sS0FBUCxDQUF2QixDQXZNeUIsQ0F5TXpCOztBQUVBLFFBQUkyWixxQkFBcUIzWixRQUFPLGVBQVAsQ0FBekI7O0FBRUEsUUFBSTRaLG9CQUFvQixTQUFwQkEsaUJBQW9CLENBQVNyVixJQUFULEVBQWU7QUFDckMsVUFBSXNWLGdCQUFnQjdaLFFBQU8sV0FBUCxJQUFzQmtQLGNBQXRCLEdBQXVDQyxlQUEzRCxDQURxQyxDQUN1Qzs7QUFDNUU1SyxhQUFPOEssUUFBUTlLLElBQVIsRUFBY3NWLGFBQWQsQ0FBUCxDQUZxQyxDQUVBOztBQUNyQyxVQUFJQyxNQUFNOVosUUFBTyxRQUFQLENBQVY7QUFDQSxVQUFJK1osVUFBVUQsSUFBSS9JLFVBQWxCOztBQUNBLFVBQUkvUSxRQUFPLFdBQVAsQ0FBSixFQUF5QjtBQUN2QjtBQUNBLFlBQUk7QUFDRixjQUFJZ2EsU0FBU2hhLFFBQU8sWUFBUCxFQUFxQmlhLElBQXJCLENBQTBCLENBQUMxVixPQUFPd1YsT0FBUixJQUFtQnZDLFlBQTdDLENBQWIsQ0FERSxDQUN1RTs7O0FBQ3pFLGNBQUl3QyxZQUFZLENBQUMsQ0FBRCxHQUFLLENBQWpCLENBQUosRUFBeUI7QUFDdkI7QUFDQSxtQkFBT2hhLFFBQU8sUUFBUCxJQUFtQkEsUUFBTyxZQUFQLEVBQXFCd0IsTUFBL0M7QUFDRCxXQUhELE1BR087QUFDTCxtQkFBTyxJQUFQO0FBQ0Q7QUFDRixTQVJELENBUUUsT0FBTXNOLENBQU4sRUFBUztBQUNUckwsa0JBQVE0UyxLQUFSLENBQWMsa0RBQWtEMEQsT0FBbEQsR0FBNkQsWUFBN0QsR0FBNEV4VixJQUE1RSxHQUFtRix5QkFBbkYsR0FBK0d1SyxDQUE3SDtBQUNBLGlCQUFPLElBQVA7QUFDRDtBQUNGO0FBQ0YsS0FwQkQ7O0FBc0JBOU8sWUFBTyxlQUFQLElBQTBCLFVBQVN1RSxJQUFULEVBQWU7QUFDdkMsVUFBSTJWLGdCQUFnQixPQUFwQixFQUE2QjtBQUMzQixlQUFPUCxtQkFBbUJwVixJQUFuQixDQUFQO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsZUFBT3FWLGtCQUFrQnJWLElBQWxCLENBQVA7QUFDRDtBQUNGLEtBTkQsQ0FuT3lCLENBMk96Qjs7O0FBQ0EsUUFBSTJWLGNBQWMsRUFBbEIsQ0E1T3lCLENBOE96QjtBQUNBO0FBQ0E7O0FBRUFsYSxZQUFPLEtBQVAsSUFBZ0IsVUFBUzRZLE1BQVQsRUFBaUJDLEdBQWpCLEVBQXNCQyxjQUF0QixFQUFzQztBQUNwREQsWUFBTWIsV0FBV2EsR0FBWCxDQUFOLENBRG9ELENBR3BEOztBQUNBLFVBQUksQ0FBQ0EsSUFBSSxPQUFKLENBQUwsRUFBbUI7QUFDakIsWUFBSXNCLGFBQWFuYSxRQUFPLGVBQVAsQ0FBakI7QUFDQSxZQUFJbWEsZUFBZXJXLFNBQW5CLEVBQThCcVcsYUFBYSxJQUFiLENBRmIsQ0FFZ0M7O0FBQ2pELFlBQUlDLGlCQUFpQnBhLFFBQU8sa0JBQVAsQ0FBckI7O0FBQ0EsWUFBSSxRQUFPZ1IsV0FBUCx5Q0FBT0EsV0FBUCxPQUF1QixRQUF2QixJQUFtQyxPQUFPQSxZQUFZcUosS0FBbkIsS0FBNkIsVUFBcEUsRUFBZ0Y7QUFDOUUsY0FBSUQsbUJBQW1CdFcsU0FBdkIsRUFBa0M7QUFDaEMrVSxnQkFBSSxPQUFKLElBQWUsSUFBSTdILFlBQVlxSixLQUFoQixDQUFzQjtBQUFFLHlCQUFXRixVQUFiO0FBQXlCLHlCQUFXQyxjQUFwQztBQUFvRCx5QkFBVztBQUEvRCxhQUF0QixDQUFmO0FBQ0QsV0FGRCxNQUVPO0FBQ0x2QixnQkFBSSxPQUFKLElBQWUsSUFBSTdILFlBQVlxSixLQUFoQixDQUFzQjtBQUFFLHlCQUFXRixVQUFiO0FBQXlCRyx1QkFBUztBQUFsQyxhQUF0QixDQUFmO0FBQ0Q7QUFDRixTQU5ELE1BTU87QUFDTHpCLGNBQUksT0FBSixJQUFlLElBQUkvUyxLQUFKLENBQVVxVSxVQUFWLENBQWYsQ0FESyxDQUNpQztBQUN2Qzs7QUFDRG5hLGdCQUFPLFdBQVAsSUFBc0I2WSxJQUFJLE9BQUosQ0FBdEI7QUFDRDs7QUFFRCxVQUFJLENBQUNBLElBQUksWUFBSixDQUFMLEVBQXdCO0FBQ3RCQSxZQUFJLFlBQUosSUFBb0I3WSxRQUFPLGFBQVAsQ0FBcEIsQ0FEc0IsQ0FDcUI7QUFDNUM7O0FBQ0QsVUFBSSxDQUFDNlksSUFBSSxXQUFKLENBQUwsRUFBdUI7QUFDckJBLFlBQUksV0FBSixJQUFtQixDQUFuQixDQURxQixDQUNDO0FBQ3ZCLE9BekJtRCxDQTJCcEQ7OztBQUVBLFVBQUluQixPQUFKO0FBQ0FBLGdCQUFVaUIsYUFBYUMsTUFBYixFQUFxQkMsR0FBckIsRUFBMEJDLGNBQTFCLENBQVY7QUFFQSxVQUFJLENBQUNwQixPQUFMLEVBQWNyVCxNQUFNLDRLQUFOO0FBR2QsYUFBT3FULE9BQVA7QUFDRCxLQXBDRDs7QUFzQ0EsUUFBSTZDLGdCQUFnQnZhLFFBQU8sS0FBUCxDQUFwQixDQXhSeUIsQ0F3UlU7QUFDcEM7O0FBRURtWCxvQkFwdEQ4QixDQXN0RDlCOztBQUVBLE1BQUlxRCxhQUFhLEVBQWpCO0FBS0FwSyxnQkFBYzVJLFdBQWQ7QUFFQS9DLGNBQVkyTCxjQUFjLElBQTFCO0FBQ0E7O0FBQTJCcUIsYUFBV2dKLElBQVg7O0FBUTNCLE1BQUlDLGNBQWMsSUFBbEI7QUFDQTFhLFVBQU8sYUFBUCxJQUF3Qm9RLFdBQXhCO0FBQ0FwUSxVQUFPLGFBQVAsSUFBd0IwYSxXQUF4QjtBQUVBOztBQUNBLE1BQUlDLGdCQUFnQmxXLFNBQXBCO0FBQStCQSxlQUFhLEVBQWI7QUFFL0IvQyxTQUFPaVosZ0JBQWdCLENBQWhCLElBQXFCLENBQTVCOztBQUVBLFdBQVNDLGFBQVQsQ0FBdUIzVCxHQUF2QixFQUE0QjtBQUFFO0FBRTVCc0MsVUFBTW9SLGFBQU4sSUFBdUJwUixNQUFNdEMsR0FBTixDQUF2QjtBQUVBc0MsVUFBTW9SLGdCQUFjLENBQXBCLElBQXlCcFIsTUFBTXRDLE1BQUksQ0FBVixDQUF6QjtBQUVBc0MsVUFBTW9SLGdCQUFjLENBQXBCLElBQXlCcFIsTUFBTXRDLE1BQUksQ0FBVixDQUF6QjtBQUVBc0MsVUFBTW9SLGdCQUFjLENBQXBCLElBQXlCcFIsTUFBTXRDLE1BQUksQ0FBVixDQUF6QjtBQUVEOztBQUVELFdBQVM0VCxjQUFULENBQXdCNVQsR0FBeEIsRUFBNkI7QUFFM0JzQyxVQUFNb1IsYUFBTixJQUF1QnBSLE1BQU10QyxHQUFOLENBQXZCO0FBRUFzQyxVQUFNb1IsZ0JBQWMsQ0FBcEIsSUFBeUJwUixNQUFNdEMsTUFBSSxDQUFWLENBQXpCO0FBRUFzQyxVQUFNb1IsZ0JBQWMsQ0FBcEIsSUFBeUJwUixNQUFNdEMsTUFBSSxDQUFWLENBQXpCO0FBRUFzQyxVQUFNb1IsZ0JBQWMsQ0FBcEIsSUFBeUJwUixNQUFNdEMsTUFBSSxDQUFWLENBQXpCO0FBRUFzQyxVQUFNb1IsZ0JBQWMsQ0FBcEIsSUFBeUJwUixNQUFNdEMsTUFBSSxDQUFWLENBQXpCO0FBRUFzQyxVQUFNb1IsZ0JBQWMsQ0FBcEIsSUFBeUJwUixNQUFNdEMsTUFBSSxDQUFWLENBQXpCO0FBRUFzQyxVQUFNb1IsZ0JBQWMsQ0FBcEIsSUFBeUJwUixNQUFNdEMsTUFBSSxDQUFWLENBQXpCO0FBRUFzQyxVQUFNb1IsZ0JBQWMsQ0FBcEIsSUFBeUJwUixNQUFNdEMsTUFBSSxDQUFWLENBQXpCO0FBRUQsR0Evd0Q2QixDQWl4RDlCOzs7QUFHRSxXQUFTNlQsT0FBVCxHQUFtQixDQUFFOztBQUdyQixNQUFJQyxXQUFTO0FBQUNDLGFBQVEsQ0FBVDtBQUFXQyxTQUFJLGFBQVVELE9BQVYsRUFBbUI7QUFDekNELGVBQVNDLE9BQVQsSUFBb0IsQ0FBcEI7QUFDQSxVQUFJN1osTUFBTXlELE9BQVVtVyxTQUFTQyxPQUFWLEdBQW9CLENBQXJCLElBQTBCLENBQWxDLENBQVY7QUFDQSxhQUFPN1osR0FBUDtBQUNELEtBSlE7QUFJUCtaLFlBQU8sa0JBQVk7QUFDbkIsVUFBSS9aLE1BQU0wSCxrQkFBa0JrUyxTQUFTRSxHQUFULEVBQWxCLENBQVY7QUFDQSxhQUFPOVosR0FBUDtBQUNELEtBUFE7QUFPUGdhLFdBQU0saUJBQVk7QUFDbEIsVUFBSXJVLE1BQU1pVSxTQUFTRSxHQUFULEVBQVY7QUFBQSxVQUEwQmxVLE9BQU9nVSxTQUFTRSxHQUFULEVBQWpDO0FBQ0EsVUFBSW5VLE9BQU8sQ0FBWCxFQUFjcEYsT0FBT3FGLFNBQVMsQ0FBaEIsRUFBZCxLQUNLckYsT0FBT3FGLFNBQVMsQ0FBQyxDQUFqQjtBQUNMLGFBQU9ELEdBQVA7QUFDRCxLQVpRO0FBWVBzVSxhQUFRLG1CQUFZO0FBQ3BCMVosYUFBT3FaLFNBQVNFLEdBQVQsT0FBbUIsQ0FBMUI7QUFDRDtBQWRRLEdBQWI7O0FBY08sV0FBU0ksYUFBVCxDQUF1QkMsS0FBdkIsRUFBOEJOLE9BQTlCLEVBQXVDO0FBQUNELGFBQVNDLE9BQVQsR0FBbUJBLE9BQW5COztBQUMvQyxRQUFJO0FBQ0g7QUFDRyxVQUFJTyxTQUFTUixTQUFTUyxlQUFULEVBQWI7QUFBQSxVQUF5Q0MsY0FBY1YsU0FBU0UsR0FBVCxFQUF2RDtBQUFBLFVBQXVFUyxhQUFhWCxTQUFTRSxHQUFULEVBQXBGO0FBQUEsVUFBb0dqQixTQUFTZSxTQUFTRSxHQUFULEVBQTdHO0FBQUEsVUFBNkhVLFNBQVNaLFNBQVNFLEdBQVQsRUFBdEksQ0FGQSxDQUdBOztBQUNBLFVBQUlXLFNBQVNGLFVBQWI7QUFDQXRGLFNBQUd5RixNQUFILENBQVVOLE1BQVYsRUFBa0JLLE1BQWxCLEVBQTBCRCxNQUExQjtBQUNBL1csYUFBU29WLE1BQUQsSUFBVSxDQUFsQixJQUFzQnVCLE9BQU9PLFFBQTdCO0FBQ0EsVUFBSVAsT0FBT1EsUUFBUCxJQUFtQkgsV0FBVyxDQUE5QixJQUFtQ0QsV0FBVyxDQUFsRCxFQUFxREosT0FBT1EsUUFBUCxHQUFrQixJQUFsQixDQVByRCxDQU82RTs7QUFDN0UsYUFBTyxDQUFQO0FBQ0QsS0FUSCxDQVNJLE9BQU9qTixDQUFQLEVBQVU7QUFDWixVQUFJLE9BQU9zSCxFQUFQLEtBQWMsV0FBZCxJQUE2QixFQUFFdEgsYUFBYXNILEdBQUdVLFVBQWxCLENBQWpDLEVBQWdFelMsTUFBTXlLLENBQU47QUFDaEUsYUFBTyxDQUFDQSxFQUFFa04sS0FBVjtBQUNEO0FBQ0E7O0FBR0QsV0FBU0MsbUJBQVQsR0FBK0I7QUFDM0I7QUFDQSxRQUFJQyxTQUFTbGMsUUFBTyxTQUFQLENBQWI7QUFDQSxRQUFJa2MsTUFBSixFQUFZQSxPQUFPLENBQVA7QUFDWixRQUFJQyxZQUFZQyxjQUFjRCxTQUE5QjtBQUNBLFFBQUksQ0FBQ0EsU0FBTCxFQUFnQjtBQUNoQixRQUFJRSxVQUFVRCxjQUFjQyxPQUE1QjtBQUNBLFFBQUlBLFFBQVEsQ0FBUixFQUFXMWEsTUFBZixFQUF1QndhLFVBQVUsQ0FBVixFQUFhLEVBQWI7QUFDdkIsUUFBSUUsUUFBUSxDQUFSLEVBQVcxYSxNQUFmLEVBQXVCd2EsVUFBVSxDQUFWLEVBQWEsRUFBYjtBQUN4Qjs7QUFBQSxXQUFTQyxhQUFULENBQXVCZCxLQUF2QixFQUE4Qk4sT0FBOUIsRUFBdUM7QUFBQ0QsYUFBU0MsT0FBVCxHQUFtQkEsT0FBbkI7O0FBQzNDLFFBQUk7QUFDSDtBQUNHO0FBQ0EsVUFBSU8sU0FBU1IsU0FBU0UsR0FBVCxFQUFiO0FBQUEsVUFBNkJxQixNQUFNdkIsU0FBU0UsR0FBVCxFQUFuQztBQUFBLFVBQW1Ec0IsU0FBU3hCLFNBQVNFLEdBQVQsRUFBNUQ7QUFDQSxVQUFJOVosTUFBTSxDQUFWOztBQUNBLFVBQUksQ0FBQ2liLGNBQWNDLE9BQW5CLEVBQTRCO0FBQzFCRCxzQkFBY0MsT0FBZCxHQUF3QixDQUFDLElBQUQsRUFBTyxFQUFQLEVBQVcsRUFBWCxDQUF4QixDQUQwQixDQUNjOztBQUN4Q0Qsc0JBQWNELFNBQWQsR0FBMEIsVUFBU1osTUFBVCxFQUFpQmxRLElBQWpCLEVBQXVCO0FBQy9DLGNBQUk3SixTQUFTNGEsY0FBY0MsT0FBZCxDQUFzQmQsTUFBdEIsQ0FBYjtBQUNBN1osaUJBQU9GLE1BQVA7O0FBQ0EsY0FBSTZKLFNBQVMsQ0FBVCxJQUFjQSxTQUFTLEVBQTNCLEVBQStCO0FBQzdCLGFBQUNrUSxXQUFXLENBQVgsR0FBZXZiLFFBQU8sT0FBUCxDQUFmLEdBQWlDQSxRQUFPLFVBQVAsQ0FBbEMsRUFBc0RzTSxrQkFBa0I5SyxNQUFsQixFQUEwQixDQUExQixDQUF0RDtBQUNBQSxtQkFBT0csTUFBUCxHQUFnQixDQUFoQjtBQUNELFdBSEQsTUFHTztBQUNMSCxtQkFBT2laLElBQVAsQ0FBWXBQLElBQVo7QUFDRDtBQUNGLFNBVEQ7QUFVRDs7QUFDRCxXQUFLLElBQUlwRixJQUFJLENBQWIsRUFBZ0JBLElBQUlzVyxNQUFwQixFQUE0QnRXLEdBQTVCLEVBQWlDO0FBQy9CLFlBQUlnQixNQUFNckMsT0FBVTBYLEdBQUQsR0FBT3JXLElBQUUsQ0FBVixJQUFlLENBQXZCLENBQVY7QUFDQSxZQUFJa0MsTUFBTXZELE9BQVUwWCxHQUFELElBQU9yVyxJQUFFLENBQUYsR0FBTSxDQUFiLENBQUQsSUFBbUIsQ0FBM0IsQ0FBVjs7QUFDQSxhQUFLLElBQUl1VyxJQUFJLENBQWIsRUFBZ0JBLElBQUlyVSxHQUFwQixFQUF5QnFVLEdBQXpCLEVBQThCO0FBQzVCSix3QkFBY0QsU0FBZCxDQUF3QlosTUFBeEIsRUFBZ0N0USxPQUFPaEUsTUFBSXVWLENBQVgsQ0FBaEM7QUFDRDs7QUFDRHJiLGVBQU9nSCxHQUFQO0FBQ0Q7O0FBQ0QsYUFBT2hILEdBQVA7QUFDRCxLQTNCSCxDQTJCSSxPQUFPMk4sQ0FBUCxFQUFVO0FBQ1osVUFBSSxPQUFPc0gsRUFBUCxLQUFjLFdBQWQsSUFBNkIsRUFBRXRILGFBQWFzSCxHQUFHVSxVQUFsQixDQUFqQyxFQUFnRXpTLE1BQU15SyxDQUFOO0FBQ2hFLGFBQU8sQ0FBQ0EsRUFBRWtOLEtBQVY7QUFDRDtBQUNBOztBQUVELFdBQVNTLFlBQVQsQ0FBc0JuQixLQUF0QixFQUE2Qk4sT0FBN0IsRUFBc0M7QUFBQ0QsYUFBU0MsT0FBVCxHQUFtQkEsT0FBbkI7O0FBQ3ZDLFFBQUk7QUFDSDtBQUNHLGFBQU8sQ0FBUDtBQUNELEtBSEgsQ0FHSSxPQUFPbE0sQ0FBUCxFQUFVO0FBQ1osVUFBSSxPQUFPc0gsRUFBUCxLQUFjLFdBQWQsSUFBNkIsRUFBRXRILGFBQWFzSCxHQUFHVSxVQUFsQixDQUFqQyxFQUFnRXpTLE1BQU15SyxDQUFOO0FBQ2hFLGFBQU8sQ0FBQ0EsRUFBRWtOLEtBQVY7QUFDRDtBQUNBOztBQUVELFdBQVNVLFdBQVQsQ0FBcUJwQixLQUFyQixFQUE0Qk4sT0FBNUIsRUFBcUM7QUFBQ0QsYUFBU0MsT0FBVCxHQUFtQkEsT0FBbkI7O0FBQ3RDLFFBQUk7QUFDSDtBQUNHLFVBQUlPLFNBQVNSLFNBQVNTLGVBQVQsRUFBYjtBQUNBcEYsU0FBR3VHLEtBQUgsQ0FBU3BCLE1BQVQ7QUFDQSxhQUFPLENBQVA7QUFDRCxLQUxILENBS0ksT0FBT3pNLENBQVAsRUFBVTtBQUNaLFVBQUksT0FBT3NILEVBQVAsS0FBYyxXQUFkLElBQTZCLEVBQUV0SCxhQUFhc0gsR0FBR1UsVUFBbEIsQ0FBakMsRUFBZ0V6UyxNQUFNeUssQ0FBTjtBQUNoRSxhQUFPLENBQUNBLEVBQUVrTixLQUFWO0FBQ0Q7QUFDQTs7QUFFRCxXQUFTWSxTQUFULEdBQXFCLENBQUU7O0FBRXZCLFdBQVNDLGlDQUFULEdBQTZDO0FBQ3pDLFdBQU8sQ0FBUDtBQUNEOztBQUtILE1BQUlDLFVBQVV2UyxTQUFTLENBQUMsQ0FBRCxFQUFHLENBQUgsRUFBSyxDQUFMLEVBQU8sQ0FBUCxFQUFTLENBQVQsRUFBVyxDQUFYLEVBQWEsQ0FBYixFQUFlLENBQWYsRUFBaUIsQ0FBakIsRUFBbUIsQ0FBbkIsRUFBcUIsQ0FBckIsRUFBdUIsQ0FBdkIsRUFBeUIsQ0FBekIsRUFBMkIsQ0FBM0IsRUFBNkIsQ0FBN0IsRUFBK0IsQ0FBL0IsRUFBaUMsQ0FBakMsRUFBbUMsQ0FBbkMsRUFBcUMsQ0FBckMsRUFBdUMsQ0FBdkMsRUFBeUMsQ0FBekMsRUFBMkMsQ0FBM0MsRUFBNkMsQ0FBN0MsRUFBK0MsQ0FBL0MsRUFBaUQsQ0FBakQsRUFBbUQsQ0FBbkQsRUFBcUQsQ0FBckQsRUFBdUQsQ0FBdkQsRUFBeUQsQ0FBekQsRUFBMkQsQ0FBM0QsRUFBNkQsQ0FBN0QsRUFBK0QsQ0FBL0QsRUFBaUUsQ0FBakUsRUFBbUUsQ0FBbkUsRUFBcUUsQ0FBckUsRUFBdUUsQ0FBdkUsRUFBeUUsQ0FBekUsRUFBMkUsQ0FBM0UsRUFBNkUsQ0FBN0UsRUFBK0UsQ0FBL0UsRUFBaUYsQ0FBakYsRUFBbUYsQ0FBbkYsRUFBcUYsQ0FBckYsRUFBdUYsQ0FBdkYsRUFBeUYsQ0FBekYsRUFBMkYsQ0FBM0YsRUFBNkYsQ0FBN0YsRUFBK0YsQ0FBL0YsRUFBaUcsQ0FBakcsRUFBbUcsQ0FBbkcsRUFBcUcsQ0FBckcsRUFBdUcsQ0FBdkcsRUFBeUcsQ0FBekcsRUFBMkcsQ0FBM0csRUFBNkcsQ0FBN0csRUFBK0csQ0FBL0csRUFBaUgsQ0FBakgsRUFBbUgsQ0FBbkgsRUFBcUgsQ0FBckgsRUFBdUgsQ0FBdkgsRUFBeUgsQ0FBekgsRUFBMkgsQ0FBM0gsRUFBNkgsQ0FBN0gsRUFBK0gsQ0FBL0gsRUFBaUksQ0FBakksRUFBbUksQ0FBbkksRUFBcUksQ0FBckksRUFBdUksQ0FBdkksRUFBeUksQ0FBekksRUFBMkksQ0FBM0ksRUFBNkksQ0FBN0ksRUFBK0ksQ0FBL0ksRUFBaUosQ0FBakosRUFBbUosQ0FBbkosRUFBcUosQ0FBckosRUFBdUosQ0FBdkosRUFBeUosQ0FBekosRUFBMkosQ0FBM0osRUFBNkosQ0FBN0osRUFBK0osQ0FBL0osRUFBaUssQ0FBakssRUFBbUssQ0FBbkssRUFBcUssQ0FBckssRUFBdUssQ0FBdkssRUFBeUssQ0FBekssRUFBMkssQ0FBM0ssRUFBNkssQ0FBN0ssRUFBK0ssQ0FBL0ssRUFBaUwsQ0FBakwsRUFBbUwsQ0FBbkwsRUFBcUwsQ0FBckwsRUFBdUwsQ0FBdkwsRUFBeUwsQ0FBekwsRUFBMkwsQ0FBM0wsRUFBNkwsQ0FBN0wsRUFBK0wsQ0FBL0wsRUFBaU0sQ0FBak0sRUFBbU0sQ0FBbk0sRUFBcU0sQ0FBck0sRUFBdU0sQ0FBdk0sRUFBeU0sQ0FBek0sRUFBMk0sQ0FBM00sRUFBNk0sQ0FBN00sRUFBK00sQ0FBL00sRUFBaU4sQ0FBak4sRUFBbU4sQ0FBbk4sRUFBcU4sQ0FBck4sRUFBdU4sQ0FBdk4sRUFBeU4sQ0FBek4sRUFBMk4sQ0FBM04sRUFBNk4sQ0FBN04sRUFBK04sQ0FBL04sRUFBaU8sQ0FBak8sRUFBbU8sQ0FBbk8sRUFBcU8sQ0FBck8sRUFBdU8sQ0FBdk8sRUFBeU8sQ0FBek8sRUFBMk8sQ0FBM08sRUFBNk8sQ0FBN08sRUFBK08sQ0FBL08sRUFBaVAsQ0FBalAsRUFBbVAsQ0FBblAsRUFBcVAsQ0FBclAsRUFBdVAsQ0FBdlAsRUFBeVAsQ0FBelAsRUFBMlAsQ0FBM1AsRUFBNlAsQ0FBN1AsRUFBK1AsQ0FBL1AsRUFBaVEsQ0FBalEsRUFBbVEsQ0FBblEsRUFBcVEsQ0FBclEsRUFBdVEsQ0FBdlEsRUFBeVEsQ0FBelEsRUFBMlEsQ0FBM1EsRUFBNlEsQ0FBN1EsRUFBK1EsQ0FBL1EsRUFBaVIsQ0FBalIsRUFBbVIsQ0FBblIsRUFBcVIsQ0FBclIsRUFBdVIsQ0FBdlIsRUFBeVIsQ0FBelIsRUFBMlIsQ0FBM1IsRUFBNlIsQ0FBN1IsRUFBK1IsQ0FBL1IsRUFBaVMsQ0FBalMsRUFBbVMsQ0FBblMsRUFBcVMsQ0FBclMsRUFBdVMsQ0FBdlMsRUFBeVMsQ0FBelMsRUFBMlMsQ0FBM1MsRUFBNlMsQ0FBN1MsRUFBK1MsQ0FBL1MsRUFBaVQsQ0FBalQsRUFBbVQsQ0FBblQsRUFBcVQsQ0FBclQsRUFBdVQsQ0FBdlQsRUFBeVQsQ0FBelQsRUFBMlQsQ0FBM1QsRUFBNlQsQ0FBN1QsRUFBK1QsQ0FBL1QsRUFBaVUsQ0FBalUsRUFBbVUsQ0FBblUsRUFBcVUsQ0FBclUsRUFBdVUsQ0FBdlUsRUFBeVUsQ0FBelUsRUFBMlUsQ0FBM1UsRUFBNlUsQ0FBN1UsRUFBK1UsQ0FBL1UsRUFBaVYsQ0FBalYsRUFBbVYsQ0FBblYsRUFBcVYsQ0FBclYsRUFBdVYsQ0FBdlYsRUFBeVYsQ0FBelYsRUFBMlYsQ0FBM1YsRUFBNlYsQ0FBN1YsRUFBK1YsQ0FBL1YsRUFBaVcsQ0FBalcsRUFBbVcsQ0FBblcsRUFBcVcsQ0FBclcsRUFBdVcsQ0FBdlcsRUFBeVcsQ0FBelcsRUFBMlcsQ0FBM1csRUFBNlcsQ0FBN1csRUFBK1csQ0FBL1csRUFBaVgsQ0FBalgsRUFBbVgsQ0FBblgsRUFBcVgsQ0FBclgsRUFBdVgsQ0FBdlgsRUFBeVgsQ0FBelgsRUFBMlgsQ0FBM1gsRUFBNlgsQ0FBN1gsRUFBK1gsQ0FBL1gsRUFBaVksQ0FBalksRUFBbVksQ0FBblksRUFBcVksQ0FBclksRUFBdVksQ0FBdlksRUFBeVksQ0FBelksRUFBMlksQ0FBM1ksRUFBNlksQ0FBN1ksRUFBK1ksQ0FBL1ksRUFBaVosQ0FBalosRUFBbVosQ0FBblosRUFBcVosQ0FBclosRUFBdVosQ0FBdlosRUFBeVosQ0FBelosRUFBMlosQ0FBM1osRUFBNlosQ0FBN1osRUFBK1osQ0FBL1osRUFBaWEsQ0FBamEsRUFBbWEsQ0FBbmEsRUFBcWEsQ0FBcmEsRUFBdWEsQ0FBdmEsRUFBeWEsQ0FBemEsRUFBMmEsQ0FBM2EsRUFBNmEsQ0FBN2EsRUFBK2EsQ0FBL2EsRUFBaWIsQ0FBamIsRUFBbWIsQ0FBbmIsRUFBcWIsQ0FBcmIsRUFBdWIsQ0FBdmIsRUFBeWIsQ0FBemIsRUFBMmIsQ0FBM2IsRUFBNmIsQ0FBN2IsRUFBK2IsQ0FBL2IsRUFBaWMsQ0FBamMsRUFBbWMsQ0FBbmMsRUFBcWMsQ0FBcmMsRUFBdWMsQ0FBdmMsRUFBeWMsQ0FBemMsRUFBMmMsQ0FBM2MsRUFBNmMsQ0FBN2MsRUFBK2MsQ0FBL2MsRUFBaWQsQ0FBamQsRUFBbWQsQ0FBbmQsRUFBcWQsQ0FBcmQsRUFBdWQsQ0FBdmQsRUFBeWQsQ0FBemQsRUFBMmQsQ0FBM2QsRUFBNmQsQ0FBN2QsRUFBK2QsQ0FBL2QsRUFBaWUsQ0FBamUsRUFBbWUsQ0FBbmUsRUFBcWUsQ0FBcmUsRUFBdWUsQ0FBdmUsRUFBeWUsQ0FBemUsRUFBMmUsQ0FBM2Us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V0FBSyxFQUFMO0FBQ0EsV0FBSyxHQUFMO0FBQ0EsV0FBSyxHQUFMO0FBQ0EsV0FBSyxFQUFMO0FBQ0EsV0FBSyxHQUFMO0FBQ0EsV0FBSyxFQUFMO0FBQ0EsV0FBSyxFQUFMO0FBQ0EsV0FBSyxFQUFMO0FBQ0EsV0FBSyxFQUFMO0FBQ0EsV0FBSyxFQUFMO0FBQ0EsV0FBSyxHQUFMO0FBQ0EsV0FBSyxFQUFMO0FBQ0EsV0FBSyxFQUFMO0FBQ0EsV0FBSyxHQUFMO0FBQ0EsV0FBSyxHQUFMO0FBQ0EsV0FBSyxDQUFMO0FBQ0EsV0FBSyxFQUFMO0FBQ0EsV0FBSyxFQUFMO0FBQ0EsV0FBSyxHQUFMO0FBQ0EsV0FBSyxHQUFMO0FBQ0EsV0FBSyxFQUFMO0FBQ0EsV0FBSyxFQUFMO0FBQ0EsV0FBSyxFQUFMO0FBQ0EsV0FBSyxHQUFMO0FBQ0EsV0FBSyxFQUFMO0FBQ0EsV0FBSyxFQUFMO0FBQ0EsV0FBSyxFQUFMO0FBQ0EsV0FBSyxFQUFMO0FBQ0EsV0FBSyxFQUFMO0FBQ0EsV0FBSyxHQUFMO0FBQ0EsV0FBSyxFQUFMO0FBQ0EsV0FBSyxFQUFMO0FBQ0EsV0FBSyxFQUFMO0FBQ0EsV0FBSyxFQUFMO0FBQ0EsV0FBSyxFQUFMO0FBQ0EsV0FBSyxFQUFMO0FBQ0EsV0FBSyxFQUFMO0FBQ0EsV0FBSyxFQUFMO0FBQ0UsZUFBTyxNQUFQOztBQUNGLFdBQUssRUFBTDtBQUNFLGVBQU8sQ0FBUDs7QUFDRixXQUFLLEVBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEVBQUw7QUFDQSxXQUFLLEVBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEVBQUw7QUFDQSxXQUFLLEVBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEVBQUw7QUFDQSxXQUFLLEVBQUw7QUFDQSxXQUFLLEVBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEVBQUw7QUFDRSxlQUFPLENBQUMsQ0FBUjs7QUFDRixXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLENBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLENBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEVBQUw7QUFDQSxXQUFLLEVBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEdBQUw7QUFDQSxXQUFLLEVBQUw7QUFDQSxXQUFLLEVBQUw7QUFDRSxlQUFPLENBQVA7O0FBQ0YsV0FBSyxFQUFMO0FBQ0EsV0FBSyxFQUFMO0FBQ0EsV0FBSyxFQUFMO0FBQ0EsV0FBSyxFQUFMO0FBQ0EsV0FBSyxDQUFMO0FBQ0UsZUFBTyxJQUFQOztBQUNGLFdBQUssRUFBTDtBQUNBLFdBQUssRUFBTDtBQUNBLFdBQUssRUFBTDtBQUNFLGVBQU8sRUFBUDs7QUFDRixXQUFLLEVBQUw7QUFDQSxXQUFLLEVBQUw7QUFDQSxXQUFLLEVBQUw7QUFDRSxlQUFPLFVBQVA7O0FBQ0YsV0FBSyxFQUFMO0FBQ0EsV0FBSyxDQUFMO0FBQ0UsZUFBTyxLQUFQOztBQUNGLFdBQUssRUFBTDtBQUNBLFdBQUssRUFBTDtBQUNFLGVBQU8sRUFBUDs7QUFDRixXQUFLLEVBQUw7QUFDQSxXQUFLLEVBQUw7QUFDRSxlQUFPLElBQVA7O0FBQ0YsV0FBSyxDQUFMO0FBQVEsZUFBTyxPQUFQOztBQUNSLFdBQUssQ0FBTDtBQUFRLGVBQU8sS0FBUDs7QUFDUixXQUFLLEVBQUw7QUFBUyxlQUFPLEtBQVA7O0FB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QzFDL1IsaUJBQVMrUixVQUFVL1IsTUFBVixFQUFrQjBSLElBQWxCLENBQVQ7QUFDRCxPQUZEO0FBR0Q7O0FBQ0QsVUFBTTFSLE1BQU47QUFDRDs7QUFDRHRaLFVBQU8sT0FBUCxJQUFrQnFFLEtBQWxCLENBbHFGOEIsQ0FvcUY5Qjs7QUFFQSxNQUFJckUsUUFBTyxTQUFQLENBQUosRUFBdUI7QUFDckIsUUFBSSxPQUFPQSxRQUFPLFNBQVAsQ0FBUCxJQUE0QixVQUFoQyxFQUE0Q0EsUUFBTyxTQUFQLElBQW9CLENBQUNBLFFBQU8sU0FBUCxDQUFELENBQXBCOztBQUM1QyxXQUFPQSxRQUFPLFNBQVAsRUFBa0IyQixNQUFsQixHQUEyQixDQUFsQyxFQUFxQztBQUNuQzNCLGNBQU8sU0FBUCxFQUFrQnNyQixHQUFsQjtBQUNEO0FBQ0Y7O0FBR0R0ckIsVUFBTyxlQUFQLElBQTBCLElBQTFCO0FBRUF1cUIsUUFockY4QixDQWtyRjlCO0FBTUE7O0FBTUUsU0FBT3ZxQixPQUFQO0FBQ0QsQ0EvckZEOztBQWdzRkEsSUFBSSw4QkFBTzBYLE9BQVAsT0FBbUIsUUFBbkIsSUFBK0IsOEJBQU93QixNQUFQLE9BQWtCLFFBQXJELEVBQ0VBLE9BQU94QixPQUFQLEdBQWlCMVgsTUFBakIsQ0FERixLQUVLLElBQUksSUFBSixFQUNILGlDQUFPLEVBQVAsbUNBQVcsWUFBVztBQUFFLFNBQU9BLE1BQVA7QUFBZ0IsQ0FBeEM7QUFBQSxxR0FERyxLQUVBLEUiLCJmaWxlIjoiaW90YS1waWNvLXBvdy13YXNtLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoXCJAaW90YS1waWNvL3Bvdy13YXNtXCIsIFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIkBpb3RhLXBpY28vcG93LXdhc21cIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiSW90YVBpY29Qb3dXYXNtXCJdID0gZmFjdG9yeSgpO1xufSkodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuICIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL2Rpc3QvaW5kZXguanNcIik7XG4iLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IGpzb25IZWxwZXJfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL2pzb25IZWxwZXJcIik7XHJcbmNvbnN0IHN0cmluZ0hlbHBlcl8xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvc3RyaW5nSGVscGVyXCIpO1xyXG4vKipcclxuICogQSBjb3JlIGltcGxlbWVudGF0aW9uIG9mIGFuIGVycm9yLlxyXG4gKi9cclxuY2xhc3MgQ29yZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgQ29yZUVycm9yLlxyXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgVGhlIG1lc3NhZ2UgZm9yIHRoZSBlcnJvci5cclxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsIEFkZGl0aW9uYWwgZGV0YWlscyBhYm91dCB0aGUgZXJyb3IuXHJcbiAgICAgKiBAcGFyYW0gaW5uZXJFcnJvciBBZGQgaW5mb3JtYXRpb24gZnJvbSBpbm5lciBlcnJvciBpZiB0aGVyZSB3YXMgb25lLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBhZGRpdGlvbmFsLCBpbm5lckVycm9yKSB7XHJcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XHJcbiAgICAgICAgdGhpcy5hZGRpdGlvbmFsID0gYWRkaXRpb25hbCA/IGFkZGl0aW9uYWwgOiB7fTtcclxuICAgICAgICB0aGlzLmlubmVyRXJyb3IgPSBpbm5lckVycm9yO1xyXG4gICAgICAgIHRoaXMuZG9tYWluID0gXCJDb3JlXCI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIGlmIGFuIG9iamVjdCBjb3VsZCBiZSBhIENvcmVFcnJvci5cclxuICAgICAqIEBwYXJhbSBvYmogVGhlIG9iamVjdCB0byBjaGVjayBpZiBpdCBpcyBhIENvcmVFcnJvci5cclxuICAgICAqIEByZXR1cm5zIHRydWUgSWYgdGhlIHRlc3RlZCBvYmplY3QgaXMgYSBDb3JlRXJyb3IuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc0Vycm9yKG9iaikge1xyXG4gICAgICAgIHJldHVybiBvYmogIT09IHVuZGVmaW5lZCAmJiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJiBcIm1lc3NhZ2VcIiBpbiBvYmogJiYgXCJhZGRpdGlvbmFsXCIgaW4gb2JqO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGb3JtYXQgdGhlIGVycm9yIHRvIGEgcmVhZGFibGUgdmVyc2lvbi5cclxuICAgICAqIEByZXR1cm5zIEZvcm1hdHRlZCB2ZXJzaW9uIG9mIHRoZSBlcnJvci5cclxuICAgICAqL1xyXG4gICAgZm9ybWF0KCkge1xyXG4gICAgICAgIGxldCBvdXQgPSBcIlwiO1xyXG4gICAgICAgIGlmICghc3RyaW5nSGVscGVyXzEuU3RyaW5nSGVscGVyLmlzRW1wdHkodGhpcy5kb21haW4pKSB7XHJcbiAgICAgICAgICAgIG91dCArPSBgJHt0aGlzLmRvbWFpbn06IGA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghc3RyaW5nSGVscGVyXzEuU3RyaW5nSGVscGVyLmlzRW1wdHkodGhpcy5tZXNzYWdlKSkge1xyXG4gICAgICAgICAgICBvdXQgKz0gYCR7dGhpcy5tZXNzYWdlfWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLmFkZGl0aW9uYWwpO1xyXG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgaWYgKG91dC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBvdXQgKz0gXCJcXG5cIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICAgICAgICAgIG91dCArPSBgXFx0JHtrZXl9OiAke2pzb25IZWxwZXJfMS5Kc29uSGVscGVyLnN0cmluZ2lmeSh0aGlzLmFkZGl0aW9uYWxba2V5XSl9XFxuYDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5Db3JlRXJyb3IgPSBDb3JlRXJyb3I7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVkyOXlaVVZ5Y205eUxtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dkxpNHZjM0pqTDJWeWNtOXlMMk52Y21WRmNuSnZjaTUwY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pTzBGQlFVRXNjMFJCUVcxRU8wRkJRMjVFTERCRVFVRjFSRHRCUVVWMlJEczdSMEZGUnp0QlFVTklMR1ZCUVhWQ0xGTkJRVkVzUzBGQlN6dEpRV2RDYUVNN096czdPMDlCUzBjN1NVRkRTQ3haUVVGWkxFOUJRV1VzUlVGQlJTeFZRVUZyUXl4RlFVRkZMRlZCUVd0Q08xRkJReTlGTEV0QlFVc3NRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJRenRSUVVObUxFbEJRVWtzUTBGQlF5eFZRVUZWTEVkQlFVY3NWVUZCVlN4RFFVRkRMRU5CUVVNc1EwRkJReXhWUVVGVkxFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXp0UlFVTXZReXhKUVVGSkxFTkJRVU1zVlVGQlZTeEhRVUZITEZWQlFWVXNRMEZCUXp0UlFVTTNRaXhKUVVGSkxFTkJRVU1zVFVGQlRTeEhRVUZITEUxQlFVMHNRMEZCUXp0SlFVTjZRaXhEUVVGRE8wbEJSVVE3T3pzN1QwRkpSenRKUVVOSkxFMUJRVTBzUTBGQlF5eFBRVUZQTEVOQlFVTXNSMEZCVVR0UlFVTXhRaXhQUVVGUExFZEJRVWNzUzBGQlN5eFRRVUZUTEVsQlFVa3NSMEZCUnl4TFFVRkxMRWxCUVVrc1NVRkJTU3hQUVVGUExFZEJRVWNzUzBGQlN5eFJRVUZSTEVsQlFVa3NVMEZCVXl4SlFVRkpMRWRCUVVjc1NVRkJTU3haUVVGWkxFbEJRVWtzUjBGQlJ5eERRVUZETzBsQlEyNUlMRU5CUVVNN1NVRkZSRHM3TzA5QlIwYzdTVUZEU1N4TlFVRk5PMUZCUTFRc1NVRkJTU3hIUVVGSExFZEJRVWNzUlVGQlJTeERRVUZETzFGQlJXSXNTVUZCU1N4RFFVRkRMREpDUVVGWkxFTkJRVU1zVDBGQlR5eERRVUZETEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1JVRkJSVHRaUVVOd1F5eEhRVUZITEVsQlFVa3NSMEZCUnl4SlFVRkpMRU5CUVVNc1RVRkJUU3hKUVVGSkxFTkJRVU03VTBGRE4wSTdVVUZEUkN4SlFVRkpMRU5CUVVNc01rSkJRVmtzUTBGQlF5eFBRVUZQTEVOQlFVTXNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhGUVVGRk8xbEJRM0pETEVkQlFVY3NTVUZCU1N4SFFVRkhMRWxCUVVrc1EwRkJReXhQUVVGUExFVkJRVVVzUTBGQlF6dFRRVU0xUWp0UlFVVkVMRTFCUVUwc1NVRkJTU3hIUVVGSExFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNTVUZCU1N4RFFVRkRMRlZCUVZVc1EwRkJReXhEUVVGRE8xRkJRekZETEVsQlFVa3NTVUZCU1N4RFFVRkRMRTFCUVUwc1IwRkJSeXhEUVVGRExFVkJRVVU3V1VGRGFrSXNTVUZCU1N4SFFVRkhMRU5CUVVNc1RVRkJUU3hIUVVGSExFTkJRVU1zUlVGQlJUdG5Ra0ZEYUVJc1IwRkJSeXhKUVVGSkxFbEJRVWtzUTBGQlF6dGhRVU5tTzFsQlEwUXNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhIUVVGSExFTkJRVU1zUlVGQlJUdG5Ra0ZEWml4SFFVRkhMRWxCUVVrc1MwRkJTeXhIUVVGSExFdEJRVXNzZFVKQlFWVXNRMEZCUXl4VFFVRlRMRU5CUVVNc1NVRkJTU3hEUVVGRExGVkJRVlVzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNN1dVRkRka1VzUTBGQlF5eERRVUZETEVOQlFVTTdVMEZEVGp0UlFVVkVMRTlCUVU4c1IwRkJSeXhEUVVGRE8wbEJRMllzUTBGQlF6dERRVU5LTzBGQmFFVkVMRGhDUVdkRlF5SjkiLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKlxyXG4gKiBGYWN0b3J5IHRvIGdlbmVyYXRlIHR5cGVzLlxyXG4gKiBAdHlwZXBhcmFtIFQgVGhlIGdlbmVyaWMgdHlwZSBmb3IgdGhlIG9iamVjdCB0eXBlcyBpbiB0aGUgZmFjdG9yeS5cclxuICovXHJcbmNsYXNzIEZhY3RvcnlCYXNlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIC8qIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX3R5cGVzID0ge307XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVyIGEgbmV3IHR5cGUgd2l0aCB0aGUgZmFjdG9yeS5cclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSB0eXBlIHRvIHJlZ2lzdGVyLlxyXG4gICAgICogQHBhcmFtIHR5cGVDb25zdHJ1Y3RvciBUaGUgY29uc3RydWN0b3IgZm9yIHRoZSB0eXBlLlxyXG4gICAgICovXHJcbiAgICByZWdpc3RlcihuYW1lLCB0eXBlQ29uc3RydWN0b3IpIHtcclxuICAgICAgICB0aGlzLmdldEluc3RhbmNlKCkuX3R5cGVzW25hbWVdID0gdHlwZUNvbnN0cnVjdG9yO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVbnJlZ2lzdGVyIGEgdHlwZSBmcm9tIHRoZSBmYWN0b3J5LlxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHR5cGUgdG8gdW5yZWdpc3Rlci5cclxuICAgICAqL1xyXG4gICAgdW5yZWdpc3RlcihuYW1lKSB7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuZ2V0SW5zdGFuY2UoKS5fdHlwZXNbbmFtZV07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERvZXMgdGhlIGZhY3RvcnkgY29udGFpbiBhIHNwZWNpZmljIHR5cGUuXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgdHlwZSB0byBsb29rIGZvci5cclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHR5cGUgZXhpc3RzLlxyXG4gICAgICovXHJcbiAgICBleGlzdHMobmFtZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKCkuX3R5cGVzW25hbWVdICE9PSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIExpc3QgdGhlIHR5cGVzIGluIHRoZSBmYWN0b3J5LlxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHR5cGUgdG8gbG9vayBmb3IuXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSB0eXBlIGV4aXN0cy5cclxuICAgICAqL1xyXG4gICAgdHlwZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuZ2V0SW5zdGFuY2UoKS5fdHlwZXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgYW4gb2JqZWN0IGZyb20gdGhlIGZhY3RvcnkuXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgdHlwZSB0byBjcmVhdGUuXHJcbiAgICAgKiBAcGFyYW0gYXJncyBBbnkgcGFyYW1ldGVycyB0byBwYXNzIHRvIHRoZSBjb25zdHJ1Y3Rvci5cclxuICAgICAqIEByZXR1cm5zIEEgbmV3IGluc3RhbmNlIG9mIHRoZSB0eXBlIGlmIGl0IGV4aXN0cywgb3IgdW5kZWZpbmVkIGlmIGl0IGRvZXMgbm90LlxyXG4gICAgICovXHJcbiAgICBjcmVhdGUobmFtZSwgLi4uYXJncykge1xyXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgIGlmIChpbnN0YW5jZS5fdHlwZXNbbmFtZV0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlLl90eXBlc1tuYW1lXSguLi5hcmdzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuRmFjdG9yeUJhc2UgPSBGYWN0b3J5QmFzZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pWm1GamRHOXllVUpoYzJVdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk4dUxpOXpjbU12Wm1GamRHOXlhV1Z6TDJaaFkzUnZjbmxDWVhObExuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdRVUZCUVRzN08wZEJSMGM3UVVGRFNEdEpRVUZCTzFGQlEwa3NaVUZCWlR0UlFVTkZMRmRCUVUwc1IwRkJPRU1zUlVGQlJTeERRVUZETzBsQmMwUTFSU3hEUVVGRE8wbEJjRVJIT3pzN08wOUJTVWM3U1VGRFNTeFJRVUZSTEVOQlFVTXNTVUZCV1N4RlFVRkZMR1ZCUVhORE8xRkJRMmhGTEVsQlFVa3NRMEZCUXl4WFFVRlhMRVZCUVVVc1EwRkJReXhOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEVkQlFVY3NaVUZCWlN4RFFVRkRPMGxCUTNSRUxFTkJRVU03U1VGRlJEczdPMDlCUjBjN1NVRkRTU3hWUVVGVkxFTkJRVU1zU1VGQldUdFJRVU14UWl4UFFVRlBMRWxCUVVrc1EwRkJReXhYUVVGWExFVkJRVVVzUTBGQlF5eE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1NVRkRNME1zUTBGQlF6dEpRVVZFT3pzN08wOUJTVWM3U1VGRFNTeE5RVUZOTEVOQlFVTXNTVUZCV1R0UlFVTjBRaXhQUVVGUExFbEJRVWtzUTBGQlF5eFhRVUZYTEVWQlFVVXNRMEZCUXl4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRExFdEJRVXNzVTBGQlV5eERRVUZETzBsQlEzcEVMRU5CUVVNN1NVRkZSRHM3T3p0UFFVbEhPMGxCUTBrc1MwRkJTenRSUVVOU0xFOUJRVThzVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1YwRkJWeXhGUVVGRkxFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTTdTVUZEYkVRc1EwRkJRenRKUVVWRU96czdPenRQUVV0SE8wbEJRMGtzVFVGQlRTeERRVUZETEVsQlFWa3NSVUZCUlN4SFFVRkhMRWxCUVZjN1VVRkRkRU1zVFVGQlRTeFJRVUZSTEVkQlFVY3NTVUZCU1N4RFFVRkRMRmRCUVZjc1JVRkJSU3hEUVVGRE8xRkJRM0JETEVsQlFVa3NVVUZCVVN4RFFVRkRMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zUlVGQlJUdFpRVU4yUWl4UFFVRlBMRkZCUVZFc1EwRkJReXhOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNSMEZCUnl4SlFVRkpMRU5CUVVNc1EwRkJRenRUUVVONlF6dGhRVUZOTzFsQlEwZ3NUMEZCVHl4VFFVRlRMRU5CUVVNN1UwRkRjRUk3U1VGRFRDeERRVUZETzBOQlNVbzdRVUY0UkVRc2EwTkJkMFJESW4wPSIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3Qgb2JqZWN0SGVscGVyXzEgPSByZXF1aXJlKFwiLi9vYmplY3RIZWxwZXJcIik7XHJcbi8qKlxyXG4gKiBBcnJheSBoZWxwZXIgbWV0aG9kcy5cclxuICovXHJcbmNsYXNzIEFycmF5SGVscGVyIHtcclxuICAgIC8qKlxyXG4gICAgICogSXMgdGhlIHZhbHVlIGFuIGFycmF5LlxyXG4gICAgICogQHBhcmFtIHZhbHVlIE9iamVjdCB0byB0ZXN0LlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYW4gYXJyYXkuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc0FycmF5KHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWRcclxuICAgICAgICAgICAgPyBmYWxzZSA6IEFycmF5LmlzQXJyYXkodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJcyB0aGUgdmFsdWUgYSBlbXB0eSBhcnJheS5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBPYmplY3QgdG8gdGVzdC5cclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHZhbHVlIGlzIGEgZW1wdHkgYXJyYXkuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc0VtcHR5KHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuICFBcnJheUhlbHBlci5pc0FycmF5KHZhbHVlKSB8fCB2YWx1ZS5sZW5ndGggPT09IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIElzIHRoZSB2YWx1ZSBhIG5vbiBlbXB0eSBhcnJheSBvZiBzcGVjaWZpYyB0eXBlLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIE9iamVjdCB0byB0ZXN0LlxyXG4gICAgICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgdGhlIG9iamVjdFxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBub24gZW1wdHkgYXJyYXkgb2YgYSBzcGVjaWZpYyB0eXBlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaXNUeXBlZCh2YWx1ZSwgdHlwZSkge1xyXG4gICAgICAgIHJldHVybiAhQXJyYXlIZWxwZXIuaXNFbXB0eSh2YWx1ZSkgJiZcclxuICAgICAgICAgICAgIXZhbHVlLmluY2x1ZGVzKHVuZGVmaW5lZCkgJiZcclxuICAgICAgICAgICAgIXZhbHVlLmluY2x1ZGVzKG51bGwpICYmXHJcbiAgICAgICAgICAgIHZhbHVlLmV2ZXJ5KChhKSA9PiBvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKGEsIHR5cGUpKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkFycmF5SGVscGVyID0gQXJyYXlIZWxwZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVlYSnlZWGxJWld4d1pYSXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOHVMaTl6Y21NdmFHVnNjR1Z5Y3k5aGNuSmhlVWhsYkhCbGNpNTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPMEZCUVVFc2FVUkJRVGhETzBGQlJUbERPenRIUVVWSE8wRkJRMGc3U1VGRFNUczdPenRQUVVsSE8wbEJRMGtzVFVGQlRTeERRVUZETEU5QlFVOHNRMEZCUXl4TFFVRlZPMUZCUXpWQ0xFOUJRVThzUzBGQlN5eExRVUZMTEVsQlFVa3NTVUZCU1N4TFFVRkxMRXRCUVVzc1UwRkJVenRaUVVONFF5eERRVUZETEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJReXhMUVVGTExFTkJRVU1zVDBGQlR5eERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRPMGxCUTNaRExFTkJRVU03U1VGRlJEczdPenRQUVVsSE8wbEJRMGtzVFVGQlRTeERRVUZETEU5QlFVOHNRMEZCUXl4TFFVRlZPMUZCUXpWQ0xFOUJRVThzUTBGQlF5eFhRVUZYTEVOQlFVTXNUMEZCVHl4RFFVRkRMRXRCUVVzc1EwRkJReXhKUVVGSkxFdEJRVXNzUTBGQlF5eE5RVUZOTEV0QlFVc3NRMEZCUXl4RFFVRkRPMGxCUXpkRUxFTkJRVU03U1VGRlJEczdPenM3VDBGTFJ6dEpRVU5KTEUxQlFVMHNRMEZCUXl4UFFVRlBMRU5CUVVNc1MwRkJWU3hGUVVGRkxFbEJRV003VVVGRE5VTXNUMEZCVHl4RFFVRkRMRmRCUVZjc1EwRkJReXhQUVVGUExFTkJRVU1zUzBGQlN5eERRVUZETzFsQlF6bENMRU5CUVVNc1MwRkJTeXhEUVVGRExGRkJRVkVzUTBGQlF5eFRRVUZUTEVOQlFVTTdXVUZETVVJc1EwRkJReXhMUVVGTExFTkJRVU1zVVVGQlVTeERRVUZETEVsQlFVa3NRMEZCUXp0WlFVTnlRaXhMUVVGTExFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCVFN4RlFVRkZMRVZCUVVVc1EwRkJReXd5UWtGQldTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRVZCUVVVc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF6dEpRVU01UkN4RFFVRkRPME5CUlVvN1FVRnFRMFFzYTBOQmFVTkRJbjA9IiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKipcclxuICogSnNvbiBoZWxwZXIgbWV0aG9kcy5cclxuICovXHJcbmNsYXNzIEpzb25IZWxwZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdHJpbmdpZnkgYW4gb2JqZWN0IHdpdGggcmVjdXJzaW9uIGJyZWFraW5nLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIEEgSmF2YVNjcmlwdCB2YWx1ZSwgdXN1YWxseSBhbiBvYmplY3Qgb3IgYXJyYXksIHRvIGJlIGNvbnZlcnRlZC5cclxuICAgICAqIEBwYXJhbSByZXBsYWNlciBBIGZ1bmN0aW9uIHRoYXQgdHJhbnNmb3JtcyB0aGUgcmVzdWx0cy5cclxuICAgICAqIEBwYXJhbSBzcGFjZSBBZGRzIGluZGVudGF0aW9uLCB3aGl0ZSBzcGFjZSwgYW5kIGxpbmUgYnJlYWsgY2hhcmFjdGVycyB0byB0aGUgcmV0dXJuLXZhbHVlIEpTT04gdGV4dCB0byBtYWtlIGl0IGVhc2llciB0byByZWFkLlxyXG4gICAgICogQHJldHVybnMgU3RyaW5nIHZlcnNpb24gb2YgdGhlIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHN0cmluZ2lmeSh2YWx1ZSwgcmVwbGFjZXIsIHNwYWNlKSB7XHJcbiAgICAgICAgLy8gZWxpbWluYXRlcyBhbnkgcmVjdXJzaW9uIGluIHRoZSBzdHJpbmdpZnlcclxuICAgICAgICBjb25zdCBjYWNoZSA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHJlY3VzaW9uUmVwbGFjZXIgPSAoa2V5LCByZXBsYWNlVmFsdWUpID0+IHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXBsYWNlVmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwgJiYgcmVwbGFjZVZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjYWNoZS5pbmRleE9mKHJlcGxhY2VWYWx1ZSkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY2lyY3VsYXIgcmVmZXJlbmNlIGZvdW5kLCBkaXNjYXJkIGtleVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlLnB1c2gocmVwbGFjZVZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVwbGFjZXIgPyByZXBsYWNlcihrZXksIHJlcGxhY2VWYWx1ZSkgOiByZXBsYWNlVmFsdWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUsIHJlY3VzaW9uUmVwbGFjZXIsIHNwYWNlKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkpzb25IZWxwZXIgPSBKc29uSGVscGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lhbk52YmtobGJIQmxjaTVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OW9aV3h3WlhKekwycHpiMjVJWld4d1pYSXVkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanRCUVVGQk96dEhRVVZITzBGQlEwZzdTVUZEU1RzN096czdPMDlCVFVjN1NVRkRTU3hOUVVGTkxFTkJRVU1zVTBGQlV5eERRVUZETEV0QlFWVXNSVUZCUlN4UlFVRXlReXhGUVVGRkxFdEJRWFZDTzFGQlEzQkhMRFJEUVVFMFF6dFJRVU0xUXl4TlFVRk5MRXRCUVVzc1IwRkJWU3hGUVVGRkxFTkJRVU03VVVGRmVFSXNUVUZCVFN4blFrRkJaMElzUjBGQlJ5eERRVUZETEVkQlFWY3NSVUZCUlN4WlFVRnBRaXhGUVVGRkxFVkJRVVU3V1VGRGVFUXNTVUZCU1N4UFFVRlBMRmxCUVZrc1MwRkJTeXhSUVVGUkxFbEJRVWtzUzBGQlN5eExRVUZMTEVsQlFVa3NTVUZCU1N4WlFVRlpMRXRCUVVzc1UwRkJVeXhGUVVGRk8yZENRVU5zUml4SlFVRkpMRXRCUVVzc1EwRkJReXhQUVVGUExFTkJRVU1zV1VGQldTeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRVZCUVVVN2IwSkJRM0JETEhkRFFVRjNRenR2UWtGRGVFTXNUMEZCVHp0cFFrRkRWanR4UWtGQlRUdHZRa0ZEU0N4TFFVRkxMRU5CUVVNc1NVRkJTU3hEUVVGRExGbEJRVmtzUTBGQlF5eERRVUZETzJsQ1FVTTFRanRoUVVOS08xbEJSVVFzVDBGQlR5eFJRVUZSTEVOQlFVTXNRMEZCUXl4RFFVRkRMRkZCUVZFc1EwRkJReXhIUVVGSExFVkJRVVVzV1VGQldTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRmxCUVZrc1EwRkJRenRSUVVOcVJTeERRVUZETEVOQlFVTTdVVUZGUml4UFFVRlBMRWxCUVVrc1EwRkJReXhUUVVGVExFTkJRVU1zUzBGQlN5eEZRVUZGTEdkQ1FVRm5RaXhGUVVGRkxFdEJRVXNzUTBGQlF5eERRVUZETzBsQlF6RkVMRU5CUVVNN1EwRkRTanRCUVROQ1JDeG5RMEV5UWtNaWZRPT0iLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKlxyXG4gKiBOdW1iZXIgaGVscGVyIG1ldGhvZHMuXHJcbiAqL1xyXG5jbGFzcyBOdW1iZXJIZWxwZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBJcyB0aGUgdmFsdWUgYW4gaW50ZWdlci5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBPYmplY3QgdG8gdGVzdCBmb3IgaXRzIGludGVnZXJuZXNzLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGEgaW50ZWdlci5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzSW50ZWdlcih2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSAmJiAhTnVtYmVyLmlzTmFOKHZhbHVlKSAmJiBOdW1iZXIuaXNGaW5pdGUodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJcyB0aGUgdmFsdWUgYSBudW1iZXIuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgT2JqZWN0IHRvIHRlc3QgZm9yIGl0cyBudW1iZXJ5bmVzcy5cclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIG9iamVjdCBpcyBhIG51bWJlci5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzTnVtYmVyKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiICYmICFOdW1iZXIuaXNOYU4odmFsdWUpICYmIE51bWJlci5pc0Zpbml0ZSh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIElzIHRoZSB2YWx1ZSBhIGZsb2F0IG51bWJlciBmb3JtYXR0ZWQgYXMgYSBzdHJpbmcsIGNhbiBiZSB1c2VkIGZvciBiaWcgbnVtYmVycyB0aGF0IHdvdWxkIG92ZXJmbG93IHBhcnNlRmxvYXQuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBudW1iZXIgaXMgZm9ybWF0dGVkIGNvcnJlY3RseS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzRmxvYXRTdHJpbmcodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gL14tP1xcZCpcXC4/XFxkKyQvLnRlc3QodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJcyB0aGUgdmFsdWUgYSBpbnRlZ2VyIG51bWJlciBmb3JtYXR0ZWQgYXMgYSBzdHJpbmcsIGNhbiBiZSB1c2VkIGZvciBiaWcgbnVtYmVycyB0aGF0IHdvdWxkIG92ZXJmbG93IHBhcnNlSW50LlxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVja1xyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgbnVtYmVyIGlzIGZvcm1hdHRlZCBjb3JyZWN0bHkuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc0ludGVnZXJTdHJpbmcodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gL14tP1xcZCskLy50ZXN0KHZhbHVlKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLk51bWJlckhlbHBlciA9IE51bWJlckhlbHBlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYm5WdFltVnlTR1ZzY0dWeUxtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dkxpNHZjM0pqTDJobGJIQmxjbk12Ym5WdFltVnlTR1ZzY0dWeUxuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdRVUZCUVRzN1IwRkZSenRCUVVOSU8wbEJRMGs3T3pzN1QwRkpSenRKUVVOSkxFMUJRVTBzUTBGQlF5eFRRVUZUTEVOQlFVTXNTMEZCVlR0UlFVTTVRaXhQUVVGUExFMUJRVTBzUTBGQlF5eFRRVUZUTEVOQlFVTXNTMEZCU3l4RFFVRkRMRWxCUVVrc1EwRkJReXhOUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETEV0QlFVc3NRMEZCUXl4SlFVRkpMRTFCUVUwc1EwRkJReXhSUVVGUkxFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTTdTVUZEY2tZc1EwRkJRenRKUVVWRU96czdPMDlCU1VjN1NVRkRTU3hOUVVGTkxFTkJRVU1zVVVGQlVTeERRVUZETEV0QlFWVTdVVUZETjBJc1QwRkJUeXhMUVVGTExFdEJRVXNzVTBGQlV5eEpRVUZKTEV0QlFVc3NTMEZCU3l4SlFVRkpMRWxCUVVrc1QwRkJUeXhMUVVGTExFdEJRVXNzVVVGQlVTeEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRXRCUVVzc1EwRkJReXhMUVVGTExFTkJRVU1zU1VGQlNTeE5RVUZOTEVOQlFVTXNVVUZCVVN4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRE8wbEJRMmhKTEVOQlFVTTdTVUZGUkRzN096dFBRVWxITzBsQlEwa3NUVUZCVFN4RFFVRkRMR0ZCUVdFc1EwRkJReXhMUVVGaE8xRkJRM0pETEU5QlFVOHNaVUZCWlN4RFFVRkRMRWxCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF6dEpRVU4yUXl4RFFVRkRPMGxCUlVRN096czdUMEZKUnp0SlFVTkpMRTFCUVUwc1EwRkJReXhsUVVGbExFTkJRVU1zUzBGQllUdFJRVU4yUXl4UFFVRlBMRk5CUVZNc1EwRkJReXhKUVVGSkxFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTTdTVUZEYWtNc1EwRkJRenREUVVOS08wRkJjRU5FTEc5RFFXOURReUo5IiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKipcclxuICogT2JqZWN0IGhlbHBlciBtZXRob2RzLlxyXG4gKi9cclxuY2xhc3MgT2JqZWN0SGVscGVyIHtcclxuICAgIC8qKlxyXG4gICAgICogSXMgdGhlIHZhbHVlIGVtcHR5LlxyXG4gICAgICogQHBhcmFtIHZhbHVlIE9iamVjdCB0byB0ZXN0LlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgZW1wdHkuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc0VtcHR5KHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIElzIHRoZSB2YWx1ZSBhbiBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgT2JqZWN0IHRvIHRlc3QuXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSB2YWx1ZSBpcyBhbiBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc09iamVjdCh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgID8gZmFsc2UgOiB0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIElzIHRoZSB2YWx1ZSBhbiBvYmplY3QgaWYgZ2l2ZW4gdHlwZS5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBPYmplY3QgdG8gdGVzdC5cclxuICAgICAqIEBwYXJhbSB0eXBlQ29uc3RydWN0b3IgQSBjYWxsYmFjayBtZXRob2Qgd2hpY2ggcmV0dXJucyBhbiBpbnN0YW5jZSBvZiB0aGUgb2JqZWN0LlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0IG9mIHRoZSBzcGVjaWZpZWQgdHlwZS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzVHlwZSh2YWx1ZSwgdHlwZUNvbnN0cnVjdG9yKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWVDbGFzc05hbWUgPSBPYmplY3RIZWxwZXIuZ2V0Q2xhc3NOYW1lKHZhbHVlKTtcclxuICAgICAgICByZXR1cm4gdmFsdWVDbGFzc05hbWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZUNsYXNzTmFtZSA9PT0gT2JqZWN0SGVscGVyLmdldENsYXNzTmFtZSh0eXBlQ29uc3RydWN0b3IpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGNsYXNzIG5hbWUgb2YgYW4gb2JqZWN0IGlmIGl0IGhhcyBvbmUuXHJcbiAgICAgKiBAcGFyYW0gb2JqZWN0IFRoZSBvYmplY3QgdG8gZ2V0IHRoZSBjbGFzcyBuYW1lIGZvci5cclxuICAgICAqIEByZXR1cm5zIFRoZSBjbGFzcyBuYW1lIGlmIGl0IGhhcyBvbmUgb3IgdW5kZWZpbmVkIGlmIG5vdC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldENsYXNzTmFtZShvYmplY3QpIHtcclxuICAgICAgICBpZiAob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBjb25zdHJ1Y3RvciA9IHR5cGVvZiBvYmplY3QgPT09IFwiZnVuY3Rpb25cIiA/IG9iamVjdC50b1N0cmluZygpIDogb2JqZWN0LmNvbnN0cnVjdG9yLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBjb25zdHJ1Y3Rvci5tYXRjaCgvXFx3Ky9nKTtcclxuICAgICAgICAgICAgcmV0dXJuIChyZXN1bHRzICYmIHJlc3VsdHMubGVuZ3RoID4gMSkgPyByZXN1bHRzWzFdIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5leHBvcnRzLk9iamVjdEhlbHBlciA9IE9iamVjdEhlbHBlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYjJKcVpXTjBTR1ZzY0dWeUxtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dkxpNHZjM0pqTDJobGJIQmxjbk12YjJKcVpXTjBTR1ZzY0dWeUxuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdRVUZCUVRzN1IwRkZSenRCUVVOSU8wbEJRMGs3T3pzN1QwRkpSenRKUVVOSkxFMUJRVTBzUTBGQlF5eFBRVUZQTEVOQlFVTXNTMEZCVlR0UlFVTTFRaXhQUVVGUExFdEJRVXNzUzBGQlN5eEpRVUZKTEVsQlFVa3NTMEZCU3l4TFFVRkxMRk5CUVZNc1EwRkJRenRKUVVOcVJDeERRVUZETzBsQlJVUTdPenM3VDBGSlJ6dEpRVU5KTEUxQlFVMHNRMEZCUXl4UlFVRlJMRU5CUVVNc1MwRkJWVHRSUVVNM1FpeFBRVUZQTEV0QlFVc3NTMEZCU3l4SlFVRkpMRWxCUVVrc1MwRkJTeXhMUVVGTExGTkJRVk03V1VGRGVFTXNRMEZCUXl4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zVDBGQlRTeERRVUZETEV0QlFVc3NRMEZCUXl4TFFVRkxMRkZCUVZFc1NVRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF5eFBRVUZQTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNN1NVRkRkRVVzUTBGQlF6dEpRVVZFT3pzN096dFBRVXRITzBsQlEwa3NUVUZCVFN4RFFVRkRMRTFCUVUwc1EwRkJReXhMUVVGVkxFVkJRVVVzWlVGQmVVSTdVVUZEZEVRc1RVRkJUU3hqUVVGakxFZEJRVWNzV1VGQldTeERRVUZETEZsQlFWa3NRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJRenRSUVVONFJDeFBRVUZQTEdOQlFXTXNTMEZCU3l4VFFVRlRMRWxCUVVrc1kwRkJZeXhMUVVGTExGbEJRVmtzUTBGQlF5eFpRVUZaTEVOQlFVTXNaVUZCWlN4RFFVRkRMRU5CUVVNN1NVRkRla2NzUTBGQlF6dEpRVVZFT3pzN08wOUJTVWM3U1VGRFNTeE5RVUZOTEVOQlFVTXNXVUZCV1N4RFFVRkRMRTFCUVZjN1VVRkRiRU1zU1VGQlNTeE5RVUZOTEV0QlFVc3NTVUZCU1N4SlFVRkpMRTFCUVUwc1MwRkJTeXhUUVVGVExFVkJRVVU3V1VGRGVrTXNUMEZCVHl4VFFVRlRMRU5CUVVNN1UwRkRjRUk3WVVGQlRUdFpRVU5JTEUxQlFVMHNWMEZCVnl4SFFVRkhMRTlCUVU4c1RVRkJUU3hMUVVGTExGVkJRVlVzUTBGQlF5eERRVUZETEVOQlFVTXNUVUZCVFN4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eE5RVUZOTEVOQlFVTXNWMEZCVnl4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRE8xbEJRM0pITEUxQlFVMHNUMEZCVHl4SFFVRkhMRmRCUVZjc1EwRkJReXhMUVVGTExFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTTdXVUZETVVNc1QwRkJUeXhEUVVGRExFOUJRVThzU1VGQlNTeFBRVUZQTEVOQlFVTXNUVUZCVFN4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExGTkJRVk1zUTBGQlF6dFRRVU51UlR0SlFVTk1MRU5CUVVNN1EwRkRTanRCUVRkRFJDeHZRMEUyUTBNaWZRPT0iLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKlxyXG4gKiBTdHJpbmcgaGVscGVyIG1ldGhvZHMuXHJcbiAqL1xyXG5jbGFzcyBTdHJpbmdIZWxwZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBJcyB0aGUgdmFsdWUgYSBzdHJpbmcuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgT2JqZWN0IHRvIHRlc3QgZm9yIGl0cyBzdHJpbmd5bmVzcy5cclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIG9iamVjdCBpcyBhIHN0cmluZy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzU3RyaW5nKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWRcclxuICAgICAgICAgICAgPyBmYWxzZSA6IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09IFwiW29iamVjdCBTdHJpbmddXCI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIElzIHRoZSB2YWx1ZSBhIHN0cmluZyB0aGF0IGlzIGVtcHR5LlxyXG4gICAgICogQHBhcmFtIHZhbHVlIE9iamVjdCB0byB0ZXN0IGZvciBpdHMgbm8gZW1wdHluZXNzLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGFuIGVtcHR5IHN0cmluZy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzRW1wdHkodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gIVN0cmluZ0hlbHBlci5pc1N0cmluZyh2YWx1ZSkgfHwgdmFsdWUubGVuZ3RoID09PSAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJcyB0aGUgc3RyaW5nIGFsbCBBU0NJSSBjaGFyYWN0ZXJzLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIHN0cmluZyB0byB0ZXN0IGlmIGlzIGlzIEFTQ0lJLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGFsbCBBU0NJSS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzQXNjaWkodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICA/IGZhbHNlIDogL15bXFx4MDAtXFx4RkZdKiQvLnRlc3QodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmNvZGUgbm9uIEFTQ0lJIGNoYXJhY3RlcnMgd2l0aCBjb250cm9sIGNoYXJhY3RlcnMuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHN0cmluZyB2YWx1ZSB0byBlc2NhcGUuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgZXNjYXBlZCB2ZXJzaW9uIG9mIHRoZSBzdHJpbmcuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBlbmNvZGVOb25BU0NJSSh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBTdHJpbmdIZWxwZXIuaXNTdHJpbmcodmFsdWUpID8gdmFsdWUucmVwbGFjZSgvW1xcdTAwN0YtXFx1RkZGRl0vZywgKGNocikgPT4gYFxcXFx1JHsoYDAwMDAke2Noci5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KX1gKS5zdWJzdHIoLTQpfWApIDogdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWNvZGUgY29udHJvbCBjaGFyYWN0ZXJzIHRvIEFTQ0lJLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBlbmNvZGVkIHN0cmluZyB0byBjb252ZXJ0IGJhY2sgdG8gQVNDSUkuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgZGVjb2RlZCB2ZXJzaW9uIG9mIHRoZSBzdHJpbmcuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBkZWNvZGVOb25BU0NJSSh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBTdHJpbmdIZWxwZXIuaXNTdHJpbmcodmFsdWUpID8gdmFsdWUucmVwbGFjZSgvXFxcXHUoW1xcZFxcd117NH0pL2dpLCAobWF0Y2gsIGdycCkgPT4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChncnAsIDE2KSkpIDogdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuU3RyaW5nSGVscGVyID0gU3RyaW5nSGVscGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2ljM1J5YVc1blNHVnNjR1Z5TG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhNaU9sc2lMaTR2TGk0dmMzSmpMMmhsYkhCbGNuTXZjM1J5YVc1blNHVnNjR1Z5TG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN1FVRkJRVHM3UjBGRlJ6dEJRVU5JTzBsQlEwazdPenM3VDBGSlJ6dEpRVU5KTEUxQlFVMHNRMEZCUXl4UlFVRlJMRU5CUVVNc1MwRkJWVHRSUVVNM1FpeFBRVUZQTEV0QlFVc3NTMEZCU3l4SlFVRkpMRWxCUVVrc1MwRkJTeXhMUVVGTExGTkJRVk03V1VGRGVFTXNRMEZCUXl4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zVFVGQlRTeERRVUZETEZOQlFWTXNRMEZCUXl4UlFVRlJMRU5CUVVNc1NVRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF5eExRVUZMTEdsQ1FVRnBRaXhEUVVGRE8wbEJRemxGTEVOQlFVTTdTVUZGUkRzN096dFBRVWxITzBsQlEwa3NUVUZCVFN4RFFVRkRMRTlCUVU4c1EwRkJReXhMUVVGVk8xRkJRelZDTEU5QlFVOHNRMEZCUXl4WlFVRlpMRU5CUVVNc1VVRkJVU3hEUVVGRExFdEJRVXNzUTBGQlF5eEpRVUZKTEV0QlFVc3NRMEZCUXl4TlFVRk5MRXRCUVVzc1EwRkJReXhEUVVGRE8wbEJReTlFTEVOQlFVTTdTVUZGUkRzN096dFBRVWxITzBsQlEwa3NUVUZCVFN4RFFVRkRMRTlCUVU4c1EwRkJReXhMUVVGaE8xRkJReTlDTEU5QlFVOHNTMEZCU3l4TFFVRkxMRWxCUVVrc1NVRkJTU3hMUVVGTExFdEJRVXNzVTBGQlV6dFpRVU40UXl4RFFVRkRMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF5eG5Ra0ZCWjBJc1EwRkJReXhKUVVGSkxFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTTdTVUZETDBNc1EwRkJRenRKUVVWRU96czdPMDlCU1VjN1NVRkRTU3hOUVVGTkxFTkJRVU1zWTBGQll5eERRVUZETEV0QlFXRTdVVUZEZEVNc1QwRkJUeXhaUVVGWkxFTkJRVU1zVVVGQlVTeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhMUVVGTExFTkJRVU1zVDBGQlR5eERRVUZETEd0Q1FVRnJRaXhGUVVGRkxFTkJRVU1zUjBGQlJ5eEZRVUZGTEVWQlFVVXNRMEZCUXl4TlFVRk5MRU5CUVVNc1QwRkJUeXhIUVVGSExFTkJRVU1zVlVGQlZTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRkZCUVZFc1EwRkJReXhGUVVGRkxFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4VFFVRlRMRU5CUVVNN1NVRkRMMG9zUTBGQlF6dEpRVVZFT3pzN08wOUJTVWM3U1VGRFNTeE5RVUZOTEVOQlFVTXNZMEZCWXl4RFFVRkRMRXRCUVdFN1VVRkRkRU1zVDBGQlR5eFpRVUZaTEVOQlFVTXNVVUZCVVN4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eExRVUZMTEVOQlFVTXNUMEZCVHl4RFFVRkRMR3RDUVVGclFpeEZRVUZGTEVOQlFVTXNTMEZCU3l4RlFVRkZMRWRCUVVjc1JVRkJSU3hGUVVGRkxFTkJRVU1zVFVGQlRTeERRVUZETEZsQlFWa3NRMEZCUXl4UlFVRlJMRU5CUVVNc1IwRkJSeXhGUVVGRkxFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1UwRkJVeXhEUVVGRE8wbEJRMmhLTEVOQlFVTTdRMEZEU2p0QlFTOURSQ3h2UTBFclEwTWlmUT09IiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKipcclxuICogUmVwcmVzZW50cyBhIGNsYXNzIHdoaWNoIGNhbiBwcm92aWRlIHRoZSB0aW1lLlxyXG4gKi9cclxuY2xhc3MgVGltZVNlcnZpY2Uge1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIDE5NzAvMDEvMDEuXHJcbiAgICAgKiBAcmV0dXJucyBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzLlxyXG4gICAgICovXHJcbiAgICBtc1NpbmNlRXBvY2goKSB7XHJcbiAgICAgICAgcmV0dXJuIERhdGUubm93KCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5UaW1lU2VydmljZSA9IFRpbWVTZXJ2aWNlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lkR2x0WlZObGNuWnBZMlV1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTh1TGk5emNtTXZjMlZ5ZG1salpYTXZkR2x0WlZObGNuWnBZMlV1ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWp0QlFVVkJPenRIUVVWSE8wRkJRMGc3U1VGRFNUczdPMDlCUjBjN1NVRkRTU3haUVVGWk8xRkJRMllzVDBGQlR5eEpRVUZKTEVOQlFVTXNSMEZCUnl4RlFVRkZMRU5CUVVNN1NVRkRkRUlzUTBGQlF6dERRVU5LTzBGQlVrUXNhME5CVVVNaWZRPT0iLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IG9iamVjdEhlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvb2JqZWN0SGVscGVyXCIpO1xyXG5jb25zdCBjcnlwdG9FcnJvcl8xID0gcmVxdWlyZShcIi4uL2Vycm9yL2NyeXB0b0Vycm9yXCIpO1xyXG4vKipcclxuICogU2hhMyBpbXBsZW1lbnRhdGlvbi5cclxuICovXHJcbmNsYXNzIFNoYTMge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgU0hBMy5cclxuICAgICAqIEBwYXJhbSBiaXRzIFRoZSBudW1iZXIgb2YgaW5wdXQgYml0cy5cclxuICAgICAqIEBwYXJhbSBwYWRkaW5nIFRoZSBwYWRkaW5nIHRvIHVzZS5cclxuICAgICAqIEBwYXJhbSBvdXRwdXRCaXRzIFRoZSBudW1iZXIgb2Ygb3V0cHV0IGJpdHMuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGJpdHMsIHBhZGRpbmcsIG91dHB1dEJpdHMpIHtcclxuICAgICAgICB0aGlzLl9wYWRkaW5nID0gcGFkZGluZztcclxuICAgICAgICB0aGlzLl9vdXRwdXRCaXRzID0gb3V0cHV0Qml0cztcclxuICAgICAgICB0aGlzLl9ibG9ja0NvdW50ID0gKDE2MDAgLSAoYml0cyA8PCAxKSkgPj4gNTtcclxuICAgICAgICB0aGlzLl9ieXRlQ291bnQgPSB0aGlzLl9ibG9ja0NvdW50IDw8IDI7XHJcbiAgICAgICAgdGhpcy5fb3V0cHV0QmxvY2tzID0gb3V0cHV0Qml0cyA+PiA1O1xyXG4gICAgICAgIHRoaXMuX2V4dHJhQnl0ZXMgPSAob3V0cHV0Qml0cyAmIDMxKSA+PiAzO1xyXG4gICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXQgdGhlIGRpZ2VzdC5cclxuICAgICAqL1xyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5fcmVzZXQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX2Jsb2NrID0gMDtcclxuICAgICAgICB0aGlzLl9zdGFydCA9IDA7XHJcbiAgICAgICAgdGhpcy5fYmxvY2tzID0gbmV3IFVpbnQzMkFycmF5KHRoaXMuX2Jsb2NrQ291bnQgKyAxKTtcclxuICAgICAgICB0aGlzLl9zdGF0ZSA9IG5ldyBVaW50MzJBcnJheSg1MCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSB0aGUgZGlnZXN0LlxyXG4gICAgICogQHBhcmFtIGlucHV0IEFycmF5IG9mIGRhdGEgdG8gdXNlIGluIHRoZSB1cGRhdGUuXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZShpbnB1dCkge1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZShpbnB1dCwgQXJyYXlCdWZmZXIpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiSW5wdXQgaXMgbm90IG9mIHR5cGUgQXJyYXlCdWZmZXJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBuZXcgVWludDhBcnJheShpbnB1dCk7XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gbWVzc2FnZS5sZW5ndGg7XHJcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcclxuICAgICAgICBsZXQgaTtcclxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3Jlc2V0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNldCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYmxvY2tzWzBdID0gdGhpcy5fYmxvY2s7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgdGhpcy5fYmxvY2tDb3VudCArIDE7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Jsb2Nrc1tpXSA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChpID0gdGhpcy5fc3RhcnQ7IGluZGV4IDwgbGVuZ3RoICYmIGkgPCB0aGlzLl9ieXRlQ291bnQ7ICsraW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Jsb2Nrc1tpID4+IDJdIHw9IG1lc3NhZ2VbaW5kZXhdIDw8IFNoYTMuU0hJRlRbaSsrICYgM107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbGFzdEJ5dGVJbmRleCA9IGk7XHJcbiAgICAgICAgICAgIGlmIChpID49IHRoaXMuX2J5dGVDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnQgPSBpIC0gdGhpcy5fYnl0ZUNvdW50O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYmxvY2sgPSB0aGlzLl9ibG9ja3NbdGhpcy5fYmxvY2tDb3VudF07XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5fYmxvY2tDb3VudDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhdGVbaV0gXj0gdGhpcy5fYmxvY2tzW2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5rZWNjYWtQZXJtdXRhdGlvbih0aGlzLl9zdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNldCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydCA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZpbmFsaXplIGFuZCByZXR1cm4gdGhlIGhhc2ggZm9yIHRoZSBkaWdlc3QsIHdpbGwgYWxzbyByZXNldCB0aGUgc3RhdGUuXHJcbiAgICAgKiBAcmV0dXJucyBBcnJheSBidWZmZXIgY29udGFpbmluZyB0aGUgZGlnZXN0LlxyXG4gICAgICovXHJcbiAgICBkaWdlc3QoKSB7XHJcbiAgICAgICAgdGhpcy5maW5hbGl6ZSgpO1xyXG4gICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICBsZXQgaiA9IDA7XHJcbiAgICAgICAgY29uc3QgYnl0ZXMgPSB0aGlzLl9vdXRwdXRCaXRzID4+IDM7XHJcbiAgICAgICAgbGV0IGJ1ZmZlcjtcclxuICAgICAgICBpZiAodGhpcy5fZXh0cmFCeXRlcykge1xyXG4gICAgICAgICAgICBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoKHRoaXMuX291dHB1dEJsb2NrcyArIDEpIDw8IDIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyKTtcclxuICAgICAgICB3aGlsZSAoaiA8IHRoaXMuX291dHB1dEJsb2Nrcykge1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5fYmxvY2tDb3VudCAmJiBqIDwgdGhpcy5fb3V0cHV0QmxvY2tzOyArK2ksICsraikge1xyXG4gICAgICAgICAgICAgICAgYXJyYXlbal0gPSB0aGlzLl9zdGF0ZVtpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fZXh0cmFCeXRlcykge1xyXG4gICAgICAgICAgICBhcnJheVtpXSA9IHRoaXMuX3N0YXRlW2ldO1xyXG4gICAgICAgICAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UoMCwgYnl0ZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlc2V0KCk7XHJcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcclxuICAgIH1cclxuICAgIC8qIEBpbnRlcm5hbCAqL1xyXG4gICAgZmluYWxpemUoKSB7XHJcbiAgICAgICAgbGV0IGkgPSB0aGlzLl9sYXN0Qnl0ZUluZGV4O1xyXG4gICAgICAgIHRoaXMuX2Jsb2Nrc1tpID4+IDJdIHw9IHRoaXMuX3BhZGRpbmdbaSAmIDNdO1xyXG4gICAgICAgIGlmICh0aGlzLl9sYXN0Qnl0ZUluZGV4ID09PSB0aGlzLl9ieXRlQ291bnQpIHtcclxuICAgICAgICAgICAgdGhpcy5fYmxvY2tzWzBdID0gdGhpcy5fYmxvY2tzW3RoaXMuX2Jsb2NrQ291bnRdO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgdGhpcy5fYmxvY2tDb3VudCArIDE7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYmxvY2tzW2ldID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9ibG9ja3NbdGhpcy5fYmxvY2tDb3VudCAtIDFdIHw9IDB4ODAwMDAwMDA7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuX2Jsb2NrQ291bnQ7ICsraSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGF0ZVtpXSBePSB0aGlzLl9ibG9ja3NbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMua2VjY2FrUGVybXV0YXRpb24odGhpcy5fc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgLyogQGludGVybmFsICovXHJcbiAgICBrZWNjYWtQZXJtdXRhdGlvbihzKSB7XHJcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm9uZS12YXJpYWJsZS1wZXItZGVjbGFyYXRpb25cclxuICAgICAgICBsZXQgaCwgbCwgbiwgYzAsIGMxLCBjMiwgYzMsIGM0LCBjNSwgYzYsIGM3LCBjOCwgYzksIGIwLCBiMSwgYjIsIGIzLCBiNCwgYjUsIGI2LCBiNywgYjgsIGI5LCBiMTAsIGIxMSwgYjEyLCBiMTMsIGIxNCwgYjE1LCBiMTYsIGIxNywgYjE4LCBiMTksIGIyMCwgYjIxLCBiMjIsIGIyMywgYjI0LCBiMjUsIGIyNiwgYjI3LCBiMjgsIGIyOSwgYjMwLCBiMzEsIGIzMiwgYjMzLCBiMzQsIGIzNSwgYjM2LCBiMzcsIGIzOCwgYjM5LCBiNDAsIGI0MSwgYjQyLCBiNDMsIGI0NCwgYjQ1LCBiNDYsIGI0NywgYjQ4LCBiNDk7XHJcbiAgICAgICAgZm9yIChuID0gMDsgbiA8IDQ4OyBuICs9IDIpIHtcclxuICAgICAgICAgICAgYzAgPSBzWzBdIF4gc1sxMF0gXiBzWzIwXSBeIHNbMzBdIF4gc1s0MF07XHJcbiAgICAgICAgICAgIGMxID0gc1sxXSBeIHNbMTFdIF4gc1syMV0gXiBzWzMxXSBeIHNbNDFdO1xyXG4gICAgICAgICAgICBjMiA9IHNbMl0gXiBzWzEyXSBeIHNbMjJdIF4gc1szMl0gXiBzWzQyXTtcclxuICAgICAgICAgICAgYzMgPSBzWzNdIF4gc1sxM10gXiBzWzIzXSBeIHNbMzNdIF4gc1s0M107XHJcbiAgICAgICAgICAgIGM0ID0gc1s0XSBeIHNbMTRdIF4gc1syNF0gXiBzWzM0XSBeIHNbNDRdO1xyXG4gICAgICAgICAgICBjNSA9IHNbNV0gXiBzWzE1XSBeIHNbMjVdIF4gc1szNV0gXiBzWzQ1XTtcclxuICAgICAgICAgICAgYzYgPSBzWzZdIF4gc1sxNl0gXiBzWzI2XSBeIHNbMzZdIF4gc1s0Nl07XHJcbiAgICAgICAgICAgIGM3ID0gc1s3XSBeIHNbMTddIF4gc1syN10gXiBzWzM3XSBeIHNbNDddO1xyXG4gICAgICAgICAgICBjOCA9IHNbOF0gXiBzWzE4XSBeIHNbMjhdIF4gc1szOF0gXiBzWzQ4XTtcclxuICAgICAgICAgICAgYzkgPSBzWzldIF4gc1sxOV0gXiBzWzI5XSBeIHNbMzldIF4gc1s0OV07XHJcbiAgICAgICAgICAgIGggPSBjOCBeICgoYzIgPDwgMSkgfCAoYzMgPj4+IDMxKSk7XHJcbiAgICAgICAgICAgIGwgPSBjOSBeICgoYzMgPDwgMSkgfCAoYzIgPj4+IDMxKSk7XHJcbiAgICAgICAgICAgIHNbMF0gXj0gaDtcclxuICAgICAgICAgICAgc1sxXSBePSBsO1xyXG4gICAgICAgICAgICBzWzEwXSBePSBoO1xyXG4gICAgICAgICAgICBzWzExXSBePSBsO1xyXG4gICAgICAgICAgICBzWzIwXSBePSBoO1xyXG4gICAgICAgICAgICBzWzIxXSBePSBsO1xyXG4gICAgICAgICAgICBzWzMwXSBePSBoO1xyXG4gICAgICAgICAgICBzWzMxXSBePSBsO1xyXG4gICAgICAgICAgICBzWzQwXSBePSBoO1xyXG4gICAgICAgICAgICBzWzQxXSBePSBsO1xyXG4gICAgICAgICAgICBoID0gYzAgXiAoKGM0IDw8IDEpIHwgKGM1ID4+PiAzMSkpO1xyXG4gICAgICAgICAgICBsID0gYzEgXiAoKGM1IDw8IDEpIHwgKGM0ID4+PiAzMSkpO1xyXG4gICAgICAgICAgICBzWzJdIF49IGg7XHJcbiAgICAgICAgICAgIHNbM10gXj0gbDtcclxuICAgICAgICAgICAgc1sxMl0gXj0gaDtcclxuICAgICAgICAgICAgc1sxM10gXj0gbDtcclxuICAgICAgICAgICAgc1syMl0gXj0gaDtcclxuICAgICAgICAgICAgc1syM10gXj0gbDtcclxuICAgICAgICAgICAgc1szMl0gXj0gaDtcclxuICAgICAgICAgICAgc1szM10gXj0gbDtcclxuICAgICAgICAgICAgc1s0Ml0gXj0gaDtcclxuICAgICAgICAgICAgc1s0M10gXj0gbDtcclxuICAgICAgICAgICAgaCA9IGMyIF4gKChjNiA8PCAxKSB8IChjNyA+Pj4gMzEpKTtcclxuICAgICAgICAgICAgbCA9IGMzIF4gKChjNyA8PCAxKSB8IChjNiA+Pj4gMzEpKTtcclxuICAgICAgICAgICAgc1s0XSBePSBoO1xyXG4gICAgICAgICAgICBzWzVdIF49IGw7XHJcbiAgICAgICAgICAgIHNbMTRdIF49IGg7XHJcbiAgICAgICAgICAgIHNbMTVdIF49IGw7XHJcbiAgICAgICAgICAgIHNbMjRdIF49IGg7XHJcbiAgICAgICAgICAgIHNbMjVdIF49IGw7XHJcbiAgICAgICAgICAgIHNbMzRdIF49IGg7XHJcbiAgICAgICAgICAgIHNbMzVdIF49IGw7XHJcbiAgICAgICAgICAgIHNbNDRdIF49IGg7XHJcbiAgICAgICAgICAgIHNbNDVdIF49IGw7XHJcbiAgICAgICAgICAgIGggPSBjNCBeICgoYzggPDwgMSkgfCAoYzkgPj4+IDMxKSk7XHJcbiAgICAgICAgICAgIGwgPSBjNSBeICgoYzkgPDwgMSkgfCAoYzggPj4+IDMxKSk7XHJcbiAgICAgICAgICAgIHNbNl0gXj0gaDtcclxuICAgICAgICAgICAgc1s3XSBePSBsO1xyXG4gICAgICAgICAgICBzWzE2XSBePSBoO1xyXG4gICAgICAgICAgICBzWzE3XSBePSBsO1xyXG4gICAgICAgICAgICBzWzI2XSBePSBoO1xyXG4gICAgICAgICAgICBzWzI3XSBePSBsO1xyXG4gICAgICAgICAgICBzWzM2XSBePSBoO1xyXG4gICAgICAgICAgICBzWzM3XSBePSBsO1xyXG4gICAgICAgICAgICBzWzQ2XSBePSBoO1xyXG4gICAgICAgICAgICBzWzQ3XSBePSBsO1xyXG4gICAgICAgICAgICBoID0gYzYgXiAoKGMwIDw8IDEpIHwgKGMxID4+PiAzMSkpO1xyXG4gICAgICAgICAgICBsID0gYzcgXiAoKGMxIDw8IDEpIHwgKGMwID4+PiAzMSkpO1xyXG4gICAgICAgICAgICBzWzhdIF49IGg7XHJcbiAgICAgICAgICAgIHNbOV0gXj0gbDtcclxuICAgICAgICAgICAgc1sxOF0gXj0gaDtcclxuICAgICAgICAgICAgc1sxOV0gXj0gbDtcclxuICAgICAgICAgICAgc1syOF0gXj0gaDtcclxuICAgICAgICAgICAgc1syOV0gXj0gbDtcclxuICAgICAgICAgICAgc1szOF0gXj0gaDtcclxuICAgICAgICAgICAgc1szOV0gXj0gbDtcclxuICAgICAgICAgICAgc1s0OF0gXj0gaDtcclxuICAgICAgICAgICAgc1s0OV0gXj0gbDtcclxuICAgICAgICAgICAgYjAgPSBzWzBdO1xyXG4gICAgICAgICAgICBiMSA9IHNbMV07XHJcbiAgICAgICAgICAgIGIzMiA9IChzWzExXSA8PCA0KSB8IChzWzEwXSA+Pj4gMjgpO1xyXG4gICAgICAgICAgICBiMzMgPSAoc1sxMF0gPDwgNCkgfCAoc1sxMV0gPj4+IDI4KTtcclxuICAgICAgICAgICAgYjE0ID0gKHNbMjBdIDw8IDMpIHwgKHNbMjFdID4+PiAyOSk7XHJcbiAgICAgICAgICAgIGIxNSA9IChzWzIxXSA8PCAzKSB8IChzWzIwXSA+Pj4gMjkpO1xyXG4gICAgICAgICAgICBiNDYgPSAoc1szMV0gPDwgOSkgfCAoc1szMF0gPj4+IDIzKTtcclxuICAgICAgICAgICAgYjQ3ID0gKHNbMzBdIDw8IDkpIHwgKHNbMzFdID4+PiAyMyk7XHJcbiAgICAgICAgICAgIGIyOCA9IChzWzQwXSA8PCAxOCkgfCAoc1s0MV0gPj4+IDE0KTtcclxuICAgICAgICAgICAgYjI5ID0gKHNbNDFdIDw8IDE4KSB8IChzWzQwXSA+Pj4gMTQpO1xyXG4gICAgICAgICAgICBiMjAgPSAoc1syXSA8PCAxKSB8IChzWzNdID4+PiAzMSk7XHJcbiAgICAgICAgICAgIGIyMSA9IChzWzNdIDw8IDEpIHwgKHNbMl0gPj4+IDMxKTtcclxuICAgICAgICAgICAgYjIgPSAoc1sxM10gPDwgMTIpIHwgKHNbMTJdID4+PiAyMCk7XHJcbiAgICAgICAgICAgIGIzID0gKHNbMTJdIDw8IDEyKSB8IChzWzEzXSA+Pj4gMjApO1xyXG4gICAgICAgICAgICBiMzQgPSAoc1syMl0gPDwgMTApIHwgKHNbMjNdID4+PiAyMik7XHJcbiAgICAgICAgICAgIGIzNSA9IChzWzIzXSA8PCAxMCkgfCAoc1syMl0gPj4+IDIyKTtcclxuICAgICAgICAgICAgYjE2ID0gKHNbMzNdIDw8IDEzKSB8IChzWzMyXSA+Pj4gMTkpO1xyXG4gICAgICAgICAgICBiMTcgPSAoc1szMl0gPDwgMTMpIHwgKHNbMzNdID4+PiAxOSk7XHJcbiAgICAgICAgICAgIGI0OCA9IChzWzQyXSA8PCAyKSB8IChzWzQzXSA+Pj4gMzApO1xyXG4gICAgICAgICAgICBiNDkgPSAoc1s0M10gPDwgMikgfCAoc1s0Ml0gPj4+IDMwKTtcclxuICAgICAgICAgICAgYjQwID0gKHNbNV0gPDwgMzApIHwgKHNbNF0gPj4+IDIpO1xyXG4gICAgICAgICAgICBiNDEgPSAoc1s0XSA8PCAzMCkgfCAoc1s1XSA+Pj4gMik7XHJcbiAgICAgICAgICAgIGIyMiA9IChzWzE0XSA8PCA2KSB8IChzWzE1XSA+Pj4gMjYpO1xyXG4gICAgICAgICAgICBiMjMgPSAoc1sxNV0gPDwgNikgfCAoc1sxNF0gPj4+IDI2KTtcclxuICAgICAgICAgICAgYjQgPSAoc1syNV0gPDwgMTEpIHwgKHNbMjRdID4+PiAyMSk7XHJcbiAgICAgICAgICAgIGI1ID0gKHNbMjRdIDw8IDExKSB8IChzWzI1XSA+Pj4gMjEpO1xyXG4gICAgICAgICAgICBiMzYgPSAoc1szNF0gPDwgMTUpIHwgKHNbMzVdID4+PiAxNyk7XHJcbiAgICAgICAgICAgIGIzNyA9IChzWzM1XSA8PCAxNSkgfCAoc1szNF0gPj4+IDE3KTtcclxuICAgICAgICAgICAgYjE4ID0gKHNbNDVdIDw8IDI5KSB8IChzWzQ0XSA+Pj4gMyk7XHJcbiAgICAgICAgICAgIGIxOSA9IChzWzQ0XSA8PCAyOSkgfCAoc1s0NV0gPj4+IDMpO1xyXG4gICAgICAgICAgICBiMTAgPSAoc1s2XSA8PCAyOCkgfCAoc1s3XSA+Pj4gNCk7XHJcbiAgICAgICAgICAgIGIxMSA9IChzWzddIDw8IDI4KSB8IChzWzZdID4+PiA0KTtcclxuICAgICAgICAgICAgYjQyID0gKHNbMTddIDw8IDIzKSB8IChzWzE2XSA+Pj4gOSk7XHJcbiAgICAgICAgICAgIGI0MyA9IChzWzE2XSA8PCAyMykgfCAoc1sxN10gPj4+IDkpO1xyXG4gICAgICAgICAgICBiMjQgPSAoc1syNl0gPDwgMjUpIHwgKHNbMjddID4+PiA3KTtcclxuICAgICAgICAgICAgYjI1ID0gKHNbMjddIDw8IDI1KSB8IChzWzI2XSA+Pj4gNyk7XHJcbiAgICAgICAgICAgIGI2ID0gKHNbMzZdIDw8IDIxKSB8IChzWzM3XSA+Pj4gMTEpO1xyXG4gICAgICAgICAgICBiNyA9IChzWzM3XSA8PCAyMSkgfCAoc1szNl0gPj4+IDExKTtcclxuICAgICAgICAgICAgYjM4ID0gKHNbNDddIDw8IDI0KSB8IChzWzQ2XSA+Pj4gOCk7XHJcbiAgICAgICAgICAgIGIzOSA9IChzWzQ2XSA8PCAyNCkgfCAoc1s0N10gPj4+IDgpO1xyXG4gICAgICAgICAgICBiMzAgPSAoc1s4XSA8PCAyNykgfCAoc1s5XSA+Pj4gNSk7XHJcbiAgICAgICAgICAgIGIzMSA9IChzWzldIDw8IDI3KSB8IChzWzhdID4+PiA1KTtcclxuICAgICAgICAgICAgYjEyID0gKHNbMThdIDw8IDIwKSB8IChzWzE5XSA+Pj4gMTIpO1xyXG4gICAgICAgICAgICBiMTMgPSAoc1sxOV0gPDwgMjApIHwgKHNbMThdID4+PiAxMik7XHJcbiAgICAgICAgICAgIGI0NCA9IChzWzI5XSA8PCA3KSB8IChzWzI4XSA+Pj4gMjUpO1xyXG4gICAgICAgICAgICBiNDUgPSAoc1syOF0gPDwgNykgfCAoc1syOV0gPj4+IDI1KTtcclxuICAgICAgICAgICAgYjI2ID0gKHNbMzhdIDw8IDgpIHwgKHNbMzldID4+PiAyNCk7XHJcbiAgICAgICAgICAgIGIyNyA9IChzWzM5XSA8PCA4KSB8IChzWzM4XSA+Pj4gMjQpO1xyXG4gICAgICAgICAgICBiOCA9IChzWzQ4XSA8PCAxNCkgfCAoc1s0OV0gPj4+IDE4KTtcclxuICAgICAgICAgICAgYjkgPSAoc1s0OV0gPDwgMTQpIHwgKHNbNDhdID4+PiAxOCk7XHJcbiAgICAgICAgICAgIHNbMF0gPSBiMCBeICh+YjIgJiBiNCk7XHJcbiAgICAgICAgICAgIHNbMV0gPSBiMSBeICh+YjMgJiBiNSk7XHJcbiAgICAgICAgICAgIHNbMTBdID0gYjEwIF4gKH5iMTIgJiBiMTQpO1xyXG4gICAgICAgICAgICBzWzExXSA9IGIxMSBeICh+YjEzICYgYjE1KTtcclxuICAgICAgICAgICAgc1syMF0gPSBiMjAgXiAofmIyMiAmIGIyNCk7XHJcbiAgICAgICAgICAgIHNbMjFdID0gYjIxIF4gKH5iMjMgJiBiMjUpO1xyXG4gICAgICAgICAgICBzWzMwXSA9IGIzMCBeICh+YjMyICYgYjM0KTtcclxuICAgICAgICAgICAgc1szMV0gPSBiMzEgXiAofmIzMyAmIGIzNSk7XHJcbiAgICAgICAgICAgIHNbNDBdID0gYjQwIF4gKH5iNDIgJiBiNDQpO1xyXG4gICAgICAgICAgICBzWzQxXSA9IGI0MSBeICh+YjQzICYgYjQ1KTtcclxuICAgICAgICAgICAgc1syXSA9IGIyIF4gKH5iNCAmIGI2KTtcclxuICAgICAgICAgICAgc1szXSA9IGIzIF4gKH5iNSAmIGI3KTtcclxuICAgICAgICAgICAgc1sxMl0gPSBiMTIgXiAofmIxNCAmIGIxNik7XHJcbiAgICAgICAgICAgIHNbMTNdID0gYjEzIF4gKH5iMTUgJiBiMTcpO1xyXG4gICAgICAgICAgICBzWzIyXSA9IGIyMiBeICh+YjI0ICYgYjI2KTtcclxuICAgICAgICAgICAgc1syM10gPSBiMjMgXiAofmIyNSAmIGIyNyk7XHJcbiAgICAgICAgICAgIHNbMzJdID0gYjMyIF4gKH5iMzQgJiBiMzYpO1xyXG4gICAgICAgICAgICBzWzMzXSA9IGIzMyBeICh+YjM1ICYgYjM3KTtcclxuICAgICAgICAgICAgc1s0Ml0gPSBiNDIgXiAofmI0NCAmIGI0Nik7XHJcbiAgICAgICAgICAgIHNbNDNdID0gYjQzIF4gKH5iNDUgJiBiNDcpO1xyXG4gICAgICAgICAgICBzWzRdID0gYjQgXiAofmI2ICYgYjgpO1xyXG4gICAgICAgICAgICBzWzVdID0gYjUgXiAofmI3ICYgYjkpO1xyXG4gICAgICAgICAgICBzWzE0XSA9IGIxNCBeICh+YjE2ICYgYjE4KTtcclxuICAgICAgICAgICAgc1sxNV0gPSBiMTUgXiAofmIxNyAmIGIxOSk7XHJcbiAgICAgICAgICAgIHNbMjRdID0gYjI0IF4gKH5iMjYgJiBiMjgpO1xyXG4gICAgICAgICAgICBzWzI1XSA9IGIyNSBeICh+YjI3ICYgYjI5KTtcclxuICAgICAgICAgICAgc1szNF0gPSBiMzQgXiAofmIzNiAmIGIzOCk7XHJcbiAgICAgICAgICAgIHNbMzVdID0gYjM1IF4gKH5iMzcgJiBiMzkpO1xyXG4gICAgICAgICAgICBzWzQ0XSA9IGI0NCBeICh+YjQ2ICYgYjQ4KTtcclxuICAgICAgICAgICAgc1s0NV0gPSBiNDUgXiAofmI0NyAmIGI0OSk7XHJcbiAgICAgICAgICAgIHNbNl0gPSBiNiBeICh+YjggJiBiMCk7XHJcbiAgICAgICAgICAgIHNbN10gPSBiNyBeICh+YjkgJiBiMSk7XHJcbiAgICAgICAgICAgIHNbMTZdID0gYjE2IF4gKH5iMTggJiBiMTApO1xyXG4gICAgICAgICAgICBzWzE3XSA9IGIxNyBeICh+YjE5ICYgYjExKTtcclxuICAgICAgICAgICAgc1syNl0gPSBiMjYgXiAofmIyOCAmIGIyMCk7XHJcbiAgICAgICAgICAgIHNbMjddID0gYjI3IF4gKH5iMjkgJiBiMjEpO1xyXG4gICAgICAgICAgICBzWzM2XSA9IGIzNiBeICh+YjM4ICYgYjMwKTtcclxuICAgICAgICAgICAgc1szN10gPSBiMzcgXiAofmIzOSAmIGIzMSk7XHJcbiAgICAgICAgICAgIHNbNDZdID0gYjQ2IF4gKH5iNDggJiBiNDApO1xyXG4gICAgICAgICAgICBzWzQ3XSA9IGI0NyBeICh+YjQ5ICYgYjQxKTtcclxuICAgICAgICAgICAgc1s4XSA9IGI4IF4gKH5iMCAmIGIyKTtcclxuICAgICAgICAgICAgc1s5XSA9IGI5IF4gKH5iMSAmIGIzKTtcclxuICAgICAgICAgICAgc1sxOF0gPSBiMTggXiAofmIxMCAmIGIxMik7XHJcbiAgICAgICAgICAgIHNbMTldID0gYjE5IF4gKH5iMTEgJiBiMTMpO1xyXG4gICAgICAgICAgICBzWzI4XSA9IGIyOCBeICh+YjIwICYgYjIyKTtcclxuICAgICAgICAgICAgc1syOV0gPSBiMjkgXiAofmIyMSAmIGIyMyk7XHJcbiAgICAgICAgICAgIHNbMzhdID0gYjM4IF4gKH5iMzAgJiBiMzIpO1xyXG4gICAgICAgICAgICBzWzM5XSA9IGIzOSBeICh+YjMxICYgYjMzKTtcclxuICAgICAgICAgICAgc1s0OF0gPSBiNDggXiAofmI0MCAmIGI0Mik7XHJcbiAgICAgICAgICAgIHNbNDldID0gYjQ5IF4gKH5iNDEgJiBiNDMpO1xyXG4gICAgICAgICAgICBzWzBdIF49IFNoYTMuUk9VTkRfQ09OU1RBTlRTW25dO1xyXG4gICAgICAgICAgICBzWzFdIF49IFNoYTMuUk9VTkRfQ09OU1RBTlRTW24gKyAxXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyogUGFkZGluZyB0byB1c2UgZm9yIEtlY2NhayAqL1xyXG5TaGEzLktFQ0NBS19QQURESU5HID0gbmV3IFVpbnQzMkFycmF5KFsxLCAyNTYsIDY1NTM2LCAxNjc3NzIxNl0pO1xyXG4vKiBAaW50ZXJuYWwgKi9cclxuU2hhMy5TSElGVCA9IG5ldyBVaW50OEFycmF5KFswLCA4LCAxNiwgMjRdKTtcclxuLyogQGludGVybmFsICovXHJcblNoYTMuUk9VTkRfQ09OU1RBTlRTID0gbmV3IFVpbnQzMkFycmF5KFsxLCAwLCAzMjg5OCwgMCwgMzI5MDYsIDIxNDc0ODM2NDgsIDIxNDc1MTY0MTYsIDIxNDc0ODM2NDgsIDMyOTA3LCAwLCAyMTQ3NDgzNjQ5LFxyXG4gICAgMCwgMjE0NzUxNjU0NSwgMjE0NzQ4MzY0OCwgMzI3NzcsIDIxNDc0ODM2NDgsIDEzOCwgMCwgMTM2LCAwLCAyMTQ3NTE2NDI1LCAwLFxyXG4gICAgMjE0NzQ4MzY1OCwgMCwgMjE0NzUxNjU1NSwgMCwgMTM5LCAyMTQ3NDgzNjQ4LCAzMjkwNSwgMjE0NzQ4MzY0OCwgMzI3NzEsXHJcbiAgICAyMTQ3NDgzNjQ4LCAzMjc3MCwgMjE0NzQ4MzY0OCwgMTI4LCAyMTQ3NDgzNjQ4LCAzMjc3OCwgMCwgMjE0NzQ4MzY1OCwgMjE0NzQ4MzY0OCxcclxuICAgIDIxNDc1MTY1NDUsIDIxNDc0ODM2NDgsIDMyODk2LCAyMTQ3NDgzNjQ4LCAyMTQ3NDgzNjQ5LCAwLCAyMTQ3NTE2NDI0LCAyMTQ3NDgzNjQ4XSk7XHJcbmV4cG9ydHMuU2hhMyA9IFNoYTM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWMyaGhNeTVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OWthV2RsYzNSekwzTm9ZVE11ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWp0QlFVRkJMRFJGUVVGNVJUdEJRVU42UlN4elJFRkJiVVE3UVVGRmJrUTdPMGRCUlVjN1FVRkRTRHRKUVhGRFNUczdPenM3VDBGTFJ6dEpRVU5JTEZsQlFWa3NTVUZCV1N4RlFVRkZMRTlCUVc5Q0xFVkJRVVVzVlVGQmEwSTdVVUZET1VRc1NVRkJTU3hEUVVGRExGRkJRVkVzUjBGQlJ5eFBRVUZQTEVOQlFVTTdVVUZEZUVJc1NVRkJTU3hEUVVGRExGZEJRVmNzUjBGQlJ5eFZRVUZWTEVOQlFVTTdVVUZET1VJc1NVRkJTU3hEUVVGRExGZEJRVmNzUjBGQlJ5eERRVUZETEVsQlFVa3NSMEZCUnl4RFFVRkRMRWxCUVVrc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0UlFVTTNReXhKUVVGSkxFTkJRVU1zVlVGQlZTeEhRVUZITEVsQlFVa3NRMEZCUXl4WFFVRlhMRWxCUVVrc1EwRkJReXhEUVVGRE8xRkJRM2hETEVsQlFVa3NRMEZCUXl4aFFVRmhMRWRCUVVjc1ZVRkJWU3hKUVVGSkxFTkJRVU1zUTBGQlF6dFJRVU55UXl4SlFVRkpMRU5CUVVNc1YwRkJWeXhIUVVGSExFTkJRVU1zVlVGQlZTeEhRVUZITEVWQlFVVXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRSUVVVeFF5eEpRVUZKTEVOQlFVTXNTMEZCU3l4RlFVRkZMRU5CUVVNN1NVRkRha0lzUTBGQlF6dEpRVVZFT3p0UFFVVkhPMGxCUTBrc1MwRkJTenRSUVVOU0xFbEJRVWtzUTBGQlF5eE5RVUZOTEVkQlFVY3NTVUZCU1N4RFFVRkRPMUZCUTI1Q0xFbEJRVWtzUTBGQlF5eE5RVUZOTEVkQlFVY3NRMEZCUXl4RFFVRkRPMUZCUTJoQ0xFbEJRVWtzUTBGQlF5eE5RVUZOTEVkQlFVY3NRMEZCUXl4RFFVRkRPMUZCUTJoQ0xFbEJRVWtzUTBGQlF5eFBRVUZQTEVkQlFVY3NTVUZCU1N4WFFVRlhMRU5CUVVNc1NVRkJTU3hEUVVGRExGZEJRVmNzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTnlSQ3hKUVVGSkxFTkJRVU1zVFVGQlRTeEhRVUZITEVsQlFVa3NWMEZCVnl4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRE8wbEJRM1JETEVOQlFVTTdTVUZGUkRzN08wOUJSMGM3U1VGRFNTeE5RVUZOTEVOQlFVTXNTMEZCYTBJN1VVRkROVUlzU1VGQlNTeERRVUZETERKQ1FVRlpMRU5CUVVNc1RVRkJUU3hEUVVGRExFdEJRVXNzUlVGQlJTeFhRVUZYTEVOQlFVTXNSVUZCUlR0WlFVTXhReXhOUVVGTkxFbEJRVWtzZVVKQlFWY3NRMEZCUXl4clEwRkJhME1zUTBGQlF5eERRVUZETzFOQlF6ZEVPMUZCUTBRc1RVRkJUU3hQUVVGUExFZEJRV1VzU1VGQlNTeFZRVUZWTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNN1VVRkRiRVFzVFVGQlRTeE5RVUZOTEVkQlFVY3NUMEZCVHl4RFFVRkRMRTFCUVUwc1EwRkJRenRSUVVNNVFpeEpRVUZKTEV0QlFVc3NSMEZCUnl4RFFVRkRMRU5CUVVNN1VVRkRaQ3hKUVVGSkxFTkJRVU1zUTBGQlF6dFJRVVZPTEU5QlFVOHNTMEZCU3l4SFFVRkhMRTFCUVUwc1JVRkJSVHRaUVVOdVFpeEpRVUZKTEVsQlFVa3NRMEZCUXl4TlFVRk5MRVZCUVVVN1owSkJRMklzU1VGQlNTeERRVUZETEUxQlFVMHNSMEZCUnl4TFFVRkxMRU5CUVVNN1owSkJRM0JDTEVsQlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJReXhEUVVGRExFZEJRVWNzU1VGQlNTeERRVUZETEUxQlFVMHNRMEZCUXp0blFrRkRPVUlzUzBGQlN5eERRVUZETEVkQlFVY3NRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhKUVVGSkxFTkJRVU1zVjBGQlZ5eEhRVUZITEVOQlFVTXNSVUZCUlN4RlFVRkZMRU5CUVVNc1JVRkJSVHR2UWtGRGRrTXNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTTdhVUpCUTNaQ08yRkJRMG83V1VGRFJDeExRVUZMTEVOQlFVTXNSMEZCUnl4SlFVRkpMRU5CUVVNc1RVRkJUU3hGUVVGRkxFdEJRVXNzUjBGQlJ5eE5RVUZOTEVsQlFVa3NRMEZCUXl4SFFVRkhMRWxCUVVrc1EwRkJReXhWUVVGVkxFVkJRVVVzUlVGQlJTeExRVUZMTEVWQlFVVTdaMEpCUTJ4RkxFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhKUVVGSkxFOUJRVThzUTBGQlF5eExRVUZMTEVOQlFVTXNTVUZCU1N4SlFVRkpMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUlVGQlJTeEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRPMkZCUTJwRk8xbEJRMFFzU1VGQlNTeERRVUZETEdOQlFXTXNSMEZCUnl4RFFVRkRMRU5CUVVNN1dVRkRlRUlzU1VGQlNTeERRVUZETEVsQlFVa3NTVUZCU1N4RFFVRkRMRlZCUVZVc1JVRkJSVHRuUWtGRGRFSXNTVUZCU1N4RFFVRkRMRTFCUVUwc1IwRkJSeXhEUVVGRExFZEJRVWNzU1VGQlNTeERRVUZETEZWQlFWVXNRMEZCUXp0blFrRkRiRU1zU1VGQlNTeERRVUZETEUxQlFVMHNSMEZCUnl4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFbEJRVWtzUTBGQlF5eFhRVUZYTEVOQlFVTXNRMEZCUXp0blFrRkROME1zUzBGQlN5eERRVUZETEVkQlFVY3NRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhKUVVGSkxFTkJRVU1zVjBGQlZ5eEZRVUZGTEVWQlFVVXNRMEZCUXl4RlFVRkZPMjlDUVVOdVF5eEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJReXhKUVVGSkxFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN2FVSkJRM0pETzJkQ1FVTkVMRWxCUVVrc1EwRkJReXhwUWtGQmFVSXNRMEZCUXl4SlFVRkpMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU03WjBKQlEzQkRMRWxCUVVrc1EwRkJReXhOUVVGTkxFZEJRVWNzU1VGQlNTeERRVUZETzJGQlEzUkNPMmxDUVVGTk8yZENRVU5JTEVsQlFVa3NRMEZCUXl4TlFVRk5MRWRCUVVjc1EwRkJReXhEUVVGRE8yRkJRMjVDTzFOQlEwbzdTVUZEVEN4RFFVRkRPMGxCUlVRN096dFBRVWRITzBsQlEwa3NUVUZCVFR0UlFVTlVMRWxCUVVrc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF6dFJRVVZvUWl4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU03VVVGRFZpeEpRVUZKTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNN1VVRkRWaXhOUVVGTkxFdEJRVXNzUjBGQlJ5eEpRVUZKTEVOQlFVTXNWMEZCVnl4SlFVRkpMRU5CUVVNc1EwRkJRenRSUVVOd1F5eEpRVUZKTEUxQlFVMHNRMEZCUXp0UlFVTllMRWxCUVVrc1NVRkJTU3hEUVVGRExGZEJRVmNzUlVGQlJUdFpRVU5zUWl4TlFVRk5MRWRCUVVjc1NVRkJTU3hYUVVGWExFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNZVUZCWVN4SFFVRkhMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETzFOQlF6TkVPMkZCUVUwN1dVRkRTQ3hOUVVGTkxFZEJRVWNzU1VGQlNTeFhRVUZYTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNN1UwRkRia003VVVGRFJDeE5RVUZOTEV0QlFVc3NSMEZCUnl4SlFVRkpMRmRCUVZjc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF6dFJRVU4wUXl4UFFVRlBMRU5CUVVNc1IwRkJSeXhKUVVGSkxFTkJRVU1zWVVGQllTeEZRVUZGTzFsQlF6TkNMRXRCUVVzc1EwRkJReXhIUVVGSExFTkJRVU1zUlVGQlJTeERRVUZETEVkQlFVY3NTVUZCU1N4RFFVRkRMRmRCUVZjc1NVRkJTU3hEUVVGRExFZEJRVWNzU1VGQlNTeERRVUZETEdGQlFXRXNSVUZCUlN4RlFVRkZMRU5CUVVNc1JVRkJSU3hGUVVGRkxFTkJRVU1zUlVGQlJUdG5Ra0ZEYkVVc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF5eEhRVUZITEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03WVVGRE4wSTdVMEZEU2p0UlFVTkVMRWxCUVVrc1NVRkJTU3hEUVVGRExGZEJRVmNzUlVGQlJUdFpRVU5zUWl4TFFVRkxMRU5CUVVNc1EwRkJReXhEUVVGRExFZEJRVWNzU1VGQlNTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVNeFFpeE5RVUZOTEVkQlFVY3NUVUZCVFN4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFVkJRVVVzUzBGQlN5eERRVUZETEVOQlFVTTdVMEZEYmtNN1VVRkRSQ3hKUVVGSkxFTkJRVU1zUzBGQlN5eEZRVUZGTEVOQlFVTTdVVUZGWWl4UFFVRlBMRTFCUVUwc1EwRkJRenRKUVVOc1FpeERRVUZETzBsQlJVUXNaVUZCWlR0SlFVTlFMRkZCUVZFN1VVRkRXaXhKUVVGSkxFTkJRVU1zUjBGQlJ5eEpRVUZKTEVOQlFVTXNZMEZCWXl4RFFVRkRPMUZCUXpWQ0xFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhKUVVGSkxFbEJRVWtzUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRemRETEVsQlFVa3NTVUZCU1N4RFFVRkRMR05CUVdNc1MwRkJTeXhKUVVGSkxFTkJRVU1zVlVGQlZTeEZRVUZGTzFsQlEzcERMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF5eERRVUZETEVkQlFVY3NTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhKUVVGSkxFTkJRVU1zVjBGQlZ5eERRVUZETEVOQlFVTTdXVUZEYWtRc1MwRkJTeXhEUVVGRExFZEJRVWNzUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUnl4SlFVRkpMRU5CUVVNc1YwRkJWeXhIUVVGSExFTkJRVU1zUlVGQlJTeEZRVUZGTEVOQlFVTXNSVUZCUlR0blFrRkRka01zU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU03WVVGRGRrSTdVMEZEU2p0UlFVTkVMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zU1VGQlNTeERRVUZETEZkQlFWY3NSMEZCUnl4RFFVRkRMRU5CUVVNc1NVRkJTU3hWUVVGVkxFTkJRVU03VVVGRGFrUXNTMEZCU3l4RFFVRkRMRWRCUVVjc1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlJ5eEpRVUZKTEVOQlFVTXNWMEZCVnl4RlFVRkZMRVZCUVVVc1EwRkJReXhGUVVGRk8xbEJRMjVETEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRExFbEJRVWtzU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRUUVVOeVF6dFJRVU5FTEVsQlFVa3NRMEZCUXl4cFFrRkJhVUlzUTBGQlF5eEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNN1NVRkRlRU1zUTBGQlF6dEpRVVZFTEdWQlFXVTdTVUZEVUN4cFFrRkJhVUlzUTBGQlF5eERRVUZqTzFGQlEzQkRMSGRFUVVGM1JEdFJRVU40UkN4SlFVRkpMRU5CUVVNc1JVRkJSU3hEUVVGRExFVkJRVVVzUTBGQlF5eEZRVUZGTEVWQlFVVXNSVUZCUlN4RlFVRkZMRVZCUVVVc1JVRkJSU3hGUVVGRkxFVkJRVVVzUlVGQlJTeEZRVUZGTEVWQlFVVXNSVUZCUlN4RlFVRkZMRVZCUVVVc1JVRkJSU3hGUVVGRkxFVkJRVVVzUlVGQlJTeEZRVUZGTEVWQlFVVXNSVUZETDBNc1JVRkJSU3hGUVVGRkxFVkJRVVVzUlVGQlJTeEZRVUZGTEVWQlFVVXNSVUZCUlN4RlFVRkZMRVZCUVVVc1JVRkJSU3hGUVVGRkxFVkJRVVVzUlVGQlJTeEZRVUZGTEVWQlFVVXNSVUZCUlN4RlFVRkZMRVZCUVVVc1JVRkJSU3hGUVVGRkxFZEJRVWNzUlVGQlJTeEhRVUZITEVWQlFVVXNSMEZCUnl4RlFVRkZMRWRCUVVjc1JVRkJSU3hIUVVGSExFVkJRVVVzUjBGQlJ5eEZRVUZGTEVkQlFVY3NSVUZCUlN4SFFVRkhMRVZCUXpsRkxFZEJRVWNzUlVGQlJTeEhRVUZITEVWQlFVVXNSMEZCUnl4RlFVRkZMRWRCUVVjc1JVRkJSU3hIUVVGSExFVkJRVVVzUjBGQlJ5eEZRVUZGTEVkQlFVY3NSVUZCUlN4SFFVRkhMRVZCUVVVc1IwRkJSeXhGUVVGRkxFZEJRVWNzUlVGQlJTeEhRVUZITEVWQlFVVXNSMEZCUnl4RlFVRkZMRWRCUVVjc1JVRkJSU3hIUVVGSExFVkJRVVVzUjBGQlJ5eEZRVUZGTEVkQlFVY3NSVUZET1VVc1IwRkJSeXhGUVVGRkxFZEJRVWNzUlVGQlJTeEhRVUZITEVWQlFVVXNSMEZCUnl4RlFVRkZMRWRCUVVjc1JVRkJSU3hIUVVGSExFVkJRVVVzUjBGQlJ5eEZRVUZGTEVkQlFVY3NSVUZCUlN4SFFVRkhMRVZCUVVVc1IwRkJSeXhGUVVGRkxFZEJRVWNzUlVGQlJTeEhRVUZITEVWQlFVVXNSMEZCUnl4RlFVRkZMRWRCUVVjc1JVRkJSU3hIUVVGSExFVkJRVVVzUjBGQlJ5eERRVUZETzFGQlEyNUdMRXRCUVVzc1EwRkJReXhIUVVGSExFTkJRVU1zUlVGQlJTeERRVUZETEVkQlFVY3NSVUZCUlN4RlFVRkZMRU5CUVVNc1NVRkJTU3hEUVVGRExFVkJRVVU3V1VGRGVFSXNSVUZCUlN4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTTdXVUZETVVNc1JVRkJSU3hIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNN1dVRkRNVU1zUlVGQlJTeEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU03V1VGRE1VTXNSVUZCUlN4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTTdXVUZETVVNc1JVRkJSU3hIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNN1dVRkRNVU1zUlVGQlJTeEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU03V1VGRE1VTXNSVUZCUlN4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTTdXVUZETVVNc1JVRkJSU3hIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNN1dVRkRNVU1zUlVGQlJTeEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU03V1VGRE1VTXNSVUZCUlN4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTTdXVUZGTVVNc1EwRkJReXhIUVVGSExFVkJRVVVzUjBGQlJ5eERRVUZETEVOQlFVTXNSVUZCUlN4SlFVRkpMRU5CUVVNc1EwRkJReXhIUVVGSExFTkJRVU1zUlVGQlJTeExRVUZMTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRia01zUTBGQlF5eEhRVUZITEVWQlFVVXNSMEZCUnl4RFFVRkRMRU5CUVVNc1JVRkJSU3hKUVVGSkxFTkJRVU1zUTBGQlF5eEhRVUZITEVOQlFVTXNSVUZCUlN4TFFVRkxMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGJrTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFpRVU5XTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRFZpeERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xbEJRMWdzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRaUVVOWUxFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1dVRkRXQ3hEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMWxCUTFnc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0WlFVTllMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdXVUZEV0N4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFsQlExZ3NRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFpRVU5ZTEVOQlFVTXNSMEZCUnl4RlFVRkZMRWRCUVVjc1EwRkJReXhEUVVGRExFVkJRVVVzU1VGQlNTeERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRVZCUVVVc1MwRkJTeXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEyNURMRU5CUVVNc1IwRkJSeXhGUVVGRkxFZEJRVWNzUTBGQlF5eERRVUZETEVWQlFVVXNTVUZCU1N4RFFVRkRMRU5CUVVNc1IwRkJSeXhEUVVGRExFVkJRVVVzUzBGQlN5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTI1RExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1dVRkRWaXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMWxCUTFZc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0WlFVTllMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdXVUZEV0N4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFsQlExZ3NRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFpRVU5ZTEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRFdDeERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xbEJRMWdzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRaUVVOWUxFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1dVRkRXQ3hEUVVGRExFZEJRVWNzUlVGQlJTeEhRVUZITEVOQlFVTXNRMEZCUXl4RlFVRkZMRWxCUVVrc1EwRkJReXhEUVVGRExFZEJRVWNzUTBGQlF5eEZRVUZGTEV0QlFVc3NSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOdVF5eERRVUZETEVkQlFVY3NSVUZCUlN4SFFVRkhMRU5CUVVNc1EwRkJReXhGUVVGRkxFbEJRVWtzUTBGQlF5eERRVUZETEVkQlFVY3NRMEZCUXl4RlFVRkZMRXRCUVVzc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU51UXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFsQlExWXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFpRVU5XTEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRFdDeERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xbEJRMWdzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRaUVVOWUxFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1dVRkRXQ3hEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMWxCUTFnc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0WlFVTllMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdXVUZEV0N4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFsQlExZ3NRMEZCUXl4SFFVRkhMRVZCUVVVc1IwRkJSeXhEUVVGRExFTkJRVU1zUlVGQlJTeEpRVUZKTEVOQlFVTXNRMEZCUXl4SFFVRkhMRU5CUVVNc1JVRkJSU3hMUVVGTExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEYmtNc1EwRkJReXhIUVVGSExFVkJRVVVzUjBGQlJ5eERRVUZETEVOQlFVTXNSVUZCUlN4SlFVRkpMRU5CUVVNc1EwRkJReXhIUVVGSExFTkJRVU1zUlVGQlJTeExRVUZMTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRia01zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRaUVVOV0xFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1dVRkRWaXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMWxCUTFnc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0WlFVTllMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdXVUZEV0N4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFsQlExZ3NRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFpRVU5ZTEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRFdDeERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xbEJRMWdzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRaUVVOWUxFTkJRVU1zUjBGQlJ5eEZRVUZGTEVkQlFVY3NRMEZCUXl4RFFVRkRMRVZCUVVVc1NVRkJTU3hEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETEVWQlFVVXNTMEZCU3l4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRMjVETEVOQlFVTXNSMEZCUnl4RlFVRkZMRWRCUVVjc1EwRkJReXhEUVVGRExFVkJRVVVzU1VGQlNTeERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRVZCUVVVc1MwRkJTeXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEyNURMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdXVUZEVml4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFsQlExWXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFpRVU5ZTEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRFdDeERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xbEJRMWdzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRaUVVOWUxFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1dVRkRXQ3hEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMWxCUTFnc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0WlFVTllMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdXVUZGV0N4RlFVRkZMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlExWXNSVUZCUlN4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5XTEVkQlFVY3NSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUzBGQlN5eEZRVUZGTEVOQlFVTXNRMEZCUXp0WlFVTndReXhIUVVGSExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRXRCUVVzc1JVRkJSU3hEUVVGRExFTkJRVU03V1VGRGNFTXNSMEZCUnl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eExRVUZMTEVWQlFVVXNRMEZCUXl4RFFVRkRPMWxCUTNCRExFZEJRVWNzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1MwRkJTeXhGUVVGRkxFTkJRVU1zUTBGQlF6dFpRVU53UXl4SFFVRkhMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEV0QlFVc3NSVUZCUlN4RFFVRkRMRU5CUVVNN1dVRkRjRU1zUjBGQlJ5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhMUVVGTExFVkJRVVVzUTBGQlF5eERRVUZETzFsQlEzQkRMRWRCUVVjc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNTVUZCU1N4RlFVRkZMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNTMEZCU3l4RlFVRkZMRU5CUVVNc1EwRkJRenRaUVVOeVF5eEhRVUZITEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFbEJRVWtzUlVGQlJTeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFdEJRVXNzUlVGQlJTeERRVUZETEVOQlFVTTdXVUZEY2tNc1IwRkJSeXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4TFFVRkxMRVZCUVVVc1EwRkJReXhEUVVGRE8xbEJRMnhETEVkQlFVY3NSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUzBGQlN5eEZRVUZGTEVOQlFVTXNRMEZCUXp0WlFVTnNReXhGUVVGRkxFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWxCUVVrc1JVRkJSU3hEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRXRCUVVzc1JVRkJSU3hEUVVGRExFTkJRVU03V1VGRGNFTXNSVUZCUlN4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEpRVUZKTEVWQlFVVXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eExRVUZMTEVWQlFVVXNRMEZCUXl4RFFVRkRPMWxCUTNCRExFZEJRVWNzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1NVRkJTU3hGUVVGRkxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1MwRkJTeXhGUVVGRkxFTkJRVU1zUTBGQlF6dFpRVU55UXl4SFFVRkhMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVsQlFVa3NSVUZCUlN4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEV0QlFVc3NSVUZCUlN4RFFVRkRMRU5CUVVNN1dVRkRja01zUjBGQlJ5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhKUVVGSkxFVkJRVVVzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhMUVVGTExFVkJRVVVzUTBGQlF5eERRVUZETzFsQlEzSkRMRWRCUVVjc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNTVUZCU1N4RlFVRkZMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNTMEZCU3l4RlFVRkZMRU5CUVVNc1EwRkJRenRaUVVOeVF5eEhRVUZITEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFdEJRVXNzUlVGQlJTeERRVUZETEVOQlFVTTdXVUZEY0VNc1IwRkJSeXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4TFFVRkxMRVZCUVVVc1EwRkJReXhEUVVGRE8xbEJRM0JETEVkQlFVY3NSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zU1VGQlNTeEZRVUZGTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTnNReXhIUVVGSExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRWxCUVVrc1JVRkJSU3hEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGJFTXNSMEZCUnl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eExRVUZMTEVWQlFVVXNRMEZCUXl4RFFVRkRPMWxCUTNCRExFZEJRVWNzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1MwRkJTeXhGUVVGRkxFTkJRVU1zUTBGQlF6dFpRVU53UXl4RlFVRkZMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVsQlFVa3NSVUZCUlN4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEV0QlFVc3NSVUZCUlN4RFFVRkRMRU5CUVVNN1dVRkRjRU1zUlVGQlJTeEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhKUVVGSkxFVkJRVVVzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhMUVVGTExFVkJRVVVzUTBGQlF5eERRVUZETzFsQlEzQkRMRWRCUVVjc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNTVUZCU1N4RlFVRkZMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNTMEZCU3l4RlFVRkZMRU5CUVVNc1EwRkJRenRaUVVOeVF5eEhRVUZITEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFbEJRVWtzUlVGQlJTeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFdEJRVXNzUlVGQlJTeERRVUZETEVOQlFVTTdXVUZEY2tNc1IwRkJSeXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SlFVRkpMRVZCUVVVc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRM0JETEVkQlFVY3NSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zU1VGQlNTeEZRVUZGTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTndReXhIUVVGSExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRWxCUVVrc1JVRkJSU3hEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGJFTXNSMEZCUnl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eEpRVUZKTEVWQlFVVXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTJ4RExFZEJRVWNzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1NVRkJTU3hGUVVGRkxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU53UXl4SFFVRkhMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVsQlFVa3NSVUZCUlN4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRjRU1zUjBGQlJ5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhKUVVGSkxFVkJRVVVzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEzQkRMRWRCUVVjc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNTVUZCU1N4RlFVRkZMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOd1F5eEZRVUZGTEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFbEJRVWtzUlVGQlJTeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFdEJRVXNzUlVGQlJTeERRVUZETEVOQlFVTTdXVUZEY0VNc1JVRkJSU3hIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SlFVRkpMRVZCUVVVc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4TFFVRkxMRVZCUVVVc1EwRkJReXhEUVVGRE8xbEJRM0JETEVkQlFVY3NSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zU1VGQlNTeEZRVUZGTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTndReXhIUVVGSExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWxCUVVrc1JVRkJSU3hEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGNFTXNSMEZCUnl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eEpRVUZKTEVWQlFVVXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTJ4RExFZEJRVWNzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1NVRkJTU3hGUVVGRkxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5zUXl4SFFVRkhMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVsQlFVa3NSVUZCUlN4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEV0QlFVc3NSVUZCUlN4RFFVRkRMRU5CUVVNN1dVRkRja01zUjBGQlJ5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhKUVVGSkxFVkJRVVVzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhMUVVGTExFVkJRVVVzUTBGQlF5eERRVUZETzFsQlEzSkRMRWRCUVVjc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNTMEZCU3l4RlFVRkZMRU5CUVVNc1EwRkJRenRaUVVOd1F5eEhRVUZITEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFdEJRVXNzUlVGQlJTeERRVUZETEVOQlFVTTdXVUZEY0VNc1IwRkJSeXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4TFFVRkxMRVZCUVVVc1EwRkJReXhEUVVGRE8xbEJRM0JETEVkQlFVY3NSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUzBGQlN5eEZRVUZGTEVOQlFVTXNRMEZCUXp0WlFVTndReXhGUVVGRkxFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWxCUVVrc1JVRkJSU3hEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRXRCUVVzc1JVRkJSU3hEUVVGRExFTkJRVU03V1VGRGNFTXNSVUZCUlN4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEpRVUZKTEVWQlFVVXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eExRVUZMTEVWQlFVVXNRMEZCUXl4RFFVRkRPMWxCUlhCRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNSMEZCUnl4RlFVRkZMRWRCUVVjc1EwRkJReXhEUVVGRExFVkJRVVVzUjBGQlJ5eEZRVUZGTEVOQlFVTXNRMEZCUXp0WlFVTjJRaXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVkQlFVY3NSVUZCUlN4SFFVRkhMRU5CUVVNc1EwRkJReXhGUVVGRkxFZEJRVWNzUlVGQlJTeERRVUZETEVOQlFVTTdXVUZEZGtJc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEVkQlFVY3NSMEZCUnl4RFFVRkRMRU5CUVVNc1IwRkJSeXhIUVVGSExFZEJRVWNzUTBGQlF5eERRVUZETzFsQlF6TkNMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlJ5eEhRVUZITEVkQlFVY3NRMEZCUXl4RFFVRkRMRWRCUVVjc1IwRkJSeXhIUVVGSExFTkJRVU1zUTBGQlF6dFpRVU16UWl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzUjBGQlJ5eEhRVUZITEVOQlFVTXNRMEZCUXl4SFFVRkhMRWRCUVVjc1IwRkJSeXhEUVVGRExFTkJRVU03V1VGRE0wSXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhIUVVGSExFZEJRVWNzUjBGQlJ5eERRVUZETEVOQlFVTXNSMEZCUnl4SFFVRkhMRWRCUVVjc1EwRkJReXhEUVVGRE8xbEJRek5DTEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhIUVVGSExFZEJRVWNzUTBGQlF5eERRVUZETEVkQlFVY3NSMEZCUnl4SFFVRkhMRU5CUVVNc1EwRkJRenRaUVVNelFpeERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1IwRkJSeXhIUVVGSExFTkJRVU1zUTBGQlF5eEhRVUZITEVkQlFVY3NSMEZCUnl4RFFVRkRMRU5CUVVNN1dVRkRNMElzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRWRCUVVjc1IwRkJSeXhEUVVGRExFTkJRVU1zUjBGQlJ5eEhRVUZITEVkQlFVY3NRMEZCUXl4RFFVRkRPMWxCUXpOQ0xFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUnl4SFFVRkhMRWRCUVVjc1EwRkJReXhEUVVGRExFZEJRVWNzUjBGQlJ5eEhRVUZITEVOQlFVTXNRMEZCUXp0WlFVTXpRaXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVkQlFVY3NSVUZCUlN4SFFVRkhMRU5CUVVNc1EwRkJReXhGUVVGRkxFZEJRVWNzUlVGQlJTeERRVUZETEVOQlFVTTdXVUZEZGtJc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eEhRVUZITEVWQlFVVXNSMEZCUnl4RFFVRkRMRU5CUVVNc1JVRkJSU3hIUVVGSExFVkJRVVVzUTBGQlF5eERRVUZETzFsQlEzWkNMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlJ5eEhRVUZITEVkQlFVY3NRMEZCUXl4RFFVRkRMRWRCUVVjc1IwRkJSeXhIUVVGSExFTkJRVU1zUTBGQlF6dFpRVU16UWl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzUjBGQlJ5eEhRVUZITEVOQlFVTXNRMEZCUXl4SFFVRkhMRWRCUVVjc1IwRkJSeXhEUVVGRExFTkJRVU03V1VGRE0wSXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhIUVVGSExFZEJRVWNzUjBGQlJ5eERRVUZETEVOQlFVTXNSMEZCUnl4SFFVRkhMRWRCUVVjc1EwRkJReXhEUVVGRE8xbEJRek5DTEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhIUVVGSExFZEJRVWNzUTBGQlF5eERRVUZETEVkQlFVY3NSMEZCUnl4SFFVRkhMRU5CUVVNc1EwRkJRenRaUVVNelFpeERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1IwRkJSeXhIUVVGSExFTkJRVU1zUTBGQlF5eEhRVUZITEVkQlFVY3NSMEZCUnl4RFFVRkRMRU5CUVVNN1dVRkRNMElzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRWRCUVVjc1IwRkJSeXhEUVVGRExFTkJRVU1zUjBGQlJ5eEhRVUZITEVkQlFVY3NRMEZCUXl4RFFVRkRPMWxCUXpOQ0xFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUnl4SFFVRkhMRWRCUVVjc1EwRkJReXhEUVVGRExFZEJRVWNzUjBGQlJ5eEhRVUZITEVOQlFVTXNRMEZCUXp0WlFVTXpRaXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVkQlFVY3NSMEZCUnl4SFFVRkhMRU5CUVVNc1EwRkJReXhIUVVGSExFZEJRVWNzUjBGQlJ5eERRVUZETEVOQlFVTTdXVUZETTBJc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eEhRVUZITEVWQlFVVXNSMEZCUnl4RFFVRkRMRU5CUVVNc1JVRkJSU3hIUVVGSExFVkJRVVVzUTBGQlF5eERRVUZETzFsQlEzWkNMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUjBGQlJ5eEZRVUZGTEVkQlFVY3NRMEZCUXl4RFFVRkRMRVZCUVVVc1IwRkJSeXhGUVVGRkxFTkJRVU1zUTBGQlF6dFpRVU4yUWl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzUjBGQlJ5eEhRVUZITEVOQlFVTXNRMEZCUXl4SFFVRkhMRWRCUVVjc1IwRkJSeXhEUVVGRExFTkJRVU03V1VGRE0wSXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhIUVVGSExFZEJRVWNzUjBGQlJ5eERRVUZETEVOQlFVTXNSMEZCUnl4SFFVRkhMRWRCUVVjc1EwRkJReXhEUVVGRE8xbEJRek5DTEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhIUVVGSExFZEJRVWNzUTBGQlF5eERRVUZETEVkQlFVY3NSMEZCUnl4SFFVRkhMRU5CUVVNc1EwRkJRenRaUVVNelFpeERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1IwRkJSeXhIUVVGSExFTkJRVU1zUTBGQlF5eEhRVUZITEVkQlFVY3NSMEZCUnl4RFFVRkRMRU5CUVVNN1dVRkRNMElzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRWRCUVVjc1IwRkJSeXhEUVVGRExFTkJRVU1zUjBGQlJ5eEhRVUZITEVkQlFVY3NRMEZCUXl4RFFVRkRPMWxCUXpOQ0xFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUnl4SFFVRkhMRWRCUVVjc1EwRkJReXhEUVVGRExFZEJRVWNzUjBGQlJ5eEhRVUZITEVOQlFVTXNRMEZCUXp0WlFVTXpRaXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVkQlFVY3NSMEZCUnl4SFFVRkhMRU5CUVVNc1EwRkJReXhIUVVGSExFZEJRVWNzUjBGQlJ5eERRVUZETEVOQlFVTTdXVUZETTBJc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEVkQlFVY3NSMEZCUnl4RFFVRkRMRU5CUVVNc1IwRkJSeXhIUVVGSExFZEJRVWNzUTBGQlF5eERRVUZETzFsQlF6TkNMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUjBGQlJ5eEZRVUZGTEVkQlFVY3NRMEZCUXl4RFFVRkRMRVZCUVVVc1IwRkJSeXhGUVVGRkxFTkJRVU1zUTBGQlF6dFpRVU4yUWl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFZEJRVWNzUlVGQlJTeEhRVUZITEVOQlFVTXNRMEZCUXl4RlFVRkZMRWRCUVVjc1JVRkJSU3hEUVVGRExFTkJRVU03V1VGRGRrSXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhIUVVGSExFZEJRVWNzUjBGQlJ5eERRVUZETEVOQlFVTXNSMEZCUnl4SFFVRkhMRWRCUVVjc1EwRkJReXhEUVVGRE8xbEJRek5DTEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhIUVVGSExFZEJRVWNzUTBGQlF5eERRVUZETEVkQlFVY3NSMEZCUnl4SFFVRkhMRU5CUVVNc1EwRkJRenRaUVVNelFpeERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1IwRkJSeXhIUVVGSExFTkJRVU1zUTBGQlF5eEhRVUZITEVkQlFVY3NSMEZCUnl4RFFVRkRMRU5CUVVNN1dVRkRNMElzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRWRCUVVjc1IwRkJSeXhEUVVGRExFTkJRVU1zUjBGQlJ5eEhRVUZITEVkQlFVY3NRMEZCUXl4RFFVRkRPMWxCUXpOQ0xFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUnl4SFFVRkhMRWRCUVVjc1EwRkJReXhEUVVGRExFZEJRVWNzUjBGQlJ5eEhRVUZITEVOQlFVTXNRMEZCUXp0WlFVTXpRaXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVkQlFVY3NSMEZCUnl4SFFVRkhMRU5CUVVNc1EwRkJReXhIUVVGSExFZEJRVWNzUjBGQlJ5eERRVUZETEVOQlFVTTdXVUZETTBJc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEVkQlFVY3NSMEZCUnl4RFFVRkRMRU5CUVVNc1IwRkJSeXhIUVVGSExFZEJRVWNzUTBGQlF5eERRVUZETzFsQlF6TkNMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlJ5eEhRVUZITEVkQlFVY3NRMEZCUXl4RFFVRkRMRWRCUVVjc1IwRkJSeXhIUVVGSExFTkJRVU1zUTBGQlF6dFpRVU16UWl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFZEJRVWNzUlVGQlJTeEhRVUZITEVOQlFVTXNRMEZCUXl4RlFVRkZMRWRCUVVjc1JVRkJSU3hEUVVGRExFTkJRVU03V1VGRGRrSXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhIUVVGSExFVkJRVVVzUjBGQlJ5eERRVUZETEVOQlFVTXNSVUZCUlN4SFFVRkhMRVZCUVVVc1EwRkJReXhEUVVGRE8xbEJRM1pDTEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhIUVVGSExFZEJRVWNzUTBGQlF5eERRVUZETEVkQlFVY3NSMEZCUnl4SFFVRkhMRU5CUVVNc1EwRkJRenRaUVVNelFpeERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1IwRkJSeXhIUVVGSExFTkJRVU1zUTBGQlF5eEhRVUZITEVkQlFVY3NSMEZCUnl4RFFVRkRMRU5CUVVNN1dVRkRNMElzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRWRCUVVjc1IwRkJSeXhEUVVGRExFTkJRVU1zUjBGQlJ5eEhRVUZITEVkQlFVY3NRMEZCUXl4RFFVRkRPMWxCUXpOQ0xFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUnl4SFFVRkhMRWRCUVVjc1EwRkJReXhEUVVGRExFZEJRVWNzUjBGQlJ5eEhRVUZITEVOQlFVTXNRMEZCUXp0WlFVTXpRaXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVkQlFVY3NSMEZCUnl4SFFVRkhMRU5CUVVNc1EwRkJReXhIUVVGSExFZEJRVWNzUjBGQlJ5eERRVUZETEVOQlFVTTdXVUZETTBJc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEVkQlFVY3NSMEZCUnl4RFFVRkRMRU5CUVVNc1IwRkJSeXhIUVVGSExFZEJRVWNzUTBGQlF5eERRVUZETzFsQlF6TkNMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlJ5eEhRVUZITEVkQlFVY3NRMEZCUXl4RFFVRkRMRWRCUVVjc1IwRkJSeXhIUVVGSExFTkJRVU1zUTBGQlF6dFpRVU16UWl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzUjBGQlJ5eEhRVUZITEVOQlFVTXNRMEZCUXl4SFFVRkhMRWRCUVVjc1IwRkJSeXhEUVVGRExFTkJRVU03V1VGRk0wSXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhKUVVGSkxFbEJRVWtzUTBGQlF5eGxRVUZsTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRhRU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4SlFVRkpMRWxCUVVrc1EwRkJReXhsUVVGbExFTkJRVU1zUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRPMU5CUTNaRE8wbEJRMHdzUTBGQlF6czdRVUZvVmtRc0swSkJRU3RDTzBGQlExSXNiVUpCUVdNc1IwRkJaMElzU1VGQlNTeFhRVUZYTEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1IwRkJSeXhGUVVGRkxFdEJRVXNzUlVGQlJTeFJRVUZSTEVOQlFVTXNRMEZCUXl4RFFVRkRPMEZCUTJoSExHVkJRV1U3UVVGRFV5eFZRVUZMTEVkQlFXVXNTVUZCU1N4VlFVRlZMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEZRVUZGTEVWQlFVVXNSVUZCUlN4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRE8wRkJRek5GTEdWQlFXVTdRVUZEVXl4dlFrRkJaU3hIUVVGblFpeEpRVUZKTEZkQlFWY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFVkJRVVVzUzBGQlN5eEZRVUZGTEVOQlFVTXNSVUZCUlN4TFFVRkxMRVZCUVVVc1ZVRkJWU3hGUVVGRkxGVkJRVlVzUlVGQlJTeFZRVUZWTEVWQlFVVXNTMEZCU3l4RlFVRkZMRU5CUVVNc1JVRkJSU3hWUVVGVk8wbEJRMjVLTEVOQlFVTXNSVUZCUlN4VlFVRlZMRVZCUVVVc1ZVRkJWU3hGUVVGRkxFdEJRVXNzUlVGQlJTeFZRVUZWTEVWQlFVVXNSMEZCUnl4RlFVRkZMRU5CUVVNc1JVRkJSU3hIUVVGSExFVkJRVVVzUTBGQlF5eEZRVUZGTEZWQlFWVXNSVUZCUlN4RFFVRkRPMGxCUXpORkxGVkJRVlVzUlVGQlJTeERRVUZETEVWQlFVVXNWVUZCVlN4RlFVRkZMRU5CUVVNc1JVRkJSU3hIUVVGSExFVkJRVVVzVlVGQlZTeEZRVUZGTEV0QlFVc3NSVUZCUlN4VlFVRlZMRVZCUVVVc1MwRkJTenRKUVVOMlJTeFZRVUZWTEVWQlFVVXNTMEZCU3l4RlFVRkZMRlZCUVZVc1JVRkJSU3hIUVVGSExFVkJRVVVzVlVGQlZTeEZRVUZGTEV0QlFVc3NSVUZCUlN4RFFVRkRMRVZCUVVVc1ZVRkJWU3hGUVVGRkxGVkJRVlU3U1VGRGFFWXNWVUZCVlN4RlFVRkZMRlZCUVZVc1JVRkJSU3hMUVVGTExFVkJRVVVzVlVGQlZTeEZRVUZGTEZWQlFWVXNSVUZCUlN4RFFVRkRMRVZCUVVVc1ZVRkJWU3hGUVVGRkxGVkJRVlVzUTBGQlF5eERRVUZETEVOQlFVTTdRVUZXTTBZc2IwSkJhMVpESW4wPSIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgY29yZUVycm9yXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jb3JlL2Rpc3QvZXJyb3IvY29yZUVycm9yXCIpO1xyXG4vKipcclxuICogQSBjcnlwdG8gaW1wbGVtZW50YXRpb24gb2YgYW4gZXJyb3IuXHJcbiAqL1xyXG5jbGFzcyBDcnlwdG9FcnJvciBleHRlbmRzIGNvcmVFcnJvcl8xLkNvcmVFcnJvciB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBDcnlwdG9FcnJvci5cclxuICAgICAqIEBwYXJhbSBtZXNzYWdlIFRoZSBtZXNzYWdlIGZvciB0aGUgZXJyb3IuXHJcbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbCBBZGRpdGlvbmFsIGRldGFpbHMgYWJvdXQgdGhlIGVycm9yLlxyXG4gICAgICogQHBhcmFtIGlubmVyRXJyb3IgQWRkIGluZm9ybWF0aW9uIGZyb20gaW5uZXIgZXJyb3IgaWYgdGhlcmUgd2FzIG9uZS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgYWRkaXRpb25hbCwgaW5uZXJFcnJvcikge1xyXG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsIGFkZGl0aW9uYWwsIGlubmVyRXJyb3IpO1xyXG4gICAgICAgIHRoaXMuZG9tYWluID0gXCJDcnlwdG9cIjtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkNyeXB0b0Vycm9yID0gQ3J5cHRvRXJyb3I7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVkzSjVjSFJ2UlhKeWIzSXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOHVMaTl6Y21NdlpYSnliM0l2WTNKNWNIUnZSWEp5YjNJdWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqdEJRVUZCTEc5RlFVRnBSVHRCUVVWcVJUczdSMEZGUnp0QlFVTklMR2xDUVVGNVFpeFRRVUZSTEhGQ1FVRlRPMGxCUTNSRE96czdPenRQUVV0SE8wbEJRMGdzV1VGQldTeFBRVUZsTEVWQlFVVXNWVUZCYTBNc1JVRkJSU3hWUVVGclFqdFJRVU12UlN4TFFVRkxMRU5CUVVNc1QwRkJUeXhGUVVGRkxGVkJRVlVzUlVGQlJTeFZRVUZWTEVOQlFVTXNRMEZCUXp0UlFVTjJReXhKUVVGSkxFTkJRVU1zVFVGQlRTeEhRVUZITEZGQlFWRXNRMEZCUXp0SlFVTXpRaXhEUVVGRE8wTkJRMG83UVVGWVJDeHJRMEZYUXlKOSIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgZmFjdG9yeUJhc2VfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9mYWN0b3JpZXMvZmFjdG9yeUJhc2VcIik7XHJcbmNvbnN0IGN1cmxfMSA9IHJlcXVpcmUoXCIuLi9zcG9uZ2VzL2N1cmxcIik7XHJcbmNvbnN0IGtlcmxfMSA9IHJlcXVpcmUoXCIuLi9zcG9uZ2VzL2tlcmxcIik7XHJcbi8qKlxyXG4gKiBGYWN0b3J5IHRvIGdlbmVyYXRlIHNwb25nZXMuXHJcbiAqL1xyXG5jbGFzcyBTcG9uZ2VGYWN0b3J5IGV4dGVuZHMgZmFjdG9yeUJhc2VfMS5GYWN0b3J5QmFzZSB7XHJcbiAgICAvKipcclxuICAgICAqIERvbid0IGFsbG93IG1hbnVhbCBjb25zdHJ1Y3Rpb24gb2YgdGhlIGZhY3RvcnkuXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBpbnN0YW5jZSBvZiB0aGUgZmFjdG9yeS5cclxuICAgICAqIEByZXR1cm5zIFRoZSBmYWN0b3J5IGluc3RhbmNlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaW5zdGFuY2UoKSB7XHJcbiAgICAgICAgaWYgKCFTcG9uZ2VGYWN0b3J5Ll9pbnN0YW5jZSkge1xyXG4gICAgICAgICAgICBTcG9uZ2VGYWN0b3J5Ll9pbnN0YW5jZSA9IG5ldyBTcG9uZ2VGYWN0b3J5KCk7XHJcbiAgICAgICAgICAgIFNwb25nZUZhY3RvcnkuX2luc3RhbmNlLnJlZ2lzdGVyKFwiY3VybFwiLCAoLi4uYXJncykgPT4gbmV3IGN1cmxfMS5DdXJsKC4uLmFyZ3MpKTtcclxuICAgICAgICAgICAgU3BvbmdlRmFjdG9yeS5faW5zdGFuY2UucmVnaXN0ZXIoXCJjdXJsODFcIiwgKC4uLmFyZ3MpID0+IG5ldyBjdXJsXzEuQ3VybCg4MSkpO1xyXG4gICAgICAgICAgICBTcG9uZ2VGYWN0b3J5Ll9pbnN0YW5jZS5yZWdpc3RlcihcImN1cmwyN1wiLCAoLi4uYXJncykgPT4gbmV3IGN1cmxfMS5DdXJsKDI3KSk7XHJcbiAgICAgICAgICAgIFNwb25nZUZhY3RvcnkuX2luc3RhbmNlLnJlZ2lzdGVyKFwia2VybFwiLCAoLi4uYXJncykgPT4gbmV3IGtlcmxfMS5LZXJsKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gU3BvbmdlRmFjdG9yeS5faW5zdGFuY2U7XHJcbiAgICB9XHJcbiAgICAvKiBAaW50ZXJuYWwgKi9cclxuICAgIGdldEluc3RhbmNlKCkge1xyXG4gICAgICAgIHJldHVybiBTcG9uZ2VGYWN0b3J5Lmluc3RhbmNlKCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5TcG9uZ2VGYWN0b3J5ID0gU3BvbmdlRmFjdG9yeTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYzNCdmJtZGxSbUZqZEc5eWVTNXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5bVlXTjBiM0pwWlhNdmMzQnZibWRsUm1GamRHOXllUzUwY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pTzBGQlFVRXNORVZCUVhsRk8wRkJSWHBGTERCRFFVRjFRenRCUVVOMlF5d3dRMEZCZFVNN1FVRkZka003TzBkQlJVYzdRVUZEU0N4dFFrRkJNa0lzVTBGQlVTeDVRa0ZCYjBJN1NVRkpia1E3T3p0UFFVZEhPMGxCUTBnN1VVRkRTU3hMUVVGTExFVkJRVVVzUTBGQlF6dEpRVU5hTEVOQlFVTTdTVUZGUkRzN08wOUJSMGM3U1VGRFNTeE5RVUZOTEVOQlFVTXNVVUZCVVR0UlFVTnNRaXhKUVVGSkxFTkJRVU1zWVVGQllTeERRVUZETEZOQlFWTXNSVUZCUlR0WlFVTXhRaXhoUVVGaExFTkJRVU1zVTBGQlV5eEhRVUZITEVsQlFVa3NZVUZCWVN4RlFVRkZMRU5CUVVNN1dVRkRPVU1zWVVGQllTeERRVUZETEZOQlFWTXNRMEZCUXl4UlFVRlJMRU5CUVVNc1RVRkJUU3hGUVVGRkxFTkJRVU1zUjBGQlJ5eEpRVUZKTEVWQlFVVXNSVUZCUlN4RFFVRkRMRWxCUVVrc1YwRkJTU3hEUVVGRExFZEJRVWNzU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTjZSU3hoUVVGaExFTkJRVU1zVTBGQlV5eERRVUZETEZGQlFWRXNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJReXhIUVVGSExFbEJRVWtzUlVGQlJTeEZRVUZGTEVOQlFVTXNTVUZCU1N4WFFVRkpMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU4wUlN4aFFVRmhMRU5CUVVNc1UwRkJVeXhEUVVGRExGRkJRVkVzUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXl4SFFVRkhMRWxCUVVrc1JVRkJSU3hGUVVGRkxFTkJRVU1zU1VGQlNTeFhRVUZKTEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOMFJTeGhRVUZoTEVOQlFVTXNVMEZCVXl4RFFVRkRMRkZCUVZFc1EwRkJReXhOUVVGTkxFVkJRVVVzUTBGQlF5eEhRVUZITEVsQlFVa3NSVUZCUlN4RlFVRkZMRU5CUVVNc1NVRkJTU3hYUVVGSkxFVkJRVVVzUTBGQlF5eERRVUZETzFOQlEzSkZPMUZCUTBRc1QwRkJUeXhoUVVGaExFTkJRVU1zVTBGQlV5eERRVUZETzBsQlEyNURMRU5CUVVNN1NVRkZSQ3hsUVVGbE8wbEJRMHdzVjBGQlZ6dFJRVU5xUWl4UFFVRlBMR0ZCUVdFc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF6dEpRVU53UXl4RFFVRkRPME5CUTBvN1FVRXZRa1FzYzBOQkswSkRJbjA9IiwidmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBudW1iZXJIZWxwZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL251bWJlckhlbHBlclwiKTtcclxuY29uc3Qgb2JqZWN0SGVscGVyXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9vYmplY3RIZWxwZXJcIik7XHJcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTppbXBvcnQtbmFtZVxyXG5jb25zdCBiaWdfaW50ZWdlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJiaWctaW50ZWdlclwiKSk7XHJcbmNvbnN0IGNyeXB0b0Vycm9yXzEgPSByZXF1aXJlKFwiLi4vZXJyb3IvY3J5cHRvRXJyb3JcIik7XHJcbi8qKlxyXG4gKiBIZWxwZXIgY2xhc3MgdG8gY29udmVydCBiZXR3ZWVuIEJpZ0ludGVnZXIgYW5kIG90aGVyIHR5cGVzLlxyXG4gKiBDb252ZXJ0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vaW90YWxlZGdlci9pcmkvYmxvYi9kZXYvc3JjL21haW4vamF2YS9jb20vaW90YS9pcmkvaGFzaC9LZXJsLmphdmFcclxuICovXHJcbmNsYXNzIEJpZ0ludGVnZXJIZWxwZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0IHRyaXRzIHRvIGEgYmlnSW50ZWdlci5cclxuICAgICAqIEBwYXJhbSB0cml0cyBUaGUgdHJpdHMgdG8gY29udmVydC5cclxuICAgICAqIEBwYXJhbSBvZmZzZXQgT2Zmc2V0IHdpdGhpbiB0aGUgYXJyYXkgdG8gc3RhcnQuXHJcbiAgICAgKiBAcGFyYW0gbGVuZ3RoIFRoZSBsZW5ndGggb2YgdGhlIHRyaXRzIGFycmF5IHRvIGNvbnZlcnQuXHJcbiAgICAgKiBAcmV0dXJucyBCaWcgaW50ZWdlciB2ZXJzaW9uIG9mIHRyaXRzLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdHJpdHNUb0JpZ0ludGVnZXIodHJpdHMsIG9mZnNldCwgbGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHRyaXRzLCBJbnQ4QXJyYXkpIHx8IHRyaXRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIlRoZSB0cml0cyBtdXN0IGJlIGEgbm9uIGVtcHR5IEludDhBcnJheVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKG9mZnNldCkgfHwgb2Zmc2V0IDwgMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIlRoZSBvZmZzZXQgbXVzdCBiZSBhIG51bWJlciA+PSAwXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIobGVuZ3RoKSB8fCBsZW5ndGggPD0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIlRoZSBsZW5ndGggbXVzdCBiZSBhIG51bWJlciA+IDBcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvZmZzZXQgKyBsZW5ndGggPiB0cml0cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJUaGUgb2Zmc2V0ICsgbGVuZ3RoIGlzIGJleW9uZCB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHZhbHVlID0gYmlnX2ludGVnZXJfMS5kZWZhdWx0Lnplcm87XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUubXVsdGlwbHkoQmlnSW50ZWdlckhlbHBlci5SQURJWCkuYWRkKGJpZ19pbnRlZ2VyXzEuZGVmYXVsdCh0cml0c1tvZmZzZXQgKyBpXSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnQgYmlnSW50ZWdlciB0byB0cml0cy5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgYmlnSW50ZWdlciB0byBjb252ZXJ0IHRvIHRyaXRzLlxyXG4gICAgICogQHBhcmFtIHRyaXRzIFRoZSBhcnJheSB0byByZWNlaXZlIHRoZSB0cml0cy5cclxuICAgICAqIEBwYXJhbSBvZmZzZXQgVGhlIG9mZnNldCB0byBwbGFjZSB0aGUgdHJpdHMgaW4gdGhlIGFycmF5LlxyXG4gICAgICogQHBhcmFtIGxlbmd0aCBUaGUgbGVuZ3RoIG9mIHRoZSBhcnJheS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGJpZ0ludGVnZXJUb1RyaXRzKHZhbHVlLCB0cml0cywgb2Zmc2V0LCBsZW5ndGgpIHtcclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUodmFsdWUsIGJpZ19pbnRlZ2VyXzEuZGVmYXVsdCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJUaGUgdmFsdWUgbXVzdCBiZSBhIGJpZ0ludGVnZXIgdHlwZVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHRyaXRzLCBJbnQ4QXJyYXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiVGhlIHRyaXRzIG11c3QgYmUgYW4gSW50OEFycmF5XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIob2Zmc2V0KSB8fCBvZmZzZXQgPCAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiVGhlIG9mZnNldCBtdXN0IGJlIGEgbnVtYmVyID49IDBcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihsZW5ndGgpIHx8IGxlbmd0aCA8PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiVGhlIGxlbmd0aCBtdXN0IGJlIGEgbnVtYmVyID4gMFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9mZnNldCArIGxlbmd0aCA+IHRyaXRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIlRoZSBvZmZzZXQgKyBsZW5ndGggaXMgYmV5b25kIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgYWJzb2x1dGVWYWx1ZSA9IHZhbHVlLmNvbXBhcmVUbyhiaWdfaW50ZWdlcl8xLmRlZmF1bHQuemVybykgPCAwID8gdmFsdWUubmVnYXRlKCkgOiB2YWx1ZTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpdlJlbWFpbmRlciA9IGFic29sdXRlVmFsdWUuZGl2bW9kKEJpZ0ludGVnZXJIZWxwZXIuUkFESVgpO1xyXG4gICAgICAgICAgICBhYnNvbHV0ZVZhbHVlID0gZGl2UmVtYWluZGVyLnF1b3RpZW50O1xyXG4gICAgICAgICAgICBsZXQgcmVtYWluZGVyID0gZGl2UmVtYWluZGVyLnJlbWFpbmRlcjtcclxuICAgICAgICAgICAgaWYgKHJlbWFpbmRlciA+IEJpZ0ludGVnZXJIZWxwZXIuTUFYX1RSSVRfVkFMVUUpIHtcclxuICAgICAgICAgICAgICAgIHJlbWFpbmRlciA9IEJpZ0ludGVnZXJIZWxwZXIuTUlOX1RSSVRfVkFMVUU7XHJcbiAgICAgICAgICAgICAgICBhYnNvbHV0ZVZhbHVlID0gYWJzb2x1dGVWYWx1ZS5hZGQoYmlnX2ludGVnZXJfMS5kZWZhdWx0W1wiMVwiXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHJpdHNbb2Zmc2V0ICsgaV0gPSByZW1haW5kZXIudG9KU051bWJlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmFsdWUuY29tcGFyZVRvKGJpZ19pbnRlZ2VyXzEuZGVmYXVsdC56ZXJvKSA8IDApIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgLy8gQXZvaWQgbmVnYXRpdmUgemVyb1xyXG4gICAgICAgICAgICAgICAgdHJpdHNbb2Zmc2V0ICsgaV0gPSB0cml0c1tvZmZzZXQgKyBpXSA9PT0gMCA/IDAgOiAtdHJpdHNbb2Zmc2V0ICsgaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnQgdGhlIGJpZ0ludGVnZXIgaW50byBieXRlcy5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cclxuICAgICAqIEBwYXJhbSBkZXN0aW5hdGlvbiBUaGUgZGVzdGluYXRpb24gYXJyYXkgdG8gc3RvcmUgdGhlIGJ5dGVzLlxyXG4gICAgICogQHBhcmFtIG9mZnNldCBUaGUgb2Zmc2V0IHdpdGhpbiB0aGUgYXJyYXkgdG8gc3RvcmUgdGhlIGJ5dGVzLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYmlnSW50ZWdlclRvQnl0ZXModmFsdWUsIGRlc3RpbmF0aW9uLCBvZmZzZXQpIHtcclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUodmFsdWUsIGJpZ19pbnRlZ2VyXzEuZGVmYXVsdCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJUaGUgdmFsdWUgbXVzdCBiZSBhIGJpZ0ludGVnZXIgdHlwZVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKGRlc3RpbmF0aW9uLCBBcnJheUJ1ZmZlcikgfHwgZGVzdGluYXRpb24uYnl0ZUxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIlRoZSBkZXN0aW5hdGlvbiBtdXN0IGJlIGFuIGFycmF5XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIob2Zmc2V0KSB8fCBvZmZzZXQgPCAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiVGhlIG9mZnNldCBtdXN0IGJlIGEgbnVtYmVyID49IDBcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkZXN0aW5hdGlvbi5ieXRlTGVuZ3RoIC0gb2Zmc2V0IDwgQmlnSW50ZWdlckhlbHBlci5CWVRFX0hBU0hfTEVOR1RIKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKGBEZXN0aW5hdGlvbiBhcnJheSBoYXMgaW52YWxpZCBzaXplLCBpdCBtdXN0IGJlIGF0IGxlYXN0ICR7QmlnSW50ZWdlckhlbHBlci5CWVRFX0hBU0hfTEVOR1RIfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZW1lbWJlciBpZiBpdCBpcyBuZWdhdGl2ZSBmb3IgbGF0ZXJcclxuICAgICAgICBjb25zdCBpc05lZyA9IHZhbHVlLmlzTmVnYXRpdmUoKSA/IC0xIDogMDtcclxuICAgICAgICBsZXQgaGV4U3RyaW5nID0gdmFsdWUudG9TdHJpbmcoMTYpO1xyXG4gICAgICAgIGlmIChpc05lZyA9PT0gLTEpIHtcclxuICAgICAgICAgICAgLy8gQnV0IHJlbW92ZSBpdCBmb3Igbm93XHJcbiAgICAgICAgICAgIGhleFN0cmluZyA9IGhleFN0cmluZy5zbGljZSgxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTm93IG1ha2Ugc3VyZSB0aGUgaGV4IHN0cmluZyBpcyBhbiBldmVuIGxlbmd0aCBzbyB0aGUgcmVnZXggd29ya3NcclxuICAgICAgICBpZiAoaGV4U3RyaW5nLmxlbmd0aCAlIDIgPT09IDEpIHtcclxuICAgICAgICAgICAgaGV4U3RyaW5nID0gYDAke2hleFN0cmluZ31gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBtYXRjaGVzID0gaGV4U3RyaW5nLm1hdGNoKC9bMC05YS1mXXsyfS9nKTtcclxuICAgICAgICAvLyBDb252ZXJ0IHRoZSBoZXggdG8gbnVtYmVyc1xyXG4gICAgICAgIGNvbnN0IHNpZ25lZEJ5dGVzID0gbmV3IEludDhBcnJheShtYXRjaGVzXHJcbiAgICAgICAgICAgIC5tYXAoaGV4ID0+IHBhcnNlSW50KGAweCR7aGV4fWAsIDE2KSkpO1xyXG4gICAgICAgIGlmIChpc05lZyA9PT0gLTEpIHtcclxuICAgICAgICAgICAgQmlnSW50ZWdlckhlbHBlci50d29zQ29tcGxlbWVudChzaWduZWRCeXRlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGRlc3RpbmF0aW9uKTtcclxuICAgICAgICAvLyBQYWQgdGhlIHN0YXJ0IG9mIHRoZSBidWZmZXIgd2l0aCB0aGUgbmVnIHZhbHVlXHJcbiAgICAgICAgbGV0IGkgPSBvZmZzZXQ7XHJcbiAgICAgICAgd2hpbGUgKGkgKyBzaWduZWRCeXRlcy5sZW5ndGggPCBCaWdJbnRlZ2VySGVscGVyLkJZVEVfSEFTSF9MRU5HVEgpIHtcclxuICAgICAgICAgICAgZGF0YVZpZXcuc2V0SW50OChpKyssIGlzTmVnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQW5kIGNvcHkgaW4gdGhlIGFjdHVhbCBieXRlc1xyXG4gICAgICAgIGZvciAobGV0IGogPSBzaWduZWRCeXRlcy5sZW5ndGg7IGotLSA+IDA7KSB7XHJcbiAgICAgICAgICAgIGRhdGFWaWV3LnNldEludDgoaSsrLCBzaWduZWRCeXRlc1tzaWduZWRCeXRlcy5sZW5ndGggLSAxIC0gal0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydCBieXRlcyB0byBhIGJpZ0ludGVnZXIuXHJcbiAgICAgKiBAcGFyYW0gc291cmNlIFRoZSBzb3VyY2UgYnl0ZXMuXHJcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IFRoZSBvZmZzZXQgd2l0aGluIHRoZSBieXRlcyB0byBzdGFydCBjb252ZXJzaW9uLlxyXG4gICAgICogQHBhcmFtIGxlbmd0aCBUaGUgbGVuZ3RoIG9mIHRoZSBieXRlcyB0byB1c2UgZm9yIGNvbnZlcnNpb24uXHJcbiAgICAgKiBAcmV0dXJucyBCaWcgaW50ZWdlciB2ZXJzaW9uIG9mIGJ5dGVzLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYnl0ZXNUb0JpZ0ludGVnZXIoc291cmNlLCBvZmZzZXQsIGxlbmd0aCkge1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZShzb3VyY2UsIEFycmF5QnVmZmVyKSB8fCBzb3VyY2UuYnl0ZUxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIlRoZSBzb3VyY2UgbXVzdCBiZSBhIG5vbiBlbXB0eSBudW1iZXIgYXJyYXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihvZmZzZXQpIHx8IG9mZnNldCA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJUaGUgb2Zmc2V0IG11c3QgYmUgYSBudW1iZXIgPj0gMFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKGxlbmd0aCkgfHwgbGVuZ3RoIDw9IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJUaGUgbGVuZ3RoIG11c3QgYmUgYSBudW1iZXIgPiAwXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc291cmNlLmJ5dGVMZW5ndGggLSBvZmZzZXQgPCBCaWdJbnRlZ2VySGVscGVyLkJZVEVfSEFTSF9MRU5HVEgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoYFNvdXJjZSBhcnJheSBoYXMgaW52YWxpZCBzaXplLCBpdCBtdXN0IGJlIGF0IGxlYXN0ICR7QmlnSW50ZWdlckhlbHBlci5CWVRFX0hBU0hfTEVOR1RIfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhzb3VyY2UpO1xyXG4gICAgICAgIGxldCBzaWduZWRCeXRlcyA9IG5ldyBJbnQ4QXJyYXkoZGF0YVZpZXcuYnl0ZUxlbmd0aCk7XHJcbiAgICAgICAgZm9yIChsZXQgYiA9IDA7IGIgPCBkYXRhVmlldy5ieXRlTGVuZ3RoOyBiKyspIHtcclxuICAgICAgICAgICAgc2lnbmVkQnl0ZXNbYl0gPSBkYXRhVmlldy5nZXRJbnQ4KGIgKyBvZmZzZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZW1vdmUgdGhlIGluaXRpYWwgcGFkZGluZyBsZWF2aW5nIGF0IGxlYXN0IG9uZSBieXRlXHJcbiAgICAgICAgbGV0IHBhZGRpbmdPZmZzZXQgPSAwO1xyXG4gICAgICAgIGNvbnN0IGZpcnN0Qnl0ZSA9IHNpZ25lZEJ5dGVzWzBdO1xyXG4gICAgICAgIGNvbnN0IGlzTmVnID0gZmlyc3RCeXRlIDwgMDtcclxuICAgICAgICAvLyBJZiB0aGUgZmlyc3QgcGFkZGluZyBjaGFyYWN0ZXIgaXMgbmVnYXRpdmUgdGhlbiByZXZlcnNlIHRoZSAycyBjb21wbGVtZW50XHJcbiAgICAgICAgLy8gYnV0IGZpcnN0IHN0cmlwIG9mIHRoZSBsZWFkaW5nIHBhZGRpbmdcclxuICAgICAgICBpZiAoZmlyc3RCeXRlID09PSAwIHx8IGZpcnN0Qnl0ZSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgd2hpbGUgKHNpZ25lZEJ5dGVzW3BhZGRpbmdPZmZzZXRdID09PSBmaXJzdEJ5dGUgJiYgcGFkZGluZ09mZnNldCA8IHNpZ25lZEJ5dGVzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgIHBhZGRpbmdPZmZzZXQrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBTdHJpcCBhbnkgcGFkZGluZ1xyXG4gICAgICAgICAgICBzaWduZWRCeXRlcyA9IHNpZ25lZEJ5dGVzLnNsaWNlKHBhZGRpbmdPZmZzZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNOZWcpIHtcclxuICAgICAgICAgICAgQmlnSW50ZWdlckhlbHBlci50d29zQ29tcGxlbWVudChzaWduZWRCeXRlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBoZXhTdHJpbmcgPSBpc05lZyA/IFwiLVwiIDogXCJcIjtcclxuICAgICAgICBjb25zdCBkdiA9IG5ldyBEYXRhVmlldyhzaWduZWRCeXRlcy5idWZmZXIpO1xyXG4gICAgICAgIGZvciAobGV0IGggPSAwOyBoIDwgZHYuYnl0ZUxlbmd0aDsgaCsrKSB7XHJcbiAgICAgICAgICAgIGhleFN0cmluZyArPSBgMDAke2R2LmdldFVpbnQ4KGgpLnRvU3RyaW5nKDE2KX1gLnNsaWNlKC0yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJpZ19pbnRlZ2VyXzEuZGVmYXVsdChoZXhTdHJpbmcsIDE2KTtcclxuICAgIH1cclxuICAgIC8qIEBpbnRlcm5hbCAqL1xyXG4gICAgc3RhdGljIHR3b3NDb21wbGVtZW50KHNpZ25lZEJ5dGVzKSB7XHJcbiAgICAgICAgLy8gaWYgdGhlIHdob2xlIG51bWJlciBpcyBuZWdhdGl2ZSB0aGVuXHJcbiAgICAgICAgLy8gY2hhbmdlIHRvIDIncyBjb21wbGVtZW50cyBieSBub3RpbmcgYWxsIHRoZSBudW1iZXJzXHJcbiAgICAgICAgLy8gYW5kIGFkZGluZyAxIHRvIHRoZSBsYXN0IGkuZS4gfmJpZ251bSsxXHJcbiAgICAgICAgZm9yIChsZXQgYiA9IDA7IGIgPCBzaWduZWRCeXRlcy5sZW5ndGg7IGIrKykge1xyXG4gICAgICAgICAgICBzaWduZWRCeXRlc1tiXSA9IH5zaWduZWRCeXRlc1tiXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQWRkIDEgdG8gbGFzdCBudW1iZXIsIGlmIHRoZSBudW1iZXIgaXMgMHhGRiBjb250aW51ZSB0byBjYXJyeVxyXG4gICAgICAgIGxldCBjID0gc2lnbmVkQnl0ZXMubGVuZ3RoIC0gMTtcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIHNpZ25lZEJ5dGVzW2NdKys7XHJcbiAgICAgICAgfSB3aGlsZSAoc2lnbmVkQnl0ZXNbYy0tXSA9PT0gMCAmJiBjID4gMCk7XHJcbiAgICB9XHJcbn1cclxuLyogQGludGVybmFsICovXHJcbkJpZ0ludGVnZXJIZWxwZXIuUkFESVggPSBiaWdfaW50ZWdlcl8xLmRlZmF1bHQoMyk7XHJcbi8qIEBpbnRlcm5hbCAqL1xyXG5CaWdJbnRlZ2VySGVscGVyLk1BWF9UUklUX1ZBTFVFID0gQmlnSW50ZWdlckhlbHBlci5SQURJWC5taW51cygxKS5kaXZpZGUoMik7XHJcbi8qIEBpbnRlcm5hbCAqL1xyXG5CaWdJbnRlZ2VySGVscGVyLk1JTl9UUklUX1ZBTFVFID0gQmlnSW50ZWdlckhlbHBlci5NQVhfVFJJVF9WQUxVRS5uZWdhdGUoKTtcclxuLyogQGludGVybmFsICovXHJcbkJpZ0ludGVnZXJIZWxwZXIuQklUX0hBU0hfTEVOR1RIID0gMzg0O1xyXG4vKiBAaW50ZXJuYWwgKi9cclxuQmlnSW50ZWdlckhlbHBlci5CWVRFX0hBU0hfTEVOR1RIID0gQmlnSW50ZWdlckhlbHBlci5CSVRfSEFTSF9MRU5HVEggLyA4O1xyXG5leHBvcnRzLkJpZ0ludGVnZXJIZWxwZXIgPSBCaWdJbnRlZ2VySGVscGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lZbWxuU1c1MFpXZGxja2hsYkhCbGNpNXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5b1pXeHdaWEp6TDJKcFowbHVkR1ZuWlhKSVpXeHdaWEl1ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWpzN096dEJRVUZCTERSRlFVRjVSVHRCUVVONlJTdzBSVUZCZVVVN1FVRkRla1VzZFVOQlFYVkRPMEZCUTNaRExEaEVRVUZwUXp0QlFVTnFReXh6UkVGQmJVUTdRVUZGYmtRN096dEhRVWRITzBGQlEwZzdTVUZoU1RzN096czdPMDlCVFVjN1NVRkRTU3hOUVVGTkxFTkJRVU1zYVVKQlFXbENMRU5CUVVNc1MwRkJaMElzUlVGQlJTeE5RVUZqTEVWQlFVVXNUVUZCWXp0UlFVTTFSU3hKUVVGSkxFTkJRVU1zTWtKQlFWa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1MwRkJTeXhGUVVGRkxGTkJRVk1zUTBGQlF5eEpRVUZKTEV0QlFVc3NRMEZCUXl4TlFVRk5MRXRCUVVzc1EwRkJReXhGUVVGRk8xbEJRemxFTEUxQlFVMHNTVUZCU1N4NVFrRkJWeXhEUVVGRExIbERRVUY1UXl4RFFVRkRMRU5CUVVNN1UwRkRjRVU3VVVGRlJDeEpRVUZKTEVOQlFVTXNNa0pCUVZrc1EwRkJReXhUUVVGVExFTkJRVU1zVFVGQlRTeERRVUZETEVsQlFVa3NUVUZCVFN4SFFVRkhMRU5CUVVNc1JVRkJSVHRaUVVNdlF5eE5RVUZOTEVsQlFVa3NlVUpCUVZjc1EwRkJReXhyUTBGQmEwTXNRMEZCUXl4RFFVRkRPMU5CUXpkRU8xRkJSVVFzU1VGQlNTeERRVUZETERKQ1FVRlpMRU5CUVVNc1UwRkJVeXhEUVVGRExFMUJRVTBzUTBGQlF5eEpRVUZKTEUxQlFVMHNTVUZCU1N4RFFVRkRMRVZCUVVVN1dVRkRhRVFzVFVGQlRTeEpRVUZKTEhsQ1FVRlhMRU5CUVVNc2FVTkJRV2xETEVOQlFVTXNRMEZCUXp0VFFVTTFSRHRSUVVWRUxFbEJRVWtzVFVGQlRTeEhRVUZITEUxQlFVMHNSMEZCUnl4TFFVRkxMRU5CUVVNc1RVRkJUU3hGUVVGRk8xbEJRMmhETEUxQlFVMHNTVUZCU1N4NVFrRkJWeXhEUVVGRExIVkVRVUYxUkN4RFFVRkRMRU5CUVVNN1UwRkRiRVk3VVVGRlJDeEpRVUZKTEV0QlFVc3NSMEZCUnl4eFFrRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF6dFJRVVY0UWl4TFFVRkxMRWxCUVVrc1EwRkJReXhIUVVGSExFMUJRVTBzUjBGQlJ5eERRVUZETEVWQlFVVXNRMEZCUXl4SlFVRkpMRU5CUVVNc1JVRkJSU3hEUVVGRExFVkJRVVVzUlVGQlJUdFpRVU5zUXl4TFFVRkxMRWRCUVVjc1MwRkJTeXhEUVVGRExGRkJRVkVzUTBGQlF5eG5Ra0ZCWjBJc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF5eEhRVUZITEVOQlFVTXNjVUpCUVUwc1EwRkJReXhMUVVGTExFTkJRVU1zVFVGQlRTeEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRUUVVOcVJqdFJRVVZFTEU5QlFVOHNTMEZCU3l4RFFVRkRPMGxCUTJwQ0xFTkJRVU03U1VGRlJEczdPenM3TzA5QlRVYzdTVUZEU1N4TlFVRk5MRU5CUVVNc2FVSkJRV2xDTEVOQlFVTXNTMEZCZDBJc1JVRkJSU3hMUVVGblFpeEZRVUZGTEUxQlFXTXNSVUZCUlN4TlFVRmpPMUZCUTNSSExFbEJRVWtzUTBGQlF5d3lRa0ZCV1N4RFFVRkRMRTFCUVUwc1EwRkJReXhMUVVGTExFVkJRVVVzY1VKQlFVMHNRMEZCUXl4RlFVRkZPMWxCUTNKRExFMUJRVTBzU1VGQlNTeDVRa0ZCVnl4RFFVRkRMSEZEUVVGeFF5eERRVUZETEVOQlFVTTdVMEZEYUVVN1VVRkZSQ3hKUVVGSkxFTkJRVU1zTWtKQlFWa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1MwRkJTeXhGUVVGRkxGTkJRVk1zUTBGQlF5eEZRVUZGTzFsQlEzaERMRTFCUVUwc1NVRkJTU3g1UWtGQlZ5eERRVUZETEdkRFFVRm5ReXhEUVVGRExFTkJRVU03VTBGRE0wUTdVVUZGUkN4SlFVRkpMRU5CUVVNc01rSkJRVmtzUTBGQlF5eFRRVUZUTEVOQlFVTXNUVUZCVFN4RFFVRkRMRWxCUVVrc1RVRkJUU3hIUVVGSExFTkJRVU1zUlVGQlJUdFpRVU12UXl4TlFVRk5MRWxCUVVrc2VVSkJRVmNzUTBGQlF5eHJRMEZCYTBNc1EwRkJReXhEUVVGRE8xTkJRemRFTzFGQlJVUXNTVUZCU1N4RFFVRkRMREpDUVVGWkxFTkJRVU1zVTBGQlV5eERRVUZETEUxQlFVMHNRMEZCUXl4SlFVRkpMRTFCUVUwc1NVRkJTU3hEUVVGRExFVkJRVVU3V1VGRGFFUXNUVUZCVFN4SlFVRkpMSGxDUVVGWExFTkJRVU1zYVVOQlFXbERMRU5CUVVNc1EwRkJRenRUUVVNMVJEdFJRVVZFTEVsQlFVa3NUVUZCVFN4SFFVRkhMRTFCUVUwc1IwRkJSeXhMUVVGTExFTkJRVU1zVFVGQlRTeEZRVUZGTzFsQlEyaERMRTFCUVUwc1NVRkJTU3g1UWtGQlZ5eERRVUZETEhWRVFVRjFSQ3hEUVVGRExFTkJRVU03VTBGRGJFWTdVVUZGUkN4SlFVRkpMR0ZCUVdFc1IwRkJSeXhMUVVGTExFTkJRVU1zVTBGQlV5eERRVUZETEhGQ1FVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4TFFVRkxMRU5CUVVNc1RVRkJUU3hGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEV0QlFVc3NRMEZCUXp0UlFVVTVSU3hMUVVGTExFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1RVRkJUU3hGUVVGRkxFTkJRVU1zUlVGQlJTeEZRVUZGTzFsQlF6ZENMRTFCUVUwc1dVRkJXU3hIUVVGSExHRkJRV0VzUTBGQlF5eE5RVUZOTEVOQlFVTXNaMEpCUVdkQ0xFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTTdXVUZEYkVVc1lVRkJZU3hIUVVGSExGbEJRVmtzUTBGQlF5eFJRVUZSTEVOQlFVTTdXVUZEZEVNc1NVRkJTU3hUUVVGVExFZEJRVWNzV1VGQldTeERRVUZETEZOQlFWTXNRMEZCUXp0WlFVVjJReXhKUVVGSkxGTkJRVk1zUjBGQlJ5eG5Ra0ZCWjBJc1EwRkJReXhqUVVGakxFVkJRVVU3WjBKQlF6ZERMRk5CUVZNc1IwRkJSeXhuUWtGQlowSXNRMEZCUXl4alFVRmpMRU5CUVVNN1owSkJRelZETEdGQlFXRXNSMEZCUnl4aFFVRmhMRU5CUVVNc1IwRkJSeXhEUVVGRExIRkNRVUZOTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJRenRoUVVOc1JEdFpRVU5FTEV0QlFVc3NRMEZCUXl4TlFVRk5MRWRCUVVjc1EwRkJReXhEUVVGRExFZEJRVWNzVTBGQlV5eERRVUZETEZWQlFWVXNSVUZCUlN4RFFVRkRPMU5CUXpsRE8xRkJSVVFzU1VGQlNTeExRVUZMTEVOQlFVTXNVMEZCVXl4RFFVRkRMSEZDUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEVkQlFVY3NRMEZCUXl4RlFVRkZPMWxCUTJ4RExFdEJRVXNzU1VGQlNTeERRVUZETEVkQlFVY3NRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhOUVVGTkxFVkJRVVVzUTBGQlF5eEZRVUZGTEVWQlFVVTdaMEpCUXpkQ0xITkNRVUZ6UWp0blFrRkRkRUlzUzBGQlN5eERRVUZETEUxQlFVMHNSMEZCUnl4RFFVRkRMRU5CUVVNc1IwRkJSeXhMUVVGTExFTkJRVU1zVFVGQlRTeEhRVUZITEVOQlFVTXNRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRXRCUVVzc1EwRkJReXhOUVVGTkxFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTTdZVUZEZUVVN1UwRkRTanRKUVVOTUxFTkJRVU03U1VGRlJEczdPenM3VDBGTFJ6dEpRVU5KTEUxQlFVMHNRMEZCUXl4cFFrRkJhVUlzUTBGQlF5eExRVUYzUWl4RlFVRkZMRmRCUVhkQ0xFVkJRVVVzVFVGQll6dFJRVU01Uml4SlFVRkpMRU5CUVVNc01rSkJRVmtzUTBGQlF5eE5RVUZOTEVOQlFVTXNTMEZCU3l4RlFVRkZMSEZDUVVGTkxFTkJRVU1zUlVGQlJUdFpRVU55UXl4TlFVRk5MRWxCUVVrc2VVSkJRVmNzUTBGQlF5eHhRMEZCY1VNc1EwRkJReXhEUVVGRE8xTkJRMmhGTzFGQlJVUXNTVUZCU1N4RFFVRkRMREpDUVVGWkxFTkJRVU1zVFVGQlRTeERRVUZETEZkQlFWY3NSVUZCUlN4WFFVRlhMRU5CUVVNc1NVRkJTU3hYUVVGWExFTkJRVU1zVlVGQlZTeExRVUZMTEVOQlFVTXNSVUZCUlR0WlFVTm9SaXhOUVVGTkxFbEJRVWtzZVVKQlFWY3NRMEZCUXl4clEwRkJhME1zUTBGQlF5eERRVUZETzFOQlF6ZEVPMUZCUlVRc1NVRkJTU3hEUVVGRExESkNRVUZaTEVOQlFVTXNVMEZCVXl4RFFVRkRMRTFCUVUwc1EwRkJReXhKUVVGSkxFMUJRVTBzUjBGQlJ5eERRVUZETEVWQlFVVTdXVUZETDBNc1RVRkJUU3hKUVVGSkxIbENRVUZYTEVOQlFVTXNhME5CUVd0RExFTkJRVU1zUTBGQlF6dFRRVU0zUkR0UlFVVkVMRWxCUVVrc1YwRkJWeXhEUVVGRExGVkJRVlVzUjBGQlJ5eE5RVUZOTEVkQlFVY3NaMEpCUVdkQ0xFTkJRVU1zWjBKQlFXZENMRVZCUVVVN1dVRkRja1VzVFVGQlRTeEpRVUZKTEhsQ1FVRlhMRU5CUVVNc01rUkJRVEpFTEdkQ1FVRm5RaXhEUVVGRExHZENRVUZuUWl4RlFVRkZMRU5CUVVNc1EwRkJRenRUUVVONlNEdFJRVVZFTEhWRFFVRjFRenRSUVVOMlF5eE5RVUZOTEV0QlFVc3NSMEZCUnl4TFFVRkxMRU5CUVVNc1ZVRkJWU3hGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRk1VTXNTVUZCU1N4VFFVRlRMRWRCUVVjc1MwRkJTeXhEUVVGRExGRkJRVkVzUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXp0UlFVVnVReXhKUVVGSkxFdEJRVXNzUzBGQlN5eERRVUZETEVOQlFVTXNSVUZCUlR0WlFVTmtMSGRDUVVGM1FqdFpRVU40UWl4VFFVRlRMRWRCUVVjc1UwRkJVeXhEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0VFFVTnNRenRSUVVORUxHOUZRVUZ2UlR0UlFVTndSU3hKUVVGSkxGTkJRVk1zUTBGQlF5eE5RVUZOTEVkQlFVY3NRMEZCUXl4TFFVRkxMRU5CUVVNc1JVRkJSVHRaUVVNMVFpeFRRVUZUTEVkQlFVY3NTVUZCU1N4VFFVRlRMRVZCUVVVc1EwRkJRenRUUVVNdlFqdFJRVU5FTEUxQlFVMHNUMEZCVHl4SFFVRkhMRk5CUVZNc1EwRkJReXhMUVVGTExFTkJRVU1zWTBGQll5eERRVUZETEVOQlFVTTdVVUZGYUVRc05rSkJRVFpDTzFGQlF6ZENMRTFCUVUwc1YwRkJWeXhIUVVGSExFbEJRVWtzVTBGQlV5eERRVUZETEU5QlFVODdZVUZEY0VNc1IwRkJSeXhEUVVGRExFZEJRVWNzUTBGQlF5eEZRVUZGTEVOQlFVTXNVVUZCVVN4RFFVRkRMRXRCUVVzc1IwRkJSeXhGUVVGRkxFVkJRVVVzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUlRORExFbEJRVWtzUzBGQlN5eExRVUZMTEVOQlFVTXNRMEZCUXl4RlFVRkZPMWxCUTJRc1owSkJRV2RDTEVOQlFVTXNZMEZCWXl4RFFVRkRMRmRCUVZjc1EwRkJReXhEUVVGRE8xTkJRMmhFTzFGQlJVUXNUVUZCVFN4UlFVRlJMRWRCUVVjc1NVRkJTU3hSUVVGUkxFTkJRVU1zVjBGQlZ5eERRVUZETEVOQlFVTTdVVUZGTTBNc2FVUkJRV2xFTzFGQlEycEVMRWxCUVVrc1EwRkJReXhIUVVGSExFMUJRVTBzUTBGQlF6dFJRVU5tTEU5QlFVOHNRMEZCUXl4SFFVRkhMRmRCUVZjc1EwRkJReXhOUVVGTkxFZEJRVWNzWjBKQlFXZENMRU5CUVVNc1owSkJRV2RDTEVWQlFVVTdXVUZETDBRc1VVRkJVU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEVWQlFVVXNSVUZCUlN4TFFVRkxMRU5CUVVNc1EwRkJRenRUUVVOb1F6dFJRVU5FTEN0Q1FVRXJRanRSUVVNdlFpeExRVUZMTEVsQlFVa3NRMEZCUXl4SFFVRkhMRmRCUVZjc1EwRkJReXhOUVVGTkxFVkJRVVVzUTBGQlF5eEZRVUZGTEVkQlFVY3NRMEZCUXl4SFFVRkhPMWxCUTNaRExGRkJRVkVzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXl4RlFVRkZMRVZCUVVVc1YwRkJWeXhEUVVGRExGZEJRVmNzUTBGQlF5eE5RVUZOTEVkQlFVY3NRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VTBGRGJFVTdTVUZEVEN4RFFVRkRPMGxCUlVRN096czdPenRQUVUxSE8wbEJRMGtzVFVGQlRTeERRVUZETEdsQ1FVRnBRaXhEUVVGRExFMUJRVzFDTEVWQlFVVXNUVUZCWXl4RlFVRkZMRTFCUVdNN1VVRkRMMFVzU1VGQlNTeERRVUZETERKQ1FVRlpMRU5CUVVNc1RVRkJUU3hEUVVGRExFMUJRVTBzUlVGQlJTeFhRVUZYTEVOQlFVTXNTVUZCU1N4TlFVRk5MRU5CUVVNc1ZVRkJWU3hMUVVGTExFTkJRVU1zUlVGQlJUdFpRVU4wUlN4TlFVRk5MRWxCUVVrc2VVSkJRVmNzUTBGQlF5dzJRMEZCTmtNc1EwRkJReXhEUVVGRE8xTkJRM2hGTzFGQlJVUXNTVUZCU1N4RFFVRkRMREpDUVVGWkxFTkJRVU1zVTBGQlV5eERRVUZETEUxQlFVMHNRMEZCUXl4SlFVRkpMRTFCUVUwc1IwRkJSeXhEUVVGRExFVkJRVVU3V1VGREwwTXNUVUZCVFN4SlFVRkpMSGxDUVVGWExFTkJRVU1zYTBOQlFXdERMRU5CUVVNc1EwRkJRenRUUVVNM1JEdFJRVVZFTEVsQlFVa3NRMEZCUXl3eVFrRkJXU3hEUVVGRExGTkJRVk1zUTBGQlF5eE5RVUZOTEVOQlFVTXNTVUZCU1N4TlFVRk5MRWxCUVVrc1EwRkJReXhGUVVGRk8xbEJRMmhFTEUxQlFVMHNTVUZCU1N4NVFrRkJWeXhEUVVGRExHbERRVUZwUXl4RFFVRkRMRU5CUVVNN1UwRkROVVE3VVVGRlJDeEpRVUZKTEUxQlFVMHNRMEZCUXl4VlFVRlZMRWRCUVVjc1RVRkJUU3hIUVVGSExHZENRVUZuUWl4RFFVRkRMR2RDUVVGblFpeEZRVUZGTzFsQlEyaEZMRTFCUVUwc1NVRkJTU3g1UWtGQlZ5eERRVUZETEhORVFVRnpSQ3huUWtGQlowSXNRMEZCUXl4blFrRkJaMElzUlVGQlJTeERRVUZETEVOQlFVTTdVMEZEY0VnN1VVRkZSQ3hOUVVGTkxGRkJRVkVzUjBGQlJ5eEpRVUZKTEZGQlFWRXNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJRenRSUVVWMFF5eEpRVUZKTEZkQlFWY3NSMEZCUnl4SlFVRkpMRk5CUVZNc1EwRkJReXhSUVVGUkxFTkJRVU1zVlVGQlZTeERRVUZETEVOQlFVTTdVVUZEY2tRc1MwRkJTeXhKUVVGSkxFTkJRVU1zUjBGQlJ5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRkZCUVZFc1EwRkJReXhWUVVGVkxFVkJRVVVzUTBGQlF5eEZRVUZGTEVWQlFVVTdXVUZETVVNc1YwRkJWeXhEUVVGRExFTkJRVU1zUTBGQlF5eEhRVUZITEZGQlFWRXNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJReXhIUVVGSExFMUJRVTBzUTBGQlF5eERRVUZETzFOQlEycEVPMUZCUlVRc2RVUkJRWFZFTzFGQlEzWkVMRWxCUVVrc1lVRkJZU3hIUVVGSExFTkJRVU1zUTBGQlF6dFJRVU4wUWl4TlFVRk5MRk5CUVZNc1IwRkJSeXhYUVVGWExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEYWtNc1RVRkJUU3hMUVVGTExFZEJRVWNzVTBGQlV5eEhRVUZITEVOQlFVTXNRMEZCUXp0UlFVVTFRaXcwUlVGQk5FVTdVVUZETlVVc2VVTkJRWGxETzFGQlEzcERMRWxCUVVrc1UwRkJVeXhMUVVGTExFTkJRVU1zU1VGQlNTeFRRVUZUTEV0QlFVc3NRMEZCUXl4RFFVRkRMRVZCUVVVN1dVRkRja01zVDBGQlR5eFhRVUZYTEVOQlFVTXNZVUZCWVN4RFFVRkRMRXRCUVVzc1UwRkJVeXhKUVVGSkxHRkJRV0VzUjBGQlJ5eFhRVUZYTEVOQlFVTXNUVUZCVFN4SFFVRkhMRU5CUVVNc1JVRkJSVHRuUWtGRGRrWXNZVUZCWVN4RlFVRkZMRU5CUVVNN1lVRkRia0k3V1VGRFJDeHZRa0ZCYjBJN1dVRkRjRUlzVjBGQlZ5eEhRVUZITEZkQlFWY3NRMEZCUXl4TFFVRkxMRU5CUVVNc1lVRkJZU3hEUVVGRExFTkJRVU03VTBGRGJFUTdVVUZGUkN4SlFVRkpMRXRCUVVzc1JVRkJSVHRaUVVOUUxHZENRVUZuUWl4RFFVRkRMR05CUVdNc1EwRkJReXhYUVVGWExFTkJRVU1zUTBGQlF6dFRRVU5vUkR0UlFVVkVMRWxCUVVrc1UwRkJVeXhIUVVGSExFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU03VVVGRGFrTXNUVUZCVFN4RlFVRkZMRWRCUVVjc1NVRkJTU3hSUVVGUkxFTkJRVU1zVjBGQlZ5eERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRPMUZCUXpWRExFdEJRVXNzU1VGQlNTeERRVUZETEVkQlFVY3NRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhGUVVGRkxFTkJRVU1zVlVGQlZTeEZRVUZGTEVOQlFVTXNSVUZCUlN4RlFVRkZPMWxCUTNCRExGTkJRVk1zU1VGQlNTeExRVUZMTEVWQlFVVXNRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zVVVGQlVTeERRVUZETEVWQlFVVXNRMEZCUXl4RlFVRkZMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdVMEZETjBRN1VVRkZSQ3hQUVVGUExIRkNRVUZOTEVOQlFVTXNVMEZCVXl4RlFVRkZMRVZCUVVVc1EwRkJReXhEUVVGRE8wbEJRMnBETEVOQlFVTTdTVUZGUkN4bFFVRmxPMGxCUTFBc1RVRkJUU3hEUVVGRExHTkJRV01zUTBGQlF5eFhRVUZ6UWp0UlFVTm9SQ3gxUTBGQmRVTTdVVUZEZGtNc2MwUkJRWE5FTzFGQlEzUkVMREJEUVVFd1F6dFJRVU14UXl4TFFVRkxMRWxCUVVrc1EwRkJReXhIUVVGSExFTkJRVU1zUlVGQlJTeERRVUZETEVkQlFVY3NWMEZCVnl4RFFVRkRMRTFCUVUwc1JVRkJSU3hEUVVGRExFVkJRVVVzUlVGQlJUdFpRVU42UXl4WFFVRlhMRU5CUVVNc1EwRkJReXhEUVVGRExFZEJRVWNzUTBGQlF5eFhRVUZYTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1UwRkRjRU03VVVGRFJDeG5SVUZCWjBVN1VVRkRhRVVzU1VGQlNTeERRVUZETEVkQlFVY3NWMEZCVnl4RFFVRkRMRTFCUVUwc1IwRkJSeXhEUVVGRExFTkJRVU03VVVGREwwSXNSMEZCUnp0WlFVTkRMRmRCUVZjc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETzFOQlEzQkNMRkZCUVZFc1YwRkJWeXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEV0QlFVc3NRMEZCUXl4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFVkJRVVU3U1VGRE9VTXNRMEZCUXpzN1FVRnNUMFFzWlVGQlpUdEJRVU5UTEhOQ1FVRkxMRWRCUVhOQ0xIRkNRVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1FVRkROMFFzWlVGQlpUdEJRVU5UTEN0Q1FVRmpMRWRCUVhOQ0xHZENRVUZuUWl4RFFVRkRMRXRCUVVzc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8wRkJRM1JITEdWQlFXVTdRVUZEVXl3clFrRkJZeXhIUVVGelFpeG5Ra0ZCWjBJc1EwRkJReXhqUVVGakxFTkJRVU1zVFVGQlRTeEZRVUZGTEVOQlFVTTdRVUZGY2tjc1pVRkJaVHRCUVVOVExHZERRVUZsTEVkQlFWY3NSMEZCUnl4RFFVRkRPMEZCUTNSRUxHVkJRV1U3UVVGRFV5eHBRMEZCWjBJc1IwRkJWeXhuUWtGQlowSXNRMEZCUXl4bFFVRmxMRWRCUVVjc1EwRkJReXhEUVVGRE8wRkJXRFZHTERSRFFXOVBReUo5IiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBvYmplY3RIZWxwZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlclwiKTtcclxuY29uc3QgaGFzaF8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvaGFzaFwiKTtcclxuY29uc3QgdHJhbnNhY3Rpb25fMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL3RyYW5zYWN0aW9uXCIpO1xyXG5jb25zdCB0cml0c18xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvdHJpdHNcIik7XHJcbmNvbnN0IGNyeXB0b0Vycm9yXzEgPSByZXF1aXJlKFwiLi4vZXJyb3IvY3J5cHRvRXJyb3JcIik7XHJcbmNvbnN0IHNwb25nZUZhY3RvcnlfMSA9IHJlcXVpcmUoXCIuLi9mYWN0b3JpZXMvc3BvbmdlRmFjdG9yeVwiKTtcclxuLyoqXHJcbiAqIEhlbHBlciBjbGFzcyBmb3IgdHJhbnNhY3Rpb25zLlxyXG4gKiBDb252ZXJ0ZWQgaHR0cHM6Ly9naXRodWIuY29tL2lvdGFsZWRnZXIvaW90YS5saWIuanMvYmxvYi9tYXN0ZXIvbGliL2NyeXB0by9zaWduaW5nL3NpZ25pbmcuanNcclxuICovXHJcbmNsYXNzIFRyYW5zYWN0aW9uSGVscGVyIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIHRoZSBoYXNoIGZvciBhIHRyYW5zYWN0aW9uLlxyXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIFRoZSB0cmFuc2FjdGlvbiB0byBnZW5lcmF0ZSB0aGUgaGFzaC5cclxuICAgICAqIEByZXR1cm5zIFRoZSBoYXNoIG9mIHRociB0cmFuc2FjdGlvbi5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGhhc2godHJhbnNhY3Rpb24pIHtcclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUodHJhbnNhY3Rpb24sIHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24pKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiVGhlIHRyYW5zYWN0aW9uIG11c3QgYmUgb2YgdHlwZSBUcmFuc2FjdGlvblwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY3VybCA9IHNwb25nZUZhY3RvcnlfMS5TcG9uZ2VGYWN0b3J5Lmluc3RhbmNlKCkuY3JlYXRlKFwiY3VybFwiKTtcclxuICAgICAgICBjb25zdCB0cmFuc2FjdGlvblRyaXRzID0gdHJpdHNfMS5Ucml0cy5mcm9tVHJ5dGVzKHRyYW5zYWN0aW9uLnRvVHJ5dGVzKCkpLnRvQXJyYXkoKTtcclxuICAgICAgICBjdXJsLmluaXRpYWxpemUoKTtcclxuICAgICAgICBjdXJsLmFic29yYih0cmFuc2FjdGlvblRyaXRzLCAwLCB0cmFuc2FjdGlvblRyaXRzLmxlbmd0aCk7XHJcbiAgICAgICAgY29uc3QgaGFzaFRyaXRzID0gbmV3IEludDhBcnJheShjdXJsLmdldENvbnN0YW50KFwiSEFTSF9MRU5HVEhcIikpO1xyXG4gICAgICAgIGN1cmwuc3F1ZWV6ZShoYXNoVHJpdHMsIDAsIGhhc2hUcml0cy5sZW5ndGgpO1xyXG4gICAgICAgIHJldHVybiBoYXNoXzEuSGFzaC5mcm9tVHJ5dGVzKHRyaXRzXzEuVHJpdHMuZnJvbUFycmF5KGhhc2hUcml0cykudG9Ucnl0ZXMoKSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5UcmFuc2FjdGlvbkhlbHBlciA9IFRyYW5zYWN0aW9uSGVscGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lkSEpoYm5OaFkzUnBiMjVJWld4d1pYSXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOHVMaTl6Y21NdmFHVnNjR1Z5Y3k5MGNtRnVjMkZqZEdsdmJraGxiSEJsY2k1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU8wRkJRVUVzTkVWQlFYbEZPMEZCUTNwRkxIbEVRVUZ6UkR0QlFVTjBSQ3gxUlVGQmIwVTdRVUZEY0VVc01rUkJRWGRFTzBGQlEzaEVMSE5FUVVGdFJEdEJRVU51UkN3NFJFRkJNa1E3UVVGRk0wUTdPenRIUVVkSE8wRkJRMGc3U1VGRFNUczdPenRQUVVsSE8wbEJRMGtzVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4WFFVRjNRanRSUVVOMlF5eEpRVUZKTEVOQlFVTXNNa0pCUVZrc1EwRkJReXhOUVVGTkxFTkJRVU1zVjBGQlZ5eEZRVUZGTEhsQ1FVRlhMRU5CUVVNc1JVRkJSVHRaUVVOb1JDeE5RVUZOTEVsQlFVa3NlVUpCUVZjc1EwRkJReXcyUTBGQk5rTXNRMEZCUXl4RFFVRkRPMU5CUTNoRk8xRkJSVVFzVFVGQlRTeEpRVUZKTEVkQlFVY3NOa0pCUVdFc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF5eE5RVUZOTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNN1VVRkRja1FzVFVGQlRTeG5Ra0ZCWjBJc1IwRkJSeXhoUVVGTExFTkJRVU1zVlVGQlZTeERRVUZETEZkQlFWY3NRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJReXhEUVVGRExFOUJRVThzUlVGQlJTeERRVUZETzFGQlJUVkZMRWxCUVVrc1EwRkJReXhWUVVGVkxFVkJRVVVzUTBGQlF6dFJRVU5zUWl4SlFVRkpMRU5CUVVNc1RVRkJUU3hEUVVGRExHZENRVUZuUWl4RlFVRkZMRU5CUVVNc1JVRkJSU3huUWtGQlowSXNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJRenRSUVVVeFJDeE5RVUZOTEZOQlFWTXNSMEZCUnl4SlFVRkpMRk5CUVZNc1EwRkJReXhKUVVGSkxFTkJRVU1zVjBGQlZ5eERRVUZETEdGQlFXRXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRha1VzU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4VFFVRlRMRVZCUVVVc1EwRkJReXhGUVVGRkxGTkJRVk1zUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXp0UlFVVTNReXhQUVVGUExGZEJRVWtzUTBGQlF5eFZRVUZWTEVOQlFVTXNZVUZCU3l4RFFVRkRMRk5CUVZNc1EwRkJReXhUUVVGVExFTkJRVU1zUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXl4RFFVRkRPMGxCUTJ4RkxFTkJRVU03UTBGRFNqdEJRWFJDUkN3NFEwRnpRa01pZlE9PSIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgYXJyYXlIZWxwZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL2FycmF5SGVscGVyXCIpO1xyXG5jb25zdCBudW1iZXJIZWxwZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL251bWJlckhlbHBlclwiKTtcclxuY29uc3Qgb2JqZWN0SGVscGVyXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9vYmplY3RIZWxwZXJcIik7XHJcbmNvbnN0IHRpbWVTZXJ2aWNlXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jb3JlL2Rpc3Qvc2VydmljZXMvdGltZVNlcnZpY2VcIik7XHJcbmNvbnN0IGhhc2hfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL2hhc2hcIik7XHJcbmNvbnN0IHRhZ18xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvdGFnXCIpO1xyXG5jb25zdCB0cmFuc2FjdGlvbl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvdHJhbnNhY3Rpb25cIik7XHJcbmNvbnN0IHRyeXRlTnVtYmVyXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9kYXRhL2Rpc3QvZGF0YS90cnl0ZU51bWJlclwiKTtcclxuY29uc3QgdHJ5dGVzXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9kYXRhL2Rpc3QvZGF0YS90cnl0ZXNcIik7XHJcbmNvbnN0IGNyeXB0b0Vycm9yXzEgPSByZXF1aXJlKFwiLi4vZXJyb3IvY3J5cHRvRXJyb3JcIik7XHJcbmNvbnN0IHRyYW5zYWN0aW9uSGVscGVyXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy90cmFuc2FjdGlvbkhlbHBlclwiKTtcclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIHByb29mIG9mIHdvcmsuXHJcbiAqL1xyXG5jbGFzcyBQcm9vZk9mV29ya0Jhc2Uge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgUHJvb2ZPZldvcmsuXHJcbiAgICAgKiBAcGFyYW0gdGltZVNlcnZpY2UgU2VydmljZSB0byBnZXQgdGhlIHRpbWUgZm9yIGF0dGFjaG1lbnRzLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcih0aW1lU2VydmljZSkge1xyXG4gICAgICAgIHRoaXMuX3RpbWVTZXJ2aWNlID0gdGltZVNlcnZpY2UgfHwgbmV3IHRpbWVTZXJ2aWNlXzEuVGltZVNlcnZpY2UoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWxsb3cgdGhlIHByb29mIG9mIHdvcmsgdG8gcGVyZm9ybSBhbnkgaW5pdGlhbGl6YXRpb24uXHJcbiAgICAgKiBXaWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiB0aGUgaW1wbGVtZW50YXRpb24gaXMgbm90IHN1cHBvcnRlZC5cclxuICAgICAqIEByZXR1cm5zIFByb21pc2UuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGluaXRpYWxpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQZXJmb3JtIGEgcHJvb2Ygb2Ygd29yayBvbiB0aGUgZGF0YS5cclxuICAgICAqIEBwYXJhbSB0cnVua1RyYW5zYWN0aW9uIFRoZSB0cnVua1RyYW5zYWN0aW9uIHRvIHVzZSBmb3IgdGhlIHBvdy5cclxuICAgICAqIEBwYXJhbSBicmFuY2hUcmFuc2FjdGlvbiBUaGUgYnJhbmNoVHJhbnNhY3Rpb24gdG8gdXNlIGZvciB0aGUgcG93LlxyXG4gICAgICogQHBhcmFtIHRyeXRlcyBUaGUgdHJ5dGVzIHRvIHBlcmZvcm0gdGhlIHBvdyBvbi5cclxuICAgICAqIEBwYXJhbSBtaW5XZWlnaHRNYWduaXR1ZGUgVGhlIG1pbmltdW0gd2VpZ2h0IG1hZ25pdHVkZS5cclxuICAgICAqIEByZXR1cm5zIFRoZSB0cnl0ZXMgcHJvZHVjZWQgYnkgdGhlIHByb29mIG9mIHdvcmsuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHBvdyh0cnVua1RyYW5zYWN0aW9uLCBicmFuY2hUcmFuc2FjdGlvbiwgdHJ5dGVzLCBtaW5XZWlnaHRNYWduaXR1ZGUpIHtcclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUodHJ1bmtUcmFuc2FjdGlvbiwgaGFzaF8xLkhhc2gpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiVGhlIHRydW5rVHJhbnNhY3Rpb24gbXVzdCBiZSBhbiBvYmplY3Qgb2YgdHlwZSBIYXNoXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUoYnJhbmNoVHJhbnNhY3Rpb24sIGhhc2hfMS5IYXNoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIlRoZSBicmFuY2hUcmFuc2FjdGlvbiBtdXN0IGJlIGFuIG9iamVjdCBvZiB0eXBlIEhhc2hcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghYXJyYXlIZWxwZXJfMS5BcnJheUhlbHBlci5pc1R5cGVkKHRyeXRlcywgdHJ5dGVzXzEuVHJ5dGVzKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIlRoZSB0cnl0ZXMgbXVzdCBiZSBhbiBhcnJheSBvZiB0eXBlIFRyeXRlc1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKG1pbldlaWdodE1hZ25pdHVkZSkgfHwgbWluV2VpZ2h0TWFnbml0dWRlIDw9IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJUaGUgbWluV2VpZ2h0TWFnbml0dWRlIG11c3QgYmUgPiAwXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBmaW5hbFRyeXRlcyA9IFtdO1xyXG4gICAgICAgIGxldCBwcmV2aW91c1RyYW5zYWN0aW9uSGFzaDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyeXRlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uZnJvbVRyeXRlcyh0cnl0ZXNbaV0pO1xyXG4gICAgICAgICAgICAvLyBTdGFydCB3aXRoIGxhc3QgaW5kZXggdHJhbnNhY3Rpb25cclxuICAgICAgICAgICAgLy8gQXNzaWduIGl0IHRoZSB0cnVuayAvIGJyYW5jaCB3aGljaCB0aGUgdXNlciBoYXMgc3VwcGxpZWRcclxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSBidW5kbGUsIGNoYWluIHRoZSBidW5kbGUgdHJhbnNhY3Rpb25zIHZpYVxyXG4gICAgICAgICAgICAvLyB0cnVua1RyYW5zYWN0aW9uIHRvZ2V0aGVyXHJcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLmF0dGFjaG1lbnRUaW1lc3RhbXAgPSB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLmZyb21OdW1iZXIodGhpcy5fdGltZVNlcnZpY2UubXNTaW5jZUVwb2NoKCkpO1xyXG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5hdHRhY2htZW50VGltZXN0YW1wTG93ZXJCb3VuZCA9IHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuZnJvbU51bWJlcigwKTtcclxuICAgICAgICAgICAgdHJhbnNhY3Rpb24uYXR0YWNobWVudFRpbWVzdGFtcFVwcGVyQm91bmQgPSB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLmZyb21OdW1iZXIoUHJvb2ZPZldvcmtCYXNlLk1BWF9USU1FU1RBTVBfVkFMVUUpO1xyXG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCB0cmFuc2FjdGlvbiwgdG8gYmUgcHJvY2Vzc2VkXHJcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IGl0J3MgdGhlIGxhc3QgaW4gdGhlIGJ1bmRsZSBhbmQgdGhlblxyXG4gICAgICAgICAgICAvLyBhc3NpZ24gaXQgdGhlIHN1cHBsaWVkIHRydW5rIGFuZCBicmFuY2ggdHJhbnNhY3Rpb25zXHJcbiAgICAgICAgICAgIGlmIChvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNFbXB0eShwcmV2aW91c1RyYW5zYWN0aW9uSGFzaCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGxhc3QgdHJhbnNhY3Rpb24gaW4gdGhlIGJ1bmRsZVxyXG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmxhc3RJbmRleC50b051bWJlcigpICE9PSB0cmFuc2FjdGlvbi5jdXJyZW50SW5kZXgudG9OdW1iZXIoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiV3JvbmcgYnVuZGxlIG9yZGVyLiBUaGUgYnVuZGxlIHNob3VsZCBiZSBvcmRlcmVkIGluIGRlc2NlbmRpbmcgb3JkZXIgZnJvbSBjdXJyZW50SW5kZXhcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi50cnVua1RyYW5zYWN0aW9uID0gdHJ1bmtUcmFuc2FjdGlvbjtcclxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmJyYW5jaFRyYW5zYWN0aW9uID0gYnJhbmNoVHJhbnNhY3Rpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi50cnVua1RyYW5zYWN0aW9uID0gcHJldmlvdXNUcmFuc2FjdGlvbkhhc2g7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5icmFuY2hUcmFuc2FjdGlvbiA9IHRydW5rVHJhbnNhY3Rpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgbmV3VHJ5dGVzID0gdHJhbnNhY3Rpb24udG9Ucnl0ZXMoKTtcclxuICAgICAgICAgICAgY29uc3Qgc2luZ2xlVHJ5dGVzID0gYXdhaXQgdGhpcy5zaW5nbGVQb3cobmV3VHJ5dGVzLCBtaW5XZWlnaHRNYWduaXR1ZGUpO1xyXG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5ub25jZSA9IHRhZ18xLlRhZy5mcm9tVHJ5dGVzKHNpbmdsZVRyeXRlcy5zdWIodHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5MRU5HVEggLSB0YWdfMS5UYWcuTEVOR1RILCB0YWdfMS5UYWcuTEVOR1RIKSk7XHJcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgaGFzaCBvZiB0aGUgbmV3IHRyYW5zYWN0aW9uIHdpdGggbm9uY2UgYW5kIHVzZSB0aGF0IGFzIHRoZSBwcmV2aW91cyBoYXNoIGZvciBuZXh0IGVudHJ5XHJcbiAgICAgICAgICAgIGNvbnN0IHJldHVyblRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5mcm9tVHJ5dGVzKHNpbmdsZVRyeXRlcyk7XHJcbiAgICAgICAgICAgIHByZXZpb3VzVHJhbnNhY3Rpb25IYXNoID0gdHJhbnNhY3Rpb25IZWxwZXJfMS5UcmFuc2FjdGlvbkhlbHBlci5oYXNoKHJldHVyblRyYW5zYWN0aW9uKTtcclxuICAgICAgICAgICAgZmluYWxUcnl0ZXMucHVzaChyZXR1cm5UcmFuc2FjdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHJldmVyc2UgdGhlIG9yZGVyIHNvIHRoYXQgaXQncyBhc2NlbmRpbmcgZnJvbSBjdXJyZW50SW5kZXhcclxuICAgICAgICByZXR1cm4gZmluYWxUcnl0ZXMucmV2ZXJzZSgpLm1hcCh0cmFuc2FjdGlvbiA9PiB0cmFuc2FjdGlvbi50b1RyeXRlcygpKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhlIG1heGltdW0gdGltZXN0YW1wIHZhbHVlIHVzZWQgaW4gcHJvb2Ygb2Ygd29yay5cclxuICovXHJcblByb29mT2ZXb3JrQmFzZS5NQVhfVElNRVNUQU1QX1ZBTFVFID0gKE1hdGgucG93KDMsIDI3KSAtIDEpIC8gMjtcclxuZXhwb3J0cy5Qcm9vZk9mV29ya0Jhc2UgPSBQcm9vZk9mV29ya0Jhc2U7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWNISnZiMlpQWmxkdmNtdENZWE5sTG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhNaU9sc2lMaTR2TGk0dmMzSmpMM0J5YjI5bVQyWlhiM0pyTDNCeWIyOW1UMlpYYjNKclFtRnpaUzUwY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pTzBGQlFVRXNNRVZCUVhWRk8wRkJRM1pGTERSRlFVRjVSVHRCUVVONlJTdzBSVUZCZVVVN1FVRkZla1VzTWtWQlFYZEZPMEZCUTNoRkxIbEVRVUZ6UkR0QlFVTjBSQ3gxUkVGQmIwUTdRVUZEY0VRc2RVVkJRVzlGTzBGQlEzQkZMSFZGUVVGdlJUdEJRVU53UlN3MlJFRkJNRVE3UVVGRE1VUXNjMFJCUVcxRU8wRkJRMjVFTEc5RlFVRnBSVHRCUVVkcVJUczdSMEZGUnp0QlFVTklPMGxCVTBrN096dFBRVWRITzBsQlEwZ3NXVUZCV1N4WFFVRXdRanRSUVVOc1F5eEpRVUZKTEVOQlFVTXNXVUZCV1N4SFFVRkhMRmRCUVZjc1NVRkJTU3hKUVVGSkxIbENRVUZYTEVWQlFVVXNRMEZCUXp0SlFVTjZSQ3hEUVVGRE8wbEJSVVE3T3pzN1QwRkpSenRKUVVOSkxFdEJRVXNzUTBGQlF5eFZRVUZWTzFGQlEyNUNMRTlCUVU4c1QwRkJUeXhEUVVGRExFOUJRVThzUlVGQlJTeERRVUZETzBsQlF6ZENMRU5CUVVNN1NVRkZSRHM3T3pzN096dFBRVTlITzBsQlEwa3NTMEZCU3l4RFFVRkRMRWRCUVVjc1EwRkJReXhuUWtGQmMwSXNSVUZCUlN4cFFrRkJkVUlzUlVGQlJTeE5RVUZuUWl4RlFVRkZMR3RDUVVFd1FqdFJRVU14Unl4SlFVRkpMRU5CUVVNc01rSkJRVmtzUTBGQlF5eE5RVUZOTEVOQlFVTXNaMEpCUVdkQ0xFVkJRVVVzVjBGQlNTeERRVUZETEVWQlFVVTdXVUZET1VNc1RVRkJUU3hKUVVGSkxIbENRVUZYTEVOQlFVTXNjVVJCUVhGRUxFTkJRVU1zUTBGQlF6dFRRVU5vUmp0UlFVTkVMRWxCUVVrc1EwRkJReXd5UWtGQldTeERRVUZETEUxQlFVMHNRMEZCUXl4cFFrRkJhVUlzUlVGQlJTeFhRVUZKTEVOQlFVTXNSVUZCUlR0WlFVTXZReXhOUVVGTkxFbEJRVWtzZVVKQlFWY3NRMEZCUXl4elJFRkJjMFFzUTBGQlF5eERRVUZETzFOQlEycEdPMUZCUTBRc1NVRkJTU3hEUVVGRExIbENRVUZYTEVOQlFVTXNUMEZCVHl4RFFVRkRMRTFCUVUwc1JVRkJSU3hsUVVGTkxFTkJRVU1zUlVGQlJUdFpRVU4wUXl4TlFVRk5MRWxCUVVrc2VVSkJRVmNzUTBGQlF5dzBRMEZCTkVNc1EwRkJReXhEUVVGRE8xTkJRM1pGTzFGQlEwUXNTVUZCU1N4RFFVRkRMREpDUVVGWkxFTkJRVU1zVTBGQlV5eERRVUZETEd0Q1FVRnJRaXhEUVVGRExFbEJRVWtzYTBKQlFXdENMRWxCUVVrc1EwRkJReXhGUVVGRk8xbEJRM2hGTEUxQlFVMHNTVUZCU1N4NVFrRkJWeXhEUVVGRExHOURRVUZ2UXl4RFFVRkRMRU5CUVVNN1UwRkRMMFE3VVVGRlJDeE5RVUZOTEZkQlFWY3NSMEZCUnl4RlFVRkZMRU5CUVVNN1VVRkZka0lzU1VGQlNTeDFRa0ZCTmtJc1EwRkJRenRSUVVWc1F5eExRVUZMTEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzVFVGQlRTeERRVUZETEUxQlFVMHNSVUZCUlN4RFFVRkRMRVZCUVVVc1JVRkJSVHRaUVVOd1F5eE5RVUZOTEZkQlFWY3NSMEZCUnl4NVFrRkJWeXhEUVVGRExGVkJRVlVzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVWMFJDeHZRMEZCYjBNN1dVRkRjRU1zTWtSQlFUSkVPMWxCUXpORUxEQkVRVUV3UkR0WlFVTXhSQ3cwUWtGQk5FSTdXVUZETlVJc1YwRkJWeXhEUVVGRExHMUNRVUZ0UWl4SFFVRkhMSGxDUVVGWExFTkJRVU1zVlVGQlZTeERRVUZETEVsQlFVa3NRMEZCUXl4WlFVRlpMRU5CUVVNc1dVRkJXU3hGUVVGRkxFTkJRVU1zUTBGQlF6dFpRVU16Uml4WFFVRlhMRU5CUVVNc05rSkJRVFpDTEVkQlFVY3NlVUpCUVZjc1EwRkJReXhWUVVGVkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEZEVVc1YwRkJWeXhEUVVGRExEWkNRVUUyUWl4SFFVRkhMSGxDUVVGWExFTkJRVU1zVlVGQlZTeERRVUZETEdWQlFXVXNRMEZCUXl4dFFrRkJiVUlzUTBGQlF5eERRVUZETzFsQlJYaEhMRzlFUVVGdlJEdFpRVU53UkN4elJFRkJjMFE3V1VGRGRFUXNkVVJCUVhWRU8xbEJSWFpFTEVsQlFVa3NNa0pCUVZrc1EwRkJReXhQUVVGUExFTkJRVU1zZFVKQlFYVkNMRU5CUVVNc1JVRkJSVHRuUWtGREwwTXNNRU5CUVRCRE8yZENRVU14UXl4SlFVRkpMRmRCUVZjc1EwRkJReXhUUVVGVExFTkJRVU1zVVVGQlVTeEZRVUZGTEV0QlFVc3NWMEZCVnl4RFFVRkRMRmxCUVZrc1EwRkJReXhSUVVGUkxFVkJRVVVzUlVGQlJUdHZRa0ZETVVVc1RVRkJUU3hKUVVGSkxIbENRVUZYTEVOQlFVTXNkMFpCUVhkR0xFTkJRVU1zUTBGQlF6dHBRa0ZEYmtnN1owSkJRMFFzVjBGQlZ5eERRVUZETEdkQ1FVRm5RaXhIUVVGSExHZENRVUZuUWl4RFFVRkRPMmRDUVVOb1JDeFhRVUZYTEVOQlFVTXNhVUpCUVdsQ0xFZEJRVWNzYVVKQlFXbENMRU5CUVVNN1lVRkRja1E3YVVKQlFVMDdaMEpCUTBnc1YwRkJWeXhEUVVGRExHZENRVUZuUWl4SFFVRkhMSFZDUVVGMVFpeERRVUZETzJkQ1FVTjJSQ3hYUVVGWExFTkJRVU1zYVVKQlFXbENMRWRCUVVjc1owSkJRV2RDTEVOQlFVTTdZVUZEY0VRN1dVRkZSQ3hOUVVGTkxGTkJRVk1zUjBGQlJ5eFhRVUZYTEVOQlFVTXNVVUZCVVN4RlFVRkZMRU5CUVVNN1dVRkZla01zVFVGQlRTeFpRVUZaTEVkQlFVY3NUVUZCVFN4SlFVRkpMRU5CUVVNc1UwRkJVeXhEUVVGRExGTkJRVk1zUlVGQlJTeHJRa0ZCYTBJc1EwRkJReXhEUVVGRE8xbEJSWHBGTEZkQlFWY3NRMEZCUXl4TFFVRkxMRWRCUVVjc1UwRkJSeXhEUVVGRExGVkJRVlVzUTBGQlF5eFpRVUZaTEVOQlFVTXNSMEZCUnl4RFFVRkRMSGxDUVVGWExFTkJRVU1zVFVGQlRTeEhRVUZITEZOQlFVY3NRMEZCUXl4TlFVRk5MRVZCUVVVc1UwRkJSeXhEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZGYkVjc2QwZEJRWGRITzFsQlEzaEhMRTFCUVUwc2FVSkJRV2xDTEVkQlFVY3NlVUpCUVZjc1EwRkJReXhWUVVGVkxFTkJRVU1zV1VGQldTeERRVUZETEVOQlFVTTdXVUZETDBRc2RVSkJRWFZDTEVkQlFVY3NjVU5CUVdsQ0xFTkJRVU1zU1VGQlNTeERRVUZETEdsQ1FVRnBRaXhEUVVGRExFTkJRVU03V1VGRmNFVXNWMEZCVnl4RFFVRkRMRWxCUVVrc1EwRkJReXhwUWtGQmFVSXNRMEZCUXl4RFFVRkRPMU5CUTNaRE8xRkJRMFFzTmtSQlFUWkVPMUZCUXpkRUxFOUJRVThzVjBGQlZ5eERRVUZETEU5QlFVOHNSVUZCUlN4RFFVRkRMRWRCUVVjc1EwRkJReXhYUVVGWExFTkJRVU1zUlVGQlJTeERRVUZETEZkQlFWY3NRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJReXhEUVVGRE8wbEJRelZGTEVOQlFVTTdPMEZCTlVaRU96dEhRVVZITzBGQlEyOUNMRzFEUVVGdFFpeEhRVUZYTEVOQlFVTXNTVUZCU1N4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFVkJRVVVzUlVGQlJTeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRE8wRkJTbTVHTERCRFFYTkhReUo5IiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBudW1iZXJIZWxwZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL251bWJlckhlbHBlclwiKTtcclxuY29uc3Qgb2JqZWN0SGVscGVyXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9vYmplY3RIZWxwZXJcIik7XHJcbmNvbnN0IGNyeXB0b0Vycm9yXzEgPSByZXF1aXJlKFwiLi4vZXJyb3IvY3J5cHRvRXJyb3JcIik7XHJcbi8qKlxyXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiBJU3BvbmdlIHVzaW5nIEN1cmwgYWxnb3JpdGhtLlxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vaW90YWxlZGdlci9pb3RhLmxpYi5qcy9ibG9iL21hc3Rlci9saWIvY3J5cHRvL2N1cmwvY3VybC5qc1xyXG4gKi9cclxuY2xhc3MgQ3VybCB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBDdXJsLlxyXG4gICAgICogQHBhcmFtIHJvdW5kcyBUaGUgbnVtYmVyIG9mIHJvdW5kcyB0byB1c2UuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHJvdW5kcyA9IEN1cmwuTlVNQkVSX09GX1JPVU5EUykge1xyXG4gICAgICAgIHRoaXMuX251bWJlck9mUm91bmRzID0gcm91bmRzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGNvbnN0YW50IGZvciB0aGUgc3BvbmUuXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgY29uc3RhbnQgdG8gZ2V0LlxyXG4gICAgICogQHJldHVybnMgVGhlIGNvbnN0YW50LlxyXG4gICAgICovXHJcbiAgICBnZXRDb25zdGFudChuYW1lKSB7XHJcbiAgICAgICAgc3dpdGNoIChuYW1lKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJOVU1CRVJfT0ZfUk9VTkRTXCI6IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9udW1iZXJPZlJvdW5kcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIFwiSEFTSF9MRU5HVEhcIjpcclxuICAgICAgICAgICAgY2FzZSBcIlNUQVRFX0xFTkdUSFwiOlxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBDdXJsW25hbWVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihgVW5rbm93biBjb25zdGFudCByZXF1ZXN0ZWQgJHtuYW1lfWApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBzdGF0ZS5cclxuICAgICAqIEByZXR1cm5zIFRoZSBzdGF0ZS5cclxuICAgICAqL1xyXG4gICAgZ2V0U3RhdGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXNlIHRoZSBoYXNoZXIuXHJcbiAgICAgKiBAcGFyYW0gc3RhdGUgVGhlIGluaXRpYWwgc3RhdGUgZm9yIHRoZSBoYXNoZXIuXHJcbiAgICAgKi9cclxuICAgIGluaXRpYWxpemUoc3RhdGUpIHtcclxuICAgICAgICBpZiAoc3RhdGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gbmV3IEludDhBcnJheShDdXJsLlNUQVRFX0xFTkdUSCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldCB0aGUgaGFzaGVyLlxyXG4gICAgICovXHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWJzb3JiIHRyaXRzIGludG8gdGhlIGhhc2guXHJcbiAgICAgKiBAcGFyYW0gdHJpdHMgVGhlIHRyaXRzIHRvIGFic29yYi5cclxuICAgICAqIEBwYXJhbSBvZmZzZXQgVGhlIG9mZnNldCBpbnRvIHRoZSB0cml0cyB0byBhYnNvcmIgZnJvbS5cclxuICAgICAqIEBwYXJhbSBsZW5ndGggVGhlIG51bWJlciBvZiB0cml0cyB0byBhYnNvcmIuXHJcbiAgICAgKi9cclxuICAgIGFic29yYih0cml0cywgb2Zmc2V0LCBsZW5ndGgpIHtcclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUodHJpdHMsIEludDhBcnJheSkgfHwgdHJpdHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiVHJpdHMgbXVzdCBiZSBhIG5vbiBlbXB0eSBJbnQ4QXJyYXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihvZmZzZXQpIHx8IG9mZnNldCA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJPZmZzZXQgbXVzdCBiZSBhIG51bWJlciA+PSAwXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIobGVuZ3RoKSB8fCBsZW5ndGggPCAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiTGVuZ3RoIG11c3QgYmUgYSBudW1iZXIgPj0gMFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxlbmd0aCArIG9mZnNldCA+IHRyaXRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIlRoZSBvZmZzZXQgKyBsZW5ndGggaXMgYmV5b25kIHRoZSBsZW5ndGggb2YgdGhlIHRyaXRzXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbG9jYWxPZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgbGV0IGxvY2FsTGVuZ3RoID0gbGVuZ3RoO1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgICAgICBjb25zdCBsaW1pdCA9IGxvY2FsTGVuZ3RoIDwgQ3VybC5IQVNIX0xFTkdUSCA/IGxvY2FsTGVuZ3RoIDogQ3VybC5IQVNIX0xFTkdUSDtcclxuICAgICAgICAgICAgd2hpbGUgKGkgPCBsaW1pdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGVbaSsrXSA9IHRyaXRzW2xvY2FsT2Zmc2V0KytdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtKCk7XHJcbiAgICAgICAgICAgIGxvY2FsTGVuZ3RoIC09IEN1cmwuSEFTSF9MRU5HVEg7XHJcbiAgICAgICAgfSB3aGlsZSAobG9jYWxMZW5ndGggPiAwKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3F1ZWV6ZSB0cml0cyBpbnRvIHRoZSBoYXNoLlxyXG4gICAgICogQHBhcmFtIHRyaXRzIFRoZSB0cml0cyB0byBzcXVlZXplLlxyXG4gICAgICogQHBhcmFtIG9mZnNldCBUaGUgb2Zmc2V0IGludG8gdGhlIHRyaXRzIHRvIHNxdWVlemUgZnJvbS5cclxuICAgICAqIEBwYXJhbSBsZW5ndGggVGhlIG51bWJlciBvZiB0cml0cyB0byBzcXVlZXplLlxyXG4gICAgICovXHJcbiAgICBzcXVlZXplKHRyaXRzLCBvZmZzZXQsIGxlbmd0aCkge1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZSh0cml0cywgSW50OEFycmF5KSB8fCB0cml0cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJUcml0cyBtdXN0IGJlIGEgbm9uIGVtcHR5IEludDhBcnJheVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKG9mZnNldCkgfHwgb2Zmc2V0IDwgMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIk9mZnNldCBtdXN0IGJlIGEgbnVtYmVyID49IDBcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihsZW5ndGgpIHx8IGxlbmd0aCA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJMZW5ndGggbXVzdCBiZSBhIG51bWJlciA+PSAwXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGVuZ3RoICsgb2Zmc2V0ID4gdHJpdHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiVGhlIG9mZnNldCArIGxlbmd0aCBpcyBiZXlvbmQgdGhlIGxlbmd0aCBvZiB0aGUgdHJpdHNcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBsb2NhbE9mZnNldCA9IG9mZnNldDtcclxuICAgICAgICBsZXQgbG9jYWxMZW5ndGggPSBsZW5ndGg7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbWl0ID0gbG9jYWxMZW5ndGggPCBDdXJsLkhBU0hfTEVOR1RIID8gbGVuZ3RoIDogQ3VybC5IQVNIX0xFTkdUSDtcclxuICAgICAgICAgICAgd2hpbGUgKGkgPCBsaW1pdCkge1xyXG4gICAgICAgICAgICAgICAgdHJpdHNbbG9jYWxPZmZzZXQrK10gPSB0aGlzLl9zdGF0ZVtpKytdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtKCk7XHJcbiAgICAgICAgICAgIGxvY2FsTGVuZ3RoIC09IEN1cmwuSEFTSF9MRU5HVEg7XHJcbiAgICAgICAgfSB3aGlsZSAobG9jYWxMZW5ndGggPiAwKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNmb3JtIHRoZSBoYXNoLlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHRyYW5zZm9ybSgpIHtcclxuICAgICAgICBsZXQgc3RhdGVDb3B5O1xyXG4gICAgICAgIGxldCBpbmRleCA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgcm91bmQgPSAwOyByb3VuZCA8IHRoaXMuX251bWJlck9mUm91bmRzOyByb3VuZCsrKSB7XHJcbiAgICAgICAgICAgIHN0YXRlQ29weSA9IG5ldyBJbnQ4QXJyYXkodGhpcy5fc3RhdGUuc2xpY2UoKSk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQ3VybC5TVEFURV9MRU5HVEg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGVbaV0gPSBDdXJsLlRSVVRIX1RBQkxFW3N0YXRlQ29weVtpbmRleF0gKyAoc3RhdGVDb3B5W2luZGV4ICs9IChpbmRleCA8IDM2NSA/IDM2NCA6IC0zNjUpXSA8PCAyKSArIDVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbkN1cmwuSEFTSF9MRU5HVEggPSAyNDM7XHJcbkN1cmwuTlVNQkVSX09GX1JPVU5EUyA9IDgxO1xyXG5DdXJsLlNUQVRFX0xFTkdUSCA9IEN1cmwuSEFTSF9MRU5HVEggKiAzO1xyXG4vKiBAaW50ZXJuYWwgKi9cclxuQ3VybC5UUlVUSF9UQUJMRSA9IG5ldyBJbnQ4QXJyYXkoWzEsIDAsIC0xLCAyLCAxLCAtMSwgMCwgMiwgLTEsIDEsIDBdKTtcclxuZXhwb3J0cy5DdXJsID0gQ3VybDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pWTNWeWJDNXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5emNHOXVaMlZ6TDJOMWNtd3VkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanRCUVVGQkxEUkZRVUY1UlR0QlFVTjZSU3cwUlVGQmVVVTdRVUZEZWtVc2MwUkJRVzFFTzBGQlIyNUVPenM3UjBGSFJ6dEJRVU5JTzBsQllVazdPenRQUVVkSE8wbEJRMGdzV1VGQldTeFRRVUZwUWl4SlFVRkpMRU5CUVVNc1owSkJRV2RDTzFGQlF6bERMRWxCUVVrc1EwRkJReXhsUVVGbExFZEJRVWNzVFVGQlRTeERRVUZETzBsQlEyeERMRU5CUVVNN1NVRkZSRHM3T3p0UFFVbEhPMGxCUTBrc1YwRkJWeXhEUVVGRExFbEJRVms3VVVGRE0wSXNVVUZCVVN4SlFVRkpMRVZCUVVVN1dVRkRWaXhMUVVGTExHdENRVUZyUWl4RFFVRkRMRU5CUVVNN1owSkJRM0pDTEU5QlFVOHNTVUZCU1N4RFFVRkRMR1ZCUVdVc1EwRkJRenRoUVVNdlFqdFpRVU5FTEV0QlFVc3NZVUZCWVN4RFFVRkRPMWxCUTI1Q0xFdEJRVXNzWTBGQll6dG5Ra0ZEYmtJN2IwSkJRMGtzVDBGQlR5eEpRVUZKTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN2FVSkJRM0pDTzFsQlEwUXNUMEZCVHl4RFFVRkRMRU5CUVVNc1RVRkJUU3hKUVVGSkxIbENRVUZYTEVOQlFVTXNPRUpCUVRoQ0xFbEJRVWtzUlVGQlJTeERRVUZETEVOQlFVTTdVMEZEZUVVN1NVRkRUQ3hEUVVGRE8wbEJSVVE3T3p0UFFVZEhPMGxCUTBrc1VVRkJVVHRSUVVOWUxFOUJRVThzU1VGQlNTeERRVUZETEUxQlFVMHNRMEZCUXp0SlFVTjJRaXhEUVVGRE8wbEJSVVE3T3p0UFFVZEhPMGxCUTBrc1ZVRkJWU3hEUVVGRExFdEJRV2xDTzFGQlF5OUNMRWxCUVVrc1MwRkJTeXhGUVVGRk8xbEJRMUFzU1VGQlNTeERRVUZETEUxQlFVMHNSMEZCUnl4TFFVRkxMRU5CUVVNN1UwRkRka0k3WVVGQlRUdFpRVU5JTEVsQlFVa3NRMEZCUXl4TlFVRk5MRWRCUVVjc1NVRkJTU3hUUVVGVExFTkJRVU1zU1VGQlNTeERRVUZETEZsQlFWa3NRMEZCUXl4RFFVRkRPMU5CUTJ4RU8wbEJRMHdzUTBGQlF6dEpRVVZFT3p0UFFVVkhPMGxCUTBrc1MwRkJTenRSUVVOU0xFbEJRVWtzUTBGQlF5eFZRVUZWTEVWQlFVVXNRMEZCUXp0SlFVTjBRaXhEUVVGRE8wbEJSVVE3T3pzN08wOUJTMGM3U1VGRFNTeE5RVUZOTEVOQlFVTXNTMEZCWjBJc1JVRkJSU3hOUVVGakxFVkJRVVVzVFVGQll6dFJRVU14UkN4SlFVRkpMRU5CUVVNc01rSkJRVmtzUTBGQlF5eE5RVUZOTEVOQlFVTXNTMEZCU3l4RlFVRkZMRk5CUVZNc1EwRkJReXhKUVVGSkxFdEJRVXNzUTBGQlF5eE5RVUZOTEV0QlFVc3NRMEZCUXl4RlFVRkZPMWxCUXpsRUxFMUJRVTBzU1VGQlNTeDVRa0ZCVnl4RFFVRkRMSEZEUVVGeFF5eERRVUZETEVOQlFVTTdVMEZEYUVVN1VVRkRSQ3hKUVVGSkxFTkJRVU1zTWtKQlFWa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1RVRkJUU3hEUVVGRExFbEJRVWtzVFVGQlRTeEhRVUZITEVOQlFVTXNSVUZCUlR0WlFVTXZReXhOUVVGTkxFbEJRVWtzZVVKQlFWY3NRMEZCUXl3NFFrRkJPRUlzUTBGQlF5eERRVUZETzFOQlEzcEVPMUZCUTBRc1NVRkJTU3hEUVVGRExESkNRVUZaTEVOQlFVTXNVMEZCVXl4RFFVRkRMRTFCUVUwc1EwRkJReXhKUVVGSkxFMUJRVTBzUjBGQlJ5eERRVUZETEVWQlFVVTdXVUZETDBNc1RVRkJUU3hKUVVGSkxIbENRVUZYTEVOQlFVTXNPRUpCUVRoQ0xFTkJRVU1zUTBGQlF6dFRRVU42UkR0UlFVTkVMRWxCUVVrc1RVRkJUU3hIUVVGSExFMUJRVTBzUjBGQlJ5eExRVUZMTEVOQlFVTXNUVUZCVFN4RlFVRkZPMWxCUTJoRExFMUJRVTBzU1VGQlNTeDVRa0ZCVnl4RFFVRkRMSFZFUVVGMVJDeERRVUZETEVOQlFVTTdVMEZEYkVZN1VVRkZSQ3hKUVVGSkxGZEJRVmNzUjBGQlJ5eE5RVUZOTEVOQlFVTTdVVUZEZWtJc1NVRkJTU3hYUVVGWExFZEJRVWNzVFVGQlRTeERRVUZETzFGQlJYcENMRWRCUVVjN1dVRkRReXhKUVVGSkxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTTdXVUZEVml4TlFVRk5MRXRCUVVzc1IwRkJSeXhYUVVGWExFZEJRVWNzU1VGQlNTeERRVUZETEZkQlFWY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1YwRkJWeXhEUVVGRExFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNWMEZCVnl4RFFVRkRPMWxCUlRsRkxFOUJRVThzUTBGQlF5eEhRVUZITEV0QlFVc3NSVUZCUlR0blFrRkRaQ3hKUVVGSkxFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1MwRkJTeXhEUVVGRExGZEJRVmNzUlVGQlJTeERRVUZETEVOQlFVTTdZVUZETTBNN1dVRkZSQ3hKUVVGSkxFTkJRVU1zVTBGQlV5eEZRVUZGTEVOQlFVTTdXVUZGYWtJc1YwRkJWeXhKUVVGSkxFbEJRVWtzUTBGQlF5eFhRVUZYTEVOQlFVTTdVMEZEYmtNc1VVRkJVU3hYUVVGWExFZEJRVWNzUTBGQlF5eEZRVUZGTzBsQlF6bENMRU5CUVVNN1NVRkZSRHM3T3pzN1QwRkxSenRKUVVOSkxFOUJRVThzUTBGQlF5eExRVUZuUWl4RlFVRkZMRTFCUVdNc1JVRkJSU3hOUVVGak8xRkJRek5FTEVsQlFVa3NRMEZCUXl3eVFrRkJXU3hEUVVGRExFMUJRVTBzUTBGQlF5eExRVUZMTEVWQlFVVXNVMEZCVXl4RFFVRkRMRWxCUVVrc1MwRkJTeXhEUVVGRExFMUJRVTBzUzBGQlN5eERRVUZETEVWQlFVVTdXVUZET1VRc1RVRkJUU3hKUVVGSkxIbENRVUZYTEVOQlFVTXNjVU5CUVhGRExFTkJRVU1zUTBGQlF6dFRRVU5vUlR0UlFVTkVMRWxCUVVrc1EwRkJReXd5UWtGQldTeERRVUZETEZOQlFWTXNRMEZCUXl4TlFVRk5MRU5CUVVNc1NVRkJTU3hOUVVGTkxFZEJRVWNzUTBGQlF5eEZRVUZGTzFsQlF5OURMRTFCUVUwc1NVRkJTU3g1UWtGQlZ5eERRVUZETERoQ1FVRTRRaXhEUVVGRExFTkJRVU03VTBGRGVrUTdVVUZEUkN4SlFVRkpMRU5CUVVNc01rSkJRVmtzUTBGQlF5eFRRVUZUTEVOQlFVTXNUVUZCVFN4RFFVRkRMRWxCUVVrc1RVRkJUU3hIUVVGSExFTkJRVU1zUlVGQlJUdFpRVU12UXl4TlFVRk5MRWxCUVVrc2VVSkJRVmNzUTBGQlF5dzRRa0ZCT0VJc1EwRkJReXhEUVVGRE8xTkJRM3BFTzFGQlEwUXNTVUZCU1N4TlFVRk5MRWRCUVVjc1RVRkJUU3hIUVVGSExFdEJRVXNzUTBGQlF5eE5RVUZOTEVWQlFVVTdXVUZEYUVNc1RVRkJUU3hKUVVGSkxIbENRVUZYTEVOQlFVTXNkVVJCUVhWRUxFTkJRVU1zUTBGQlF6dFRRVU5zUmp0UlFVVkVMRWxCUVVrc1YwRkJWeXhIUVVGSExFMUJRVTBzUTBGQlF6dFJRVU42UWl4SlFVRkpMRmRCUVZjc1IwRkJSeXhOUVVGTkxFTkJRVU03VVVGRmVrSXNSMEZCUnp0WlFVVkRMRWxCUVVrc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF6dFpRVU5XTEUxQlFVMHNTMEZCU3l4SFFVRkhMRmRCUVZjc1IwRkJSeXhKUVVGSkxFTkJRVU1zVjBGQlZ5eERRVUZETEVOQlFVTXNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF5eFhRVUZYTEVOQlFVTTdXVUZGZWtVc1QwRkJUeXhEUVVGRExFZEJRVWNzUzBGQlN5eEZRVUZGTzJkQ1FVTmtMRXRCUVVzc1EwRkJReXhYUVVGWExFVkJRVVVzUTBGQlF5eEhRVUZITEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF6dGhRVU16UXp0WlFVVkVMRWxCUVVrc1EwRkJReXhUUVVGVExFVkJRVVVzUTBGQlF6dFpRVVZxUWl4WFFVRlhMRWxCUVVrc1NVRkJTU3hEUVVGRExGZEJRVmNzUTBGQlF6dFRRVU51UXl4UlFVRlJMRmRCUVZjc1IwRkJSeXhEUVVGRExFVkJRVVU3U1VGRE9VSXNRMEZCUXp0SlFVVkVPenM3VDBGSFJ6dEpRVU5MTEZOQlFWTTdVVUZEWWl4SlFVRkpMRk5CUVc5Q0xFTkJRVU03VVVGRGVrSXNTVUZCU1N4TFFVRkxMRWRCUVVjc1EwRkJReXhEUVVGRE8xRkJSV1FzUzBGQlN5eEpRVUZKTEV0QlFVc3NSMEZCUnl4RFFVRkRMRVZCUVVVc1MwRkJTeXhIUVVGSExFbEJRVWtzUTBGQlF5eGxRVUZsTEVWQlFVVXNTMEZCU3l4RlFVRkZMRVZCUVVVN1dVRkRka1FzVTBGQlV5eEhRVUZITEVsQlFVa3NVMEZCVXl4RFFVRkRMRWxCUVVrc1EwRkJReXhOUVVGTkxFTkJRVU1zUzBGQlN5eEZRVUZGTEVOQlFVTXNRMEZCUXp0WlFVVXZReXhMUVVGTExFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1NVRkJTU3hEUVVGRExGbEJRVmtzUlVGQlJTeERRVUZETEVWQlFVVXNSVUZCUlR0blFrRkZlRU1zU1VGQlNTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNc1IwRkJSeXhKUVVGSkxFTkJRVU1zVjBGQlZ5eERRVUZETEZOQlFWTXNRMEZCUXl4TFFVRkxMRU5CUVVNc1IwRkJSeXhEUVVGRExGTkJRVk1zUTBGQlF5eExRVUZMTEVsQlFVa3NRMEZCUXl4TFFVRkxMRWRCUVVjc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJRenRoUVVOdVNEdFRRVU5LTzBsQlEwd3NRMEZCUXpzN1FVRTNTbk5DTEdkQ1FVRlhMRWRCUVZjc1IwRkJSeXhEUVVGRE8wRkJRekZDTEhGQ1FVRm5RaXhIUVVGWExFVkJRVVVzUTBGQlF6dEJRVU01UWl4cFFrRkJXU3hIUVVGWExFbEJRVWtzUTBGQlF5eFhRVUZYTEVkQlFVY3NRMEZCUXl4RFFVRkRPMEZCUlc1RkxHVkJRV1U3UVVGRFV5eG5Ra0ZCVnl4SFFVRmpMRWxCUVVrc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFVkJRVVVzUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1JVRkJSU3hEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03UVVGT2VrY3NiMEpCSzBwREluMD0iLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IG51bWJlckhlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvbnVtYmVySGVscGVyXCIpO1xyXG5jb25zdCBvYmplY3RIZWxwZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlclwiKTtcclxuY29uc3Qgc2hhM18xID0gcmVxdWlyZShcIi4uL2RpZ2VzdHMvc2hhM1wiKTtcclxuY29uc3QgY3J5cHRvRXJyb3JfMSA9IHJlcXVpcmUoXCIuLi9lcnJvci9jcnlwdG9FcnJvclwiKTtcclxuY29uc3QgYmlnSW50ZWdlckhlbHBlcl8xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvYmlnSW50ZWdlckhlbHBlclwiKTtcclxuLyoqXHJcbiAqIEltcGxlbWVudGF0aW9uIG9mIElTcG9uZ2UgdXNpbmcgS2VybCBhbGdvcml0aG0uXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9pb3RhbGVkZ2VyL2lyaS9ibG9iL2Rldi9zcmMvbWFpbi9qYXZhL2NvbS9pb3RhL2lyaS9oYXNoL0tlcmwuamF2YVxyXG4gKi9cclxuY2xhc3MgS2VybCB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBLZXJsLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLl9rZWNjYWsgPSBuZXcgc2hhM18xLlNoYTMoMzg0LCBzaGEzXzEuU2hhMy5LRUNDQUtfUEFERElORywgMzg0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBjb25zdGFudCBmb3IgdGhlIHNwb25lLlxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGNvbnN0YW50IHRvIGdldC5cclxuICAgICAqIEByZXR1cm5zIFRoZSBjb25zdGFudC5cclxuICAgICAqL1xyXG4gICAgZ2V0Q29uc3RhbnQobmFtZSkge1xyXG4gICAgICAgIHN3aXRjaCAobmFtZSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiSEFTSF9MRU5HVEhcIjpcclxuICAgICAgICAgICAgY2FzZSBcIkJJVF9IQVNIX0xFTkdUSFwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiQllURV9IQVNIX0xFTkdUSFwiOlxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBLZXJsW25hbWVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihgVW5rbm93biBjb25zdGFudCByZXF1ZXN0ZWQgJHtuYW1lfWApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBzdGF0ZS5cclxuICAgICAqIEByZXR1cm5zIFRoZSBzdGF0ZS5cclxuICAgICAqL1xyXG4gICAgZ2V0U3RhdGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGlzZSB0aGUgaGFzaGVyLlxyXG4gICAgICogQHBhcmFtIHN0YXRlIFRoZSBpbml0aWFsIHN0YXRlIGZvciB0aGUgaGFzaGVyLlxyXG4gICAgICovXHJcbiAgICBpbml0aWFsaXplKHN0YXRlKSB7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0IHRoZSBoYXNoZXIuXHJcbiAgICAgKi9cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMuX2tlY2Nhay5yZXNldCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBYnNvcmIgdHJpdHMgaW50byB0aGUgaGFzaC5cclxuICAgICAqIEBwYXJhbSB0cml0cyBUaGUgdHJpdHMgdG8gYWJzb3JiLlxyXG4gICAgICogQHBhcmFtIG9mZnNldCBUaGUgb2Zmc2V0IGludG8gdGhlIHRyaXRzIHRvIGFic29yYiBmcm9tLlxyXG4gICAgICogQHBhcmFtIGxlbmd0aCBUaGUgbnVtYmVyIG9mIHRyaXRzIHRvIGFic29yYi5cclxuICAgICAqL1xyXG4gICAgYWJzb3JiKHRyaXRzLCBvZmZzZXQsIGxlbmd0aCkge1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZSh0cml0cywgSW50OEFycmF5KSB8fCB0cml0cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJUcml0cyBtdXN0IGJlIGEgbm9uIGVtcHR5IEludDhBcnJheVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKG9mZnNldCkgfHwgb2Zmc2V0IDwgMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIk9mZnNldCBtdXN0IGJlIGEgbnVtYmVyID49IDBcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihsZW5ndGgpIHx8IGxlbmd0aCA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJMZW5ndGggbXVzdCBiZSBhIG51bWJlciA+PSAwXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGVuZ3RoICsgb2Zmc2V0ID4gdHJpdHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiVGhlIG9mZnNldCArIGxlbmd0aCBpcyBiZXlvbmQgdGhlIGxlbmd0aCBvZiB0aGUgdHJpdHNcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsZW5ndGggJSAyNDMgIT09IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoYExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgJHtLZXJsLkhBU0hfTEVOR1RIfWAsIHsgbGVuZ3RoIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbG9jYWxPZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgbGV0IGxvY2FsTGVuZ3RoID0gbGVuZ3RoO1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgY29uc3QgdHJpdFN0YXRlID0gdHJpdHMuc2xpY2UobG9jYWxPZmZzZXQsIGxvY2FsT2Zmc2V0ICsgS2VybC5IQVNIX0xFTkdUSCk7XHJcbiAgICAgICAgICAgIHRyaXRTdGF0ZVtLZXJsLkhBU0hfTEVOR1RIIC0gMV0gPSAwO1xyXG4gICAgICAgICAgICBjb25zdCBiaWdJbnQgPSBiaWdJbnRlZ2VySGVscGVyXzEuQmlnSW50ZWdlckhlbHBlci50cml0c1RvQmlnSW50ZWdlcih0cml0U3RhdGUsIDAsIHRyaXRTdGF0ZS5sZW5ndGgpO1xyXG4gICAgICAgICAgICBjb25zdCBieXRlU3RhdGUgPSBuZXcgQXJyYXlCdWZmZXIoS2VybC5CWVRFX0hBU0hfTEVOR1RIKTtcclxuICAgICAgICAgICAgYmlnSW50ZWdlckhlbHBlcl8xLkJpZ0ludGVnZXJIZWxwZXIuYmlnSW50ZWdlclRvQnl0ZXMoYmlnSW50LCBieXRlU3RhdGUsIDApO1xyXG4gICAgICAgICAgICB0aGlzLl9rZWNjYWsudXBkYXRlKGJ5dGVTdGF0ZSk7XHJcbiAgICAgICAgICAgIGxvY2FsT2Zmc2V0ICs9IEtlcmwuSEFTSF9MRU5HVEg7XHJcbiAgICAgICAgICAgIGxvY2FsTGVuZ3RoIC09IEtlcmwuSEFTSF9MRU5HVEg7XHJcbiAgICAgICAgfSB3aGlsZSAobG9jYWxMZW5ndGggPiAwKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3F1ZWV6ZSB0cml0cyBpbnRvIHRoZSBoYXNoLlxyXG4gICAgICogQHBhcmFtIHRyaXRzIFRoZSB0cml0cyB0byBzcXVlZXplLlxyXG4gICAgICogQHBhcmFtIG9mZnNldCBUaGUgb2Zmc2V0IGludG8gdGhlIHRyaXRzIHRvIHNxdWVlemUgZnJvbS5cclxuICAgICAqIEBwYXJhbSBsZW5ndGggVGhlIG51bWJlciBvZiB0cml0cyB0byBzcXVlZXplLlxyXG4gICAgICovXHJcbiAgICBzcXVlZXplKHRyaXRzLCBvZmZzZXQsIGxlbmd0aCkge1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZSh0cml0cywgSW50OEFycmF5KSB8fCB0cml0cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJUcml0cyBtdXN0IGJlIGEgbm9uIGVtcHR5IEludDhBcnJheVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKG9mZnNldCkgfHwgb2Zmc2V0IDwgMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIk9mZnNldCBtdXN0IGJlIGEgbnVtYmVyID49IDBcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihsZW5ndGgpIHx8IGxlbmd0aCA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJMZW5ndGggbXVzdCBiZSBhIG51bWJlciA+PSAwXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGVuZ3RoICsgb2Zmc2V0ID4gdHJpdHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiVGhlIG9mZnNldCArIGxlbmd0aCBpcyBiZXlvbmQgdGhlIGxlbmd0aCBvZiB0aGUgdHJpdHNcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsZW5ndGggJSAyNDMgIT09IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoYExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgJHtLZXJsLkhBU0hfTEVOR1RIfWAsIHsgbGVuZ3RoIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbG9jYWxPZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgbGV0IGxvY2FsTGVuZ3RoID0gbGVuZ3RoO1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgY29uc3QgYnl0ZVN0YXRlQnVmZmVyID0gdGhpcy5fa2VjY2FrLmRpZ2VzdCgpO1xyXG4gICAgICAgICAgICBjb25zdCBiaWdJbnQgPSBiaWdJbnRlZ2VySGVscGVyXzEuQmlnSW50ZWdlckhlbHBlci5ieXRlc1RvQmlnSW50ZWdlcihieXRlU3RhdGVCdWZmZXIsIDAsIEtlcmwuQllURV9IQVNIX0xFTkdUSCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRyaXRTdGF0ZSA9IG5ldyBJbnQ4QXJyYXkoS2VybC5IQVNIX0xFTkdUSCk7XHJcbiAgICAgICAgICAgIGJpZ0ludGVnZXJIZWxwZXJfMS5CaWdJbnRlZ2VySGVscGVyLmJpZ0ludGVnZXJUb1RyaXRzKGJpZ0ludCwgdHJpdFN0YXRlLCAwLCBLZXJsLkhBU0hfTEVOR1RIKTtcclxuICAgICAgICAgICAgdHJpdFN0YXRlW0tlcmwuSEFTSF9MRU5HVEggLSAxXSA9IDA7XHJcbiAgICAgICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICAgICAgd2hpbGUgKGkgPCBLZXJsLkhBU0hfTEVOR1RIKSB7XHJcbiAgICAgICAgICAgICAgICB0cml0c1tsb2NhbE9mZnNldCsrXSA9IHRyaXRTdGF0ZVtpKytdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGR2ID0gbmV3IERhdGFWaWV3KGJ5dGVTdGF0ZUJ1ZmZlcik7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBkdi5ieXRlTGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGR2LnNldFVpbnQ4KGksIGR2LmdldFVpbnQ4KGkpIF4gMHhGRik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fa2VjY2FrLnVwZGF0ZShieXRlU3RhdGVCdWZmZXIpO1xyXG4gICAgICAgICAgICBsb2NhbExlbmd0aCAtPSBLZXJsLkhBU0hfTEVOR1RIO1xyXG4gICAgICAgIH0gd2hpbGUgKGxvY2FsTGVuZ3RoID4gMCk7XHJcbiAgICB9XHJcbn1cclxuLyogQGludGVybmFsICovXHJcbktlcmwuSEFTSF9MRU5HVEggPSAyNDM7XHJcbi8qIEBpbnRlcm5hbCAqL1xyXG5LZXJsLkJJVF9IQVNIX0xFTkdUSCA9IDM4NDtcclxuLyogQGludGVybmFsICovXHJcbktlcmwuQllURV9IQVNIX0xFTkdUSCA9IEtlcmwuQklUX0hBU0hfTEVOR1RIIC8gODtcclxuZXhwb3J0cy5LZXJsID0gS2VybDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYTJWeWJDNXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5emNHOXVaMlZ6TDJ0bGNtd3VkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanRCUVVGQkxEUkZRVUY1UlR0QlFVTjZSU3cwUlVGQmVVVTdRVUZEZWtVc01FTkJRWFZETzBGQlEzWkRMSE5FUVVGdFJEdEJRVU51UkN4clJVRkJLMFE3UVVGSEwwUTdPenRIUVVkSE8wRkJRMGc3U1VGWFNUczdUMEZGUnp0SlFVTklPMUZCUTBrc1NVRkJTU3hEUVVGRExFOUJRVThzUjBGQlJ5eEpRVUZKTEZkQlFVa3NRMEZCUXl4SFFVRkhMRVZCUVVVc1YwRkJTU3hEUVVGRExHTkJRV01zUlVGQlJTeEhRVUZITEVOQlFVTXNRMEZCUXp0SlFVTXpSQ3hEUVVGRE8wbEJSVVE3T3pzN1QwRkpSenRKUVVOSkxGZEJRVmNzUTBGQlF5eEpRVUZaTzFGQlF6TkNMRkZCUVZFc1NVRkJTU3hGUVVGRk8xbEJRMVlzUzBGQlN5eGhRVUZoTEVOQlFVTTdXVUZEYmtJc1MwRkJTeXhwUWtGQmFVSXNRMEZCUXp0WlFVTjJRaXhMUVVGTExHdENRVUZyUWp0blFrRkRka0k3YjBKQlEwa3NUMEZCVHl4SlFVRkpMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03YVVKQlEzSkNPMWxCUTBRc1QwRkJUeXhEUVVGRExFTkJRVU1zVFVGQlRTeEpRVUZKTEhsQ1FVRlhMRU5CUVVNc09FSkJRVGhDTEVsQlFVa3NSVUZCUlN4RFFVRkRMRU5CUVVNN1UwRkRlRVU3U1VGRFRDeERRVUZETzBsQlJVUTdPenRQUVVkSE8wbEJRMGtzVVVGQlVUdFJRVU5ZTEU5QlFVOHNVMEZCVXl4RFFVRkRPMGxCUTNKQ0xFTkJRVU03U1VGRlJEczdPMDlCUjBjN1NVRkRTU3hWUVVGVkxFTkJRVU1zUzBGQmFVSTdTVUZEYmtNc1EwRkJRenRKUVVWRU96dFBRVVZITzBsQlEwa3NTMEZCU3p0UlFVTlNMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zUzBGQlN5eEZRVUZGTEVOQlFVTTdTVUZEZWtJc1EwRkJRenRKUVVWRU96czdPenRQUVV0SE8wbEJRMGtzVFVGQlRTeERRVUZETEV0QlFXZENMRVZCUVVVc1RVRkJZeXhGUVVGRkxFMUJRV003VVVGRE1VUXNTVUZCU1N4RFFVRkRMREpDUVVGWkxFTkJRVU1zVFVGQlRTeERRVUZETEV0QlFVc3NSVUZCUlN4VFFVRlRMRU5CUVVNc1NVRkJTU3hMUVVGTExFTkJRVU1zVFVGQlRTeExRVUZMTEVOQlFVTXNSVUZCUlR0WlFVTTVSQ3hOUVVGTkxFbEJRVWtzZVVKQlFWY3NRMEZCUXl4eFEwRkJjVU1zUTBGQlF5eERRVUZETzFOQlEyaEZPMUZCUTBRc1NVRkJTU3hEUVVGRExESkNRVUZaTEVOQlFVTXNVMEZCVXl4RFFVRkRMRTFCUVUwc1EwRkJReXhKUVVGSkxFMUJRVTBzUjBGQlJ5eERRVUZETEVWQlFVVTdXVUZETDBNc1RVRkJUU3hKUVVGSkxIbENRVUZYTEVOQlFVTXNPRUpCUVRoQ0xFTkJRVU1zUTBGQlF6dFRRVU42UkR0UlFVTkVMRWxCUVVrc1EwRkJReXd5UWtGQldTeERRVUZETEZOQlFWTXNRMEZCUXl4TlFVRk5MRU5CUVVNc1NVRkJTU3hOUVVGTkxFZEJRVWNzUTBGQlF5eEZRVUZGTzFsQlF5OURMRTFCUVUwc1NVRkJTU3g1UWtGQlZ5eERRVUZETERoQ1FVRTRRaXhEUVVGRExFTkJRVU03VTBGRGVrUTdVVUZEUkN4SlFVRkpMRTFCUVUwc1IwRkJSeXhOUVVGTkxFZEJRVWNzUzBGQlN5eERRVUZETEUxQlFVMHNSVUZCUlR0WlFVTm9ReXhOUVVGTkxFbEJRVWtzZVVKQlFWY3NRMEZCUXl4MVJFRkJkVVFzUTBGQlF5eERRVUZETzFOQlEyeEdPMUZCUTBRc1NVRkJTU3hOUVVGTkxFZEJRVWNzUjBGQlJ5eExRVUZMTEVOQlFVTXNSVUZCUlR0WlFVTndRaXhOUVVGTkxFbEJRVWtzZVVKQlFWY3NRMEZCUXl4blEwRkJaME1zU1VGQlNTeERRVUZETEZkQlFWY3NSVUZCUlN4RlFVRkZMRVZCUVVVc1RVRkJUU3hGUVVGRkxFTkJRVU1zUTBGQlF6dFRRVU42Ump0UlFVVkVMRWxCUVVrc1YwRkJWeXhIUVVGSExFMUJRVTBzUTBGQlF6dFJRVU42UWl4SlFVRkpMRmRCUVZjc1IwRkJSeXhOUVVGTkxFTkJRVU03VVVGRmVrSXNSMEZCUnp0WlFVTkRMRTFCUVUwc1UwRkJVeXhIUVVGSExFdEJRVXNzUTBGQlF5eExRVUZMTEVOQlFVTXNWMEZCVnl4RlFVRkZMRmRCUVZjc1IwRkJSeXhKUVVGSkxFTkJRVU1zVjBGQlZ5eERRVUZETEVOQlFVTTdXVUZGTTBVc1UwRkJVeXhEUVVGRExFbEJRVWtzUTBGQlF5eFhRVUZYTEVkQlFVY3NRMEZCUXl4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRE8xbEJRM0JETEUxQlFVMHNUVUZCVFN4SFFVRkhMRzFEUVVGblFpeERRVUZETEdsQ1FVRnBRaXhEUVVGRExGTkJRVk1zUlVGQlJTeERRVUZETEVWQlFVVXNVMEZCVXl4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRE8xbEJRMnhHTEUxQlFVMHNVMEZCVXl4SFFVRkhMRWxCUVVrc1YwRkJWeXhEUVVGRExFbEJRVWtzUTBGQlF5eG5Ra0ZCWjBJc1EwRkJReXhEUVVGRE8xbEJRM3BFTEcxRFFVRm5RaXhEUVVGRExHbENRVUZwUWl4RFFVRkRMRTFCUVUwc1JVRkJSU3hUUVVGVExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZGZWtRc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eE5RVUZOTEVOQlFVTXNVMEZCVXl4RFFVRkRMRU5CUVVNN1dVRkZMMElzVjBGQlZ5eEpRVUZKTEVsQlFVa3NRMEZCUXl4WFFVRlhMRU5CUVVNN1dVRkRhRU1zVjBGQlZ5eEpRVUZKTEVsQlFVa3NRMEZCUXl4WFFVRlhMRU5CUVVNN1UwRkRia01zVVVGQlVTeFhRVUZYTEVkQlFVY3NRMEZCUXl4RlFVRkZPMGxCUXpsQ0xFTkJRVU03U1VGRlJEczdPenM3VDBGTFJ6dEpRVU5KTEU5QlFVOHNRMEZCUXl4TFFVRm5RaXhGUVVGRkxFMUJRV01zUlVGQlJTeE5RVUZqTzFGQlF6TkVMRWxCUVVrc1EwRkJReXd5UWtGQldTeERRVUZETEUxQlFVMHNRMEZCUXl4TFFVRkxMRVZCUVVVc1UwRkJVeXhEUVVGRExFbEJRVWtzUzBGQlN5eERRVUZETEUxQlFVMHNTMEZCU3l4RFFVRkRMRVZCUVVVN1dVRkRPVVFzVFVGQlRTeEpRVUZKTEhsQ1FVRlhMRU5CUVVNc2NVTkJRWEZETEVOQlFVTXNRMEZCUXp0VFFVTm9SVHRSUVVORUxFbEJRVWtzUTBGQlF5d3lRa0ZCV1N4RFFVRkRMRk5CUVZNc1EwRkJReXhOUVVGTkxFTkJRVU1zU1VGQlNTeE5RVUZOTEVkQlFVY3NRMEZCUXl4RlFVRkZPMWxCUXk5RExFMUJRVTBzU1VGQlNTeDVRa0ZCVnl4RFFVRkRMRGhDUVVFNFFpeERRVUZETEVOQlFVTTdVMEZEZWtRN1VVRkRSQ3hKUVVGSkxFTkJRVU1zTWtKQlFWa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1RVRkJUU3hEUVVGRExFbEJRVWtzVFVGQlRTeEhRVUZITEVOQlFVTXNSVUZCUlR0WlFVTXZReXhOUVVGTkxFbEJRVWtzZVVKQlFWY3NRMEZCUXl3NFFrRkJPRUlzUTBGQlF5eERRVUZETzFOQlEzcEVPMUZCUTBRc1NVRkJTU3hOUVVGTkxFZEJRVWNzVFVGQlRTeEhRVUZITEV0QlFVc3NRMEZCUXl4TlFVRk5MRVZCUVVVN1dVRkRhRU1zVFVGQlRTeEpRVUZKTEhsQ1FVRlhMRU5CUVVNc2RVUkJRWFZFTEVOQlFVTXNRMEZCUXp0VFFVTnNSanRSUVVORUxFbEJRVWtzVFVGQlRTeEhRVUZITEVkQlFVY3NTMEZCU3l4RFFVRkRMRVZCUVVVN1dVRkRjRUlzVFVGQlRTeEpRVUZKTEhsQ1FVRlhMRU5CUVVNc1owTkJRV2RETEVsQlFVa3NRMEZCUXl4WFFVRlhMRVZCUVVVc1JVRkJSU3hGUVVGRkxFMUJRVTBzUlVGQlJTeERRVUZETEVOQlFVTTdVMEZEZWtZN1VVRkZSQ3hKUVVGSkxGZEJRVmNzUjBGQlJ5eE5RVUZOTEVOQlFVTTdVVUZEZWtJc1NVRkJTU3hYUVVGWExFZEJRVWNzVFVGQlRTeERRVUZETzFGQlJYcENMRWRCUVVjN1dVRkRReXhOUVVGTkxHVkJRV1VzUjBGQlJ5eEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMRTFCUVUwc1JVRkJSU3hEUVVGRE8xbEJSVGxETEUxQlFVMHNUVUZCVFN4SFFVRkhMRzFEUVVGblFpeERRVUZETEdsQ1FVRnBRaXhEUVVGRExHVkJRV1VzUlVGQlJTeERRVUZETEVWQlFVVXNTVUZCU1N4RFFVRkRMR2RDUVVGblFpeERRVUZETEVOQlFVTTdXVUZGTjBZc1RVRkJUU3hUUVVGVExFZEJRV01zU1VGQlNTeFRRVUZUTEVOQlFVTXNTVUZCU1N4RFFVRkRMRmRCUVZjc1EwRkJReXhEUVVGRE8xbEJRemRFTEcxRFFVRm5RaXhEUVVGRExHbENRVUZwUWl4RFFVRkRMRTFCUVUwc1JVRkJSU3hUUVVGVExFVkJRVVVzUTBGQlF5eEZRVUZGTEVsQlFVa3NRMEZCUXl4WFFVRlhMRU5CUVVNc1EwRkJRenRaUVVVelJTeFRRVUZUTEVOQlFVTXNTVUZCU1N4RFFVRkRMRmRCUVZjc1IwRkJSeXhEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTTdXVUZGY0VNc1NVRkJTU3hEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETzFsQlExWXNUMEZCVHl4RFFVRkRMRWRCUVVjc1NVRkJTU3hEUVVGRExGZEJRVmNzUlVGQlJUdG5Ra0ZEZWtJc1MwRkJTeXhEUVVGRExGZEJRVmNzUlVGQlJTeERRVUZETEVkQlFVY3NVMEZCVXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU03WVVGRGVrTTdXVUZGUkN4TlFVRk5MRVZCUVVVc1IwRkJSeXhKUVVGSkxGRkJRVkVzUTBGQlF5eGxRVUZsTEVOQlFVTXNRMEZCUXp0WlFVTjZReXhMUVVGTExFTkJRVU1zUjBGQlJ5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRVZCUVVVc1EwRkJReXhWUVVGVkxFVkJRVVVzUTBGQlF5eEZRVUZGTEVWQlFVVTdaMEpCUTJoRExFVkJRVVVzUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXl4RlFVRkZMRVZCUVVVc1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF5eERRVUZETEVkQlFVY3NTVUZCU1N4RFFVRkRMRU5CUVVNN1lVRkRla003V1VGRlJDeEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMRTFCUVUwc1EwRkJReXhsUVVGbExFTkJRVU1zUTBGQlF6dFpRVVZ5UXl4WFFVRlhMRWxCUVVrc1NVRkJTU3hEUVVGRExGZEJRVmNzUTBGQlF6dFRRVU51UXl4UlFVRlJMRmRCUVZjc1IwRkJSeXhEUVVGRExFVkJRVVU3U1VGRE9VSXNRMEZCUXpzN1FVRnVTa1FzWlVGQlpUdEJRVU5UTEdkQ1FVRlhMRWRCUVZjc1IwRkJSeXhEUVVGRE8wRkJRMnhFTEdWQlFXVTdRVUZEVXl4dlFrRkJaU3hIUVVGWExFZEJRVWNzUTBGQlF6dEJRVU4wUkN4bFFVRmxPMEZCUTFNc2NVSkJRV2RDTEVkQlFWY3NTVUZCU1N4RFFVRkRMR1ZCUVdVc1IwRkJSeXhEUVVGRExFTkJRVU03UVVGT2FFWXNiMEpCY1VwREluMD0iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lXCIpO1xuIiwidmFyIGJpZ0ludCA9IChmdW5jdGlvbiAodW5kZWZpbmVkKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICB2YXIgQkFTRSA9IDFlNyxcclxuICAgICAgICBMT0dfQkFTRSA9IDcsXHJcbiAgICAgICAgTUFYX0lOVCA9IDkwMDcxOTkyNTQ3NDA5OTIsXHJcbiAgICAgICAgTUFYX0lOVF9BUlIgPSBzbWFsbFRvQXJyYXkoTUFYX0lOVCksXHJcbiAgICAgICAgTE9HX01BWF9JTlQgPSBNYXRoLmxvZyhNQVhfSU5UKTtcclxuXHJcbiAgICBmdW5jdGlvbiBJbnRlZ2VyKHYsIHJhZGl4KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gSW50ZWdlclswXTtcclxuICAgICAgICBpZiAodHlwZW9mIHJhZGl4ICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gK3JhZGl4ID09PSAxMCA/IHBhcnNlVmFsdWUodikgOiBwYXJzZUJhc2UodiwgcmFkaXgpO1xyXG4gICAgICAgIHJldHVybiBwYXJzZVZhbHVlKHYpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIEJpZ0ludGVnZXIodmFsdWUsIHNpZ24pIHtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5zaWduID0gc2lnbjtcclxuICAgICAgICB0aGlzLmlzU21hbGwgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJbnRlZ2VyLnByb3RvdHlwZSk7XHJcblxyXG4gICAgZnVuY3Rpb24gU21hbGxJbnRlZ2VyKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuc2lnbiA9IHZhbHVlIDwgMDtcclxuICAgICAgICB0aGlzLmlzU21hbGwgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSW50ZWdlci5wcm90b3R5cGUpO1xyXG5cclxuICAgIGZ1bmN0aW9uIGlzUHJlY2lzZShuKSB7XHJcbiAgICAgICAgcmV0dXJuIC1NQVhfSU5UIDwgbiAmJiBuIDwgTUFYX0lOVDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzbWFsbFRvQXJyYXkobikgeyAvLyBGb3IgcGVyZm9ybWFuY2UgcmVhc29ucyBkb2Vzbid0IHJlZmVyZW5jZSBCQVNFLCBuZWVkIHRvIGNoYW5nZSB0aGlzIGZ1bmN0aW9uIGlmIEJBU0UgY2hhbmdlc1xyXG4gICAgICAgIGlmIChuIDwgMWU3KVxyXG4gICAgICAgICAgICByZXR1cm4gW25dO1xyXG4gICAgICAgIGlmIChuIDwgMWUxNClcclxuICAgICAgICAgICAgcmV0dXJuIFtuICUgMWU3LCBNYXRoLmZsb29yKG4gLyAxZTcpXTtcclxuICAgICAgICByZXR1cm4gW24gJSAxZTcsIE1hdGguZmxvb3IobiAvIDFlNykgJSAxZTcsIE1hdGguZmxvb3IobiAvIDFlMTQpXTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhcnJheVRvU21hbGwoYXJyKSB7IC8vIElmIEJBU0UgY2hhbmdlcyB0aGlzIGZ1bmN0aW9uIG1heSBuZWVkIHRvIGNoYW5nZVxyXG4gICAgICAgIHRyaW0oYXJyKTtcclxuICAgICAgICB2YXIgbGVuZ3RoID0gYXJyLmxlbmd0aDtcclxuICAgICAgICBpZiAobGVuZ3RoIDwgNCAmJiBjb21wYXJlQWJzKGFyciwgTUFYX0lOVF9BUlIpIDwgMCkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gMDtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIGFyclswXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIGFyclswXSArIGFyclsxXSAqIEJBU0U7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gYXJyWzBdICsgKGFyclsxXSArIGFyclsyXSAqIEJBU0UpICogQkFTRTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXJyO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRyaW0odikge1xyXG4gICAgICAgIHZhciBpID0gdi5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKHZbLS1pXSA9PT0gMCk7XHJcbiAgICAgICAgdi5sZW5ndGggPSBpICsgMTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVBcnJheShsZW5ndGgpIHsgLy8gZnVuY3Rpb24gc2hhbWVsZXNzbHkgc3RvbGVuIGZyb20gWWFmZmxlJ3MgbGlicmFyeSBodHRwczovL2dpdGh1Yi5jb20vWWFmZmxlL0JpZ0ludGVnZXJcclxuICAgICAgICB2YXIgeCA9IG5ldyBBcnJheShsZW5ndGgpO1xyXG4gICAgICAgIHZhciBpID0gLTE7XHJcbiAgICAgICAgd2hpbGUgKCsraSA8IGxlbmd0aCkge1xyXG4gICAgICAgICAgICB4W2ldID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHg7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdHJ1bmNhdGUobikge1xyXG4gICAgICAgIGlmIChuID4gMCkgcmV0dXJuIE1hdGguZmxvb3Iobik7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbChuKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhZGQoYSwgYikgeyAvLyBhc3N1bWVzIGEgYW5kIGIgYXJlIGFycmF5cyB3aXRoIGEubGVuZ3RoID49IGIubGVuZ3RoXHJcbiAgICAgICAgdmFyIGxfYSA9IGEubGVuZ3RoLFxyXG4gICAgICAgICAgICBsX2IgPSBiLmxlbmd0aCxcclxuICAgICAgICAgICAgciA9IG5ldyBBcnJheShsX2EpLFxyXG4gICAgICAgICAgICBjYXJyeSA9IDAsXHJcbiAgICAgICAgICAgIGJhc2UgPSBCQVNFLFxyXG4gICAgICAgICAgICBzdW0sIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxfYjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHN1bSA9IGFbaV0gKyBiW2ldICsgY2Fycnk7XHJcbiAgICAgICAgICAgIGNhcnJ5ID0gc3VtID49IGJhc2UgPyAxIDogMDtcclxuICAgICAgICAgICAgcltpXSA9IHN1bSAtIGNhcnJ5ICogYmFzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKGkgPCBsX2EpIHtcclxuICAgICAgICAgICAgc3VtID0gYVtpXSArIGNhcnJ5O1xyXG4gICAgICAgICAgICBjYXJyeSA9IHN1bSA9PT0gYmFzZSA/IDEgOiAwO1xyXG4gICAgICAgICAgICByW2krK10gPSBzdW0gLSBjYXJyeSAqIGJhc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjYXJyeSA+IDApIHIucHVzaChjYXJyeSk7XHJcbiAgICAgICAgcmV0dXJuIHI7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYWRkQW55KGEsIGIpIHtcclxuICAgICAgICBpZiAoYS5sZW5ndGggPj0gYi5sZW5ndGgpIHJldHVybiBhZGQoYSwgYik7XHJcbiAgICAgICAgcmV0dXJuIGFkZChiLCBhKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhZGRTbWFsbChhLCBjYXJyeSkgeyAvLyBhc3N1bWVzIGEgaXMgYXJyYXksIGNhcnJ5IGlzIG51bWJlciB3aXRoIDAgPD0gY2FycnkgPCBNQVhfSU5UXHJcbiAgICAgICAgdmFyIGwgPSBhLmxlbmd0aCxcclxuICAgICAgICAgICAgciA9IG5ldyBBcnJheShsKSxcclxuICAgICAgICAgICAgYmFzZSA9IEJBU0UsXHJcbiAgICAgICAgICAgIHN1bSwgaTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHN1bSA9IGFbaV0gLSBiYXNlICsgY2Fycnk7XHJcbiAgICAgICAgICAgIGNhcnJ5ID0gTWF0aC5mbG9vcihzdW0gLyBiYXNlKTtcclxuICAgICAgICAgICAgcltpXSA9IHN1bSAtIGNhcnJ5ICogYmFzZTtcclxuICAgICAgICAgICAgY2FycnkgKz0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKGNhcnJ5ID4gMCkge1xyXG4gICAgICAgICAgICByW2krK10gPSBjYXJyeSAlIGJhc2U7XHJcbiAgICAgICAgICAgIGNhcnJ5ID0gTWF0aC5mbG9vcihjYXJyeSAvIGJhc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcjtcclxuICAgIH1cclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHZhciBuID0gcGFyc2VWYWx1ZSh2KTtcclxuICAgICAgICBpZiAodGhpcy5zaWduICE9PSBuLnNpZ24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3VidHJhY3Qobi5uZWdhdGUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBhID0gdGhpcy52YWx1ZSwgYiA9IG4udmFsdWU7XHJcbiAgICAgICAgaWYgKG4uaXNTbWFsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoYWRkU21hbGwoYSwgTWF0aC5hYnMoYikpLCB0aGlzLnNpZ24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoYWRkQW55KGEsIGIpLCB0aGlzLnNpZ24pO1xyXG4gICAgfTtcclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnBsdXMgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hZGQ7XHJcblxyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHZhciBuID0gcGFyc2VWYWx1ZSh2KTtcclxuICAgICAgICB2YXIgYSA9IHRoaXMudmFsdWU7XHJcbiAgICAgICAgaWYgKGEgPCAwICE9PSBuLnNpZ24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3VidHJhY3Qobi5uZWdhdGUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBiID0gbi52YWx1ZTtcclxuICAgICAgICBpZiAobi5pc1NtYWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChpc1ByZWNpc2UoYSArIGIpKSByZXR1cm4gbmV3IFNtYWxsSW50ZWdlcihhICsgYik7XHJcbiAgICAgICAgICAgIGIgPSBzbWFsbFRvQXJyYXkoTWF0aC5hYnMoYikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoYWRkU21hbGwoYiwgTWF0aC5hYnMoYSkpLCBhIDwgMCk7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5wbHVzID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5hZGQ7XHJcblxyXG4gICAgZnVuY3Rpb24gc3VidHJhY3QoYSwgYikgeyAvLyBhc3N1bWVzIGEgYW5kIGIgYXJlIGFycmF5cyB3aXRoIGEgPj0gYlxyXG4gICAgICAgIHZhciBhX2wgPSBhLmxlbmd0aCxcclxuICAgICAgICAgICAgYl9sID0gYi5sZW5ndGgsXHJcbiAgICAgICAgICAgIHIgPSBuZXcgQXJyYXkoYV9sKSxcclxuICAgICAgICAgICAgYm9ycm93ID0gMCxcclxuICAgICAgICAgICAgYmFzZSA9IEJBU0UsXHJcbiAgICAgICAgICAgIGksIGRpZmZlcmVuY2U7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJfbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGRpZmZlcmVuY2UgPSBhW2ldIC0gYm9ycm93IC0gYltpXTtcclxuICAgICAgICAgICAgaWYgKGRpZmZlcmVuY2UgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBkaWZmZXJlbmNlICs9IGJhc2U7XHJcbiAgICAgICAgICAgICAgICBib3Jyb3cgPSAxO1xyXG4gICAgICAgICAgICB9IGVsc2UgYm9ycm93ID0gMDtcclxuICAgICAgICAgICAgcltpXSA9IGRpZmZlcmVuY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoaSA9IGJfbDsgaSA8IGFfbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGRpZmZlcmVuY2UgPSBhW2ldIC0gYm9ycm93O1xyXG4gICAgICAgICAgICBpZiAoZGlmZmVyZW5jZSA8IDApIGRpZmZlcmVuY2UgKz0gYmFzZTtcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByW2krK10gPSBkaWZmZXJlbmNlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcltpXSA9IGRpZmZlcmVuY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoOyBpIDwgYV9sOyBpKyspIHtcclxuICAgICAgICAgICAgcltpXSA9IGFbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyaW0ocik7XHJcbiAgICAgICAgcmV0dXJuIHI7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc3VidHJhY3RBbnkoYSwgYiwgc2lnbikge1xyXG4gICAgICAgIHZhciB2YWx1ZTtcclxuICAgICAgICBpZiAoY29tcGFyZUFicyhhLCBiKSA+PSAwKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gc3VidHJhY3QoYSxiKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHN1YnRyYWN0KGIsIGEpO1xyXG4gICAgICAgICAgICBzaWduID0gIXNpZ247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhbHVlID0gYXJyYXlUb1NtYWxsKHZhbHVlKTtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgIGlmIChzaWduKSB2YWx1ZSA9IC12YWx1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTbWFsbEludGVnZXIodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIodmFsdWUsIHNpZ24pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHN1YnRyYWN0U21hbGwoYSwgYiwgc2lnbikgeyAvLyBhc3N1bWVzIGEgaXMgYXJyYXksIGIgaXMgbnVtYmVyIHdpdGggMCA8PSBiIDwgTUFYX0lOVFxyXG4gICAgICAgIHZhciBsID0gYS5sZW5ndGgsXHJcbiAgICAgICAgICAgIHIgPSBuZXcgQXJyYXkobCksXHJcbiAgICAgICAgICAgIGNhcnJ5ID0gLWIsXHJcbiAgICAgICAgICAgIGJhc2UgPSBCQVNFLFxyXG4gICAgICAgICAgICBpLCBkaWZmZXJlbmNlO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgZGlmZmVyZW5jZSA9IGFbaV0gKyBjYXJyeTtcclxuICAgICAgICAgICAgY2FycnkgPSBNYXRoLmZsb29yKGRpZmZlcmVuY2UgLyBiYXNlKTtcclxuICAgICAgICAgICAgZGlmZmVyZW5jZSAlPSBiYXNlO1xyXG4gICAgICAgICAgICByW2ldID0gZGlmZmVyZW5jZSA8IDAgPyBkaWZmZXJlbmNlICsgYmFzZSA6IGRpZmZlcmVuY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHIgPSBhcnJheVRvU21hbGwocik7XHJcbiAgICAgICAgaWYgKHR5cGVvZiByID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgIGlmIChzaWduKSByID0gLXI7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU21hbGxJbnRlZ2VyKHIpO1xyXG4gICAgICAgIH0gcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKHIsIHNpZ24pO1xyXG4gICAgfVxyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICB2YXIgbiA9IHBhcnNlVmFsdWUodik7XHJcbiAgICAgICAgaWYgKHRoaXMuc2lnbiAhPT0gbi5zaWduKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChuLm5lZ2F0ZSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGEgPSB0aGlzLnZhbHVlLCBiID0gbi52YWx1ZTtcclxuICAgICAgICBpZiAobi5pc1NtYWxsKVxyXG4gICAgICAgICAgICByZXR1cm4gc3VidHJhY3RTbWFsbChhLCBNYXRoLmFicyhiKSwgdGhpcy5zaWduKTtcclxuICAgICAgICByZXR1cm4gc3VidHJhY3RBbnkoYSwgYiwgdGhpcy5zaWduKTtcclxuICAgIH07XHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5taW51cyA9IEJpZ0ludGVnZXIucHJvdG90eXBlLnN1YnRyYWN0O1xyXG5cclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHZhciBuID0gcGFyc2VWYWx1ZSh2KTtcclxuICAgICAgICB2YXIgYSA9IHRoaXMudmFsdWU7XHJcbiAgICAgICAgaWYgKGEgPCAwICE9PSBuLnNpZ24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKG4ubmVnYXRlKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYiA9IG4udmFsdWU7XHJcbiAgICAgICAgaWYgKG4uaXNTbWFsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFNtYWxsSW50ZWdlcihhIC0gYik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdWJ0cmFjdFNtYWxsKGIsIE1hdGguYWJzKGEpLCBhID49IDApO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUubWludXMgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLnN1YnRyYWN0O1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIodGhpcy52YWx1ZSwgIXRoaXMuc2lnbik7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5uZWdhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNpZ24gPSB0aGlzLnNpZ247XHJcbiAgICAgICAgdmFyIHNtYWxsID0gbmV3IFNtYWxsSW50ZWdlcigtdGhpcy52YWx1ZSk7XHJcbiAgICAgICAgc21hbGwuc2lnbiA9ICFzaWduO1xyXG4gICAgICAgIHJldHVybiBzbWFsbDtcclxuICAgIH07XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYWJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcih0aGlzLnZhbHVlLCBmYWxzZSk7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5hYnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTbWFsbEludGVnZXIoTWF0aC5hYnModGhpcy52YWx1ZSkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBtdWx0aXBseUxvbmcoYSwgYikge1xyXG4gICAgICAgIHZhciBhX2wgPSBhLmxlbmd0aCxcclxuICAgICAgICAgICAgYl9sID0gYi5sZW5ndGgsXHJcbiAgICAgICAgICAgIGwgPSBhX2wgKyBiX2wsXHJcbiAgICAgICAgICAgIHIgPSBjcmVhdGVBcnJheShsKSxcclxuICAgICAgICAgICAgYmFzZSA9IEJBU0UsXHJcbiAgICAgICAgICAgIHByb2R1Y3QsIGNhcnJ5LCBpLCBhX2ksIGJfajtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYV9sOyArK2kpIHtcclxuICAgICAgICAgICAgYV9pID0gYVtpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBiX2w7ICsraikge1xyXG4gICAgICAgICAgICAgICAgYl9qID0gYltqXTtcclxuICAgICAgICAgICAgICAgIHByb2R1Y3QgPSBhX2kgKiBiX2ogKyByW2kgKyBqXTtcclxuICAgICAgICAgICAgICAgIGNhcnJ5ID0gTWF0aC5mbG9vcihwcm9kdWN0IC8gYmFzZSk7XHJcbiAgICAgICAgICAgICAgICByW2kgKyBqXSA9IHByb2R1Y3QgLSBjYXJyeSAqIGJhc2U7XHJcbiAgICAgICAgICAgICAgICByW2kgKyBqICsgMV0gKz0gY2Fycnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdHJpbShyKTtcclxuICAgICAgICByZXR1cm4gcjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBtdWx0aXBseVNtYWxsKGEsIGIpIHsgLy8gYXNzdW1lcyBhIGlzIGFycmF5LCBiIGlzIG51bWJlciB3aXRoIHxifCA8IEJBU0VcclxuICAgICAgICB2YXIgbCA9IGEubGVuZ3RoLFxyXG4gICAgICAgICAgICByID0gbmV3IEFycmF5KGwpLFxyXG4gICAgICAgICAgICBiYXNlID0gQkFTRSxcclxuICAgICAgICAgICAgY2FycnkgPSAwLFxyXG4gICAgICAgICAgICBwcm9kdWN0LCBpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgcHJvZHVjdCA9IGFbaV0gKiBiICsgY2Fycnk7XHJcbiAgICAgICAgICAgIGNhcnJ5ID0gTWF0aC5mbG9vcihwcm9kdWN0IC8gYmFzZSk7XHJcbiAgICAgICAgICAgIHJbaV0gPSBwcm9kdWN0IC0gY2FycnkgKiBiYXNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAoY2FycnkgPiAwKSB7XHJcbiAgICAgICAgICAgIHJbaSsrXSA9IGNhcnJ5ICUgYmFzZTtcclxuICAgICAgICAgICAgY2FycnkgPSBNYXRoLmZsb29yKGNhcnJ5IC8gYmFzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNoaWZ0TGVmdCh4LCBuKSB7XHJcbiAgICAgICAgdmFyIHIgPSBbXTtcclxuICAgICAgICB3aGlsZSAobi0tID4gMCkgci5wdXNoKDApO1xyXG4gICAgICAgIHJldHVybiByLmNvbmNhdCh4KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBtdWx0aXBseUthcmF0c3ViYSh4LCB5KSB7XHJcbiAgICAgICAgdmFyIG4gPSBNYXRoLm1heCh4Lmxlbmd0aCwgeS5sZW5ndGgpO1xyXG5cclxuICAgICAgICBpZiAobiA8PSAzMCkgcmV0dXJuIG11bHRpcGx5TG9uZyh4LCB5KTtcclxuICAgICAgICBuID0gTWF0aC5jZWlsKG4gLyAyKTtcclxuXHJcbiAgICAgICAgdmFyIGIgPSB4LnNsaWNlKG4pLFxyXG4gICAgICAgICAgICBhID0geC5zbGljZSgwLCBuKSxcclxuICAgICAgICAgICAgZCA9IHkuc2xpY2UobiksXHJcbiAgICAgICAgICAgIGMgPSB5LnNsaWNlKDAsIG4pO1xyXG5cclxuICAgICAgICB2YXIgYWMgPSBtdWx0aXBseUthcmF0c3ViYShhLCBjKSxcclxuICAgICAgICAgICAgYmQgPSBtdWx0aXBseUthcmF0c3ViYShiLCBkKSxcclxuICAgICAgICAgICAgYWJjZCA9IG11bHRpcGx5S2FyYXRzdWJhKGFkZEFueShhLCBiKSwgYWRkQW55KGMsIGQpKTtcclxuXHJcbiAgICAgICAgdmFyIHByb2R1Y3QgPSBhZGRBbnkoYWRkQW55KGFjLCBzaGlmdExlZnQoc3VidHJhY3Qoc3VidHJhY3QoYWJjZCwgYWMpLCBiZCksIG4pKSwgc2hpZnRMZWZ0KGJkLCAyICogbikpO1xyXG4gICAgICAgIHRyaW0ocHJvZHVjdCk7XHJcbiAgICAgICAgcmV0dXJuIHByb2R1Y3Q7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVGhlIGZvbGxvd2luZyBmdW5jdGlvbiBpcyBkZXJpdmVkIGZyb20gYSBzdXJmYWNlIGZpdCBvZiBhIGdyYXBoIHBsb3R0aW5nIHRoZSBwZXJmb3JtYW5jZSBkaWZmZXJlbmNlXHJcbiAgICAvLyBiZXR3ZWVuIGxvbmcgbXVsdGlwbGljYXRpb24gYW5kIGthcmF0c3ViYSBtdWx0aXBsaWNhdGlvbiB2ZXJzdXMgdGhlIGxlbmd0aHMgb2YgdGhlIHR3byBhcnJheXMuXHJcbiAgICBmdW5jdGlvbiB1c2VLYXJhdHN1YmEobDEsIGwyKSB7XHJcbiAgICAgICAgcmV0dXJuIC0wLjAxMiAqIGwxIC0gMC4wMTIgKiBsMiArIDAuMDAwMDE1ICogbDEgKiBsMiA+IDA7XHJcbiAgICB9XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHZhciBuID0gcGFyc2VWYWx1ZSh2KSxcclxuICAgICAgICAgICAgYSA9IHRoaXMudmFsdWUsIGIgPSBuLnZhbHVlLFxyXG4gICAgICAgICAgICBzaWduID0gdGhpcy5zaWduICE9PSBuLnNpZ24sXHJcbiAgICAgICAgICAgIGFicztcclxuICAgICAgICBpZiAobi5pc1NtYWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChiID09PSAwKSByZXR1cm4gSW50ZWdlclswXTtcclxuICAgICAgICAgICAgaWYgKGIgPT09IDEpIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICBpZiAoYiA9PT0gLTEpIHJldHVybiB0aGlzLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICBhYnMgPSBNYXRoLmFicyhiKTtcclxuICAgICAgICAgICAgaWYgKGFicyA8IEJBU0UpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihtdWx0aXBseVNtYWxsKGEsIGFicyksIHNpZ24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGIgPSBzbWFsbFRvQXJyYXkoYWJzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHVzZUthcmF0c3ViYShhLmxlbmd0aCwgYi5sZW5ndGgpKSAvLyBLYXJhdHN1YmEgaXMgb25seSBmYXN0ZXIgZm9yIGNlcnRhaW4gYXJyYXkgc2l6ZXNcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKG11bHRpcGx5S2FyYXRzdWJhKGEsIGIpLCBzaWduKTtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIobXVsdGlwbHlMb25nKGEsIGIpLCBzaWduKTtcclxuICAgIH07XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUudGltZXMgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseTtcclxuXHJcbiAgICBmdW5jdGlvbiBtdWx0aXBseVNtYWxsQW5kQXJyYXkoYSwgYiwgc2lnbikgeyAvLyBhID49IDBcclxuICAgICAgICBpZiAoYSA8IEJBU0UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKG11bHRpcGx5U21hbGwoYiwgYSksIHNpZ24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIobXVsdGlwbHlMb25nKGIsIHNtYWxsVG9BcnJheShhKSksIHNpZ24pO1xyXG4gICAgfVxyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5fbXVsdGlwbHlCeVNtYWxsID0gZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgaWYgKGlzUHJlY2lzZShhLnZhbHVlICogdGhpcy52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU21hbGxJbnRlZ2VyKGEudmFsdWUgKiB0aGlzLnZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbXVsdGlwbHlTbWFsbEFuZEFycmF5KE1hdGguYWJzKGEudmFsdWUpLCBzbWFsbFRvQXJyYXkoTWF0aC5hYnModGhpcy52YWx1ZSkpLCB0aGlzLnNpZ24gIT09IGEuc2lnbik7XHJcbiAgICB9O1xyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuX211bHRpcGx5QnlTbWFsbCA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIGlmIChhLnZhbHVlID09PSAwKSByZXR1cm4gSW50ZWdlclswXTtcclxuICAgICAgICAgICAgaWYgKGEudmFsdWUgPT09IDEpIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICBpZiAoYS52YWx1ZSA9PT0gLTEpIHJldHVybiB0aGlzLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gbXVsdGlwbHlTbWFsbEFuZEFycmF5KE1hdGguYWJzKGEudmFsdWUpLCB0aGlzLnZhbHVlLCB0aGlzLnNpZ24gIT09IGEuc2lnbik7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlVmFsdWUodikuX211bHRpcGx5QnlTbWFsbCh0aGlzKTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLnRpbWVzID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseTtcclxuXHJcbiAgICBmdW5jdGlvbiBzcXVhcmUoYSkge1xyXG4gICAgICAgIHZhciBsID0gYS5sZW5ndGgsXHJcbiAgICAgICAgICAgIHIgPSBjcmVhdGVBcnJheShsICsgbCksXHJcbiAgICAgICAgICAgIGJhc2UgPSBCQVNFLFxyXG4gICAgICAgICAgICBwcm9kdWN0LCBjYXJyeSwgaSwgYV9pLCBhX2o7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICBhX2kgPSBhW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGw7IGorKykge1xyXG4gICAgICAgICAgICAgICAgYV9qID0gYVtqXTtcclxuICAgICAgICAgICAgICAgIHByb2R1Y3QgPSBhX2kgKiBhX2ogKyByW2kgKyBqXTtcclxuICAgICAgICAgICAgICAgIGNhcnJ5ID0gTWF0aC5mbG9vcihwcm9kdWN0IC8gYmFzZSk7XHJcbiAgICAgICAgICAgICAgICByW2kgKyBqXSA9IHByb2R1Y3QgLSBjYXJyeSAqIGJhc2U7XHJcbiAgICAgICAgICAgICAgICByW2kgKyBqICsgMV0gKz0gY2Fycnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdHJpbShyKTtcclxuICAgICAgICByZXR1cm4gcjtcclxuICAgIH1cclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zcXVhcmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKHNxdWFyZSh0aGlzLnZhbHVlKSwgZmFsc2UpO1xyXG4gICAgfTtcclxuXHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLnNxdWFyZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlICogdGhpcy52YWx1ZTtcclxuICAgICAgICBpZiAoaXNQcmVjaXNlKHZhbHVlKSkgcmV0dXJuIG5ldyBTbWFsbEludGVnZXIodmFsdWUpO1xyXG4gICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihzcXVhcmUoc21hbGxUb0FycmF5KE1hdGguYWJzKHRoaXMudmFsdWUpKSksIGZhbHNlKTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gZGl2TW9kMShhLCBiKSB7IC8vIExlZnQgb3ZlciBmcm9tIHByZXZpb3VzIHZlcnNpb24uIFBlcmZvcm1zIGZhc3RlciB0aGFuIGRpdk1vZDIgb24gc21hbGxlciBpbnB1dCBzaXplcy5cclxuICAgICAgICB2YXIgYV9sID0gYS5sZW5ndGgsXHJcbiAgICAgICAgICAgIGJfbCA9IGIubGVuZ3RoLFxyXG4gICAgICAgICAgICBiYXNlID0gQkFTRSxcclxuICAgICAgICAgICAgcmVzdWx0ID0gY3JlYXRlQXJyYXkoYi5sZW5ndGgpLFxyXG4gICAgICAgICAgICBkaXZpc29yTW9zdFNpZ25pZmljYW50RGlnaXQgPSBiW2JfbCAtIDFdLFxyXG4gICAgICAgICAgICAvLyBub3JtYWxpemF0aW9uXHJcbiAgICAgICAgICAgIGxhbWJkYSA9IE1hdGguY2VpbChiYXNlIC8gKDIgKiBkaXZpc29yTW9zdFNpZ25pZmljYW50RGlnaXQpKSxcclxuICAgICAgICAgICAgcmVtYWluZGVyID0gbXVsdGlwbHlTbWFsbChhLCBsYW1iZGEpLFxyXG4gICAgICAgICAgICBkaXZpc29yID0gbXVsdGlwbHlTbWFsbChiLCBsYW1iZGEpLFxyXG4gICAgICAgICAgICBxdW90aWVudERpZ2l0LCBzaGlmdCwgY2FycnksIGJvcnJvdywgaSwgbCwgcTtcclxuICAgICAgICBpZiAocmVtYWluZGVyLmxlbmd0aCA8PSBhX2wpIHJlbWFpbmRlci5wdXNoKDApO1xyXG4gICAgICAgIGRpdmlzb3IucHVzaCgwKTtcclxuICAgICAgICBkaXZpc29yTW9zdFNpZ25pZmljYW50RGlnaXQgPSBkaXZpc29yW2JfbCAtIDFdO1xyXG4gICAgICAgIGZvciAoc2hpZnQgPSBhX2wgLSBiX2w7IHNoaWZ0ID49IDA7IHNoaWZ0LS0pIHtcclxuICAgICAgICAgICAgcXVvdGllbnREaWdpdCA9IGJhc2UgLSAxO1xyXG4gICAgICAgICAgICBpZiAocmVtYWluZGVyW3NoaWZ0ICsgYl9sXSAhPT0gZGl2aXNvck1vc3RTaWduaWZpY2FudERpZ2l0KSB7XHJcbiAgICAgICAgICAgICAgcXVvdGllbnREaWdpdCA9IE1hdGguZmxvb3IoKHJlbWFpbmRlcltzaGlmdCArIGJfbF0gKiBiYXNlICsgcmVtYWluZGVyW3NoaWZ0ICsgYl9sIC0gMV0pIC8gZGl2aXNvck1vc3RTaWduaWZpY2FudERpZ2l0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBxdW90aWVudERpZ2l0IDw9IGJhc2UgLSAxXHJcbiAgICAgICAgICAgIGNhcnJ5ID0gMDtcclxuICAgICAgICAgICAgYm9ycm93ID0gMDtcclxuICAgICAgICAgICAgbCA9IGRpdmlzb3IubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjYXJyeSArPSBxdW90aWVudERpZ2l0ICogZGl2aXNvcltpXTtcclxuICAgICAgICAgICAgICAgIHEgPSBNYXRoLmZsb29yKGNhcnJ5IC8gYmFzZSk7XHJcbiAgICAgICAgICAgICAgICBib3Jyb3cgKz0gcmVtYWluZGVyW3NoaWZ0ICsgaV0gLSAoY2FycnkgLSBxICogYmFzZSk7XHJcbiAgICAgICAgICAgICAgICBjYXJyeSA9IHE7XHJcbiAgICAgICAgICAgICAgICBpZiAoYm9ycm93IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmRlcltzaGlmdCArIGldID0gYm9ycm93ICsgYmFzZTtcclxuICAgICAgICAgICAgICAgICAgICBib3Jyb3cgPSAtMTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluZGVyW3NoaWZ0ICsgaV0gPSBib3Jyb3c7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9ycm93ID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB3aGlsZSAoYm9ycm93ICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBxdW90aWVudERpZ2l0IC09IDE7XHJcbiAgICAgICAgICAgICAgICBjYXJyeSA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FycnkgKz0gcmVtYWluZGVyW3NoaWZ0ICsgaV0gLSBiYXNlICsgZGl2aXNvcltpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FycnkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbWFpbmRlcltzaGlmdCArIGldID0gY2FycnkgKyBiYXNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXJyeSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtYWluZGVyW3NoaWZ0ICsgaV0gPSBjYXJyeTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FycnkgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJvcnJvdyArPSBjYXJyeTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXN1bHRbc2hpZnRdID0gcXVvdGllbnREaWdpdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZGVub3JtYWxpemF0aW9uXHJcbiAgICAgICAgcmVtYWluZGVyID0gZGl2TW9kU21hbGwocmVtYWluZGVyLCBsYW1iZGEpWzBdO1xyXG4gICAgICAgIHJldHVybiBbYXJyYXlUb1NtYWxsKHJlc3VsdCksIGFycmF5VG9TbWFsbChyZW1haW5kZXIpXTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkaXZNb2QyKGEsIGIpIHsgLy8gSW1wbGVtZW50YXRpb24gaWRlYSBzaGFtZWxlc3NseSBzdG9sZW4gZnJvbSBTaWxlbnQgTWF0dCdzIGxpYnJhcnkgaHR0cDovL3NpbGVudG1hdHQuY29tL2JpZ2ludGVnZXIvXHJcbiAgICAgICAgLy8gUGVyZm9ybXMgZmFzdGVyIHRoYW4gZGl2TW9kMSBvbiBsYXJnZXIgaW5wdXQgc2l6ZXMuXHJcbiAgICAgICAgdmFyIGFfbCA9IGEubGVuZ3RoLFxyXG4gICAgICAgICAgICBiX2wgPSBiLmxlbmd0aCxcclxuICAgICAgICAgICAgcmVzdWx0ID0gW10sXHJcbiAgICAgICAgICAgIHBhcnQgPSBbXSxcclxuICAgICAgICAgICAgYmFzZSA9IEJBU0UsXHJcbiAgICAgICAgICAgIGd1ZXNzLCB4bGVuLCBoaWdoeCwgaGlnaHksIGNoZWNrO1xyXG4gICAgICAgIHdoaWxlIChhX2wpIHtcclxuICAgICAgICAgICAgcGFydC51bnNoaWZ0KGFbLS1hX2xdKTtcclxuICAgICAgICAgICAgdHJpbShwYXJ0KTtcclxuICAgICAgICAgICAgaWYgKGNvbXBhcmVBYnMocGFydCwgYikgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgwKTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHhsZW4gPSBwYXJ0Lmxlbmd0aDtcclxuICAgICAgICAgICAgaGlnaHggPSBwYXJ0W3hsZW4gLSAxXSAqIGJhc2UgKyBwYXJ0W3hsZW4gLSAyXTtcclxuICAgICAgICAgICAgaGlnaHkgPSBiW2JfbCAtIDFdICogYmFzZSArIGJbYl9sIC0gMl07XHJcbiAgICAgICAgICAgIGlmICh4bGVuID4gYl9sKSB7XHJcbiAgICAgICAgICAgICAgICBoaWdoeCA9IChoaWdoeCArIDEpICogYmFzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBndWVzcyA9IE1hdGguY2VpbChoaWdoeCAvIGhpZ2h5KTtcclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgY2hlY2sgPSBtdWx0aXBseVNtYWxsKGIsIGd1ZXNzKTtcclxuICAgICAgICAgICAgICAgIGlmIChjb21wYXJlQWJzKGNoZWNrLCBwYXJ0KSA8PSAwKSBicmVhaztcclxuICAgICAgICAgICAgICAgIGd1ZXNzLS07XHJcbiAgICAgICAgICAgIH0gd2hpbGUgKGd1ZXNzKTtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZ3Vlc3MpO1xyXG4gICAgICAgICAgICBwYXJ0ID0gc3VidHJhY3QocGFydCwgY2hlY2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQucmV2ZXJzZSgpO1xyXG4gICAgICAgIHJldHVybiBbYXJyYXlUb1NtYWxsKHJlc3VsdCksIGFycmF5VG9TbWFsbChwYXJ0KV07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZGl2TW9kU21hbGwodmFsdWUsIGxhbWJkYSkge1xyXG4gICAgICAgIHZhciBsZW5ndGggPSB2YWx1ZS5sZW5ndGgsXHJcbiAgICAgICAgICAgIHF1b3RpZW50ID0gY3JlYXRlQXJyYXkobGVuZ3RoKSxcclxuICAgICAgICAgICAgYmFzZSA9IEJBU0UsXHJcbiAgICAgICAgICAgIGksIHEsIHJlbWFpbmRlciwgZGl2aXNvcjtcclxuICAgICAgICByZW1haW5kZXIgPSAwO1xyXG4gICAgICAgIGZvciAoaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XHJcbiAgICAgICAgICAgIGRpdmlzb3IgPSByZW1haW5kZXIgKiBiYXNlICsgdmFsdWVbaV07XHJcbiAgICAgICAgICAgIHEgPSB0cnVuY2F0ZShkaXZpc29yIC8gbGFtYmRhKTtcclxuICAgICAgICAgICAgcmVtYWluZGVyID0gZGl2aXNvciAtIHEgKiBsYW1iZGE7XHJcbiAgICAgICAgICAgIHF1b3RpZW50W2ldID0gcSB8IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbcXVvdGllbnQsIHJlbWFpbmRlciB8IDBdO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRpdk1vZEFueShzZWxmLCB2KSB7XHJcbiAgICAgICAgdmFyIHZhbHVlLCBuID0gcGFyc2VWYWx1ZSh2KTtcclxuICAgICAgICB2YXIgYSA9IHNlbGYudmFsdWUsIGIgPSBuLnZhbHVlO1xyXG4gICAgICAgIHZhciBxdW90aWVudDtcclxuICAgICAgICBpZiAoYiA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGRpdmlkZSBieSB6ZXJvXCIpO1xyXG4gICAgICAgIGlmIChzZWxmLmlzU21hbGwpIHtcclxuICAgICAgICAgICAgaWYgKG4uaXNTbWFsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtuZXcgU21hbGxJbnRlZ2VyKHRydW5jYXRlKGEgLyBiKSksIG5ldyBTbWFsbEludGVnZXIoYSAlIGIpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gW0ludGVnZXJbMF0sIHNlbGZdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobi5pc1NtYWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChiID09PSAxKSByZXR1cm4gW3NlbGYsIEludGVnZXJbMF1dO1xyXG4gICAgICAgICAgICBpZiAoYiA9PSAtMSkgcmV0dXJuIFtzZWxmLm5lZ2F0ZSgpLCBJbnRlZ2VyWzBdXTtcclxuICAgICAgICAgICAgdmFyIGFicyA9IE1hdGguYWJzKGIpO1xyXG4gICAgICAgICAgICBpZiAoYWJzIDwgQkFTRSkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBkaXZNb2RTbWFsbChhLCBhYnMpO1xyXG4gICAgICAgICAgICAgICAgcXVvdGllbnQgPSBhcnJheVRvU21hbGwodmFsdWVbMF0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlbWFpbmRlciA9IHZhbHVlWzFdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuc2lnbikgcmVtYWluZGVyID0gLXJlbWFpbmRlcjtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcXVvdGllbnQgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5zaWduICE9PSBuLnNpZ24pIHF1b3RpZW50ID0gLXF1b3RpZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbbmV3IFNtYWxsSW50ZWdlcihxdW90aWVudCksIG5ldyBTbWFsbEludGVnZXIocmVtYWluZGVyKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW25ldyBCaWdJbnRlZ2VyKHF1b3RpZW50LCBzZWxmLnNpZ24gIT09IG4uc2lnbiksIG5ldyBTbWFsbEludGVnZXIocmVtYWluZGVyKV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYiA9IHNtYWxsVG9BcnJheShhYnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY29tcGFyaXNvbiA9IGNvbXBhcmVBYnMoYSwgYik7XHJcbiAgICAgICAgaWYgKGNvbXBhcmlzb24gPT09IC0xKSByZXR1cm4gW0ludGVnZXJbMF0sIHNlbGZdO1xyXG4gICAgICAgIGlmIChjb21wYXJpc29uID09PSAwKSByZXR1cm4gW0ludGVnZXJbc2VsZi5zaWduID09PSBuLnNpZ24gPyAxIDogLTFdLCBJbnRlZ2VyWzBdXTtcclxuXHJcbiAgICAgICAgLy8gZGl2TW9kMSBpcyBmYXN0ZXIgb24gc21hbGxlciBpbnB1dCBzaXplc1xyXG4gICAgICAgIGlmIChhLmxlbmd0aCArIGIubGVuZ3RoIDw9IDIwMClcclxuICAgICAgICAgICAgdmFsdWUgPSBkaXZNb2QxKGEsIGIpO1xyXG4gICAgICAgIGVsc2UgdmFsdWUgPSBkaXZNb2QyKGEsIGIpO1xyXG5cclxuICAgICAgICBxdW90aWVudCA9IHZhbHVlWzBdO1xyXG4gICAgICAgIHZhciBxU2lnbiA9IHNlbGYuc2lnbiAhPT0gbi5zaWduLFxyXG4gICAgICAgICAgICBtb2QgPSB2YWx1ZVsxXSxcclxuICAgICAgICAgICAgbVNpZ24gPSBzZWxmLnNpZ247XHJcbiAgICAgICAgaWYgKHR5cGVvZiBxdW90aWVudCA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICBpZiAocVNpZ24pIHF1b3RpZW50ID0gLXF1b3RpZW50O1xyXG4gICAgICAgICAgICBxdW90aWVudCA9IG5ldyBTbWFsbEludGVnZXIocXVvdGllbnQpO1xyXG4gICAgICAgIH0gZWxzZSBxdW90aWVudCA9IG5ldyBCaWdJbnRlZ2VyKHF1b3RpZW50LCBxU2lnbik7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBtb2QgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgaWYgKG1TaWduKSBtb2QgPSAtbW9kO1xyXG4gICAgICAgICAgICBtb2QgPSBuZXcgU21hbGxJbnRlZ2VyKG1vZCk7XHJcbiAgICAgICAgfSBlbHNlIG1vZCA9IG5ldyBCaWdJbnRlZ2VyKG1vZCwgbVNpZ24pO1xyXG4gICAgICAgIHJldHVybiBbcXVvdGllbnQsIG1vZF07XHJcbiAgICB9XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZGl2bW9kID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gZGl2TW9kQW55KHRoaXMsIHYpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHF1b3RpZW50OiByZXN1bHRbMF0sXHJcbiAgICAgICAgICAgIHJlbWFpbmRlcjogcmVzdWx0WzFdXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLmRpdm1vZCA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmRpdm1vZDtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHJldHVybiBkaXZNb2RBbnkodGhpcywgdilbMF07XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5vdmVyID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5kaXZpZGUgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5vdmVyID0gQmlnSW50ZWdlci5wcm90b3R5cGUuZGl2aWRlO1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgcmV0dXJuIGRpdk1vZEFueSh0aGlzLCB2KVsxXTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLnJlbWFpbmRlciA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUubW9kID0gQmlnSW50ZWdlci5wcm90b3R5cGUucmVtYWluZGVyID0gQmlnSW50ZWdlci5wcm90b3R5cGUubW9kO1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgdmFyIG4gPSBwYXJzZVZhbHVlKHYpLFxyXG4gICAgICAgICAgICBhID0gdGhpcy52YWx1ZSxcclxuICAgICAgICAgICAgYiA9IG4udmFsdWUsXHJcbiAgICAgICAgICAgIHZhbHVlLCB4LCB5O1xyXG4gICAgICAgIGlmIChiID09PSAwKSByZXR1cm4gSW50ZWdlclsxXTtcclxuICAgICAgICBpZiAoYSA9PT0gMCkgcmV0dXJuIEludGVnZXJbMF07XHJcbiAgICAgICAgaWYgKGEgPT09IDEpIHJldHVybiBJbnRlZ2VyWzFdO1xyXG4gICAgICAgIGlmIChhID09PSAtMSkgcmV0dXJuIG4uaXNFdmVuKCkgPyBJbnRlZ2VyWzFdIDogSW50ZWdlclstMV07XHJcbiAgICAgICAgaWYgKG4uc2lnbikge1xyXG4gICAgICAgICAgICByZXR1cm4gSW50ZWdlclswXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFuLmlzU21hbGwpIHRocm93IG5ldyBFcnJvcihcIlRoZSBleHBvbmVudCBcIiArIG4udG9TdHJpbmcoKSArIFwiIGlzIHRvbyBsYXJnZS5cIik7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNTbWFsbCkge1xyXG4gICAgICAgICAgICBpZiAoaXNQcmVjaXNlKHZhbHVlID0gTWF0aC5wb3coYSwgYikpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTbWFsbEludGVnZXIodHJ1bmNhdGUodmFsdWUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgeCA9IHRoaXM7XHJcbiAgICAgICAgeSA9IEludGVnZXJbMV07XHJcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgaWYgKGIgJiAxID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICB5ID0geS50aW1lcyh4KTtcclxuICAgICAgICAgICAgICAgIC0tYjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYiA9PT0gMCkgYnJlYWs7XHJcbiAgICAgICAgICAgIGIgLz0gMjtcclxuICAgICAgICAgICAgeCA9IHguc3F1YXJlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB5O1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUucG93ID0gQmlnSW50ZWdlci5wcm90b3R5cGUucG93O1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZFBvdyA9IGZ1bmN0aW9uIChleHAsIG1vZCkge1xyXG4gICAgICAgIGV4cCA9IHBhcnNlVmFsdWUoZXhwKTtcclxuICAgICAgICBtb2QgPSBwYXJzZVZhbHVlKG1vZCk7XHJcbiAgICAgICAgaWYgKG1vZC5pc1plcm8oKSkgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHRha2UgbW9kUG93IHdpdGggbW9kdWx1cyAwXCIpO1xyXG4gICAgICAgIHZhciByID0gSW50ZWdlclsxXSxcclxuICAgICAgICAgICAgYmFzZSA9IHRoaXMubW9kKG1vZCk7XHJcbiAgICAgICAgd2hpbGUgKGV4cC5pc1Bvc2l0aXZlKCkpIHtcclxuICAgICAgICAgICAgaWYgKGJhc2UuaXNaZXJvKCkpIHJldHVybiBJbnRlZ2VyWzBdO1xyXG4gICAgICAgICAgICBpZiAoZXhwLmlzT2RkKCkpIHIgPSByLm11bHRpcGx5KGJhc2UpLm1vZChtb2QpO1xyXG4gICAgICAgICAgICBleHAgPSBleHAuZGl2aWRlKDIpO1xyXG4gICAgICAgICAgICBiYXNlID0gYmFzZS5zcXVhcmUoKS5tb2QobW9kKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHI7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5tb2RQb3cgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RQb3c7XHJcblxyXG4gICAgZnVuY3Rpb24gY29tcGFyZUFicyhhLCBiKSB7XHJcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYS5sZW5ndGggPiBiLmxlbmd0aCA/IDEgOiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBhW2ldID4gYltpXSA/IDEgOiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuY29tcGFyZUFicyA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgdmFyIG4gPSBwYXJzZVZhbHVlKHYpLFxyXG4gICAgICAgICAgICBhID0gdGhpcy52YWx1ZSxcclxuICAgICAgICAgICAgYiA9IG4udmFsdWU7XHJcbiAgICAgICAgaWYgKG4uaXNTbWFsbCkgcmV0dXJuIDE7XHJcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVBYnMoYSwgYik7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5jb21wYXJlQWJzID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICB2YXIgbiA9IHBhcnNlVmFsdWUodiksXHJcbiAgICAgICAgICAgIGEgPSBNYXRoLmFicyh0aGlzLnZhbHVlKSxcclxuICAgICAgICAgICAgYiA9IG4udmFsdWU7XHJcbiAgICAgICAgaWYgKG4uaXNTbWFsbCkge1xyXG4gICAgICAgICAgICBiID0gTWF0aC5hYnMoYik7XHJcbiAgICAgICAgICAgIHJldHVybiBhID09PSBiID8gMCA6IGEgPiBiID8gMSA6IC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9O1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIC8vIFNlZSBkaXNjdXNzaW9uIGFib3V0IGNvbXBhcmlzb24gd2l0aCBJbmZpbml0eTpcclxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcGV0ZXJvbHNvbi9CaWdJbnRlZ2VyLmpzL2lzc3Vlcy82MVxyXG4gICAgICAgIGlmICh2ID09PSBJbmZpbml0eSkge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2ID09PSAtSW5maW5pdHkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbiA9IHBhcnNlVmFsdWUodiksXHJcbiAgICAgICAgICAgIGEgPSB0aGlzLnZhbHVlLFxyXG4gICAgICAgICAgICBiID0gbi52YWx1ZTtcclxuICAgICAgICBpZiAodGhpcy5zaWduICE9PSBuLnNpZ24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG4uc2lnbiA/IDEgOiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG4uaXNTbWFsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaWduID8gLTEgOiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29tcGFyZUFicyhhLCBiKSAqICh0aGlzLnNpZ24gPyAtMSA6IDEpO1xyXG4gICAgfTtcclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmNvbXBhcmVUbyA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmNvbXBhcmU7XHJcblxyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICBpZiAodiA9PT0gSW5maW5pdHkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodiA9PT0gLUluZmluaXR5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG4gPSBwYXJzZVZhbHVlKHYpLFxyXG4gICAgICAgICAgICBhID0gdGhpcy52YWx1ZSxcclxuICAgICAgICAgICAgYiA9IG4udmFsdWU7XHJcbiAgICAgICAgaWYgKG4uaXNTbWFsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYSA9PSBiID8gMCA6IGEgPiBiID8gMSA6IC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYSA8IDAgIT09IG4uc2lnbikge1xyXG4gICAgICAgICAgICByZXR1cm4gYSA8IDAgPyAtMSA6IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhIDwgMCA/IDEgOiAtMTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLmNvbXBhcmVUbyA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuY29tcGFyZTtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUodikgPT09IDA7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5lcSA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuZXF1YWxzID0gQmlnSW50ZWdlci5wcm90b3R5cGUuZXEgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5lcXVhbHM7XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubm90RXF1YWxzID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlKHYpICE9PSAwO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUubmVxID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5ub3RFcXVhbHMgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5uZXEgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5ub3RFcXVhbHM7XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZ3JlYXRlciA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZSh2KSA+IDA7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5ndCA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuZ3JlYXRlciA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmd0ID0gQmlnSW50ZWdlci5wcm90b3R5cGUuZ3JlYXRlcjtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5sZXNzZXIgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUodikgPCAwO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUubHQgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmxlc3NlciA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmx0ID0gQmlnSW50ZWdlci5wcm90b3R5cGUubGVzc2VyO1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmdyZWF0ZXJPckVxdWFscyA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZSh2KSA+PSAwO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuZ2VxID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5ncmVhdGVyT3JFcXVhbHMgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5nZXEgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5ncmVhdGVyT3JFcXVhbHM7XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubGVzc2VyT3JFcXVhbHMgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUodikgPD0gMDtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLmxlcSA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUubGVzc2VyT3JFcXVhbHMgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5sZXEgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5sZXNzZXJPckVxdWFscztcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc0V2ZW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnZhbHVlWzBdICYgMSkgPT09IDA7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5pc0V2ZW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnZhbHVlICYgMSkgPT09IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy52YWx1ZVswXSAmIDEpID09PSAxO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnZhbHVlICYgMSkgPT09IDE7XHJcbiAgICB9O1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmlzUG9zaXRpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLnNpZ247XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5pc1Bvc2l0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlID4gMDtcclxuICAgIH07XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuaXNOZWdhdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zaWduO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNOZWdhdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA8IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmlzVW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5pc1VuaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHRoaXMudmFsdWUpID09PSAxO1xyXG4gICAgfTtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlID09PSAwO1xyXG4gICAgfTtcclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmlzRGl2aXNpYmxlQnkgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHZhciBuID0gcGFyc2VWYWx1ZSh2KTtcclxuICAgICAgICB2YXIgdmFsdWUgPSBuLnZhbHVlO1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gMCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gMSkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgaWYgKHZhbHVlID09PSAyKSByZXR1cm4gdGhpcy5pc0V2ZW4oKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5tb2QobikuZXF1YWxzKEludGVnZXJbMF0pO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNEaXZpc2libGVCeSA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmlzRGl2aXNpYmxlQnk7XHJcblxyXG4gICAgZnVuY3Rpb24gaXNCYXNpY1ByaW1lKHYpIHtcclxuICAgICAgICB2YXIgbiA9IHYuYWJzKCk7XHJcbiAgICAgICAgaWYgKG4uaXNVbml0KCkpIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpZiAobi5lcXVhbHMoMikgfHwgbi5lcXVhbHMoMykgfHwgbi5lcXVhbHMoNSkpIHJldHVybiB0cnVlO1xyXG4gICAgICAgIGlmIChuLmlzRXZlbigpIHx8IG4uaXNEaXZpc2libGVCeSgzKSB8fCBuLmlzRGl2aXNpYmxlQnkoNSkpIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpZiAobi5sZXNzZXIoMjUpKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAvLyB3ZSBkb24ndCBrbm93IGlmIGl0J3MgcHJpbWU6IGxldCB0aGUgb3RoZXIgZnVuY3Rpb25zIGZpZ3VyZSBpdCBvdXRcclxuICAgIH1cclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc1ByaW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBpc1ByaW1lID0gaXNCYXNpY1ByaW1lKHRoaXMpO1xyXG4gICAgICAgIGlmIChpc1ByaW1lICE9PSB1bmRlZmluZWQpIHJldHVybiBpc1ByaW1lO1xyXG4gICAgICAgIHZhciBuID0gdGhpcy5hYnMoKSxcclxuICAgICAgICAgICAgblByZXYgPSBuLnByZXYoKTtcclxuICAgICAgICB2YXIgYSA9IFsyLCAzLCA1LCA3LCAxMSwgMTMsIDE3LCAxOV0sXHJcbiAgICAgICAgICAgIGIgPSBuUHJldixcclxuICAgICAgICAgICAgZCwgdCwgaSwgeDtcclxuICAgICAgICB3aGlsZSAoYi5pc0V2ZW4oKSkgYiA9IGIuZGl2aWRlKDIpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHggPSBiaWdJbnQoYVtpXSkubW9kUG93KGIsIG4pO1xyXG4gICAgICAgICAgICBpZiAoeC5lcXVhbHMoSW50ZWdlclsxXSkgfHwgeC5lcXVhbHMoblByZXYpKSBjb250aW51ZTtcclxuICAgICAgICAgICAgZm9yICh0ID0gdHJ1ZSwgZCA9IGI7IHQgJiYgZC5sZXNzZXIoblByZXYpIDsgZCA9IGQubXVsdGlwbHkoMikpIHtcclxuICAgICAgICAgICAgICAgIHggPSB4LnNxdWFyZSgpLm1vZChuKTtcclxuICAgICAgICAgICAgICAgIGlmICh4LmVxdWFscyhuUHJldikpIHQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLmlzUHJpbWUgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc1ByaW1lO1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmlzUHJvYmFibGVQcmltZSA9IGZ1bmN0aW9uIChpdGVyYXRpb25zKSB7XHJcbiAgICAgICAgdmFyIGlzUHJpbWUgPSBpc0Jhc2ljUHJpbWUodGhpcyk7XHJcbiAgICAgICAgaWYgKGlzUHJpbWUgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGlzUHJpbWU7XHJcbiAgICAgICAgdmFyIG4gPSB0aGlzLmFicygpO1xyXG4gICAgICAgIHZhciB0ID0gaXRlcmF0aW9ucyA9PT0gdW5kZWZpbmVkID8gNSA6IGl0ZXJhdGlvbnM7XHJcbiAgICAgICAgLy8gdXNlIHRoZSBGZXJtYXQgcHJpbWFsaXR5IHRlc3RcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHQ7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgYSA9IGJpZ0ludC5yYW5kQmV0d2VlbigyLCBuLm1pbnVzKDIpKTtcclxuICAgICAgICAgICAgaWYgKCFhLm1vZFBvdyhuLnByZXYoKSwgbikuaXNVbml0KCkpIHJldHVybiBmYWxzZTsgLy8gZGVmaW5pdGVseSBjb21wb3NpdGVcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIGxhcmdlIGNoYW5jZSBvZiBiZWluZyBwcmltZVxyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNQcm9iYWJsZVByaW1lID0gQmlnSW50ZWdlci5wcm90b3R5cGUuaXNQcm9iYWJsZVByaW1lO1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZEludiA9IGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgdmFyIHQgPSBiaWdJbnQuemVybywgbmV3VCA9IGJpZ0ludC5vbmUsIHIgPSBwYXJzZVZhbHVlKG4pLCBuZXdSID0gdGhpcy5hYnMoKSwgcSwgbGFzdFQsIGxhc3RSO1xyXG4gICAgICAgIHdoaWxlICghbmV3Ui5lcXVhbHMoYmlnSW50Lnplcm8pKSB7XHJcbiAgICAgICAgICAgIHEgPSByLmRpdmlkZShuZXdSKTtcclxuICAgICAgICAgICAgbGFzdFQgPSB0O1xyXG4gICAgICAgICAgICBsYXN0UiA9IHI7XHJcbiAgICAgICAgICAgIHQgPSBuZXdUO1xyXG4gICAgICAgICAgICByID0gbmV3UjtcclxuICAgICAgICAgICAgbmV3VCA9IGxhc3RULnN1YnRyYWN0KHEubXVsdGlwbHkobmV3VCkpO1xyXG4gICAgICAgICAgICBuZXdSID0gbGFzdFIuc3VidHJhY3QocS5tdWx0aXBseShuZXdSKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghci5lcXVhbHMoMSkpIHRocm93IG5ldyBFcnJvcih0aGlzLnRvU3RyaW5nKCkgKyBcIiBhbmQgXCIgKyBuLnRvU3RyaW5nKCkgKyBcIiBhcmUgbm90IGNvLXByaW1lXCIpO1xyXG4gICAgICAgIGlmICh0LmNvbXBhcmUoMCkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHQgPSB0LmFkZChuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0Lm5lZ2F0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcblxyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5tb2RJbnYgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RJbnY7XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xyXG4gICAgICAgIGlmICh0aGlzLnNpZ24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN1YnRyYWN0U21hbGwodmFsdWUsIDEsIHRoaXMuc2lnbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihhZGRTbWFsbCh2YWx1ZSwgMSksIHRoaXMuc2lnbik7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XHJcbiAgICAgICAgaWYgKHZhbHVlICsgMSA8IE1BWF9JTlQpIHJldHVybiBuZXcgU21hbGxJbnRlZ2VyKHZhbHVlICsgMSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKE1BWF9JTlRfQVJSLCBmYWxzZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcclxuICAgICAgICBpZiAodGhpcy5zaWduKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihhZGRTbWFsbCh2YWx1ZSwgMSksIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3VidHJhY3RTbWFsbCh2YWx1ZSwgMSwgdGhpcy5zaWduKTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcclxuICAgICAgICBpZiAodmFsdWUgLSAxID4gLU1BWF9JTlQpIHJldHVybiBuZXcgU21hbGxJbnRlZ2VyKHZhbHVlIC0gMSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKE1BWF9JTlRfQVJSLCB0cnVlKTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIHBvd2Vyc09mVHdvID0gWzFdO1xyXG4gICAgd2hpbGUgKDIgKiBwb3dlcnNPZlR3b1twb3dlcnNPZlR3by5sZW5ndGggLSAxXSA8PSBCQVNFKSBwb3dlcnNPZlR3by5wdXNoKDIgKiBwb3dlcnNPZlR3b1twb3dlcnNPZlR3by5sZW5ndGggLSAxXSk7XHJcbiAgICB2YXIgcG93ZXJzMkxlbmd0aCA9IHBvd2Vyc09mVHdvLmxlbmd0aCwgaGlnaGVzdFBvd2VyMiA9IHBvd2Vyc09mVHdvW3Bvd2VyczJMZW5ndGggLSAxXTtcclxuXHJcbiAgICBmdW5jdGlvbiBzaGlmdF9pc1NtYWxsKG4pIHtcclxuICAgICAgICByZXR1cm4gKCh0eXBlb2YgbiA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgbiA9PT0gXCJzdHJpbmdcIikgJiYgK01hdGguYWJzKG4pIDw9IEJBU0UpIHx8XHJcbiAgICAgICAgICAgIChuIGluc3RhbmNlb2YgQmlnSW50ZWdlciAmJiBuLnZhbHVlLmxlbmd0aCA8PSAxKTtcclxuICAgIH1cclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdExlZnQgPSBmdW5jdGlvbiAobikge1xyXG4gICAgICAgIGlmICghc2hpZnRfaXNTbWFsbChuKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoU3RyaW5nKG4pICsgXCIgaXMgdG9vIGxhcmdlIGZvciBzaGlmdGluZy5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG4gPSArbjtcclxuICAgICAgICBpZiAobiA8IDApIHJldHVybiB0aGlzLnNoaWZ0UmlnaHQoLW4pO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzO1xyXG4gICAgICAgIHdoaWxlIChuID49IHBvd2VyczJMZW5ndGgpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bHRpcGx5KGhpZ2hlc3RQb3dlcjIpO1xyXG4gICAgICAgICAgICBuIC09IHBvd2VyczJMZW5ndGggLSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0Lm11bHRpcGx5KHBvd2Vyc09mVHdvW25dKTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLnNoaWZ0TGVmdCA9IEJpZ0ludGVnZXIucHJvdG90eXBlLnNoaWZ0TGVmdDtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdFJpZ2h0ID0gZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICB2YXIgcmVtUXVvO1xyXG4gICAgICAgIGlmICghc2hpZnRfaXNTbWFsbChuKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoU3RyaW5nKG4pICsgXCIgaXMgdG9vIGxhcmdlIGZvciBzaGlmdGluZy5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG4gPSArbjtcclxuICAgICAgICBpZiAobiA8IDApIHJldHVybiB0aGlzLnNoaWZ0TGVmdCgtbik7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXM7XHJcbiAgICAgICAgd2hpbGUgKG4gPj0gcG93ZXJzMkxlbmd0aCkge1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0LmlzWmVybygpKSByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICByZW1RdW8gPSBkaXZNb2RBbnkocmVzdWx0LCBoaWdoZXN0UG93ZXIyKTtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVtUXVvWzFdLmlzTmVnYXRpdmUoKSA/IHJlbVF1b1swXS5wcmV2KCkgOiByZW1RdW9bMF07XHJcbiAgICAgICAgICAgIG4gLT0gcG93ZXJzMkxlbmd0aCAtIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbVF1byA9IGRpdk1vZEFueShyZXN1bHQsIHBvd2Vyc09mVHdvW25dKTtcclxuICAgICAgICByZXR1cm4gcmVtUXVvWzFdLmlzTmVnYXRpdmUoKSA/IHJlbVF1b1swXS5wcmV2KCkgOiByZW1RdW9bMF07XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdFJpZ2h0ID0gQmlnSW50ZWdlci5wcm90b3R5cGUuc2hpZnRSaWdodDtcclxuXHJcbiAgICBmdW5jdGlvbiBiaXR3aXNlKHgsIHksIGZuKSB7XHJcbiAgICAgICAgeSA9IHBhcnNlVmFsdWUoeSk7XHJcbiAgICAgICAgdmFyIHhTaWduID0geC5pc05lZ2F0aXZlKCksIHlTaWduID0geS5pc05lZ2F0aXZlKCk7XHJcbiAgICAgICAgdmFyIHhSZW0gPSB4U2lnbiA/IHgubm90KCkgOiB4LFxyXG4gICAgICAgICAgICB5UmVtID0geVNpZ24gPyB5Lm5vdCgpIDogeTtcclxuICAgICAgICB2YXIgeERpZ2l0ID0gMCwgeURpZ2l0ID0gMDtcclxuICAgICAgICB2YXIgeERpdk1vZCA9IG51bGwsIHlEaXZNb2QgPSBudWxsO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgICAgICB3aGlsZSAoIXhSZW0uaXNaZXJvKCkgfHwgIXlSZW0uaXNaZXJvKCkpIHtcclxuICAgICAgICAgICAgeERpdk1vZCA9IGRpdk1vZEFueSh4UmVtLCBoaWdoZXN0UG93ZXIyKTtcclxuICAgICAgICAgICAgeERpZ2l0ID0geERpdk1vZFsxXS50b0pTTnVtYmVyKCk7XHJcbiAgICAgICAgICAgIGlmICh4U2lnbikge1xyXG4gICAgICAgICAgICAgICAgeERpZ2l0ID0gaGlnaGVzdFBvd2VyMiAtIDEgLSB4RGlnaXQ7IC8vIHR3bydzIGNvbXBsZW1lbnQgZm9yIG5lZ2F0aXZlIG51bWJlcnNcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgeURpdk1vZCA9IGRpdk1vZEFueSh5UmVtLCBoaWdoZXN0UG93ZXIyKTtcclxuICAgICAgICAgICAgeURpZ2l0ID0geURpdk1vZFsxXS50b0pTTnVtYmVyKCk7XHJcbiAgICAgICAgICAgIGlmICh5U2lnbikge1xyXG4gICAgICAgICAgICAgICAgeURpZ2l0ID0gaGlnaGVzdFBvd2VyMiAtIDEgLSB5RGlnaXQ7IC8vIHR3bydzIGNvbXBsZW1lbnQgZm9yIG5lZ2F0aXZlIG51bWJlcnNcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgeFJlbSA9IHhEaXZNb2RbMF07XHJcbiAgICAgICAgICAgIHlSZW0gPSB5RGl2TW9kWzBdO1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChmbih4RGlnaXQsIHlEaWdpdCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3VtID0gZm4oeFNpZ24gPyAxIDogMCwgeVNpZ24gPyAxIDogMCkgIT09IDAgPyBiaWdJbnQoLTEpIDogYmlnSW50KDApO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSByZXN1bHQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcclxuICAgICAgICAgICAgc3VtID0gc3VtLm11bHRpcGx5KGhpZ2hlc3RQb3dlcjIpLmFkZChiaWdJbnQocmVzdWx0W2ldKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdW07XHJcbiAgICB9XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubm90ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5lZ2F0ZSgpLnByZXYoKTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLm5vdCA9IEJpZ0ludGVnZXIucHJvdG90eXBlLm5vdDtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiAobikge1xyXG4gICAgICAgIHJldHVybiBiaXR3aXNlKHRoaXMsIG4sIGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhICYgYjsgfSk7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5hbmQgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hbmQ7XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiAobikge1xyXG4gICAgICAgIHJldHVybiBiaXR3aXNlKHRoaXMsIG4sIGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhIHwgYjsgfSk7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5vciA9IEJpZ0ludGVnZXIucHJvdG90eXBlLm9yO1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgcmV0dXJuIGJpdHdpc2UodGhpcywgbiwgZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgXiBiOyB9KTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLnhvciA9IEJpZ0ludGVnZXIucHJvdG90eXBlLnhvcjtcclxuXHJcbiAgICB2YXIgTE9CTUFTS19JID0gMSA8PCAzMCwgTE9CTUFTS19CSSA9IChCQVNFICYgLUJBU0UpICogKEJBU0UgJiAtQkFTRSkgfCBMT0JNQVNLX0k7XHJcbiAgICBmdW5jdGlvbiByb3VnaExPQihuKSB7IC8vIGdldCBsb3dlc3RPbmVCaXQgKHJvdWdoKVxyXG4gICAgICAgIC8vIFNtYWxsSW50ZWdlcjogcmV0dXJuIE1pbihsb3dlc3RPbmVCaXQobiksIDEgPDwgMzApXHJcbiAgICAgICAgLy8gQmlnSW50ZWdlcjogcmV0dXJuIE1pbihsb3dlc3RPbmVCaXQobiksIDEgPDwgMTQpIFtCQVNFPTFlN11cclxuICAgICAgICB2YXIgdiA9IG4udmFsdWUsIHggPSB0eXBlb2YgdiA9PT0gXCJudW1iZXJcIiA/IHYgfCBMT0JNQVNLX0kgOiB2WzBdICsgdlsxXSAqIEJBU0UgfCBMT0JNQVNLX0JJO1xyXG4gICAgICAgIHJldHVybiB4ICYgLXg7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbWF4KGEsIGIpIHtcclxuICAgICAgICBhID0gcGFyc2VWYWx1ZShhKTtcclxuICAgICAgICBiID0gcGFyc2VWYWx1ZShiKTtcclxuICAgICAgICByZXR1cm4gYS5ncmVhdGVyKGIpID8gYSA6IGI7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBtaW4oYSwgYikge1xyXG4gICAgICAgIGEgPSBwYXJzZVZhbHVlKGEpO1xyXG4gICAgICAgIGIgPSBwYXJzZVZhbHVlKGIpO1xyXG4gICAgICAgIHJldHVybiBhLmxlc3NlcihiKSA/IGEgOiBiO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2NkKGEsIGIpIHtcclxuICAgICAgICBhID0gcGFyc2VWYWx1ZShhKS5hYnMoKTtcclxuICAgICAgICBiID0gcGFyc2VWYWx1ZShiKS5hYnMoKTtcclxuICAgICAgICBpZiAoYS5lcXVhbHMoYikpIHJldHVybiBhO1xyXG4gICAgICAgIGlmIChhLmlzWmVybygpKSByZXR1cm4gYjtcclxuICAgICAgICBpZiAoYi5pc1plcm8oKSkgcmV0dXJuIGE7XHJcbiAgICAgICAgdmFyIGMgPSBJbnRlZ2VyWzFdLCBkLCB0O1xyXG4gICAgICAgIHdoaWxlIChhLmlzRXZlbigpICYmIGIuaXNFdmVuKCkpIHtcclxuICAgICAgICAgICAgZCA9IE1hdGgubWluKHJvdWdoTE9CKGEpLCByb3VnaExPQihiKSk7XHJcbiAgICAgICAgICAgIGEgPSBhLmRpdmlkZShkKTtcclxuICAgICAgICAgICAgYiA9IGIuZGl2aWRlKGQpO1xyXG4gICAgICAgICAgICBjID0gYy5tdWx0aXBseShkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKGEuaXNFdmVuKCkpIHtcclxuICAgICAgICAgICAgYSA9IGEuZGl2aWRlKHJvdWdoTE9CKGEpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICB3aGlsZSAoYi5pc0V2ZW4oKSkge1xyXG4gICAgICAgICAgICAgICAgYiA9IGIuZGl2aWRlKHJvdWdoTE9CKGIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYS5ncmVhdGVyKGIpKSB7XHJcbiAgICAgICAgICAgICAgICB0ID0gYjsgYiA9IGE7IGEgPSB0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGIgPSBiLnN1YnRyYWN0KGEpO1xyXG4gICAgICAgIH0gd2hpbGUgKCFiLmlzWmVybygpKTtcclxuICAgICAgICByZXR1cm4gYy5pc1VuaXQoKSA/IGEgOiBhLm11bHRpcGx5KGMpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gbGNtKGEsIGIpIHtcclxuICAgICAgICBhID0gcGFyc2VWYWx1ZShhKS5hYnMoKTtcclxuICAgICAgICBiID0gcGFyc2VWYWx1ZShiKS5hYnMoKTtcclxuICAgICAgICByZXR1cm4gYS5kaXZpZGUoZ2NkKGEsIGIpKS5tdWx0aXBseShiKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJhbmRCZXR3ZWVuKGEsIGIpIHtcclxuICAgICAgICBhID0gcGFyc2VWYWx1ZShhKTtcclxuICAgICAgICBiID0gcGFyc2VWYWx1ZShiKTtcclxuICAgICAgICB2YXIgbG93ID0gbWluKGEsIGIpLCBoaWdoID0gbWF4KGEsIGIpO1xyXG4gICAgICAgIHZhciByYW5nZSA9IGhpZ2guc3VidHJhY3QobG93KS5hZGQoMSk7XHJcbiAgICAgICAgaWYgKHJhbmdlLmlzU21hbGwpIHJldHVybiBsb3cuYWRkKE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHJhbmdlKSk7XHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IHJhbmdlLnZhbHVlLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdLCByZXN0cmljdGVkID0gdHJ1ZTtcclxuICAgICAgICBmb3IgKHZhciBpID0gbGVuZ3RoOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICB2YXIgdG9wID0gcmVzdHJpY3RlZCA/IHJhbmdlLnZhbHVlW2ldIDogQkFTRTtcclxuICAgICAgICAgICAgdmFyIGRpZ2l0ID0gdHJ1bmNhdGUoTWF0aC5yYW5kb20oKSAqIHRvcCk7XHJcbiAgICAgICAgICAgIHJlc3VsdC51bnNoaWZ0KGRpZ2l0KTtcclxuICAgICAgICAgICAgaWYgKGRpZ2l0IDwgdG9wKSByZXN0cmljdGVkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdCA9IGFycmF5VG9TbWFsbChyZXN1bHQpO1xyXG4gICAgICAgIHJldHVybiBsb3cuYWRkKHR5cGVvZiByZXN1bHQgPT09IFwibnVtYmVyXCIgPyBuZXcgU21hbGxJbnRlZ2VyKHJlc3VsdCkgOiBuZXcgQmlnSW50ZWdlcihyZXN1bHQsIGZhbHNlKSk7XHJcbiAgICB9XHJcbiAgICB2YXIgcGFyc2VCYXNlID0gZnVuY3Rpb24gKHRleHQsIGJhc2UpIHtcclxuICAgICAgICB2YXIgbGVuZ3RoID0gdGV4dC5sZW5ndGg7XHJcblx0XHR2YXIgaTtcclxuXHRcdHZhciBhYnNCYXNlID0gTWF0aC5hYnMoYmFzZSk7XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGMgPSB0ZXh0W2ldLnRvTG93ZXJDYXNlKCk7XHJcblx0XHRcdGlmKGMgPT09IFwiLVwiKSBjb250aW51ZTtcclxuXHRcdFx0aWYoL1thLXowLTldLy50ZXN0KGMpKSB7XHJcblx0XHRcdCAgICBpZigvWzAtOV0vLnRlc3QoYykgJiYgK2MgPj0gYWJzQmFzZSkge1xyXG5cdFx0XHRcdFx0aWYoYyA9PT0gXCIxXCIgJiYgYWJzQmFzZSA9PT0gMSkgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGMgKyBcIiBpcyBub3QgYSB2YWxpZCBkaWdpdCBpbiBiYXNlIFwiICsgYmFzZSArIFwiLlwiKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYoYy5jaGFyQ29kZUF0KDApIC0gODcgPj0gYWJzQmFzZSkge1xyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGMgKyBcIiBpcyBub3QgYSB2YWxpZCBkaWdpdCBpbiBiYXNlIFwiICsgYmFzZSArIFwiLlwiKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuICAgICAgICBpZiAoMiA8PSBiYXNlICYmIGJhc2UgPD0gMzYpIHtcclxuICAgICAgICAgICAgaWYgKGxlbmd0aCA8PSBMT0dfTUFYX0lOVCAvIE1hdGgubG9nKGJhc2UpKSB7XHJcblx0XHRcdFx0dmFyIHJlc3VsdCA9IHBhcnNlSW50KHRleHQsIGJhc2UpO1xyXG5cdFx0XHRcdGlmKGlzTmFOKHJlc3VsdCkpIHtcclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihjICsgXCIgaXMgbm90IGEgdmFsaWQgZGlnaXQgaW4gYmFzZSBcIiArIGJhc2UgKyBcIi5cIik7XHJcblx0XHRcdFx0fVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTbWFsbEludGVnZXIocGFyc2VJbnQodGV4dCwgYmFzZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJhc2UgPSBwYXJzZVZhbHVlKGJhc2UpO1xyXG4gICAgICAgIHZhciBkaWdpdHMgPSBbXTtcclxuICAgICAgICB2YXIgaXNOZWdhdGl2ZSA9IHRleHRbMF0gPT09IFwiLVwiO1xyXG4gICAgICAgIGZvciAoaSA9IGlzTmVnYXRpdmUgPyAxIDogMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGMgPSB0ZXh0W2ldLnRvTG93ZXJDYXNlKCksXHJcbiAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IGMuY2hhckNvZGVBdCgwKTtcclxuICAgICAgICAgICAgaWYgKDQ4IDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IDU3KSBkaWdpdHMucHVzaChwYXJzZVZhbHVlKGMpKTtcclxuICAgICAgICAgICAgZWxzZSBpZiAoOTcgPD0gY2hhckNvZGUgJiYgY2hhckNvZGUgPD0gMTIyKSBkaWdpdHMucHVzaChwYXJzZVZhbHVlKGMuY2hhckNvZGVBdCgwKSAtIDg3KSk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09IFwiPFwiKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBpO1xyXG4gICAgICAgICAgICAgICAgZG8geyBpKys7IH0gd2hpbGUgKHRleHRbaV0gIT09IFwiPlwiKTtcclxuICAgICAgICAgICAgICAgIGRpZ2l0cy5wdXNoKHBhcnNlVmFsdWUodGV4dC5zbGljZShzdGFydCArIDEsIGkpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoYyArIFwiIGlzIG5vdCBhIHZhbGlkIGNoYXJhY3RlclwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlQmFzZUZyb21BcnJheShkaWdpdHMsIGJhc2UsIGlzTmVnYXRpdmUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBwYXJzZUJhc2VGcm9tQXJyYXkoZGlnaXRzLCBiYXNlLCBpc05lZ2F0aXZlKSB7XHJcbiAgICAgICAgdmFyIHZhbCA9IEludGVnZXJbMF0sIHBvdyA9IEludGVnZXJbMV0sIGk7XHJcbiAgICAgICAgZm9yIChpID0gZGlnaXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIHZhbCA9IHZhbC5hZGQoZGlnaXRzW2ldLnRpbWVzKHBvdykpO1xyXG4gICAgICAgICAgICBwb3cgPSBwb3cudGltZXMoYmFzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpc05lZ2F0aXZlID8gdmFsLm5lZ2F0ZSgpIDogdmFsO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHN0cmluZ2lmeShkaWdpdCkge1xyXG4gICAgICAgIGlmIChkaWdpdCA8PSAzNSkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIi5jaGFyQXQoZGlnaXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gXCI8XCIgKyBkaWdpdCArIFwiPlwiO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRvQmFzZShuLCBiYXNlKSB7XHJcbiAgICAgICAgYmFzZSA9IGJpZ0ludChiYXNlKTtcclxuICAgICAgICBpZiAoYmFzZS5pc1plcm8oKSkge1xyXG4gICAgICAgICAgICBpZiAobi5pc1plcm8oKSkgcmV0dXJuIHt2YWx1ZTogWzBdLCBpc05lZ2F0aXZlOiBmYWxzZX07XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb252ZXJ0IG5vbnplcm8gbnVtYmVycyB0byBiYXNlIDAuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYmFzZS5lcXVhbHMoLTEpKSB7XHJcbiAgICAgICAgICAgIGlmIChuLmlzWmVybygpKSByZXR1cm4ge3ZhbHVlOiBbMF0sIGlzTmVnYXRpdmU6IGZhbHNlfTtcclxuICAgICAgICAgICAgaWYgKG4uaXNOZWdhdGl2ZSgpKVxyXG4gICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogW10uY29uY2F0LmFwcGx5KFtdLCBBcnJheS5hcHBseShudWxsLCBBcnJheSgtbikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKEFycmF5LnByb3RvdHlwZS52YWx1ZU9mLCBbMSwgMF0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgICAgIGlzTmVnYXRpdmU6IGZhbHNlXHJcbiAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHZhciBhcnIgPSBBcnJheS5hcHBseShudWxsLCBBcnJheSgrbiAtIDEpKVxyXG4gICAgICAgICAgICAgIC5tYXAoQXJyYXkucHJvdG90eXBlLnZhbHVlT2YsIFswLCAxXSk7XHJcbiAgICAgICAgICAgIGFyci51bnNoaWZ0KFsxXSk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgdmFsdWU6IFtdLmNvbmNhdC5hcHBseShbXSwgYXJyKSxcclxuICAgICAgICAgICAgICBpc05lZ2F0aXZlOiBmYWxzZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG5lZyA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChuLmlzTmVnYXRpdmUoKSAmJiBiYXNlLmlzUG9zaXRpdmUoKSkge1xyXG4gICAgICAgICAgICBuZWcgPSB0cnVlO1xyXG4gICAgICAgICAgICBuID0gbi5hYnMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJhc2UuZXF1YWxzKDEpKSB7XHJcbiAgICAgICAgICAgIGlmIChuLmlzWmVybygpKSByZXR1cm4ge3ZhbHVlOiBbMF0sIGlzTmVnYXRpdmU6IGZhbHNlfTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgdmFsdWU6IEFycmF5LmFwcGx5KG51bGwsIEFycmF5KCtuKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAubWFwKE51bWJlci5wcm90b3R5cGUudmFsdWVPZiwgMSksXHJcbiAgICAgICAgICAgICAgaXNOZWdhdGl2ZTogbmVnXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvdXQgPSBbXTtcclxuICAgICAgICB2YXIgbGVmdCA9IG4sIGRpdm1vZDtcclxuICAgICAgICB3aGlsZSAobGVmdC5pc05lZ2F0aXZlKCkgfHwgbGVmdC5jb21wYXJlQWJzKGJhc2UpID49IDApIHtcclxuICAgICAgICAgICAgZGl2bW9kID0gbGVmdC5kaXZtb2QoYmFzZSk7XHJcbiAgICAgICAgICAgIGxlZnQgPSBkaXZtb2QucXVvdGllbnQ7XHJcbiAgICAgICAgICAgIHZhciBkaWdpdCA9IGRpdm1vZC5yZW1haW5kZXI7XHJcbiAgICAgICAgICAgIGlmIChkaWdpdC5pc05lZ2F0aXZlKCkpIHtcclxuICAgICAgICAgICAgICAgIGRpZ2l0ID0gYmFzZS5taW51cyhkaWdpdCkuYWJzKCk7XHJcbiAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5uZXh0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3V0LnB1c2goZGlnaXQudG9KU051bWJlcigpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgb3V0LnB1c2gobGVmdC50b0pTTnVtYmVyKCkpO1xyXG4gICAgICAgIHJldHVybiB7dmFsdWU6IG91dC5yZXZlcnNlKCksIGlzTmVnYXRpdmU6IG5lZ307XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdG9CYXNlU3RyaW5nKG4sIGJhc2UpIHtcclxuICAgICAgICB2YXIgYXJyID0gdG9CYXNlKG4sIGJhc2UpO1xyXG4gICAgICAgIHJldHVybiAoYXJyLmlzTmVnYXRpdmUgPyBcIi1cIiA6IFwiXCIpICsgYXJyLnZhbHVlLm1hcChzdHJpbmdpZnkpLmpvaW4oJycpO1xyXG4gICAgfVxyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAocmFkaXgpIHtcclxuICAgICAgcmV0dXJuIHRvQmFzZSh0aGlzLCByYWRpeCk7XHJcbiAgICB9O1xyXG5cclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIChyYWRpeCkge1xyXG4gICAgICByZXR1cm4gdG9CYXNlKHRoaXMsIHJhZGl4KTtcclxuICAgIH07XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAocmFkaXgpIHtcclxuICAgICAgICBpZiAocmFkaXggPT09IHVuZGVmaW5lZCkgcmFkaXggPSAxMDtcclxuICAgICAgICBpZiAocmFkaXggIT09IDEwKSByZXR1cm4gdG9CYXNlU3RyaW5nKHRoaXMsIHJhZGl4KTtcclxuICAgICAgICB2YXIgdiA9IHRoaXMudmFsdWUsIGwgPSB2Lmxlbmd0aCwgc3RyID0gU3RyaW5nKHZbLS1sXSksIHplcm9zID0gXCIwMDAwMDAwXCIsIGRpZ2l0O1xyXG4gICAgICAgIHdoaWxlICgtLWwgPj0gMCkge1xyXG4gICAgICAgICAgICBkaWdpdCA9IFN0cmluZyh2W2xdKTtcclxuICAgICAgICAgICAgc3RyICs9IHplcm9zLnNsaWNlKGRpZ2l0Lmxlbmd0aCkgKyBkaWdpdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNpZ24gPSB0aGlzLnNpZ24gPyBcIi1cIiA6IFwiXCI7XHJcbiAgICAgICAgcmV0dXJuIHNpZ24gKyBzdHI7XHJcbiAgICB9O1xyXG5cclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAocmFkaXgpIHtcclxuICAgICAgICBpZiAocmFkaXggPT09IHVuZGVmaW5lZCkgcmFkaXggPSAxMDtcclxuICAgICAgICBpZiAocmFkaXggIT0gMTApIHJldHVybiB0b0Jhc2VTdHJpbmcodGhpcywgcmFkaXgpO1xyXG4gICAgICAgIHJldHVybiBTdHJpbmcodGhpcy52YWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUudG9KU09OID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTsgfVxyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnZhbHVlT2YgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHRoaXMudG9TdHJpbmcoKSwgMTApO1xyXG4gICAgfTtcclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnRvSlNOdW1iZXIgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS52YWx1ZU9mO1xyXG5cclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUudmFsdWVPZiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLnRvSlNOdW1iZXIgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLnZhbHVlT2Y7XHJcblxyXG4gICAgZnVuY3Rpb24gcGFyc2VTdHJpbmdWYWx1ZSh2KSB7XHJcbiAgICAgICAgICAgIGlmIChpc1ByZWNpc2UoK3YpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgeCA9ICt2O1xyXG4gICAgICAgICAgICAgICAgaWYgKHggPT09IHRydW5jYXRlKHgpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU21hbGxJbnRlZ2VyKHgpO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIGludGVnZXI6IFwiICsgdjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgc2lnbiA9IHZbMF0gPT09IFwiLVwiO1xyXG4gICAgICAgICAgICBpZiAoc2lnbikgdiA9IHYuc2xpY2UoMSk7XHJcbiAgICAgICAgICAgIHZhciBzcGxpdCA9IHYuc3BsaXQoL2UvaSk7XHJcbiAgICAgICAgICAgIGlmIChzcGxpdC5sZW5ndGggPiAyKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGludGVnZXI6IFwiICsgc3BsaXQuam9pbihcImVcIikpO1xyXG4gICAgICAgICAgICBpZiAoc3BsaXQubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXhwID0gc3BsaXRbMV07XHJcbiAgICAgICAgICAgICAgICBpZiAoZXhwWzBdID09PSBcIitcIikgZXhwID0gZXhwLnNsaWNlKDEpO1xyXG4gICAgICAgICAgICAgICAgZXhwID0gK2V4cDtcclxuICAgICAgICAgICAgICAgIGlmIChleHAgIT09IHRydW5jYXRlKGV4cCkgfHwgIWlzUHJlY2lzZShleHApKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGludGVnZXI6IFwiICsgZXhwICsgXCIgaXMgbm90IGEgdmFsaWQgZXhwb25lbnQuXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSBzcGxpdFswXTtcclxuICAgICAgICAgICAgICAgIHZhciBkZWNpbWFsUGxhY2UgPSB0ZXh0LmluZGV4T2YoXCIuXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlY2ltYWxQbGFjZSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwIC09IHRleHQubGVuZ3RoIC0gZGVjaW1hbFBsYWNlIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZSgwLCBkZWNpbWFsUGxhY2UpICsgdGV4dC5zbGljZShkZWNpbWFsUGxhY2UgKyAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChleHAgPCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgaW5jbHVkZSBuZWdhdGl2ZSBleHBvbmVudCBwYXJ0IGZvciBpbnRlZ2Vyc1wiKTtcclxuICAgICAgICAgICAgICAgIHRleHQgKz0gKG5ldyBBcnJheShleHAgKyAxKSkuam9pbihcIjBcIik7XHJcbiAgICAgICAgICAgICAgICB2ID0gdGV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaXNWYWxpZCA9IC9eKFswLTldWzAtOV0qKSQvLnRlc3Qodik7XHJcbiAgICAgICAgICAgIGlmICghaXNWYWxpZCkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnRlZ2VyOiBcIiArIHYpO1xyXG4gICAgICAgICAgICB2YXIgciA9IFtdLCBtYXggPSB2Lmxlbmd0aCwgbCA9IExPR19CQVNFLCBtaW4gPSBtYXggLSBsO1xyXG4gICAgICAgICAgICB3aGlsZSAobWF4ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgci5wdXNoKCt2LnNsaWNlKG1pbiwgbWF4KSk7XHJcbiAgICAgICAgICAgICAgICBtaW4gLT0gbDtcclxuICAgICAgICAgICAgICAgIGlmIChtaW4gPCAwKSBtaW4gPSAwO1xyXG4gICAgICAgICAgICAgICAgbWF4IC09IGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHJpbShyKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKHIsIHNpZ24pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHBhcnNlTnVtYmVyVmFsdWUodikge1xyXG4gICAgICAgIGlmIChpc1ByZWNpc2UodikpIHtcclxuICAgICAgICAgICAgaWYgKHYgIT09IHRydW5jYXRlKHYpKSB0aHJvdyBuZXcgRXJyb3IodiArIFwiIGlzIG5vdCBhbiBpbnRlZ2VyLlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTbWFsbEludGVnZXIodik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXJzZVN0cmluZ1ZhbHVlKHYudG9TdHJpbmcoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcGFyc2VWYWx1ZSh2KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZU51bWJlclZhbHVlKHYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHYgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlU3RyaW5nVmFsdWUodik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2O1xyXG4gICAgfVxyXG4gICAgLy8gUHJlLWRlZmluZSBudW1iZXJzIGluIHJhbmdlIFstOTk5LDk5OV1cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTAwMDsgaSsrKSB7XHJcbiAgICAgICAgSW50ZWdlcltpXSA9IG5ldyBTbWFsbEludGVnZXIoaSk7XHJcbiAgICAgICAgaWYgKGkgPiAwKSBJbnRlZ2VyWy1pXSA9IG5ldyBTbWFsbEludGVnZXIoLWkpO1xyXG4gICAgfVxyXG4gICAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcclxuICAgIEludGVnZXIub25lID0gSW50ZWdlclsxXTtcclxuICAgIEludGVnZXIuemVybyA9IEludGVnZXJbMF07XHJcbiAgICBJbnRlZ2VyLm1pbnVzT25lID0gSW50ZWdlclstMV07XHJcbiAgICBJbnRlZ2VyLm1heCA9IG1heDtcclxuICAgIEludGVnZXIubWluID0gbWluO1xyXG4gICAgSW50ZWdlci5nY2QgPSBnY2Q7XHJcbiAgICBJbnRlZ2VyLmxjbSA9IGxjbTtcclxuICAgIEludGVnZXIuaXNJbnN0YW5jZSA9IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4IGluc3RhbmNlb2YgQmlnSW50ZWdlciB8fCB4IGluc3RhbmNlb2YgU21hbGxJbnRlZ2VyOyB9O1xyXG4gICAgSW50ZWdlci5yYW5kQmV0d2VlbiA9IHJhbmRCZXR3ZWVuO1xyXG5cclxuICAgIEludGVnZXIuZnJvbUFycmF5ID0gZnVuY3Rpb24gKGRpZ2l0cywgYmFzZSwgaXNOZWdhdGl2ZSkge1xyXG4gICAgICAgIHJldHVybiBwYXJzZUJhc2VGcm9tQXJyYXkoZGlnaXRzLm1hcChwYXJzZVZhbHVlKSwgcGFyc2VWYWx1ZShiYXNlIHx8IDEwKSwgaXNOZWdhdGl2ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBJbnRlZ2VyO1xyXG59KSgpO1xyXG5cclxuLy8gTm9kZS5qcyBjaGVja1xyXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUuaGFzT3duUHJvcGVydHkoXCJleHBvcnRzXCIpKSB7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGJpZ0ludDtcclxufVxyXG5cclxuLy9hbWQgY2hlY2tcclxuaWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcclxuICBkZWZpbmUoIFwiYmlnLWludGVnZXJcIiwgW10sIGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIGJpZ0ludDtcclxuICB9KTtcclxufVxyXG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbi8vIFRoaXMgbWV0aG9kIG9mIG9idGFpbmluZyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdCBuZWVkcyB0byBiZVxuLy8ga2VwdCBpZGVudGljYWwgdG8gdGhlIHdheSBpdCBpcyBvYnRhaW5lZCBpbiBydW50aW1lLmpzXG52YXIgZyA9IChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMgfSkoKSB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG5cbi8vIFVzZSBgZ2V0T3duUHJvcGVydHlOYW1lc2AgYmVjYXVzZSBub3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgY2FsbGluZ1xuLy8gYGhhc093blByb3BlcnR5YCBvbiB0aGUgZ2xvYmFsIGBzZWxmYCBvYmplY3QgaW4gYSB3b3JrZXIuIFNlZSAjMTgzLlxudmFyIGhhZFJ1bnRpbWUgPSBnLnJlZ2VuZXJhdG9yUnVudGltZSAmJlxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhnKS5pbmRleE9mKFwicmVnZW5lcmF0b3JSdW50aW1lXCIpID49IDA7XG5cbi8vIFNhdmUgdGhlIG9sZCByZWdlbmVyYXRvclJ1bnRpbWUgaW4gY2FzZSBpdCBuZWVkcyB0byBiZSByZXN0b3JlZCBsYXRlci5cbnZhciBvbGRSdW50aW1lID0gaGFkUnVudGltZSAmJiBnLnJlZ2VuZXJhdG9yUnVudGltZTtcblxuLy8gRm9yY2UgcmVldmFsdXRhdGlvbiBvZiBydW50aW1lLmpzLlxuZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSB1bmRlZmluZWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vcnVudGltZVwiKTtcblxuaWYgKGhhZFJ1bnRpbWUpIHtcbiAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgcnVudGltZS5cbiAgZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSBvbGRSdW50aW1lO1xufSBlbHNlIHtcbiAgLy8gUmVtb3ZlIHRoZSBnbG9iYWwgcHJvcGVydHkgYWRkZWQgYnkgcnVudGltZS5qcy5cbiAgdHJ5IHtcbiAgICBkZWxldGUgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIH0gY2F0Y2goZSkge1xuICAgIGcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuICB9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbiEoZnVuY3Rpb24oZ2xvYmFsKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgdmFyIGluTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIjtcbiAgdmFyIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lO1xuICBpZiAocnVudGltZSkge1xuICAgIGlmIChpbk1vZHVsZSkge1xuICAgICAgLy8gSWYgcmVnZW5lcmF0b3JSdW50aW1lIGlzIGRlZmluZWQgZ2xvYmFsbHkgYW5kIHdlJ3JlIGluIGEgbW9kdWxlLFxuICAgICAgLy8gbWFrZSB0aGUgZXhwb3J0cyBvYmplY3QgaWRlbnRpY2FsIHRvIHJlZ2VuZXJhdG9yUnVudGltZS5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gcnVudGltZTtcbiAgICB9XG4gICAgLy8gRG9uJ3QgYm90aGVyIGV2YWx1YXRpbmcgdGhlIHJlc3Qgb2YgdGhpcyBmaWxlIGlmIHRoZSBydW50aW1lIHdhc1xuICAgIC8vIGFscmVhZHkgZGVmaW5lZCBnbG9iYWxseS5cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBEZWZpbmUgdGhlIHJ1bnRpbWUgZ2xvYmFsbHkgKGFzIGV4cGVjdGVkIGJ5IGdlbmVyYXRlZCBjb2RlKSBhcyBlaXRoZXJcbiAgLy8gbW9kdWxlLmV4cG9ydHMgKGlmIHdlJ3JlIGluIGEgbW9kdWxlKSBvciBhIG5ldywgZW1wdHkgb2JqZWN0LlxuICBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZSA9IGluTW9kdWxlID8gbW9kdWxlLmV4cG9ydHMgOiB7fTtcblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBydW50aW1lLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZVt0b1N0cmluZ1RhZ1N5bWJvbF0gPVxuICAgIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIHJ1bnRpbWUubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICBydW50aW1lLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi4gSWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQsIGhvd2V2ZXIsIHRoZVxuICAgICAgICAgIC8vIHJlc3VsdCBmb3IgdGhpcyBpdGVyYXRpb24gd2lsbCBiZSByZWplY3RlZCB3aXRoIHRoZSBzYW1lXG4gICAgICAgICAgLy8gcmVhc29uLiBOb3RlIHRoYXQgcmVqZWN0aW9ucyBvZiB5aWVsZGVkIFByb21pc2VzIGFyZSBub3RcbiAgICAgICAgICAvLyB0aHJvd24gYmFjayBpbnRvIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIGFzIGlzIHRoZSBjYXNlXG4gICAgICAgICAgLy8gd2hlbiBhbiBhd2FpdGVkIFByb21pc2UgaXMgcmVqZWN0ZWQuIFRoaXMgZGlmZmVyZW5jZSBpblxuICAgICAgICAgIC8vIGJlaGF2aW9yIGJldHdlZW4geWllbGQgYW5kIGF3YWl0IGlzIGltcG9ydGFudCwgYmVjYXVzZSBpdFxuICAgICAgICAgIC8vIGFsbG93cyB0aGUgY29uc3VtZXIgdG8gZGVjaWRlIHdoYXQgdG8gZG8gd2l0aCB0aGUgeWllbGRlZFxuICAgICAgICAgIC8vIHJlamVjdGlvbiAoc3dhbGxvdyBpdCBhbmQgY29udGludWUsIG1hbnVhbGx5IC50aHJvdyBpdCBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgZ2VuZXJhdG9yLCBhYmFuZG9uIGl0ZXJhdGlvbiwgd2hhdGV2ZXIpLiBXaXRoXG4gICAgICAgICAgLy8gYXdhaXQsIGJ5IGNvbnRyYXN0LCB0aGVyZSBpcyBubyBvcHBvcnR1bml0eSB0byBleGFtaW5lIHRoZVxuICAgICAgICAgIC8vIHJlamVjdGlvbiByZWFzb24gb3V0c2lkZSB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBzbyB0aGVcbiAgICAgICAgICAvLyBvbmx5IG9wdGlvbiBpcyB0byB0aHJvdyBpdCBmcm9tIHRoZSBhd2FpdCBleHByZXNzaW9uLCBhbmRcbiAgICAgICAgICAvLyBsZXQgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiBoYW5kbGUgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgQXN5bmNJdGVyYXRvci5wcm90b3R5cGVbYXN5bmNJdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIHJ1bnRpbWUuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIHJ1bnRpbWUuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KVxuICAgICk7XG5cbiAgICByZXR1cm4gcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICBpZiAoISBpbmZvKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIEdwW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yXCI7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgcnVudGltZS5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIHJ1bnRpbWUudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG59KShcbiAgLy8gSW4gc2xvcHB5IG1vZGUsIHVuYm91bmQgYHRoaXNgIHJlZmVycyB0byB0aGUgZ2xvYmFsIG9iamVjdCwgZmFsbGJhY2sgdG9cbiAgLy8gRnVuY3Rpb24gY29uc3RydWN0b3IgaWYgd2UncmUgaW4gZ2xvYmFsIHN0cmljdCBtb2RlLiBUaGF0IGlzIHNhZGx5IGEgZm9ybVxuICAvLyBvZiBpbmRpcmVjdCBldmFsIHdoaWNoIHZpb2xhdGVzIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5LlxuICAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzIH0pKCkgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpXG4pO1xuIiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBvYmplY3RIZWxwZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlclwiKTtcclxuY29uc3QgZGF0YUVycm9yXzEgPSByZXF1aXJlKFwiLi4vZXJyb3IvZGF0YUVycm9yXCIpO1xyXG5jb25zdCB0cnl0ZXNfMSA9IHJlcXVpcmUoXCIuL3RyeXRlc1wiKTtcclxuLyoqXHJcbiAqIEEgY2xhc3MgZm9yIGhhbmRsaW5nIGFkZHJlc3Nlcy5cclxuICovXHJcbmNsYXNzIEFkZHJlc3Mge1xyXG4gICAgLyogQGludGVybmFsICovXHJcbiAgICBjb25zdHJ1Y3RvcihhZGRyZXNzVHJ5dGVzLCBjaGVja3N1bVRyeXRlcykge1xyXG4gICAgICAgIHRoaXMuX2FkZHJlc3NUcnl0ZXMgPSBhZGRyZXNzVHJ5dGVzO1xyXG4gICAgICAgIHRoaXMuX2NoZWNrc3VtVHJ5dGVzID0gY2hlY2tzdW1Ucnl0ZXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhZGRyZXNzIGZyb20gdHJ5dGVzLlxyXG4gICAgICogQHBhcmFtIGFkZHJlc3MgVGhlIHRyeXRlcyB0byBjcmVhdGUgdGhlIGFkZHJlc3MgZnJvbS5cclxuICAgICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIEFkZHJlc3MuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tVHJ5dGVzKGFkZHJlc3MpIHtcclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUoYWRkcmVzcywgdHJ5dGVzXzEuVHJ5dGVzKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFwiVGhlIGFkZHJlc3Mgc2hvdWxkIGJlIGEgdmFsaWQgVHJ5dGVzIG9iamVjdFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdHJ5dGVzU3RyaW5nID0gYWRkcmVzcy50b1N0cmluZygpO1xyXG4gICAgICAgIGlmICh0cnl0ZXNTdHJpbmcubGVuZ3RoICE9PSBBZGRyZXNzLkxFTkdUSCAmJiB0cnl0ZXNTdHJpbmcubGVuZ3RoICE9PSBBZGRyZXNzLkxFTkdUSF9XSVRIX0NIRUNLU1VNKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoYFRoZSBhZGRyZXNzIHNob3VsZCBlaXRoZXIgYmUgJHtBZGRyZXNzLkxFTkdUSH0gb3IgJHtBZGRyZXNzLkxFTkdUSF9XSVRIX0NIRUNLU1VNfSBjaGFyYWN0ZXJzIGluIGxlbmd0aGAsIHsgbGVuZ3RoOiB0cnl0ZXNTdHJpbmcubGVuZ3RoIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBhZGRyZXNzVHJ5dGVzID0gdHJ5dGVzU3RyaW5nLnN1YnN0cigwLCBBZGRyZXNzLkxFTkdUSCk7XHJcbiAgICAgICAgbGV0IGNoZWNrc3VtVHJ5dGVzO1xyXG4gICAgICAgIGlmICh0cnl0ZXNTdHJpbmcubGVuZ3RoID09PSBBZGRyZXNzLkxFTkdUSF9XSVRIX0NIRUNLU1VNKSB7XHJcbiAgICAgICAgICAgIGNoZWNrc3VtVHJ5dGVzID0gdHJ5dGVzU3RyaW5nLnN1YnN0cihBZGRyZXNzLkxFTkdUSCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgQWRkcmVzcyhhZGRyZXNzVHJ5dGVzLCBjaGVja3N1bVRyeXRlcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnQgdGhlIGFkZHJlc3MgdG8gdHJ5dGVzIHdpdGggbm8gY2hlY2tzdW0uXHJcbiAgICAgKiBAcmV0dXJucyBUcnl0ZXMgdmVyc2lvbiBvZiB0aGUgYWRkcmVzcyB3aXRoIG5vIGNoZWNrc3VtLlxyXG4gICAgICovXHJcbiAgICB0b1RyeXRlcygpIHtcclxuICAgICAgICByZXR1cm4gdHJ5dGVzXzEuVHJ5dGVzLmZyb21TdHJpbmcodGhpcy5fYWRkcmVzc1RyeXRlcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnQgdGhlIGFkZHJlc3MgdG8gdHJ5dGVzIHdpdGggYSBjaGVja3N1bSwgY3JlYXRpbmcgYSBibGFuayBvbmUgaWYgbmVlZGVkLlxyXG4gICAgICogQHJldHVybnMgVHJ5dGVzIHZlcnNpb24gb2YgdGhlIGFkZHJlc3Mgd2l0aCBjaGVja3N1LC5cclxuICAgICAqL1xyXG4gICAgdG9Ucnl0ZXNXaXRoQ2hlY2tzdW0oKSB7XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNFbXB0eSh0aGlzLl9jaGVja3N1bVRyeXRlcykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRyeXRlc18xLlRyeXRlcy5mcm9tU3RyaW5nKHRoaXMuX2FkZHJlc3NUcnl0ZXMgKyB0aGlzLl9jaGVja3N1bVRyeXRlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKGBUaGlzIGFkZHJlc3MgaGFzIG5vIGNoZWNrc3VtIGNhbGN1bGF0ZWQgZm9yIGl0YCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHN0cmluZyB2aWV3IG9mIHRoZSBvYmplY3QuXHJcbiAgICAgKiBAcmV0dXJucyBzdHJpbmcgb2YgdGhlIHRyeXRlcy5cclxuICAgICAqL1xyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNFbXB0eSh0aGlzLl9jaGVja3N1bVRyeXRlcykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZHJlc3NUcnl0ZXMgKyB0aGlzLl9jaGVja3N1bVRyeXRlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hZGRyZXNzVHJ5dGVzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhlIGxlbmd0aCBmb3IgYSB2YWxpZCBhZGRyZXNzIHdpdGhvdXQgY2hlY2tzdW0gKDgxKS5cclxuICovXHJcbkFkZHJlc3MuTEVOR1RIID0gODE7XHJcbi8qKlxyXG4gKiBUaGUgbGVuZ3RoIGZvciBhbiBhZGRyZXNzIGNoZWNrc3VtICg5KS5cclxuICovXHJcbkFkZHJlc3MuTEVOR1RIX0NIRUNLU1VNID0gOTtcclxuLyoqXHJcbiAqIFRoZSBsZW5ndGggZm9yIHZhbGlkIGFkZHJlc3Mgd2l0aCBjaGVja3N1bSAoOTApLlxyXG4gKi9cclxuQWRkcmVzcy5MRU5HVEhfV0lUSF9DSEVDS1NVTSA9IEFkZHJlc3MuTEVOR1RIICsgQWRkcmVzcy5MRU5HVEhfQ0hFQ0tTVU07XHJcbi8qKlxyXG4gKiBBbiBlbXB0eSBoYXNoIGFsbCA5cy5cclxuICovXHJcbkFkZHJlc3MuRU1QVFkgPSBBZGRyZXNzLmZyb21Ucnl0ZXModHJ5dGVzXzEuVHJ5dGVzLmZyb21TdHJpbmcoXCI5XCIucmVwZWF0KEFkZHJlc3MuTEVOR1RIKSkpO1xyXG5leHBvcnRzLkFkZHJlc3MgPSBBZGRyZXNzO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lZV1JrY21WemN5NXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5a1lYUmhMMkZrWkhKbGMzTXVkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanRCUVVGQkxEUkZRVUY1UlR0QlFVTjZSU3hyUkVGQkswTTdRVUZETDBNc2NVTkJRV3RETzBGQlJXeERPenRIUVVWSE8wRkJRMGc3U1VGM1Fra3NaVUZCWlR0SlFVTm1MRmxCUVc5Q0xHRkJRWEZDTEVWQlFVVXNZMEZCYzBJN1VVRkROMFFzU1VGQlNTeERRVUZETEdOQlFXTXNSMEZCUnl4aFFVRmhMRU5CUVVNN1VVRkRjRU1zU1VGQlNTeERRVUZETEdWQlFXVXNSMEZCU1N4alFVRmpMRU5CUVVNN1NVRkRNME1zUTBGQlF6dEpRVVZFT3pzN08wOUJTVWM3U1VGRFNTeE5RVUZOTEVOQlFVTXNWVUZCVlN4RFFVRkRMRTlCUVdVN1VVRkRjRU1zU1VGQlNTeERRVUZETERKQ1FVRlpMRU5CUVVNc1RVRkJUU3hEUVVGRExFOUJRVThzUlVGQlJTeGxRVUZOTEVOQlFVTXNSVUZCUlR0WlFVTjJReXhOUVVGTkxFbEJRVWtzY1VKQlFWTXNRMEZCUXl3MlEwRkJOa01zUTBGQlF5eERRVUZETzFOQlEzUkZPMUZCUlVRc1RVRkJUU3haUVVGWkxFZEJRVWNzVDBGQlR5eERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRPMUZCUlhoRExFbEJRVWtzV1VGQldTeERRVUZETEUxQlFVMHNTMEZCU3l4UFFVRlBMRU5CUVVNc1RVRkJUU3hKUVVGSkxGbEJRVmtzUTBGQlF5eE5RVUZOTEV0QlFVc3NUMEZCVHl4RFFVRkRMRzlDUVVGdlFpeEZRVUZGTzFsQlEyaEhMRTFCUVUwc1NVRkJTU3h4UWtGQlV5eERRVUZETEdkRFFVRm5ReXhQUVVGUExFTkJRVU1zVFVGQlRTeFBRVUZQTEU5QlFVOHNRMEZCUXl4dlFrRkJiMElzZFVKQlFYVkNMRVZCUVVVc1JVRkJSU3hOUVVGTkxFVkJRVVVzV1VGQldTeERRVUZETEUxQlFVMHNSVUZCUlN4RFFVRkRMRU5CUVVNN1UwRkRiRXM3VVVGRlJDeE5RVUZOTEdGQlFXRXNSMEZCUnl4WlFVRlpMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUlVGQlJTeFBRVUZQTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNN1VVRkROMFFzU1VGQlNTeGpRVUZqTEVOQlFVTTdVVUZEYmtJc1NVRkJTU3haUVVGWkxFTkJRVU1zVFVGQlRTeExRVUZMTEU5QlFVOHNRMEZCUXl4dlFrRkJiMElzUlVGQlJUdFpRVU4wUkN4alFVRmpMRWRCUVVjc1dVRkJXU3hEUVVGRExFMUJRVTBzUTBGQlF5eFBRVUZQTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNN1UwRkRlRVE3VVVGRFJDeFBRVUZQTEVsQlFVa3NUMEZCVHl4RFFVRkRMR0ZCUVdFc1JVRkJSU3hqUVVGakxFTkJRVU1zUTBGQlF6dEpRVU4wUkN4RFFVRkRPMGxCUlVRN096dFBRVWRITzBsQlEwa3NVVUZCVVR0UlFVTllMRTlCUVU4c1pVRkJUU3hEUVVGRExGVkJRVlVzUTBGQlF5eEpRVUZKTEVOQlFVTXNZMEZCWXl4RFFVRkRMRU5CUVVNN1NVRkRiRVFzUTBGQlF6dEpRVVZFT3pzN1QwRkhSenRKUVVOSkxHOUNRVUZ2UWp0UlFVTjJRaXhKUVVGSkxFTkJRVU1zTWtKQlFWa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1NVRkJTU3hEUVVGRExHVkJRV1VzUTBGQlF5eEZRVUZGTzFsQlF6ZERMRTlCUVU4c1pVRkJUU3hEUVVGRExGVkJRVlVzUTBGQlF5eEpRVUZKTEVOQlFVTXNZMEZCWXl4SFFVRkhMRWxCUVVrc1EwRkJReXhsUVVGbExFTkJRVU1zUTBGQlF6dFRRVU40UlR0aFFVRk5PMWxCUTBnc1RVRkJUU3hKUVVGSkxIRkNRVUZUTEVOQlFVTXNaMFJCUVdkRUxFTkJRVU1zUTBGQlF6dFRRVU42UlR0SlFVTk1MRU5CUVVNN1NVRkZSRHM3TzA5QlIwYzdTVUZEU1N4UlFVRlJPMUZCUTFnc1NVRkJTU3hEUVVGRExESkNRVUZaTEVOQlFVTXNUMEZCVHl4RFFVRkRMRWxCUVVrc1EwRkJReXhsUVVGbExFTkJRVU1zUlVGQlJUdFpRVU0zUXl4UFFVRlBMRWxCUVVrc1EwRkJReXhqUVVGakxFZEJRVWNzU1VGQlNTeERRVUZETEdWQlFXVXNRMEZCUXp0VFFVTnlSRHRoUVVGTk8xbEJRMGdzVDBGQlR5eEpRVUZKTEVOQlFVTXNZMEZCWXl4RFFVRkRPMU5CUXpsQ08wbEJRMHdzUTBGQlF6czdRVUZ1UmtRN08wZEJSVWM3UVVGRGIwSXNZMEZCVFN4SFFVRlhMRVZCUVVVc1EwRkJRenRCUVVNelF6czdSMEZGUnp0QlFVTnZRaXgxUWtGQlpTeEhRVUZYTEVOQlFVTXNRMEZCUXp0QlFVTnVSRHM3UjBGRlJ6dEJRVU52UWl3MFFrRkJiMElzUjBGQlZ5eFBRVUZQTEVOQlFVTXNUVUZCVFN4SFFVRkhMRTlCUVU4c1EwRkJReXhsUVVGbExFTkJRVU03UVVGRkwwWTdPMGRCUlVjN1FVRkRiMElzWVVGQlN5eEhRVUZaTEU5QlFVOHNRMEZCUXl4VlFVRlZMRU5CUVVNc1pVRkJUU3hEUVVGRExGVkJRVlVzUTBGQlF5eEhRVUZITEVOQlFVTXNUVUZCVFN4RFFVRkRMRTlCUVU4c1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdRVUZxUWpsSExEQkNRWEZHUXlKOSIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3Qgb2JqZWN0SGVscGVyXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9vYmplY3RIZWxwZXJcIik7XHJcbmNvbnN0IGRhdGFFcnJvcl8xID0gcmVxdWlyZShcIi4uL2Vycm9yL2RhdGFFcnJvclwiKTtcclxuY29uc3QgdHJ5dGVzXzEgPSByZXF1aXJlKFwiLi90cnl0ZXNcIik7XHJcbi8qKlxyXG4gKiBBIGNsYXNzIGZvciBoYW5kbGluZyBoYXNoZXMuXHJcbiAqL1xyXG5jbGFzcyBIYXNoIHtcclxuICAgIC8qIEBpbnRlcm5hbCAqL1xyXG4gICAgY29uc3RydWN0b3IodHJ5dGVzKSB7XHJcbiAgICAgICAgdGhpcy5fdHJ5dGVzID0gdHJ5dGVzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgaGFzaCBmcm9tIHRyeXRlcy5cclxuICAgICAqIEBwYXJhbSBoYXNoIFRoZSB0cnl0ZXMgdG8gY3JlYXRlIHRoZSBoYXNoIGZyb20uXHJcbiAgICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBIYXNoLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbVRyeXRlcyhoYXNoKSB7XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKGhhc2gsIHRyeXRlc18xLlRyeXRlcykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihcIlRoZSBoYXNoIHNob3VsZCBiZSBhIHZhbGlkIFRyeXRlcyBvYmplY3RcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGhhc2gubGVuZ3RoKCk7XHJcbiAgICAgICAgaWYgKGxlbmd0aCAhPT0gSGFzaC5MRU5HVEgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihgVGhlIGhhc2ggc2hvdWxkIGJlICR7SGFzaC5MRU5HVEh9IGNoYXJhY3RlcnMgaW4gbGVuZ3RoYCwgeyBsZW5ndGggfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgSGFzaChoYXNoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydCB0aGUgaGFzaCB0byB0cnl0ZXMuXHJcbiAgICAgKiBAcmV0dXJucyBUcnl0ZXMgdmVyc2lvbiBvZiB0aGUgaGFzaC5cclxuICAgICAqL1xyXG4gICAgdG9Ucnl0ZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyeXRlcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBzdHJpbmcgdmlldyBvZiB0aGUgb2JqZWN0LlxyXG4gICAgICogQHJldHVybnMgc3RyaW5nIG9mIHRoZSB0cnl0ZXMuXHJcbiAgICAgKi9cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90cnl0ZXMudG9TdHJpbmcoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhlIGxlbmd0aCBmb3IgYSB2YWxpZCBoYXNoICg4MSkuXHJcbiAqL1xyXG5IYXNoLkxFTkdUSCA9IDgxO1xyXG4vKipcclxuICogQW4gZW1wdHkgaGFzaCBhbGwgOXMuXHJcbiAqL1xyXG5IYXNoLkVNUFRZID0gSGFzaC5mcm9tVHJ5dGVzKHRyeXRlc18xLlRyeXRlcy5mcm9tU3RyaW5nKFwiOVwiLnJlcGVhdChIYXNoLkxFTkdUSCkpKTtcclxuZXhwb3J0cy5IYXNoID0gSGFzaDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYUdGemFDNXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5a1lYUmhMMmhoYzJndWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqdEJRVUZCTERSRlFVRjVSVHRCUVVONlJTeHJSRUZCSzBNN1FVRkRMME1zY1VOQlFXdERPMEZCUld4RE96dEhRVVZITzBGQlEwZzdTVUZoU1N4bFFVRmxPMGxCUTJZc1dVRkJiMElzVFVGQll6dFJRVU01UWl4SlFVRkpMRU5CUVVNc1QwRkJUeXhIUVVGSExFMUJRVTBzUTBGQlF6dEpRVU14UWl4RFFVRkRPMGxCUlVRN096czdUMEZKUnp0SlFVTkpMRTFCUVUwc1EwRkJReXhWUVVGVkxFTkJRVU1zU1VGQldUdFJRVU5xUXl4SlFVRkpMRU5CUVVNc01rSkJRVmtzUTBGQlF5eE5RVUZOTEVOQlFVTXNTVUZCU1N4RlFVRkZMR1ZCUVUwc1EwRkJReXhGUVVGRk8xbEJRM0JETEUxQlFVMHNTVUZCU1N4eFFrRkJVeXhEUVVGRExEQkRRVUV3UXl4RFFVRkRMRU5CUVVNN1UwRkRia1U3VVVGRlJDeE5RVUZOTEUxQlFVMHNSMEZCUnl4SlFVRkpMRU5CUVVNc1RVRkJUU3hGUVVGRkxFTkJRVU03VVVGRE4wSXNTVUZCU1N4TlFVRk5MRXRCUVVzc1NVRkJTU3hEUVVGRExFMUJRVTBzUlVGQlJUdFpRVU40UWl4TlFVRk5MRWxCUVVrc2NVSkJRVk1zUTBGQlF5eHpRa0ZCYzBJc1NVRkJTU3hEUVVGRExFMUJRVTBzZFVKQlFYVkNMRVZCUVVVc1JVRkJSU3hOUVVGTkxFVkJRVVVzUTBGQlF5eERRVUZETzFOQlF6ZEdPMUZCUlVRc1QwRkJUeXhKUVVGSkxFbEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0SlFVTXhRaXhEUVVGRE8wbEJSVVE3T3p0UFFVZEhPMGxCUTBrc1VVRkJVVHRSUVVOWUxFOUJRVThzU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXp0SlFVTjRRaXhEUVVGRE8wbEJSVVE3T3p0UFFVZEhPMGxCUTBrc1VVRkJVVHRSUVVOWUxFOUJRVThzU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJRenRKUVVOdVF5eERRVUZET3p0QlFXcEVSRHM3UjBGRlJ6dEJRVU52UWl4WFFVRk5MRWRCUVZjc1JVRkJSU3hEUVVGRE8wRkJRek5ET3p0SFFVVkhPMEZCUTI5Q0xGVkJRVXNzUjBGQlV5eEpRVUZKTEVOQlFVTXNWVUZCVlN4RFFVRkRMR1ZCUVUwc1EwRkJReXhWUVVGVkxFTkJRVU1zUjBGQlJ5eERRVUZETEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzBGQlVuSkhMRzlDUVcxRVF5SjkiLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IG9iamVjdEhlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvb2JqZWN0SGVscGVyXCIpO1xyXG5jb25zdCBkYXRhRXJyb3JfMSA9IHJlcXVpcmUoXCIuLi9lcnJvci9kYXRhRXJyb3JcIik7XHJcbmNvbnN0IHRyeXRlc18xID0gcmVxdWlyZShcIi4vdHJ5dGVzXCIpO1xyXG4vKipcclxuICogQSBjbGFzcyBmb3IgaGFuZGxpbmcgc2lnbmF0dXJlIG1lc3NhZ2UgZnJhZ21lbnRzLlxyXG4gKi9cclxuY2xhc3MgU2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50IHtcclxuICAgIC8qIEBpbnRlcm5hbCAqL1xyXG4gICAgY29uc3RydWN0b3IodHJ5dGVzKSB7XHJcbiAgICAgICAgdGhpcy5fdHJ5dGVzID0gdHJ5dGVzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgc2lnbmF0dXJlIGZyYWdtZW50IGZyb20gdHJ5dGVzLlxyXG4gICAgICogQHBhcmFtIHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudCBUaGUgdHJ5dGVzIHRvIGNyZWF0ZSB0aGUgc2lnbmF0dXJlIGZyYWdtZW50IGZyb20uXHJcbiAgICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBTaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tVHJ5dGVzKHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudCkge1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZShzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQsIHRyeXRlc18xLlRyeXRlcykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihcIlRoZSBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQgc2hvdWxkIGJlIGEgdmFsaWQgVHJ5dGVzIG9iamVjdFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50Lmxlbmd0aCgpO1xyXG4gICAgICAgIGlmIChsZW5ndGggIT09IFNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudC5MRU5HVEgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihgVGhlIHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudCBzaG91bGQgYmUgJHtTaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQuTEVOR1RIfSBjaGFyYWN0ZXJzIGluIGxlbmd0aGAsIHsgbGVuZ3RoIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudChzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0IHRoZSBzaWduYXR1cmUgZnJhZ21lbnQgdG8gdHJ5dGVzLlxyXG4gICAgICogQHJldHVybnMgVHJ5dGVzIHZlcnNpb24gb2YgdGhlIHNpZ25hdHVyZSBmcmFnbWVudC5cclxuICAgICAqL1xyXG4gICAgdG9Ucnl0ZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyeXRlcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBzdHJpbmcgdmlldyBvZiB0aGUgb2JqZWN0LlxyXG4gICAgICogQHJldHVybnMgc3RyaW5nIG9mIHRoZSB0cnl0ZXMuXHJcbiAgICAgKi9cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90cnl0ZXMudG9TdHJpbmcoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhlIGxlbmd0aCBvZiBhIHZhbGlkIHNpZ25hdHVyZSBtZXNzYWdlIGZyYWdtZW50ICgyMTg3KVxyXG4gKi9cclxuU2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LkxFTkdUSCA9IDIxODc7XHJcbi8qKlxyXG4gKiBBbiBlbXB0eSBzaWduYXR1cmUgbWVzc2FnZSBmcmFnbWVudCBhbGwgOXMuXHJcbiAqL1xyXG5TaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQuRU1QVFkgPSBTaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQuZnJvbVRyeXRlcyh0cnl0ZXNfMS5Ucnl0ZXMuZnJvbVN0cmluZyhcIjlcIi5yZXBlYXQoU2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LkxFTkdUSCkpKTtcclxuZXhwb3J0cy5TaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQgPSBTaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQ7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWMybG5ibUYwZFhKbFRXVnpjMkZuWlVaeVlXZHRaVzUwTG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhNaU9sc2lMaTR2TGk0dmMzSmpMMlJoZEdFdmMybG5ibUYwZFhKbFRXVnpjMkZuWlVaeVlXZHRaVzUwTG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN1FVRkJRU3cwUlVGQmVVVTdRVUZEZWtVc2EwUkJRU3RETzBGQlF5OURMSEZEUVVGclF6dEJRVVZzUXpzN1IwRkZSenRCUVVOSU8wbEJZVWtzWlVGQlpUdEpRVU5tTEZsQlFXOUNMRTFCUVdNN1VVRkRPVUlzU1VGQlNTeERRVUZETEU5QlFVOHNSMEZCUnl4TlFVRk5MRU5CUVVNN1NVRkRNVUlzUTBGQlF6dEpRVVZFT3pzN08wOUJTVWM3U1VGRFNTeE5RVUZOTEVOQlFVTXNWVUZCVlN4RFFVRkRMSGRDUVVGblF6dFJRVU55UkN4SlFVRkpMRU5CUVVNc01rSkJRVmtzUTBGQlF5eE5RVUZOTEVOQlFVTXNkMEpCUVhkQ0xFVkJRVVVzWlVGQlRTeERRVUZETEVWQlFVVTdXVUZEZUVRc1RVRkJUU3hKUVVGSkxIRkNRVUZUTEVOQlFVTXNPRVJCUVRoRUxFTkJRVU1zUTBGQlF6dFRRVU4yUmp0UlFVVkVMRTFCUVUwc1RVRkJUU3hIUVVGSExIZENRVUYzUWl4RFFVRkRMRTFCUVUwc1JVRkJSU3hEUVVGRE8xRkJRMnBFTEVsQlFVa3NUVUZCVFN4TFFVRkxMSGRDUVVGM1FpeERRVUZETEUxQlFVMHNSVUZCUlR0WlFVTTFReXhOUVVGTkxFbEJRVWtzY1VKQlFWTXNRMEZCUXl3d1EwRkJNRU1zZDBKQlFYZENMRU5CUVVNc1RVRkJUU3gxUWtGQmRVSXNSVUZCUlN4RlFVRkZMRTFCUVUwc1JVRkJSU3hEUVVGRExFTkJRVU03VTBGRGNrazdVVUZEUkN4UFFVRlBMRWxCUVVrc2QwSkJRWGRDTEVOQlFVTXNkMEpCUVhkQ0xFTkJRVU1zUTBGQlF6dEpRVU5zUlN4RFFVRkRPMGxCUlVRN096dFBRVWRITzBsQlEwa3NVVUZCVVR0UlFVTllMRTlCUVU4c1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF6dEpRVU40UWl4RFFVRkRPMGxCUlVRN096dFBRVWRITzBsQlEwa3NVVUZCVVR0UlFVTllMRTlCUVU4c1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXp0SlFVTnVReXhEUVVGRE96dEJRV2hFUkRzN1IwRkZSenRCUVVOdlFpd3JRa0ZCVFN4SFFVRlhMRWxCUVVrc1EwRkJRenRCUVVNM1F6czdSMEZGUnp0QlFVTnZRaXc0UWtGQlN5eEhRVUUyUWl4M1FrRkJkMElzUTBGQlF5eFZRVUZWTEVOQlFVTXNaVUZCVFN4RFFVRkRMRlZCUVZVc1EwRkJReXhIUVVGSExFTkJRVU1zVFVGQlRTeERRVUZETEhkQ1FVRjNRaXhEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0QlFWSnFTeXcwUkVGclJFTWlmUT09IiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBvYmplY3RIZWxwZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlclwiKTtcclxuY29uc3QgZGF0YUVycm9yXzEgPSByZXF1aXJlKFwiLi4vZXJyb3IvZGF0YUVycm9yXCIpO1xyXG5jb25zdCB0cnl0ZXNfMSA9IHJlcXVpcmUoXCIuL3RyeXRlc1wiKTtcclxuLyoqXHJcbiAqIEEgY2xhc3MgZm9yIGhhbmRsaW5nIHRhZ3MuXHJcbiAqL1xyXG5jbGFzcyBUYWcge1xyXG4gICAgLyogQGludGVybmFsICovXHJcbiAgICBjb25zdHJ1Y3Rvcih0cnl0ZXMpIHtcclxuICAgICAgICB0aGlzLl90cnl0ZXMgPSB0cnl0ZXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSB0YWcgZnJvbSB0cnl0ZXMuXHJcbiAgICAgKiBAcGFyYW0gdGFnIFRoZSB0cnl0ZXMgdG8gY3JlYXRlIHRoZSB0YWcgZnJvbS5cclxuICAgICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIFRhZy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21Ucnl0ZXModGFnKSB7XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHRhZywgdHJ5dGVzXzEuVHJ5dGVzKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFwiVGhlIHRhZyBzaG91bGQgYmUgYSB2YWxpZCBUcnl0ZXMgb2JqZWN0XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgdHJ5dGVzU3RyaW5nID0gdGFnLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgaWYgKHRyeXRlc1N0cmluZy5sZW5ndGggPiBUYWcuTEVOR1RIKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoYFRoZSB0YWcgc2hvdWxkIGJlIGF0IG1vc3QgJHtUYWcuTEVOR1RIfSBjaGFyYWN0ZXJzIGluIGxlbmd0aGAsIHsgbGVuZ3RoOiB0cnl0ZXNTdHJpbmcubGVuZ3RoIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAodHJ5dGVzU3RyaW5nLmxlbmd0aCA8IFRhZy5MRU5HVEgpIHtcclxuICAgICAgICAgICAgdHJ5dGVzU3RyaW5nICs9IFwiOVwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFRhZyh0cnl0ZXNTdHJpbmcpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0IHRoZSB0YWcgdG8gdHJ5dGVzLlxyXG4gICAgICogQHJldHVybnMgVHJ5dGVzIHZlcnNpb24gb2YgdGhlIHRhZy5cclxuICAgICAqL1xyXG4gICAgdG9Ucnl0ZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRyeXRlc18xLlRyeXRlcy5mcm9tU3RyaW5nKHRoaXMuX3RyeXRlcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgc3RyaW5nIHZpZXcgb2YgdGhlIG9iamVjdC5cclxuICAgICAqIEByZXR1cm5zIHN0cmluZyBvZiB0aGUgdHJ5dGVzLlxyXG4gICAgICovXHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdHJ5dGVzO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGUgbGVuZ3RoIG9mIGEgdmFsaWQgdGFnICgyNykuXHJcbiAqL1xyXG5UYWcuTEVOR1RIID0gMjc7XHJcbi8qKlxyXG4gKiBBbiBlbXB0eSB0YWcgYWxsIDlzLlxyXG4gKi9cclxuVGFnLkVNUFRZID0gVGFnLmZyb21Ucnl0ZXModHJ5dGVzXzEuVHJ5dGVzLmZyb21TdHJpbmcoXCI5XCIucmVwZWF0KFRhZy5MRU5HVEgpKSk7XHJcbmV4cG9ydHMuVGFnID0gVGFnO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lkR0ZuTG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhNaU9sc2lMaTR2TGk0dmMzSmpMMlJoZEdFdmRHRm5MblJ6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3UVVGQlFTdzBSVUZCZVVVN1FVRkRla1VzYTBSQlFTdERPMEZCUXk5RExIRkRRVUZyUXp0QlFVVnNRenM3UjBGRlJ6dEJRVU5JTzBsQllVa3NaVUZCWlR0SlFVTm1MRmxCUVc5Q0xFMUJRV003VVVGRE9VSXNTVUZCU1N4RFFVRkRMRTlCUVU4c1IwRkJSeXhOUVVGTkxFTkJRVU03U1VGRE1VSXNRMEZCUXp0SlFVVkVPenM3TzA5QlNVYzdTVUZEU1N4TlFVRk5MRU5CUVVNc1ZVRkJWU3hEUVVGRExFZEJRVmM3VVVGRGFFTXNTVUZCU1N4RFFVRkRMREpDUVVGWkxFTkJRVU1zVFVGQlRTeERRVUZETEVkQlFVY3NSVUZCUlN4bFFVRk5MRU5CUVVNc1JVRkJSVHRaUVVOdVF5eE5RVUZOTEVsQlFVa3NjVUpCUVZNc1EwRkJReXg1UTBGQmVVTXNRMEZCUXl4RFFVRkRPMU5CUTJ4Rk8xRkJSVVFzU1VGQlNTeFpRVUZaTEVkQlFVY3NSMEZCUnl4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRE8xRkJSV3hETEVsQlFVa3NXVUZCV1N4RFFVRkRMRTFCUVUwc1IwRkJSeXhIUVVGSExFTkJRVU1zVFVGQlRTeEZRVUZGTzFsQlEyeERMRTFCUVUwc1NVRkJTU3h4UWtGQlV5eERRVUZETERaQ1FVRTJRaXhIUVVGSExFTkJRVU1zVFVGQlRTeDFRa0ZCZFVJc1JVRkJSU3hGUVVGRkxFMUJRVTBzUlVGQlJTeFpRVUZaTEVOQlFVTXNUVUZCVFN4RlFVRkZMRU5CUVVNc1EwRkJRenRUUVVONFNEdFJRVVZFTEU5QlFVOHNXVUZCV1N4RFFVRkRMRTFCUVUwc1IwRkJSeXhIUVVGSExFTkJRVU1zVFVGQlRTeEZRVUZGTzFsQlEzSkRMRmxCUVZrc1NVRkJTU3hIUVVGSExFTkJRVU03VTBGRGRrSTdVVUZGUkN4UFFVRlBMRWxCUVVrc1IwRkJSeXhEUVVGRExGbEJRVmtzUTBGQlF5eERRVUZETzBsQlEycERMRU5CUVVNN1NVRkZSRHM3TzA5QlIwYzdTVUZEU1N4UlFVRlJPMUZCUTFnc1QwRkJUeXhsUVVGTkxFTkJRVU1zVlVGQlZTeERRVUZETEVsQlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJRenRKUVVNelF5eERRVUZETzBsQlJVUTdPenRQUVVkSE8wbEJRMGtzVVVGQlVUdFJRVU5ZTEU5QlFVOHNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJRenRKUVVONFFpeERRVUZET3p0QlFYUkVSRHM3UjBGRlJ6dEJRVU52UWl4VlFVRk5MRWRCUVZjc1JVRkJSU3hEUVVGRE8wRkJRek5ET3p0SFFVVkhPMEZCUTI5Q0xGTkJRVXNzUjBGQlVTeEhRVUZITEVOQlFVTXNWVUZCVlN4RFFVRkRMR1ZCUVUwc1EwRkJReXhWUVVGVkxFTkJRVU1zUjBGQlJ5eERRVUZETEUxQlFVMHNRMEZCUXl4SFFVRkhMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzBGQlVteEhMR3RDUVhkRVF5SjkiLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IG9iamVjdEhlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvb2JqZWN0SGVscGVyXCIpO1xyXG5jb25zdCBkYXRhRXJyb3JfMSA9IHJlcXVpcmUoXCIuLi9lcnJvci9kYXRhRXJyb3JcIik7XHJcbmNvbnN0IGFkZHJlc3NfMSA9IHJlcXVpcmUoXCIuL2FkZHJlc3NcIik7XHJcbmNvbnN0IGhhc2hfMSA9IHJlcXVpcmUoXCIuL2hhc2hcIik7XHJcbmNvbnN0IHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudF8xID0gcmVxdWlyZShcIi4vc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50XCIpO1xyXG5jb25zdCB0YWdfMSA9IHJlcXVpcmUoXCIuL3RhZ1wiKTtcclxuY29uc3QgdHJ5dGVOdW1iZXJfMSA9IHJlcXVpcmUoXCIuL3RyeXRlTnVtYmVyXCIpO1xyXG5jb25zdCB0cnl0ZXNfMSA9IHJlcXVpcmUoXCIuL3RyeXRlc1wiKTtcclxuLyoqXHJcbiAqIEEgY2xhc3MgZm9yIGhhbmRsaW5nIHRyYW5zYWN0aW9ucy5cclxuICovXHJcbmNsYXNzIFRyYW5zYWN0aW9uIHtcclxuICAgIC8qIEBpbnRlcm5hbCAqL1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBpbnN0YW5jZSBvZiB0cmFuc2FjdGlvbiBmcm9tIHBhcmFtZXRlcnMuXHJcbiAgICAgKiBAcGFyYW0gc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50IFRoZSBzaWduYXR1cmUgbWVzc2FnZSBmcmFnbWVudC5cclxuICAgICAqIEBwYXJhbSBhZGRyZXNzIFRoZSBhZGRyZXNzLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZS5cclxuICAgICAqIEBwYXJhbSBvYnNvbGV0ZVRhZyBPYnNvbGV0ZSB0cmFuc2FjdGlvbiB0YWcuXHJcbiAgICAgKiBAcGFyYW0gdGltZXN0YW1wIFRoZSB0aW1lc3RhbXAuXHJcbiAgICAgKiBAcGFyYW0gY3VycmVudEluZGV4IFRoZSBjdXJyZW50IGluZGV4LlxyXG4gICAgICogQHBhcmFtIGxhc3RJbmRleCBUaGUgbGFzdCBpbmRleC5cclxuICAgICAqIEBwYXJhbSBidW5kbGUgVGhlIGJ1bmRsZS5cclxuICAgICAqIEBwYXJhbSB0cnVua1RyYW5zYWN0aW9uIFRoZSB0cnVuayB0cmFuc2FjdGlvbi5cclxuICAgICAqIEBwYXJhbSBicmFuY2hUcmFuc2FjdGlvbiBUaGUgYnJhbmNoIHRyYW5zYWN0aW9uLlxyXG4gICAgICogQHBhcmFtIHRhZyBUaGUgdGFnLlxyXG4gICAgICogQHBhcmFtIGF0dGFjaG1lbnRUaW1lc3RhbXAgVGhlIGF0dGFjaG1lbnQgdGltZXN0YW1wLlxyXG4gICAgICogQHBhcmFtIGF0dGFjaG1lbnRUaW1lc3RhbXBMb3dlckJvdW5kIFRoZSBhdHRhY2htZW50IHRpbWVzdGFtcCBsb3dlciBib3VuZC5cclxuICAgICAqIEBwYXJhbSBhdHRhY2htZW50VGltZXN0YW1wVXBwZXJCb3VuZCAgVGhlIGF0dGFjaG1lbnQgdGltZXN0YW1wIHVwcGVyIGJvdW5kLlxyXG4gICAgICogQHBhcmFtIG5vbmNlIFRoZSBub25jZS5cclxuICAgICAqIEByZXR1cm5zIE5ldyBpbnN0YW5jZSBvZiB0cmFuc2FjdGlvbi5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21QYXJhbXMoc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LCBhZGRyZXNzLCB2YWx1ZSwgb2Jzb2xldGVUYWcsIHRpbWVzdGFtcCwgY3VycmVudEluZGV4LCBsYXN0SW5kZXgsIGJ1bmRsZSwgdHJ1bmtUcmFuc2FjdGlvbiwgYnJhbmNoVHJhbnNhY3Rpb24sIHRhZywgYXR0YWNobWVudFRpbWVzdGFtcCwgYXR0YWNobWVudFRpbWVzdGFtcExvd2VyQm91bmQsIGF0dGFjaG1lbnRUaW1lc3RhbXBVcHBlckJvdW5kLCBub25jZSkge1xyXG4gICAgICAgIGNvbnN0IHR4ID0gbmV3IFRyYW5zYWN0aW9uKCk7XHJcbiAgICAgICAgdHguc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50ID0gc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50O1xyXG4gICAgICAgIHR4LmFkZHJlc3MgPSBhZGRyZXNzO1xyXG4gICAgICAgIHR4LnZhbHVlID0gdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5mcm9tTnVtYmVyKHZhbHVlLCAxMSk7XHJcbiAgICAgICAgdHgub2Jzb2xldGVUYWcgPSBvYnNvbGV0ZVRhZztcclxuICAgICAgICB0eC50aW1lc3RhbXAgPSB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLmZyb21OdW1iZXIodGltZXN0YW1wKTtcclxuICAgICAgICB0eC5jdXJyZW50SW5kZXggPSB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLmZyb21OdW1iZXIoY3VycmVudEluZGV4KTtcclxuICAgICAgICB0eC5sYXN0SW5kZXggPSB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLmZyb21OdW1iZXIobGFzdEluZGV4KTtcclxuICAgICAgICB0eC5idW5kbGUgPSBidW5kbGU7XHJcbiAgICAgICAgdHgudHJ1bmtUcmFuc2FjdGlvbiA9IHRydW5rVHJhbnNhY3Rpb247XHJcbiAgICAgICAgdHguYnJhbmNoVHJhbnNhY3Rpb24gPSBicmFuY2hUcmFuc2FjdGlvbjtcclxuICAgICAgICB0eC50YWcgPSB0YWc7XHJcbiAgICAgICAgdHguYXR0YWNobWVudFRpbWVzdGFtcCA9IHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuZnJvbU51bWJlcihhdHRhY2htZW50VGltZXN0YW1wKTtcclxuICAgICAgICB0eC5hdHRhY2htZW50VGltZXN0YW1wTG93ZXJCb3VuZCA9IHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuZnJvbU51bWJlcihhdHRhY2htZW50VGltZXN0YW1wTG93ZXJCb3VuZCk7XHJcbiAgICAgICAgdHguYXR0YWNobWVudFRpbWVzdGFtcFVwcGVyQm91bmQgPSB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLmZyb21OdW1iZXIoYXR0YWNobWVudFRpbWVzdGFtcFVwcGVyQm91bmQpO1xyXG4gICAgICAgIHR4Lm5vbmNlID0gbm9uY2U7XHJcbiAgICAgICAgcmV0dXJuIHR4O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgaW5zdGFuY2Ugb2YgdHJhbnNhY3Rpb24gZnJvbSB0cnl0ZXMuXHJcbiAgICAgKiBAcGFyYW0gdHJ5dGVzIFRoZSB0cnl0ZXMgZm9yIHRoZSB0aGlzLlxyXG4gICAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhpcy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21Ucnl0ZXModHJ5dGVzKSB7XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHRyeXRlcywgdHJ5dGVzXzEuVHJ5dGVzKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFwiVGhlIHRyeXRlcyBzaG91bGQgYmUgYSB2YWxpZCBUcnl0ZXMgb2JqZWN0XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBsZW5ndGggPSB0cnl0ZXMubGVuZ3RoKCk7XHJcbiAgICAgICAgaWYgKGxlbmd0aCAhPT0gVHJhbnNhY3Rpb24uTEVOR1RIKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoYFRoZSB0cnl0ZXMgbXVzdCBiZSAke1RyYW5zYWN0aW9uLkxFTkdUSH0gaW4gbGVuZ3RoYCwgeyBsZW5ndGggfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNoZWNrSW5kZXhTdGFydCA9IDIyNzk7XHJcbiAgICAgICAgY29uc3QgY2hlY2tJbmRleExlbmd0aCA9IDE2O1xyXG4gICAgICAgIGNvbnN0IGNoZWNrID0gdHJ5dGVzLnN1YihjaGVja0luZGV4U3RhcnQsIGNoZWNrSW5kZXhMZW5ndGgpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgaWYgKGNoZWNrICE9PSBUcmFuc2FjdGlvbi5DSEVDS19WQUxVRSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKGBUaGUgdHJ5dGVzIGJldHdlZW4gJHtjaGVja0luZGV4U3RhcnR9IGFuZCAke2NoZWNrSW5kZXhTdGFydCArIGNoZWNrSW5kZXhMZW5ndGh9IHNob3VsZCBiZSBhbGwgOXNgLCB7IGNoZWNrIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0eCA9IG5ldyBUcmFuc2FjdGlvbigpO1xyXG4gICAgICAgIGxldCBzdGFydFBvcyA9IDA7XHJcbiAgICAgICAgdHguc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50ID0gc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50XzEuU2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LmZyb21Ucnl0ZXModHJ5dGVzLnN1YihzdGFydFBvcywgc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50XzEuU2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LkxFTkdUSCkpO1xyXG4gICAgICAgIHN0YXJ0UG9zICs9IHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudF8xLlNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudC5MRU5HVEg7XHJcbiAgICAgICAgdHguYWRkcmVzcyA9IGFkZHJlc3NfMS5BZGRyZXNzLmZyb21Ucnl0ZXModHJ5dGVzLnN1YihzdGFydFBvcywgYWRkcmVzc18xLkFkZHJlc3MuTEVOR1RIKSk7XHJcbiAgICAgICAgc3RhcnRQb3MgKz0gYWRkcmVzc18xLkFkZHJlc3MuTEVOR1RIO1xyXG4gICAgICAgIHR4LnZhbHVlID0gdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5mcm9tVHJ5dGVzKHRyeXRlcy5zdWIoc3RhcnRQb3MsIDExKSwgMTEpO1xyXG4gICAgICAgIHN0YXJ0UG9zICs9IDExO1xyXG4gICAgICAgIHN0YXJ0UG9zICs9IFRyYW5zYWN0aW9uLkNIRUNLX1ZBTFVFX0xFTkdUSDtcclxuICAgICAgICB0eC5vYnNvbGV0ZVRhZyA9IHRhZ18xLlRhZy5mcm9tVHJ5dGVzKHRyeXRlcy5zdWIoc3RhcnRQb3MsIHRhZ18xLlRhZy5MRU5HVEgpKTtcclxuICAgICAgICBzdGFydFBvcyArPSB0YWdfMS5UYWcuTEVOR1RIO1xyXG4gICAgICAgIHR4LnRpbWVzdGFtcCA9IHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuZnJvbVRyeXRlcyh0cnl0ZXMuc3ViKHN0YXJ0UG9zLCB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLkxFTkdUSF85KSk7XHJcbiAgICAgICAgc3RhcnRQb3MgKz0gdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5MRU5HVEhfOTtcclxuICAgICAgICB0eC5jdXJyZW50SW5kZXggPSB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLmZyb21Ucnl0ZXModHJ5dGVzLnN1YihzdGFydFBvcywgdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5MRU5HVEhfOSkpO1xyXG4gICAgICAgIHN0YXJ0UG9zICs9IHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuTEVOR1RIXzk7XHJcbiAgICAgICAgdHgubGFzdEluZGV4ID0gdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5mcm9tVHJ5dGVzKHRyeXRlcy5zdWIoc3RhcnRQb3MsIHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuTEVOR1RIXzkpKTtcclxuICAgICAgICBzdGFydFBvcyArPSB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLkxFTkdUSF85O1xyXG4gICAgICAgIHR4LmJ1bmRsZSA9IGhhc2hfMS5IYXNoLmZyb21Ucnl0ZXModHJ5dGVzLnN1YihzdGFydFBvcywgaGFzaF8xLkhhc2guTEVOR1RIKSk7XHJcbiAgICAgICAgc3RhcnRQb3MgKz0gaGFzaF8xLkhhc2guTEVOR1RIO1xyXG4gICAgICAgIHR4LnRydW5rVHJhbnNhY3Rpb24gPSBoYXNoXzEuSGFzaC5mcm9tVHJ5dGVzKHRyeXRlcy5zdWIoc3RhcnRQb3MsIGhhc2hfMS5IYXNoLkxFTkdUSCkpO1xyXG4gICAgICAgIHN0YXJ0UG9zICs9IGhhc2hfMS5IYXNoLkxFTkdUSDtcclxuICAgICAgICB0eC5icmFuY2hUcmFuc2FjdGlvbiA9IGhhc2hfMS5IYXNoLmZyb21Ucnl0ZXModHJ5dGVzLnN1YihzdGFydFBvcywgaGFzaF8xLkhhc2guTEVOR1RIKSk7XHJcbiAgICAgICAgc3RhcnRQb3MgKz0gaGFzaF8xLkhhc2guTEVOR1RIO1xyXG4gICAgICAgIHR4LnRhZyA9IHRhZ18xLlRhZy5mcm9tVHJ5dGVzKHRyeXRlcy5zdWIoc3RhcnRQb3MsIHRhZ18xLlRhZy5MRU5HVEgpKTtcclxuICAgICAgICBzdGFydFBvcyArPSB0YWdfMS5UYWcuTEVOR1RIO1xyXG4gICAgICAgIHR4LmF0dGFjaG1lbnRUaW1lc3RhbXAgPSB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLmZyb21Ucnl0ZXModHJ5dGVzLnN1YihzdGFydFBvcywgdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5MRU5HVEhfOSkpO1xyXG4gICAgICAgIHN0YXJ0UG9zICs9IHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuTEVOR1RIXzk7XHJcbiAgICAgICAgdHguYXR0YWNobWVudFRpbWVzdGFtcExvd2VyQm91bmQgPSB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLmZyb21Ucnl0ZXModHJ5dGVzLnN1YihzdGFydFBvcywgdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5MRU5HVEhfOSkpO1xyXG4gICAgICAgIHN0YXJ0UG9zICs9IHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuTEVOR1RIXzk7XHJcbiAgICAgICAgdHguYXR0YWNobWVudFRpbWVzdGFtcFVwcGVyQm91bmQgPSB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLmZyb21Ucnl0ZXModHJ5dGVzLnN1YihzdGFydFBvcywgdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5MRU5HVEhfOSkpO1xyXG4gICAgICAgIHN0YXJ0UG9zICs9IHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuTEVOR1RIXzk7XHJcbiAgICAgICAgdHgubm9uY2UgPSB0YWdfMS5UYWcuZnJvbVRyeXRlcyh0cnl0ZXMuc3ViKHN0YXJ0UG9zLCB0YWdfMS5UYWcuTEVOR1RIKSk7XHJcbiAgICAgICAgcmV0dXJuIHR4O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0IHRoZSB0cmFuc2FjdGlvbiB0byB0cnl0ZXMuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgdHJhbnNhY3Rpb24gYXMgdHJ5dGVzLlxyXG4gICAgICovXHJcbiAgICB0b1RyeXRlcygpIHtcclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUodGhpcy5zaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQsIHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudF8xLlNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihgVGhlIHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudCBtdXN0IGJlIHNldCB0byBjcmVhdGUgdHJhbnNhY3Rpb24gdHJ5dGVzYCwgeyBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQ6IHRoaXMuc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUodGhpcy5hZGRyZXNzLCBhZGRyZXNzXzEuQWRkcmVzcykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihgVGhlIGFkZHJlc3MgbXVzdCBiZSBzZXQgdG8gY3JlYXRlIHRyYW5zYWN0aW9uIHRyeXRlc2AsIHsgYWRkcmVzczogdGhpcy5hZGRyZXNzIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUodGhpcy5vYnNvbGV0ZVRhZywgdGFnXzEuVGFnKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKGBUaGUgb2Jzb2xldGVUYWcgbXVzdCBiZSBzZXQgdG8gY3JlYXRlIHRyYW5zYWN0aW9uIHRyeXRlc2AsIHsgb2Jzb2xldGVUYWc6IHRoaXMub2Jzb2xldGVUYWcgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZSh0aGlzLmJ1bmRsZSwgaGFzaF8xLkhhc2gpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoYFRoZSBidW5kbGUgbXVzdCBiZSBzZXQgdG8gY3JlYXRlIHRyYW5zYWN0aW9uIHRyeXRlc2AsIHsgYnVuZGxlOiB0aGlzLmJ1bmRsZSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHRoaXMudHJ1bmtUcmFuc2FjdGlvbiwgaGFzaF8xLkhhc2gpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoYFRoZSB0cnVua1RyYW5zYWN0aW9uIG11c3QgYmUgc2V0IHRvIGNyZWF0ZSB0cmFuc2FjdGlvbiB0cnl0ZXNgLCB7IHRydW5rVHJhbnNhY3Rpb246IHRoaXMudHJ1bmtUcmFuc2FjdGlvbiB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHRoaXMuYnJhbmNoVHJhbnNhY3Rpb24sIGhhc2hfMS5IYXNoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKGBUaGUgYnJhbmNoVHJhbnNhY3Rpb24gbXVzdCBiZSBzZXQgdG8gY3JlYXRlIHRyYW5zYWN0aW9uIHRyeXRlc2AsIHsgYnJhbmNoVHJhbnNhY3Rpb246IHRoaXMuYnJhbmNoVHJhbnNhY3Rpb24gfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZSh0aGlzLm5vbmNlLCB0YWdfMS5UYWcpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoYFRoZSBub25jZSBtdXN0IGJlIHNldCB0byBjcmVhdGUgdHJhbnNhY3Rpb24gdHJ5dGVzYCwgeyBub25jZTogdGhpcy5ub25jZSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdHJ5dGVzID0gdGhpcy5zaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQudG9Ucnl0ZXMoKS50b1N0cmluZygpXHJcbiAgICAgICAgICAgICsgdGhpcy5hZGRyZXNzLnRvVHJ5dGVzKCkudG9TdHJpbmcoKVxyXG4gICAgICAgICAgICArICh0aGlzLnZhbHVlIHx8IFRyYW5zYWN0aW9uLkVNUFRZXzExKS50b1RyeXRlcygpLnRvU3RyaW5nKClcclxuICAgICAgICAgICAgKyBUcmFuc2FjdGlvbi5DSEVDS19WQUxVRVxyXG4gICAgICAgICAgICArIHRoaXMub2Jzb2xldGVUYWcudG9Ucnl0ZXMoKS50b1N0cmluZygpXHJcbiAgICAgICAgICAgICsgKHRoaXMudGltZXN0YW1wIHx8IHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuRU1QVFlfOSkudG9Ucnl0ZXMoKS50b1N0cmluZygpXHJcbiAgICAgICAgICAgICsgKHRoaXMuY3VycmVudEluZGV4IHx8IHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuRU1QVFlfOSkudG9Ucnl0ZXMoKS50b1N0cmluZygpXHJcbiAgICAgICAgICAgICsgKHRoaXMubGFzdEluZGV4IHx8IHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuRU1QVFlfOSkudG9Ucnl0ZXMoKS50b1N0cmluZygpXHJcbiAgICAgICAgICAgICsgdGhpcy5idW5kbGUudG9Ucnl0ZXMoKS50b1N0cmluZygpXHJcbiAgICAgICAgICAgICsgdGhpcy50cnVua1RyYW5zYWN0aW9uLnRvVHJ5dGVzKCkudG9TdHJpbmcoKVxyXG4gICAgICAgICAgICArIHRoaXMuYnJhbmNoVHJhbnNhY3Rpb24udG9Ucnl0ZXMoKS50b1N0cmluZygpXHJcbiAgICAgICAgICAgICsgKHRoaXMudGFnIHx8IHRoaXMub2Jzb2xldGVUYWcpLnRvVHJ5dGVzKCkudG9TdHJpbmcoKVxyXG4gICAgICAgICAgICArICh0aGlzLmF0dGFjaG1lbnRUaW1lc3RhbXAgfHwgdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5FTVBUWV85KS50b1RyeXRlcygpLnRvU3RyaW5nKClcclxuICAgICAgICAgICAgKyAodGhpcy5hdHRhY2htZW50VGltZXN0YW1wTG93ZXJCb3VuZCB8fCB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLkVNUFRZXzkpLnRvVHJ5dGVzKCkudG9TdHJpbmcoKVxyXG4gICAgICAgICAgICArICh0aGlzLmF0dGFjaG1lbnRUaW1lc3RhbXBVcHBlckJvdW5kIHx8IHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuRU1QVFlfOSkudG9Ucnl0ZXMoKS50b1N0cmluZygpXHJcbiAgICAgICAgICAgICsgdGhpcy5ub25jZS50b1RyeXRlcygpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdHJ5dGVzLmxlbmd0aDtcclxuICAgICAgICBpZiAobGVuZ3RoICE9PSBUcmFuc2FjdGlvbi5MRU5HVEgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihgVGhlIHRyeXRlcyBtdXN0IGJlICR7VHJhbnNhY3Rpb24uTEVOR1RIfSBpbiBsZW5ndGggJHtsZW5ndGh9YCwgeyBsZW5ndGggfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnl0ZXNfMS5Ucnl0ZXMuZnJvbVN0cmluZyh0cnl0ZXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHN0cmluZyB2aWV3IG9mIHRoZSBvYmplY3QuXHJcbiAgICAgKiBAcmV0dXJucyBzdHJpbmcgdmlldyBvZiB0aGUgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gYHtcblxcdHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudDogXCIkeyh0aGlzLnNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudCB8fCBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRfMS5TaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQuRU1QVFkpLnRvVHJ5dGVzKCkudG9TdHJpbmcoKX1cIlxuXFx0YWRkcmVzczogXCIkeyh0aGlzLmFkZHJlc3MgfHwgYWRkcmVzc18xLkFkZHJlc3MuRU1QVFkpLnRvVHJ5dGVzKCkudG9TdHJpbmcoKX1cIlxuXFx0dmFsdWU6ICR7KHRoaXMudmFsdWUgfHwgVHJhbnNhY3Rpb24uRU1QVFlfMTEpLnRvTnVtYmVyKCl9XG5cXHRvYnNvbGV0ZVRhZzogXCIkeyh0aGlzLm9ic29sZXRlVGFnIHx8IHRhZ18xLlRhZy5FTVBUWSkudG9Ucnl0ZXMoKS50b1N0cmluZygpfVwiXG5cXHR0aW1lc3RhbXA6ICR7KHRoaXMudGltZXN0YW1wIHx8IHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuRU1QVFlfOSkudG9OdW1iZXIoKX1cblxcdGN1cnJlbnRJbmRleDogJHsodGhpcy5jdXJyZW50SW5kZXggfHwgdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5FTVBUWV85KS50b051bWJlcigpfVxuXFx0bGFzdEluZGV4OiAkeyh0aGlzLmxhc3RJbmRleCB8fCB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLkVNUFRZXzkpLnRvTnVtYmVyKCl9XG5cXHRidW5kbGU6IFwiJHsodGhpcy5idW5kbGUgfHwgaGFzaF8xLkhhc2guRU1QVFkpLnRvVHJ5dGVzKCkudG9TdHJpbmcoKX1cIlxuXFx0dHJ1bmtUcmFuc2FjdGlvbjogXCIkeyh0aGlzLnRydW5rVHJhbnNhY3Rpb24gfHwgaGFzaF8xLkhhc2guRU1QVFkpLnRvVHJ5dGVzKCkudG9TdHJpbmcoKX1cIlxuXFx0YnJhbmNoVHJhbnNhY3Rpb246IFwiJHsodGhpcy5icmFuY2hUcmFuc2FjdGlvbiB8fCBoYXNoXzEuSGFzaC5FTVBUWSkudG9Ucnl0ZXMoKS50b1N0cmluZygpfVwiXG5cXHR0YWc6IFwiJHsodGhpcy50YWcgfHwgdGhpcy5vYnNvbGV0ZVRhZyB8fCB0YWdfMS5UYWcuRU1QVFkpLnRvVHJ5dGVzKCkudG9TdHJpbmcoKX1cIlxuXFx0YXR0YWNobWVudFRpbWVzdGFtcDogJHsodGhpcy5hdHRhY2htZW50VGltZXN0YW1wIHx8IHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuRU1QVFlfOSkudG9OdW1iZXIoKX1cblxcdGF0dGFjaG1lbnRUaW1lc3RhbXBMb3dlckJvdW5kOiAkeyh0aGlzLmF0dGFjaG1lbnRUaW1lc3RhbXBMb3dlckJvdW5kIHx8IHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuRU1QVFlfOSkudG9OdW1iZXIoKX1cblxcdGF0dGFjaG1lbnRUaW1lc3RhbXBVcHBlckJvdW5kOiAkeyh0aGlzLmF0dGFjaG1lbnRUaW1lc3RhbXBVcHBlckJvdW5kIHx8IHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuRU1QVFlfOSkudG9OdW1iZXIoKX1cblxcdG5vbmNlOiBcIiR7KHRoaXMubm9uY2UgfHwgdGFnXzEuVGFnLkVNUFRZKS50b1RyeXRlcygpLnRvU3RyaW5nKCl9XCJcbn1gO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGUgbGVuZ3RoIG9mIGEgdmFsaWQgdHJhbnNhY3Rpb24gKDI2NzMpLlxyXG4gKi9cclxuVHJhbnNhY3Rpb24uTEVOR1RIID0gMjY3MztcclxuLyoqXHJcbiAqIFRoZSBsZW5ndGggb2YgYSB2YWxpZCBjaGVjayB2YWx1ZSAoMTYpLlxyXG4gKi9cclxuVHJhbnNhY3Rpb24uQ0hFQ0tfVkFMVUVfTEVOR1RIID0gMTY7XHJcbi8qKlxyXG4gKiBUaGUgY2hlY2sgdmFsdWUgZm9yIGJ1bmRsZXMgYWxsIDlzLlxyXG4gKi9cclxuVHJhbnNhY3Rpb24uQ0hFQ0tfVkFMVUUgPSBcIjlcIi5yZXBlYXQoVHJhbnNhY3Rpb24uQ0hFQ0tfVkFMVUVfTEVOR1RIKTtcclxuLyogQGludGVybmFsICovXHJcblRyYW5zYWN0aW9uLkVNUFRZXzExID0gdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5mcm9tTnVtYmVyKDAsIDExKTtcclxuZXhwb3J0cy5UcmFuc2FjdGlvbiA9IFRyYW5zYWN0aW9uO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lkSEpoYm5OaFkzUnBiMjR1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTh1TGk5emNtTXZaR0YwWVM5MGNtRnVjMkZqZEdsdmJpNTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPMEZCUVVFc05FVkJRWGxGTzBGQlEzcEZMR3RFUVVFclF6dEJRVU12UXl4MVEwRkJiME03UVVGRGNFTXNhVU5CUVRoQ08wRkJRemxDTEhsRlFVRnpSVHRCUVVOMFJTd3JRa0ZCTkVJN1FVRkROVUlzSzBOQlFUUkRPMEZCUXpWRExIRkRRVUZyUXp0QlFVVnNRenM3UjBGRlJ6dEJRVU5JTzBsQlowWkpMR1ZCUVdVN1NVRkRaanRKUVVOQkxFTkJRVU03U1VGRlJEczdPenM3T3pzN096czdPenM3T3pzN08wOUJhMEpITzBsQlEwa3NUVUZCVFN4RFFVRkRMRlZCUVZVc1EwRkJReXgzUWtGQmEwUXNSVUZEYkVRc1QwRkJaMElzUlVGRGFFSXNTMEZCWVN4RlFVTmlMRmRCUVdkQ0xFVkJRMmhDTEZOQlFXbENMRVZCUTJwQ0xGbEJRVzlDTEVWQlEzQkNMRk5CUVdsQ0xFVkJRMnBDTEUxQlFWa3NSVUZEV2l4blFrRkJjMElzUlVGRGRFSXNhVUpCUVhWQ0xFVkJRM1pDTEVkQlFWRXNSVUZEVWl4dFFrRkJNa0lzUlVGRE0wSXNOa0pCUVhGRExFVkJRM0pETERaQ1FVRnhReXhGUVVOeVF5eExRVUZWTzFGQlF5OUNMRTFCUVUwc1JVRkJSU3hIUVVGSExFbEJRVWtzVjBGQlZ5eEZRVUZGTEVOQlFVTTdVVUZETjBJc1JVRkJSU3hEUVVGRExIZENRVUYzUWl4SFFVRkhMSGRDUVVGM1FpeERRVUZETzFGQlEzWkVMRVZCUVVVc1EwRkJReXhQUVVGUExFZEJRVWNzVDBGQlR5eERRVUZETzFGQlEzSkNMRVZCUVVVc1EwRkJReXhMUVVGTExFZEJRVWNzZVVKQlFWY3NRMEZCUXl4VlFVRlZMRU5CUVVNc1MwRkJTeXhGUVVGRkxFVkJRVVVzUTBGQlF5eERRVUZETzFGQlF6ZERMRVZCUVVVc1EwRkJReXhYUVVGWExFZEJRVWNzVjBGQlZ5eERRVUZETzFGQlF6ZENMRVZCUVVVc1EwRkJReXhUUVVGVExFZEJRVWNzZVVKQlFWY3NRMEZCUXl4VlFVRlZMRU5CUVVNc1UwRkJVeXhEUVVGRExFTkJRVU03VVVGRGFrUXNSVUZCUlN4RFFVRkRMRmxCUVZrc1IwRkJSeXg1UWtGQlZ5eERRVUZETEZWQlFWVXNRMEZCUXl4WlFVRlpMRU5CUVVNc1EwRkJRenRSUVVOMlJDeEZRVUZGTEVOQlFVTXNVMEZCVXl4SFFVRkhMSGxDUVVGWExFTkJRVU1zVlVGQlZTeERRVUZETEZOQlFWTXNRMEZCUXl4RFFVRkRPMUZCUTJwRUxFVkJRVVVzUTBGQlF5eE5RVUZOTEVkQlFVY3NUVUZCVFN4RFFVRkRPMUZCUTI1Q0xFVkJRVVVzUTBGQlF5eG5Ra0ZCWjBJc1IwRkJSeXhuUWtGQlowSXNRMEZCUXp0UlFVTjJReXhGUVVGRkxFTkJRVU1zYVVKQlFXbENMRWRCUVVjc2FVSkJRV2xDTEVOQlFVTTdVVUZEZWtNc1JVRkJSU3hEUVVGRExFZEJRVWNzUjBGQlJ5eEhRVUZITEVOQlFVTTdVVUZEWWl4RlFVRkZMRU5CUVVNc2JVSkJRVzFDTEVkQlFVY3NlVUpCUVZjc1EwRkJReXhWUVVGVkxFTkJRVU1zYlVKQlFXMUNMRU5CUVVNc1EwRkJRenRSUVVOeVJTeEZRVUZGTEVOQlFVTXNOa0pCUVRaQ0xFZEJRVWNzZVVKQlFWY3NRMEZCUXl4VlFVRlZMRU5CUVVNc05rSkJRVFpDTEVOQlFVTXNRMEZCUXp0UlFVTjZSaXhGUVVGRkxFTkJRVU1zTmtKQlFUWkNMRWRCUVVjc2VVSkJRVmNzUTBGQlF5eFZRVUZWTEVOQlFVTXNOa0pCUVRaQ0xFTkJRVU1zUTBGQlF6dFJRVU42Uml4RlFVRkZMRU5CUVVNc1MwRkJTeXhIUVVGSExFdEJRVXNzUTBGQlF6dFJRVU5xUWl4UFFVRlBMRVZCUVVVc1EwRkJRenRKUVVOa0xFTkJRVU03U1VGRlJEczdPenRQUVVsSE8wbEJRMGtzVFVGQlRTeERRVUZETEZWQlFWVXNRMEZCUXl4TlFVRmpPMUZCUTI1RExFbEJRVWtzUTBGQlF5d3lRa0ZCV1N4RFFVRkRMRTFCUVUwc1EwRkJReXhOUVVGTkxFVkJRVVVzWlVGQlRTeERRVUZETEVWQlFVVTdXVUZEZEVNc1RVRkJUU3hKUVVGSkxIRkNRVUZUTEVOQlFVTXNORU5CUVRSRExFTkJRVU1zUTBGQlF6dFRRVU55UlR0UlFVVkVMRTFCUVUwc1RVRkJUU3hIUVVGSExFMUJRVTBzUTBGQlF5eE5RVUZOTEVWQlFVVXNRMEZCUXp0UlFVTXZRaXhKUVVGSkxFMUJRVTBzUzBGQlN5eFhRVUZYTEVOQlFVTXNUVUZCVFN4RlFVRkZPMWxCUXk5Q0xFMUJRVTBzU1VGQlNTeHhRa0ZCVXl4RFFVRkRMSE5DUVVGelFpeFhRVUZYTEVOQlFVTXNUVUZCVFN4WlFVRlpMRVZCUVVVc1JVRkJSU3hOUVVGTkxFVkJRVVVzUTBGQlF5eERRVUZETzFOQlEzcEdPMUZCUlVRc1RVRkJUU3hsUVVGbExFZEJRVWNzU1VGQlNTeERRVUZETzFGQlF6ZENMRTFCUVUwc1owSkJRV2RDTEVkQlFVY3NSVUZCUlN4RFFVRkRPMUZCUXpWQ0xFMUJRVTBzUzBGQlN5eEhRVUZITEUxQlFVMHNRMEZCUXl4SFFVRkhMRU5CUVVNc1pVRkJaU3hGUVVGRkxHZENRVUZuUWl4RFFVRkRMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVU03VVVGRmRrVXNTVUZCU1N4TFFVRkxMRXRCUVVzc1YwRkJWeXhEUVVGRExGZEJRVmNzUlVGQlJUdFpRVU51UXl4TlFVRk5MRWxCUVVrc2NVSkJRVk1zUTBGQlF5eHpRa0ZCYzBJc1pVRkJaU3hSUVVGUkxHVkJRV1VzUjBGQlJ5eG5Ra0ZCWjBJc2JVSkJRVzFDTEVWQlFVVXNSVUZCUlN4TFFVRkxMRVZCUVVVc1EwRkJReXhEUVVGRE8xTkJRM1JKTzFGQlJVUXNUVUZCVFN4RlFVRkZMRWRCUVVjc1NVRkJTU3hYUVVGWExFVkJRVVVzUTBGQlF6dFJRVVUzUWl4SlFVRkpMRkZCUVZFc1IwRkJSeXhEUVVGRExFTkJRVU03VVVGRGFrSXNSVUZCUlN4RFFVRkRMSGRDUVVGM1FpeEhRVUZITEcxRVFVRjNRaXhEUVVGRExGVkJRVlVzUTBGQlF5eE5RVUZOTEVOQlFVTXNSMEZCUnl4RFFVRkRMRkZCUVZFc1JVRkJSU3h0UkVGQmQwSXNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRM3BJTEZGQlFWRXNTVUZCU1N4dFJFRkJkMElzUTBGQlF5eE5RVUZOTEVOQlFVTTdVVUZETlVNc1JVRkJSU3hEUVVGRExFOUJRVThzUjBGQlJ5eHBRa0ZCVHl4RFFVRkRMRlZCUVZVc1EwRkJReXhOUVVGTkxFTkJRVU1zUjBGQlJ5eERRVUZETEZGQlFWRXNSVUZCUlN4cFFrRkJUeXhEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEZEVVc1VVRkJVU3hKUVVGSkxHbENRVUZQTEVOQlFVTXNUVUZCVFN4RFFVRkRPMUZCUXpOQ0xFVkJRVVVzUTBGQlF5eExRVUZMTEVkQlFVY3NlVUpCUVZjc1EwRkJReXhWUVVGVkxFTkJRVU1zVFVGQlRTeERRVUZETEVkQlFVY3NRMEZCUXl4UlFVRlJMRVZCUVVVc1JVRkJSU3hEUVVGRExFVkJRVVVzUlVGQlJTeERRVUZETEVOQlFVTTdVVUZEYUVVc1VVRkJVU3hKUVVGSkxFVkJRVVVzUTBGQlF6dFJRVU5tTEZGQlFWRXNTVUZCU1N4WFFVRlhMRU5CUVVNc2EwSkJRV3RDTEVOQlFVTTdVVUZETTBNc1JVRkJSU3hEUVVGRExGZEJRVmNzUjBGQlJ5eFRRVUZITEVOQlFVTXNWVUZCVlN4RFFVRkRMRTFCUVUwc1EwRkJReXhIUVVGSExFTkJRVU1zVVVGQlVTeEZRVUZGTEZOQlFVY3NRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMnhGTEZGQlFWRXNTVUZCU1N4VFFVRkhMRU5CUVVNc1RVRkJUU3hEUVVGRE8xRkJRM1pDTEVWQlFVVXNRMEZCUXl4VFFVRlRMRWRCUVVjc2VVSkJRVmNzUTBGQlF5eFZRVUZWTEVOQlFVTXNUVUZCVFN4RFFVRkRMRWRCUVVjc1EwRkJReXhSUVVGUkxFVkJRVVVzZVVKQlFWY3NRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMnhHTEZGQlFWRXNTVUZCU1N4NVFrRkJWeXhEUVVGRExGRkJRVkVzUTBGQlF6dFJRVU5xUXl4RlFVRkZMRU5CUVVNc1dVRkJXU3hIUVVGSExIbENRVUZYTEVOQlFVTXNWVUZCVlN4RFFVRkRMRTFCUVUwc1EwRkJReXhIUVVGSExFTkJRVU1zVVVGQlVTeEZRVUZGTEhsQ1FVRlhMRU5CUVVNc1VVRkJVU3hEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU55Uml4UlFVRlJMRWxCUVVrc2VVSkJRVmNzUTBGQlF5eFJRVUZSTEVOQlFVTTdVVUZEYWtNc1JVRkJSU3hEUVVGRExGTkJRVk1zUjBGQlJ5eDVRa0ZCVnl4RFFVRkRMRlZCUVZVc1EwRkJReXhOUVVGTkxFTkJRVU1zUjBGQlJ5eERRVUZETEZGQlFWRXNSVUZCUlN4NVFrRkJWeXhEUVVGRExGRkJRVkVzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEYkVZc1VVRkJVU3hKUVVGSkxIbENRVUZYTEVOQlFVTXNVVUZCVVN4RFFVRkRPMUZCUTJwRExFVkJRVVVzUTBGQlF5eE5RVUZOTEVkQlFVY3NWMEZCU1N4RFFVRkRMRlZCUVZVc1EwRkJReXhOUVVGTkxFTkJRVU1zUjBGQlJ5eERRVUZETEZGQlFWRXNSVUZCUlN4WFFVRkpMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU12UkN4UlFVRlJMRWxCUVVrc1YwRkJTU3hEUVVGRExFMUJRVTBzUTBGQlF6dFJRVU40UWl4RlFVRkZMRU5CUVVNc1owSkJRV2RDTEVkQlFVY3NWMEZCU1N4RFFVRkRMRlZCUVZVc1EwRkJReXhOUVVGTkxFTkJRVU1zUjBGQlJ5eERRVUZETEZGQlFWRXNSVUZCUlN4WFFVRkpMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU42UlN4UlFVRlJMRWxCUVVrc1YwRkJTU3hEUVVGRExFMUJRVTBzUTBGQlF6dFJRVU40UWl4RlFVRkZMRU5CUVVNc2FVSkJRV2xDTEVkQlFVY3NWMEZCU1N4RFFVRkRMRlZCUVZVc1EwRkJReXhOUVVGTkxFTkJRVU1zUjBGQlJ5eERRVUZETEZGQlFWRXNSVUZCUlN4WFFVRkpMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU14UlN4UlFVRlJMRWxCUVVrc1YwRkJTU3hEUVVGRExFMUJRVTBzUTBGQlF6dFJRVU40UWl4RlFVRkZMRU5CUVVNc1IwRkJSeXhIUVVGSExGTkJRVWNzUTBGQlF5eFZRVUZWTEVOQlFVTXNUVUZCVFN4RFFVRkRMRWRCUVVjc1EwRkJReXhSUVVGUkxFVkJRVVVzVTBGQlJ5eERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRNVVFzVVVGQlVTeEpRVUZKTEZOQlFVY3NRMEZCUXl4TlFVRk5MRU5CUVVNN1VVRkRka0lzUlVGQlJTeERRVUZETEcxQ1FVRnRRaXhIUVVGSExIbENRVUZYTEVOQlFVTXNWVUZCVlN4RFFVRkRMRTFCUVUwc1EwRkJReXhIUVVGSExFTkJRVU1zVVVGQlVTeEZRVUZGTEhsQ1FVRlhMRU5CUVVNc1VVRkJVU3hEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU0xUml4UlFVRlJMRWxCUVVrc2VVSkJRVmNzUTBGQlF5eFJRVUZSTEVOQlFVTTdVVUZEYWtNc1JVRkJSU3hEUVVGRExEWkNRVUUyUWl4SFFVRkhMSGxDUVVGWExFTkJRVU1zVlVGQlZTeERRVUZETEUxQlFVMHNRMEZCUXl4SFFVRkhMRU5CUVVNc1VVRkJVU3hGUVVGRkxIbENRVUZYTEVOQlFVTXNVVUZCVVN4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOMFJ5eFJRVUZSTEVsQlFVa3NlVUpCUVZjc1EwRkJReXhSUVVGUkxFTkJRVU03VVVGRGFrTXNSVUZCUlN4RFFVRkRMRFpDUVVFMlFpeEhRVUZITEhsQ1FVRlhMRU5CUVVNc1ZVRkJWU3hEUVVGRExFMUJRVTBzUTBGQlF5eEhRVUZITEVOQlFVTXNVVUZCVVN4RlFVRkZMSGxDUVVGWExFTkJRVU1zVVVGQlVTeERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTjBSeXhSUVVGUkxFbEJRVWtzZVVKQlFWY3NRMEZCUXl4UlFVRlJMRU5CUVVNN1VVRkRha01zUlVGQlJTeERRVUZETEV0QlFVc3NSMEZCUnl4VFFVRkhMRU5CUVVNc1ZVRkJWU3hEUVVGRExFMUJRVTBzUTBGQlF5eEhRVUZITEVOQlFVTXNVVUZCVVN4RlFVRkZMRk5CUVVjc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETzFGQlJUVkVMRTlCUVU4c1JVRkJSU3hEUVVGRE8wbEJRMlFzUTBGQlF6dEpRVVZFT3pzN1QwRkhSenRKUVVOSkxGRkJRVkU3VVVGRFdDeEpRVUZKTEVOQlFVTXNNa0pCUVZrc1EwRkJReXhOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEhkQ1FVRjNRaXhGUVVGRkxHMUVRVUYzUWl4RFFVRkRMRVZCUVVVN1dVRkRMMFVzVFVGQlRTeEpRVUZKTEhGQ1FVRlRMRU5CUVVNc2RVVkJRWFZGTEVWQlFVVXNSVUZCUlN4M1FrRkJkMElzUlVGQlJTeEpRVUZKTEVOQlFVTXNkMEpCUVhkQ0xFVkJRVVVzUTBGQlF5eERRVUZETzFOQlF6ZEtPMUZCUlVRc1NVRkJTU3hEUVVGRExESkNRVUZaTEVOQlFVTXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhQUVVGUExFVkJRVVVzYVVKQlFVOHNRMEZCUXl4RlFVRkZPMWxCUXpkRExFMUJRVTBzU1VGQlNTeHhRa0ZCVXl4RFFVRkRMSE5FUVVGelJDeEZRVUZGTEVWQlFVVXNUMEZCVHl4RlFVRkZMRWxCUVVrc1EwRkJReXhQUVVGUExFVkJRVVVzUTBGQlF5eERRVUZETzFOQlF6RkhPMUZCUlVRc1NVRkJTU3hEUVVGRExESkNRVUZaTEVOQlFVTXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhYUVVGWExFVkJRVVVzVTBGQlJ5eERRVUZETEVWQlFVVTdXVUZETjBNc1RVRkJUU3hKUVVGSkxIRkNRVUZUTEVOQlFVTXNNRVJCUVRCRUxFVkJRVVVzUlVGQlJTeFhRVUZYTEVWQlFVVXNTVUZCU1N4RFFVRkRMRmRCUVZjc1JVRkJSU3hEUVVGRExFTkJRVU03VTBGRGRFZzdVVUZGUkN4SlFVRkpMRU5CUVVNc01rSkJRVmtzUTBGQlF5eE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRTFCUVUwc1JVRkJSU3hYUVVGSkxFTkJRVU1zUlVGQlJUdFpRVU42UXl4TlFVRk5MRWxCUVVrc2NVSkJRVk1zUTBGQlF5eHhSRUZCY1VRc1JVRkJSU3hGUVVGRkxFMUJRVTBzUlVGQlJTeEpRVUZKTEVOQlFVTXNUVUZCVFN4RlFVRkZMRU5CUVVNc1EwRkJRenRUUVVOMlJ6dFJRVVZFTEVsQlFVa3NRMEZCUXl3eVFrRkJXU3hEUVVGRExFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNaMEpCUVdkQ0xFVkJRVVVzVjBGQlNTeERRVUZETEVWQlFVVTdXVUZEYmtRc1RVRkJUU3hKUVVGSkxIRkNRVUZUTEVOQlFVTXNLMFJCUVN0RUxFVkJRVVVzUlVGQlJTeG5Ra0ZCWjBJc1JVRkJSU3hKUVVGSkxFTkJRVU1zWjBKQlFXZENMRVZCUVVVc1EwRkJReXhEUVVGRE8xTkJRM0pKTzFGQlJVUXNTVUZCU1N4RFFVRkRMREpDUVVGWkxFTkJRVU1zVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4cFFrRkJhVUlzUlVGQlJTeFhRVUZKTEVOQlFVTXNSVUZCUlR0WlFVTndSQ3hOUVVGTkxFbEJRVWtzY1VKQlFWTXNRMEZCUXl4blJVRkJaMFVzUlVGQlJTeEZRVUZGTEdsQ1FVRnBRaXhGUVVGRkxFbEJRVWtzUTBGQlF5eHBRa0ZCYVVJc1JVRkJSU3hEUVVGRExFTkJRVU03VTBGRGVFazdVVUZGUkN4SlFVRkpMRU5CUVVNc01rSkJRVmtzUTBGQlF5eE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRXRCUVVzc1JVRkJSU3hUUVVGSExFTkJRVU1zUlVGQlJUdFpRVU4yUXl4TlFVRk5MRWxCUVVrc2NVSkJRVk1zUTBGQlF5eHZSRUZCYjBRc1JVRkJSU3hGUVVGRkxFdEJRVXNzUlVGQlJTeEpRVUZKTEVOQlFVTXNTMEZCU3l4RlFVRkZMRU5CUVVNc1EwRkJRenRUUVVOd1J6dFJRVVZFTEUxQlFVMHNUVUZCVFN4SFFVRkhMRWxCUVVrc1EwRkJReXgzUWtGQmQwSXNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJReXhSUVVGUkxFVkJRVVU3WTBGRE5VUXNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF5eFJRVUZSTEVWQlFVVTdZMEZEYkVNc1EwRkJReXhKUVVGSkxFTkJRVU1zUzBGQlN5eEpRVUZKTEZkQlFWY3NRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF5eFJRVUZSTEVWQlFVVTdZMEZETVVRc1YwRkJWeXhEUVVGRExGZEJRVmM3WTBGRGRrSXNTVUZCU1N4RFFVRkRMRmRCUVZjc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF5eFJRVUZSTEVWQlFVVTdZMEZEZEVNc1EwRkJReXhKUVVGSkxFTkJRVU1zVTBGQlV5eEpRVUZKTEhsQ1FVRlhMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVTXNVVUZCVVN4RlFVRkZPMk5CUXpkRUxFTkJRVU1zU1VGQlNTeERRVUZETEZsQlFWa3NTVUZCU1N4NVFrRkJWeXhEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRMRkZCUVZFc1JVRkJSVHRqUVVOb1JTeERRVUZETEVsQlFVa3NRMEZCUXl4VFFVRlRMRWxCUVVrc2VVSkJRVmNzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJReXhSUVVGUkxFVkJRVVU3WTBGRE4wUXNTVUZCU1N4RFFVRkRMRTFCUVUwc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF5eFJRVUZSTEVWQlFVVTdZMEZEYWtNc1NVRkJTU3hEUVVGRExHZENRVUZuUWl4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRExGRkJRVkVzUlVGQlJUdGpRVU16UXl4SlFVRkpMRU5CUVVNc2FVSkJRV2xDTEVOQlFVTXNVVUZCVVN4RlFVRkZMRU5CUVVNc1VVRkJVU3hGUVVGRk8yTkJRelZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRWRCUVVjc1NVRkJTU3hKUVVGSkxFTkJRVU1zVjBGQlZ5eERRVUZETEVOQlFVTXNVVUZCVVN4RlFVRkZMRU5CUVVNc1VVRkJVU3hGUVVGRk8yTkJRM0JFTEVOQlFVTXNTVUZCU1N4RFFVRkRMRzFDUVVGdFFpeEpRVUZKTEhsQ1FVRlhMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVTXNVVUZCVVN4RlFVRkZPMk5CUTNaRkxFTkJRVU1zU1VGQlNTeERRVUZETERaQ1FVRTJRaXhKUVVGSkxIbENRVUZYTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVU1zVVVGQlVTeEZRVUZGTzJOQlEycEdMRU5CUVVNc1NVRkJTU3hEUVVGRExEWkNRVUUyUWl4SlFVRkpMSGxDUVVGWExFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTXNVVUZCVVN4RlFVRkZMRU5CUVVNc1VVRkJVU3hGUVVGRk8yTkJRMnBHTEVsQlFVa3NRMEZCUXl4TFFVRkxMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVTTdVVUZGZGtNc1RVRkJUU3hOUVVGTkxFZEJRVWNzVFVGQlRTeERRVUZETEUxQlFVMHNRMEZCUXp0UlFVTTNRaXhKUVVGSkxFMUJRVTBzUzBGQlN5eFhRVUZYTEVOQlFVTXNUVUZCVFN4RlFVRkZPMWxCUXk5Q0xFMUJRVTBzU1VGQlNTeHhRa0ZCVXl4RFFVRkRMSE5DUVVGelFpeFhRVUZYTEVOQlFVTXNUVUZCVFN4alFVRmpMRTFCUVUwc1JVRkJSU3hGUVVGRkxFVkJRVVVzVFVGQlRTeEZRVUZGTEVOQlFVTXNRMEZCUXp0VFFVTnVSenRSUVVWRUxFOUJRVThzWlVGQlRTeERRVUZETEZWQlFWVXNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJRenRKUVVOeVF5eERRVUZETzBsQlJVUTdPenRQUVVkSE8wbEJRMGtzVVVGQlVUdFJRVU5ZTEU5QlFVODdLMEpCUTJkQ0xFTkJRVU1zU1VGQlNTeERRVUZETEhkQ1FVRjNRaXhKUVVGSkxHMUVRVUYzUWl4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETEZGQlFWRXNSVUZCUlR0alFVTjRSeXhEUVVGRExFbEJRVWtzUTBGQlF5eFBRVUZQTEVsQlFVa3NhVUpCUVU4c1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXl4UlFVRlJMRVZCUVVVN1YwRkRlRVFzUTBGQlF5eEpRVUZKTEVOQlFVTXNTMEZCU3l4SlFVRkpMRmRCUVZjc1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF5eFJRVUZSTEVWQlFVVTdhMEpCUTNoRExFTkJRVU1zU1VGQlNTeERRVUZETEZkQlFWY3NTVUZCU1N4VFFVRkhMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVTXNVVUZCVVN4RlFVRkZPMlZCUTNoRUxFTkJRVU1zU1VGQlNTeERRVUZETEZOQlFWTXNTVUZCU1N4NVFrRkJWeXhEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEZGQlFWRXNSVUZCUlR0clFrRkRMME1zUTBGQlF5eEpRVUZKTEVOQlFVTXNXVUZCV1N4SlFVRkpMSGxDUVVGWExFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTXNVVUZCVVN4RlFVRkZPMlZCUTNoRUxFTkJRVU1zU1VGQlNTeERRVUZETEZOQlFWTXNTVUZCU1N4NVFrRkJWeXhEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEZGQlFWRXNSVUZCUlR0aFFVTndSQ3hEUVVGRExFbEJRVWtzUTBGQlF5eE5RVUZOTEVsQlFVa3NWMEZCU1N4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETEZGQlFWRXNSVUZCUlR0MVFrRkRka01zUTBGQlF5eEpRVUZKTEVOQlFVTXNaMEpCUVdkQ0xFbEJRVWtzVjBGQlNTeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRExGRkJRVkVzUlVGQlJUdDNRa0ZETVVRc1EwRkJReXhKUVVGSkxFTkJRVU1zYVVKQlFXbENMRWxCUVVrc1YwRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRMRkZCUVZFc1JVRkJSVHRWUVVNeFJTeERRVUZETEVsQlFVa3NRMEZCUXl4SFFVRkhMRWxCUVVrc1NVRkJTU3hEUVVGRExGZEJRVmNzU1VGQlNTeFRRVUZITEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVU1zVVVGQlVTeEZRVUZGTzNsQ1FVTnNSQ3hEUVVGRExFbEJRVWtzUTBGQlF5eHRRa0ZCYlVJc1NVRkJTU3g1UWtGQlZ5eERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRMRkZCUVZFc1JVRkJSVHR0UTBGRGJFUXNRMEZCUXl4SlFVRkpMRU5CUVVNc05rSkJRVFpDTEVsQlFVa3NlVUpCUVZjc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF5eFJRVUZSTEVWQlFVVTdiVU5CUTNSRkxFTkJRVU1zU1VGQlNTeERRVUZETERaQ1FVRTJRaXhKUVVGSkxIbENRVUZYTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNc1VVRkJVU3hGUVVGRk8xbEJRemRHTEVOQlFVTXNTVUZCU1N4RFFVRkRMRXRCUVVzc1NVRkJTU3hUUVVGSExFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNVVUZCVVN4RlFVRkZMRU5CUVVNc1VVRkJVU3hGUVVGRk8wVkJRM3BFTEVOQlFVTTdTVUZEUXl4RFFVRkRPenRCUVhCU1JEczdSMEZGUnp0QlFVTnZRaXhyUWtGQlRTeEhRVUZYTEVsQlFVa3NRMEZCUXp0QlFVVTNRenM3UjBGRlJ6dEJRVU52UWl3NFFrRkJhMElzUjBGQlZ5eEZRVUZGTEVOQlFVTTdRVUZGZGtRN08wZEJSVWM3UVVGRGIwSXNkVUpCUVZjc1IwRkJWeXhIUVVGSExFTkJRVU1zVFVGQlRTeERRVUZETEZkQlFWY3NRMEZCUXl4clFrRkJhMElzUTBGQlF5eERRVUZETzBGQlJYaEdMR1ZCUVdVN1FVRkRVeXh2UWtGQlVTeEhRVUZuUWl4NVFrRkJWeXhEUVVGRExGVkJRVlVzUTBGQlF5eERRVUZETEVWQlFVVXNSVUZCUlN4RFFVRkRMRU5CUVVNN1FVRnFRbXhHTEd0RFFYTlNReUo5IiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBhcnJheUhlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvYXJyYXlIZWxwZXJcIik7XHJcbmNvbnN0IG51bWJlckhlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvbnVtYmVySGVscGVyXCIpO1xyXG5jb25zdCBvYmplY3RIZWxwZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlclwiKTtcclxuY29uc3QgZGF0YUVycm9yXzEgPSByZXF1aXJlKFwiLi4vZXJyb3IvZGF0YUVycm9yXCIpO1xyXG5jb25zdCB0cnl0ZXNfMSA9IHJlcXVpcmUoXCIuL3RyeXRlc1wiKTtcclxuLyoqXHJcbiAqIEEgY2xhc3MgZm9yIGhhbmRsaW5nIHRyaXRzLlxyXG4gKi9cclxuY2xhc3MgVHJpdHMge1xyXG4gICAgLyogQGludGVybmFsICovXHJcbiAgICBjb25zdHJ1Y3Rvcih0cml0cykge1xyXG4gICAgICAgIHRoaXMuX3RyaXRzID0gdHJpdHM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBpbnN0YW5jZSBvZiB0cml0cyBmcm9tIEludDhBcnJheSBhcnJheS5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBUcnl0ZXMgdXNlZCB0byBjcmVhdGUgdHJpdHMuXHJcbiAgICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBUcml0cy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21BcnJheSh2YWx1ZSkge1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZSh2YWx1ZSwgSW50OEFycmF5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFwiVGhlIHZhbHVlIGRvZXMgbm90IGNvbnRhaW4gdmFsaWQgdHJpdHNcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgVHJpdHModmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgaW5zdGFuY2Ugb2YgdHJpdHMgZnJvbSBudW1iZXIgYXJyYXkuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVHJ5dGVzIHVzZWQgdG8gY3JlYXRlIHRyaXRzLlxyXG4gICAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgVHJpdHMuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tTnVtYmVyQXJyYXkodmFsdWUpIHtcclxuICAgICAgICBpZiAoIWFycmF5SGVscGVyXzEuQXJyYXlIZWxwZXIuaXNUeXBlZCh2YWx1ZSwgTnVtYmVyKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFwiVGhlIHZhbHVlIGRvZXMgbm90IGNvbnRhaW4gdmFsaWQgdHJpdHNcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgVHJpdHMobmV3IEludDhBcnJheSh2YWx1ZSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgaW5zdGFuY2Ugb2YgdHJpdHMgZnJvbSB0cnl0ZXMuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVHJ5dGVzIHVzZWQgdG8gY3JlYXRlIHRyaXRzLlxyXG4gICAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgVHJpdHMuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tVHJ5dGVzKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHZhbHVlLCB0cnl0ZXNfMS5Ucnl0ZXMpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXCJUaGUgdmFsdWUgc2hvdWxkIGJlIGEgdmFsaWQgVHJ5dGVzIG9iamVjdFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdHJ5dGVzU3RyaW5nID0gdmFsdWUudG9TdHJpbmcoKTtcclxuICAgICAgICBjb25zdCB0cml0cyA9IG5ldyBJbnQ4QXJyYXkodHJ5dGVzU3RyaW5nLmxlbmd0aCAqIDMpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJ5dGVzU3RyaW5nLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkeCA9IHRyeXRlc18xLlRyeXRlcy5BTFBIQUJFVC5pbmRleE9mKHRyeXRlc1N0cmluZy5jaGFyQXQoaSkpO1xyXG4gICAgICAgICAgICB0cml0c1tpICogM10gPSBUcml0cy5UUllURVNfVFJJVFNbaWR4XVswXTtcclxuICAgICAgICAgICAgdHJpdHNbaSAqIDMgKyAxXSA9IFRyaXRzLlRSWVRFU19UUklUU1tpZHhdWzFdO1xyXG4gICAgICAgICAgICB0cml0c1tpICogMyArIDJdID0gVHJpdHMuVFJZVEVTX1RSSVRTW2lkeF1bMl07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgVHJpdHModHJpdHMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgaW5zdGFuY2Ugb2YgdHJpdHMgZnJvbSBudW1iZXJcclxuICAgICAqIEBwYXJhbSB2YWx1ZSBOdW1iZXIgdXNlZCB0byBjcmVhdGUgdHJpdHMuXHJcbiAgICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBUcml0cy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21OdW1iZXIodmFsdWUpIHtcclxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXCJUaGUgdmFsdWUgaXMgbm90IGFuIGludGVnZXJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRyaXRzID0gW107XHJcbiAgICAgICAgbGV0IGFic29sdXRlVmFsdWUgPSB2YWx1ZSA8IDAgPyAtdmFsdWUgOiB2YWx1ZTtcclxuICAgICAgICB3aGlsZSAoYWJzb2x1dGVWYWx1ZSA+IDApIHtcclxuICAgICAgICAgICAgbGV0IHJlbWFpbmRlciA9IGFic29sdXRlVmFsdWUgJSAzO1xyXG4gICAgICAgICAgICBhYnNvbHV0ZVZhbHVlID0gTWF0aC5mbG9vcihhYnNvbHV0ZVZhbHVlIC8gMyk7XHJcbiAgICAgICAgICAgIGlmIChyZW1haW5kZXIgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICByZW1haW5kZXIgPSAtMTtcclxuICAgICAgICAgICAgICAgIGFic29sdXRlVmFsdWUrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0cml0c1t0cml0cy5sZW5ndGhdID0gcmVtYWluZGVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmFsdWUgPCAwKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJpdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRyaXRzW2ldID0gLXRyaXRzW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgVHJpdHMobmV3IEludDhBcnJheSh0cml0cykpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgdHdvIHRyaXRzIHRvZ2V0aGVyLlxyXG4gICAgICogQHBhcmFtIGZpcnN0IFRoZSBmaXJzdCB0cml0LlxyXG4gICAgICogQHBhcmFtIHNlY29uZCBUaGUgc2Vjb25kIHRyaXQuXHJcbiAgICAgKiBAcmV0dXJucyBOZXcgdHJpdCB3aGljaCBpcyB0aGUgYWRkaXRpb24gb2YgdGhlIGEgKyBiLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYWRkKGZpcnN0LCBzZWNvbmQpIHtcclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUoZmlyc3QsIFRyaXRzKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFwiVGhlIGZpcnN0IHNob3VsZCBiZSBhIHZhbGlkIFRyaXRzIG9iamVjdFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHNlY29uZCwgVHJpdHMpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXCJUaGUgc2Vjb25kcyBzaG91bGQgYmUgYSB2YWxpZCBUcml0cyBvYmplY3RcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG91dCA9IG5ldyBJbnQ4QXJyYXkoTWF0aC5tYXgoZmlyc3QuX3RyaXRzLmxlbmd0aCwgc2Vjb25kLl90cml0cy5sZW5ndGgpKTtcclxuICAgICAgICBsZXQgY2FycnkgPSAwO1xyXG4gICAgICAgIGxldCBpQTtcclxuICAgICAgICBsZXQgaUI7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaUEgPSBpIDwgZmlyc3QuX3RyaXRzLmxlbmd0aCA/IGZpcnN0Ll90cml0c1tpXSA6IDA7XHJcbiAgICAgICAgICAgIGlCID0gaSA8IHNlY29uZC5fdHJpdHMubGVuZ3RoID8gc2Vjb25kLl90cml0c1tpXSA6IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IGZBID0gVHJpdHMuZnVsbEFkZChpQSwgaUIsIGNhcnJ5KTtcclxuICAgICAgICAgICAgb3V0W2ldID0gZkFbMF07XHJcbiAgICAgICAgICAgIGNhcnJ5ID0gZkFbMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBUcml0cy5mcm9tQXJyYXkob3V0KTtcclxuICAgIH1cclxuICAgIC8qIEBpbnRlcm5hbCAqL1xyXG4gICAgc3RhdGljIGZ1bGxBZGQoYSwgYiwgYykge1xyXG4gICAgICAgIGNvbnN0IHNBID0gVHJpdHMuc3VtKGEsIGIpO1xyXG4gICAgICAgIGNvbnN0IGNBID0gVHJpdHMuY29ucyhhLCBiKTtcclxuICAgICAgICBjb25zdCBjQiA9IFRyaXRzLmNvbnMoc0EsIGMpO1xyXG4gICAgICAgIGNvbnN0IGNPdXQgPSBUcml0cy5hbnkoY0EsIGNCKTtcclxuICAgICAgICBjb25zdCBzT1V0ID0gVHJpdHMuc3VtKHNBLCBjKTtcclxuICAgICAgICByZXR1cm4gbmV3IEludDhBcnJheShbc09VdCwgY091dF0pO1xyXG4gICAgfVxyXG4gICAgLyogQGludGVybmFsICovXHJcbiAgICBzdGF0aWMgc3VtKGEsIGIpIHtcclxuICAgICAgICBjb25zdCBzID0gYSArIGI7XHJcbiAgICAgICAgc3dpdGNoIChzKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICBjYXNlIC0yOiByZXR1cm4gMTtcclxuICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIHM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyogQGludGVybmFsICovXHJcbiAgICBzdGF0aWMgY29ucyhhLCBiKSB7XHJcbiAgICAgICAgaWYgKGEgPT09IGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgLyogQGludGVybmFsICovXHJcbiAgICBzdGF0aWMgYW55KGEsIGIpIHtcclxuICAgICAgICBjb25zdCBzID0gYSArIGI7XHJcbiAgICAgICAgaWYgKHMgPiAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzIDwgMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHZhbHVlIG9mIHRoZSB0cml0cyBhcnJheS5cclxuICAgICAqIEByZXR1cm5zIEFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0cml0cy5cclxuICAgICAqL1xyXG4gICAgdG9BcnJheSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdHJpdHM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgdmFsdWUgb2YgdGhlIHRyaXRzIGFycmF5IGFzIGEgbnVtYmVyIGFycmF5LlxyXG4gICAgICogQHJldHVybnMgQXJyYXkgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRyaXRzLlxyXG4gICAgICovXHJcbiAgICB0b051bWJlckFycmF5KCkge1xyXG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuX3RyaXRzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSB0cml0cyBhcyB0cnl0ZXMuXHJcbiAgICAgKiBAcmV0dXJucyBJbnN0YW5jZSBvZiBUcnl0ZXMuXHJcbiAgICAgKi9cclxuICAgIHRvVHJ5dGVzKCkge1xyXG4gICAgICAgIGxldCB0cnl0ZXMgPSBcIlwiO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdHJpdHMubGVuZ3RoOyBpICs9IDMpIHtcclxuICAgICAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIGFsbCBwb3NzaWJsZSB0cnl0ZSB2YWx1ZXMgdG8gZmluZCBjb3JyZWN0IHRyaXQgcmVwcmVzZW50YXRpb25cclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0cnl0ZXNfMS5Ucnl0ZXMuQUxQSEFCRVQubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChUcml0cy5UUllURVNfVFJJVFNbal1bMF0gPT09IHRoaXMuX3RyaXRzW2ldICYmXHJcbiAgICAgICAgICAgICAgICAgICAgVHJpdHMuVFJZVEVTX1RSSVRTW2pdWzFdID09PSB0aGlzLl90cml0c1tpICsgMV0gJiZcclxuICAgICAgICAgICAgICAgICAgICBUcml0cy5UUllURVNfVFJJVFNbal1bMl0gPT09IHRoaXMuX3RyaXRzW2kgKyAyXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeXRlcyArPSB0cnl0ZXNfMS5Ucnl0ZXMuQUxQSEFCRVQuY2hhckF0KGopO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnl0ZXNfMS5Ucnl0ZXMuZnJvbVN0cmluZyh0cnl0ZXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHRyaXRzIGFzIGEgbnVtYmVyLlxyXG4gICAgICogQHJldHVybnMgVGhlIHRyaXRzIGNvbnZlcnRlZCB0byBhIG51bWJlci5cclxuICAgICAqL1xyXG4gICAgdG9OdW1iZXIoKSB7XHJcbiAgICAgICAgbGV0IHJldHVyblZhbHVlID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fdHJpdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSByZXR1cm5WYWx1ZSAqIDMgKyB0aGlzLl90cml0c1tpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGF0IGlzIHRoZSBsZW5ndGggb2YgdGhlIHRyaXRzLlxyXG4gICAgICogQHJldHVybnMgTGVuZ3RoIG9mIHRoZSB0cml0cy5cclxuICAgICAqL1xyXG4gICAgbGVuZ3RoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90cml0cy5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCBhIHN1YiBvZiB0aGUgdHJpdHMuXHJcbiAgICAgKiBAcGFyYW0gc3RhcnQgVGhlIHN0YXJ0IHBvc2l0aW9uIHRvIGdldCB0aGUgc3ViLlxyXG4gICAgICogQHBhcmFtIGxlbmd0aCBUaGUgbGVuZ3RoIG9mIHRoZSBzdWIuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgdHJpdHMgc3ViLlxyXG4gICAgICovXHJcbiAgICBzdWIoc3RhcnQsIGxlbmd0aCkge1xyXG4gICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihzdGFydCkgfHwgc3RhcnQgPCAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXCJUaGUgc3RhcnQgbXVzdCBiZSBhIG51bWJlciA+PSAwXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIobGVuZ3RoKSB8fCAoc3RhcnQgKyBsZW5ndGgpID4gdGhpcy5fdHJpdHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoYFRoZSBzdGFydCArIGxlbmd0aCBtdXN0IDw9ICR7dGhpcy5fdHJpdHMubGVuZ3RofWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gVHJpdHMuZnJvbUFycmF5KHRoaXMuX3RyaXRzLnNsaWNlKHN0YXJ0LCBzdGFydCArIGxlbmd0aCkpO1xyXG4gICAgfVxyXG59XHJcbi8qIEBpbnRlcm5hbCAqL1xyXG5Ucml0cy5UUllURVNfVFJJVFMgPSBbXHJcbiAgICBuZXcgSW50OEFycmF5KFswLCAwLCAwXSksXHJcbiAgICBuZXcgSW50OEFycmF5KFsxLCAwLCAwXSksXHJcbiAgICBuZXcgSW50OEFycmF5KFstMSwgMSwgMF0pLFxyXG4gICAgbmV3IEludDhBcnJheShbMCwgMSwgMF0pLFxyXG4gICAgbmV3IEludDhBcnJheShbMSwgMSwgMF0pLFxyXG4gICAgbmV3IEludDhBcnJheShbLTEsIC0xLCAxXSksXHJcbiAgICBuZXcgSW50OEFycmF5KFswLCAtMSwgMV0pLFxyXG4gICAgbmV3IEludDhBcnJheShbMSwgLTEsIDFdKSxcclxuICAgIG5ldyBJbnQ4QXJyYXkoWy0xLCAwLCAxXSksXHJcbiAgICBuZXcgSW50OEFycmF5KFswLCAwLCAxXSksXHJcbiAgICBuZXcgSW50OEFycmF5KFsxLCAwLCAxXSksXHJcbiAgICBuZXcgSW50OEFycmF5KFstMSwgMSwgMV0pLFxyXG4gICAgbmV3IEludDhBcnJheShbMCwgMSwgMV0pLFxyXG4gICAgbmV3IEludDhBcnJheShbMSwgMSwgMV0pLFxyXG4gICAgbmV3IEludDhBcnJheShbLTEsIC0xLCAtMV0pLFxyXG4gICAgbmV3IEludDhBcnJheShbMCwgLTEsIC0xXSksXHJcbiAgICBuZXcgSW50OEFycmF5KFsxLCAtMSwgLTFdKSxcclxuICAgIG5ldyBJbnQ4QXJyYXkoWy0xLCAwLCAtMV0pLFxyXG4gICAgbmV3IEludDhBcnJheShbMCwgMCwgLTFdKSxcclxuICAgIG5ldyBJbnQ4QXJyYXkoWzEsIDAsIC0xXSksXHJcbiAgICBuZXcgSW50OEFycmF5KFstMSwgMSwgLTFdKSxcclxuICAgIG5ldyBJbnQ4QXJyYXkoWzAsIDEsIC0xXSksXHJcbiAgICBuZXcgSW50OEFycmF5KFsxLCAxLCAtMV0pLFxyXG4gICAgbmV3IEludDhBcnJheShbLTEsIC0xLCAwXSksXHJcbiAgICBuZXcgSW50OEFycmF5KFswLCAtMSwgMF0pLFxyXG4gICAgbmV3IEludDhBcnJheShbMSwgLTEsIDBdKSxcclxuICAgIG5ldyBJbnQ4QXJyYXkoWy0xLCAwLCAwXSlcclxuXTtcclxuZXhwb3J0cy5Ucml0cyA9IFRyaXRzO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lkSEpwZEhNdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk4dUxpOXpjbU12WkdGMFlTOTBjbWwwY3k1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU8wRkJRVUVzTUVWQlFYVkZPMEZCUTNaRkxEUkZRVUY1UlR0QlFVTjZSU3cwUlVGQmVVVTdRVUZEZWtVc2EwUkJRU3RETzBGQlF5OURMSEZEUVVGclF6dEJRVVZzUXpzN1IwRkZSenRCUVVOSU8wbEJiVU5KTEdWQlFXVTdTVUZEWml4WlFVRnZRaXhMUVVGblFqdFJRVU5vUXl4SlFVRkpMRU5CUVVNc1RVRkJUU3hIUVVGSExFdEJRVXNzUTBGQlF6dEpRVU40UWl4RFFVRkRPMGxCUlVRN096czdUMEZKUnp0SlFVTkpMRTFCUVUwc1EwRkJReXhUUVVGVExFTkJRVU1zUzBGQlowSTdVVUZEY0VNc1NVRkJTU3hEUVVGRExESkNRVUZaTEVOQlFVTXNUVUZCVFN4RFFVRkRMRXRCUVVzc1JVRkJSU3hUUVVGVExFTkJRVU1zUlVGQlJUdFpRVU40UXl4TlFVRk5MRWxCUVVrc2NVSkJRVk1zUTBGQlF5eDNRMEZCZDBNc1EwRkJReXhEUVVGRE8xTkJRMnBGTzFGQlEwUXNUMEZCVHl4SlFVRkpMRXRCUVVzc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF6dEpRVU0xUWl4RFFVRkRPMGxCUlVRN096czdUMEZKUnp0SlFVTkpMRTFCUVUwc1EwRkJReXhsUVVGbExFTkJRVU1zUzBGQlpUdFJRVU42UXl4SlFVRkpMRU5CUVVNc2VVSkJRVmNzUTBGQlF5eFBRVUZQTEVOQlFVTXNTMEZCU3l4RlFVRkZMRTFCUVUwc1EwRkJReXhGUVVGRk8xbEJRM0pETEUxQlFVMHNTVUZCU1N4eFFrRkJVeXhEUVVGRExIZERRVUYzUXl4RFFVRkRMRU5CUVVNN1UwRkRha1U3VVVGRFJDeFBRVUZQTEVsQlFVa3NTMEZCU3l4RFFVRkRMRWxCUVVrc1UwRkJVeXhEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTTdTVUZETTBNc1EwRkJRenRKUVVWRU96czdPMDlCU1VjN1NVRkRTU3hOUVVGTkxFTkJRVU1zVlVGQlZTeERRVUZETEV0QlFXRTdVVUZEYkVNc1NVRkJTU3hEUVVGRExESkNRVUZaTEVOQlFVTXNUVUZCVFN4RFFVRkRMRXRCUVVzc1JVRkJSU3hsUVVGTkxFTkJRVU1zUlVGQlJUdFpRVU55UXl4TlFVRk5MRWxCUVVrc2NVSkJRVk1zUTBGQlF5d3lRMEZCTWtNc1EwRkJReXhEUVVGRE8xTkJRM0JGTzFGQlEwUXNUVUZCVFN4WlFVRlpMRWRCUVVjc1MwRkJTeXhEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETzFGQlEzUkRMRTFCUVUwc1MwRkJTeXhIUVVGakxFbEJRVWtzVTBGQlV5eERRVUZETEZsQlFWa3NRMEZCUXl4TlFVRk5MRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGFFVXNTMEZCU3l4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEZsQlFWa3NRMEZCUXl4TlFVRk5MRVZCUVVVc1EwRkJReXhGUVVGRkxFVkJRVVU3V1VGRE1VTXNUVUZCVFN4SFFVRkhMRWRCUVVjc1pVRkJUU3hEUVVGRExGRkJRVkVzUTBGQlF5eFBRVUZQTEVOQlFVTXNXVUZCV1N4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlF6VkVMRXRCUVVzc1EwRkJReXhEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVkQlFVY3NTMEZCU3l4RFFVRkRMRmxCUVZrc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTXhReXhMUVVGTExFTkJRVU1zUTBGQlF5eEhRVUZITEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1IwRkJSeXhMUVVGTExFTkJRVU1zV1VGQldTeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRemxETEV0QlFVc3NRMEZCUXl4RFFVRkRMRWRCUVVjc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eEhRVUZITEV0QlFVc3NRMEZCUXl4WlFVRlpMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdVMEZEYWtRN1VVRkRSQ3hQUVVGUExFbEJRVWtzUzBGQlN5eERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRPMGxCUXpWQ0xFTkJRVU03U1VGRlJEczdPenRQUVVsSE8wbEJRMGtzVFVGQlRTeERRVUZETEZWQlFWVXNRMEZCUXl4TFFVRmhPMUZCUTJ4RExFbEJRVWtzUTBGQlF5d3lRa0ZCV1N4RFFVRkRMRk5CUVZNc1EwRkJReXhMUVVGTExFTkJRVU1zUlVGQlJUdFpRVU5vUXl4TlFVRk5MRWxCUVVrc2NVSkJRVk1zUTBGQlF5dzJRa0ZCTmtJc1EwRkJReXhEUVVGRE8xTkJRM1JFTzFGQlEwUXNUVUZCVFN4TFFVRkxMRWRCUVdFc1JVRkJSU3hEUVVGRE8xRkJRek5DTEVsQlFVa3NZVUZCWVN4SFFVRkhMRXRCUVVzc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJReXhMUVVGTExFTkJRVU03VVVGRkwwTXNUMEZCVHl4aFFVRmhMRWRCUVVjc1EwRkJReXhGUVVGRk8xbEJRM1JDTEVsQlFVa3NVMEZCVXl4SFFVRkhMR0ZCUVdFc1IwRkJSeXhEUVVGRExFTkJRVU03V1VGRGJFTXNZVUZCWVN4SFFVRkhMRWxCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zWVVGQllTeEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUlRsRExFbEJRVWtzVTBGQlV5eEhRVUZITEVOQlFVTXNSVUZCUlR0blFrRkRaaXhUUVVGVExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUTJZc1lVRkJZU3hGUVVGRkxFTkJRVU03WVVGRGJrSTdXVUZGUkN4TFFVRkxMRU5CUVVNc1MwRkJTeXhEUVVGRExFMUJRVTBzUTBGQlF5eEhRVUZITEZOQlFWTXNRMEZCUXp0VFFVTnVRenRSUVVORUxFbEJRVWtzUzBGQlN5eEhRVUZITEVOQlFVTXNSVUZCUlR0WlFVTllMRXRCUVVzc1NVRkJTU3hEUVVGRExFZEJRVWNzUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUnl4TFFVRkxMRU5CUVVNc1RVRkJUU3hGUVVGRkxFTkJRVU1zUlVGQlJTeEZRVUZGTzJkQ1FVTnVReXhMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETEVkQlFVY3NRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03WVVGRGVFSTdVMEZEU2p0UlFVVkVMRTlCUVU4c1NVRkJTU3hMUVVGTExFTkJRVU1zU1VGQlNTeFRRVUZUTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJRenRKUVVNelF5eERRVUZETzBsQlJVUTdPenM3TzA5QlMwYzdTVUZEU1N4TlFVRk5MRU5CUVVNc1IwRkJSeXhEUVVGRExFdEJRVmtzUlVGQlJTeE5RVUZoTzFGQlEzcERMRWxCUVVrc1EwRkJReXd5UWtGQldTeERRVUZETEUxQlFVMHNRMEZCUXl4TFFVRkxMRVZCUVVVc1MwRkJTeXhEUVVGRExFVkJRVVU3V1VGRGNFTXNUVUZCVFN4SlFVRkpMSEZDUVVGVExFTkJRVU1zTUVOQlFUQkRMRU5CUVVNc1EwRkJRenRUUVVOdVJUdFJRVU5FTEVsQlFVa3NRMEZCUXl3eVFrRkJXU3hEUVVGRExFMUJRVTBzUTBGQlF5eE5RVUZOTEVWQlFVVXNTMEZCU3l4RFFVRkRMRVZCUVVVN1dVRkRja01zVFVGQlRTeEpRVUZKTEhGQ1FVRlRMRU5CUVVNc05FTkJRVFJETEVOQlFVTXNRMEZCUXp0VFFVTnlSVHRSUVVWRUxFMUJRVTBzUjBGQlJ5eEhRVUZITEVsQlFVa3NVMEZCVXl4RFFVRkRMRWxCUVVrc1EwRkJReXhIUVVGSExFTkJRVU1zUzBGQlN5eERRVUZETEUxQlFVMHNRMEZCUXl4TlFVRk5MRVZCUVVVc1RVRkJUU3hEUVVGRExFMUJRVTBzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUXk5RkxFbEJRVWtzUzBGQlN5eEhRVUZITEVOQlFVTXNRMEZCUXp0UlFVTmtMRWxCUVVrc1JVRkJSU3hEUVVGRE8xRkJRMUFzU1VGQlNTeEZRVUZGTEVOQlFVTTdVVUZGVUN4TFFVRkxMRWxCUVVrc1EwRkJReXhIUVVGSExFTkJRVU1zUlVGQlJTeERRVUZETEVkQlFVY3NSMEZCUnl4RFFVRkRMRTFCUVUwc1JVRkJSU3hEUVVGRExFVkJRVVVzUlVGQlJUdFpRVVZxUXl4RlFVRkZMRWRCUVVjc1EwRkJReXhIUVVGSExFdEJRVXNzUTBGQlF5eE5RVUZOTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJReXhMUVVGTExFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGJrUXNSVUZCUlN4SFFVRkhMRU5CUVVNc1IwRkJSeXhOUVVGTkxFTkJRVU1zVFVGQlRTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNc1RVRkJUU3hEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRM0pFTEUxQlFVMHNSVUZCUlN4SFFVRkhMRXRCUVVzc1EwRkJReXhQUVVGUExFTkJRVU1zUlVGQlJTeEZRVUZGTEVWQlFVVXNSVUZCUlN4TFFVRkxMRU5CUVVNc1EwRkJRenRaUVVONFF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRWRCUVVjc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEyWXNTMEZCU3l4SFFVRkhMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFRRVU5xUWp0UlFVVkVMRTlCUVU4c1MwRkJTeXhEUVVGRExGTkJRVk1zUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXp0SlFVTm9ReXhEUVVGRE8wbEJSVVFzWlVGQlpUdEpRVU5RTEUxQlFVMHNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJVeXhGUVVGRkxFTkJRVk1zUlVGQlJTeERRVUZUTzFGQlEyeEVMRTFCUVUwc1JVRkJSU3hIUVVGSExFdEJRVXNzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRek5DTEUxQlFVMHNSVUZCUlN4SFFVRkhMRXRCUVVzc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUXpWQ0xFMUJRVTBzUlVGQlJTeEhRVUZITEV0QlFVc3NRMEZCUXl4SlFVRkpMRU5CUVVNc1JVRkJSU3hGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETzFGQlF6ZENMRTFCUVUwc1NVRkJTU3hIUVVGSExFdEJRVXNzUTBGQlF5eEhRVUZITEVOQlFVTXNSVUZCUlN4RlFVRkZMRVZCUVVVc1EwRkJReXhEUVVGRE8xRkJReTlDTEUxQlFVMHNTVUZCU1N4SFFVRkhMRXRCUVVzc1EwRkJReXhIUVVGSExFTkJRVU1zUlVGQlJTeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUlRsQ0xFOUJRVThzU1VGQlNTeFRRVUZUTEVOQlFVTXNRMEZCUXl4SlFVRkpMRVZCUVVVc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF6dEpRVU4yUXl4RFFVRkRPMGxCUlVRc1pVRkJaVHRKUVVOUUxFMUJRVTBzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCVXl4RlFVRkZMRU5CUVZNN1VVRkRia01zVFVGQlRTeERRVUZETEVkQlFVY3NRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJRenRSUVVWb1FpeFJRVUZSTEVOQlFVTXNSVUZCUlR0WlFVTlFMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTnNRaXhMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNN1dVRkRiRUlzVDBGQlR5eERRVUZETEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNN1UwRkRja0k3U1VGRFRDeERRVUZETzBsQlJVUXNaVUZCWlR0SlFVTlFMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlV5eEZRVUZGTEVOQlFWTTdVVUZEY0VNc1NVRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF5eEZRVUZGTzFsQlExUXNUMEZCVHl4RFFVRkRMRU5CUVVNN1UwRkRXanRSUVVORUxFOUJRVThzUTBGQlF5eERRVUZETzBsQlEySXNRMEZCUXp0SlFVVkVMR1ZCUVdVN1NVRkRVQ3hOUVVGTkxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFWTXNSVUZCUlN4RFFVRlRPMUZCUTI1RExFMUJRVTBzUTBGQlF5eEhRVUZITEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNN1VVRkZhRUlzU1VGQlNTeERRVUZETEVkQlFVY3NRMEZCUXl4RlFVRkZPMWxCUTFBc1QwRkJUeXhEUVVGRExFTkJRVU03VTBGRFdqdGhRVUZOTEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1JVRkJSVHRaUVVOa0xFOUJRVThzUTBGQlF5eERRVUZETEVOQlFVTTdVMEZEWWp0UlFVVkVMRTlCUVU4c1EwRkJReXhEUVVGRE8wbEJRMklzUTBGQlF6dEpRVVZFT3pzN1QwRkhSenRKUVVOSkxFOUJRVTg3VVVGRFZpeFBRVUZQTEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNN1NVRkRka0lzUTBGQlF6dEpRVVZFT3pzN1QwRkhSenRKUVVOSkxHRkJRV0U3VVVGRGFFSXNUMEZCVHl4TFFVRkxMRU5CUVVNc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXp0SlFVTnVReXhEUVVGRE8wbEJSVVE3T3p0UFFVZEhPMGxCUTBrc1VVRkJVVHRSUVVOWUxFbEJRVWtzVFVGQlRTeEhRVUZITEVWQlFVVXNRMEZCUXp0UlFVVm9RaXhMUVVGTExFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1NVRkJTU3hEUVVGRExFMUJRVTBzUTBGQlF5eE5RVUZOTEVWQlFVVXNRMEZCUXl4SlFVRkpMRU5CUVVNc1JVRkJSVHRaUVVNMVF5dzJSVUZCTmtVN1dVRkROMFVzUzBGQlN5eEpRVUZKTEVOQlFVTXNSMEZCUnl4RFFVRkRMRVZCUVVVc1EwRkJReXhIUVVGSExHVkJRVTBzUTBGQlF5eFJRVUZSTEVOQlFVTXNUVUZCVFN4RlFVRkZMRU5CUVVNc1JVRkJSU3hGUVVGRk8yZENRVU0zUXl4SlFVRkpMRXRCUVVzc1EwRkJReXhaUVVGWkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRXRCUVVzc1NVRkJTU3hEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTTdiMEpCUXpORExFdEJRVXNzUTBGQlF5eFpRVUZaTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFdEJRVXNzU1VGQlNTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRE8yOUNRVU12UXl4TFFVRkxMRU5CUVVNc1dVRkJXU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4TFFVRkxMRWxCUVVrc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RlFVRkZPMjlDUVVOcVJDeE5RVUZOTEVsQlFVa3NaVUZCVFN4RFFVRkRMRkZCUVZFc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdiMEpCUTNCRExFMUJRVTA3YVVKQlExUTdZVUZEU2p0VFFVTktPMUZCUlVRc1QwRkJUeXhsUVVGTkxFTkJRVU1zVlVGQlZTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRPMGxCUTNKRExFTkJRVU03U1VGRlJEczdPMDlCUjBjN1NVRkRTU3hSUVVGUk8xRkJRMWdzU1VGQlNTeFhRVUZYTEVkQlFVY3NRMEZCUXl4RFFVRkRPMUZCUlhCQ0xFdEJRVXNzU1VGQlNTeERRVUZETEVkQlFVY3NTVUZCU1N4RFFVRkRMRTFCUVUwc1EwRkJReXhOUVVGTkxFZEJRVWNzUTBGQlF5eEZRVUZGTEVOQlFVTXNTVUZCU1N4RFFVRkRMRVZCUVVVc1EwRkJReXhGUVVGRkxFVkJRVVU3V1VGRE9VTXNWMEZCVnl4SFFVRkhMRmRCUVZjc1IwRkJSeXhEUVVGRExFZEJRVWNzU1VGQlNTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRUUVVOc1JEdFJRVVZFTEU5QlFVOHNWMEZCVnl4RFFVRkRPMGxCUTNaQ0xFTkJRVU03U1VGRlJEczdPMDlCUjBjN1NVRkRTU3hOUVVGTk8xRkJRMVFzVDBGQlR5eEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRTFCUVUwc1EwRkJRenRKUVVNNVFpeERRVUZETzBsQlJVUTdPenM3TzA5QlMwYzdTVUZEU1N4SFFVRkhMRU5CUVVNc1MwRkJZU3hGUVVGRkxFMUJRV003VVVGRGNFTXNTVUZCU1N4RFFVRkRMREpDUVVGWkxFTkJRVU1zVTBGQlV5eERRVUZETEV0QlFVc3NRMEZCUXl4SlFVRkpMRXRCUVVzc1IwRkJSeXhEUVVGRExFVkJRVVU3V1VGRE4wTXNUVUZCVFN4SlFVRkpMSEZDUVVGVExFTkJRVU1zYVVOQlFXbERMRU5CUVVNc1EwRkJRenRUUVVNeFJEdFJRVU5FTEVsQlFVa3NRMEZCUXl3eVFrRkJXU3hEUVVGRExGTkJRVk1zUTBGQlF5eE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRXRCUVVzc1IwRkJSeXhOUVVGTkxFTkJRVU1zUjBGQlJ5eEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRTFCUVUwc1JVRkJSVHRaUVVNeFJTeE5RVUZOTEVsQlFVa3NjVUpCUVZNc1EwRkJReXc0UWtGQk9FSXNTVUZCU1N4RFFVRkRMRTFCUVUwc1EwRkJReXhOUVVGTkxFVkJRVVVzUTBGQlF5eERRVUZETzFOQlF6TkZPMUZCUTBRc1QwRkJUeXhMUVVGTExFTkJRVU1zVTBGQlV5eERRVUZETEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRExFdEJRVXNzUlVGQlJTeExRVUZMTEVkQlFVY3NUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJRenRKUVVOeVJTeERRVUZET3p0QlFYWlJSQ3hsUVVGbE8wRkJRMU1zYTBKQlFWa3NSMEZCWjBJN1NVRkRhRVFzU1VGQlNTeFRRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETzBsQlEzaENMRWxCUVVrc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJRenRKUVVONFFpeEpRVUZKTEZOQlFWTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXp0SlFVTjZRaXhKUVVGSkxGTkJRVk1zUTBGQlF5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU03U1VGRGVFSXNTVUZCU1N4VFFVRlRMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRPMGxCUTNoQ0xFbEJRVWtzVTBGQlV5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTTdTVUZETVVJc1NVRkJTU3hUUVVGVExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU03U1VGRGVrSXNTVUZCU1N4VFFVRlRMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkRla0lzU1VGQlNTeFRRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTTdTVUZEZWtJc1NVRkJTU3hUUVVGVExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJRM2hDTEVsQlFVa3NVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXp0SlFVTjRRaXhKUVVGSkxGTkJRVk1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF6dEpRVU42UWl4SlFVRkpMRk5CUVZNc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkRlRUlzU1VGQlNTeFRRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETzBsQlEzaENMRWxCUVVrc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dEpRVU16UWl4SlFVRkpMRk5CUVZNc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJRekZDTEVsQlFVa3NVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkRNVUlzU1VGQlNTeFRRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0SlFVTXhRaXhKUVVGSkxGTkJRVk1zUTBGQlF5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dEpRVU42UWl4SlFVRkpMRk5CUVZNc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRKUVVONlFpeEpRVUZKTEZOQlFWTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMGxCUXpGQ0xFbEJRVWtzVTBGQlV5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzBsQlEzcENMRWxCUVVrc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJRM3BDTEVsQlFVa3NVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkRNVUlzU1VGQlNTeFRRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTTdTVUZEZWtJc1NVRkJTU3hUUVVGVExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU03U1VGRGVrSXNTVUZCU1N4VFFVRlRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNN1EwRkROVUlzUTBGQlF6dEJRVGxDVGl4elFrRXdVVU1pZlE9PSIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgbnVtYmVySGVscGVyXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9udW1iZXJIZWxwZXJcIik7XHJcbmNvbnN0IG9iamVjdEhlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvb2JqZWN0SGVscGVyXCIpO1xyXG5jb25zdCBkYXRhRXJyb3JfMSA9IHJlcXVpcmUoXCIuLi9lcnJvci9kYXRhRXJyb3JcIik7XHJcbmNvbnN0IHRyaXRzXzEgPSByZXF1aXJlKFwiLi90cml0c1wiKTtcclxuY29uc3QgdHJ5dGVzXzEgPSByZXF1aXJlKFwiLi90cnl0ZXNcIik7XHJcbi8qKlxyXG4gKiBBIGNsYXNzIGZvciBoYW5kbGluZyB0cnl0ZSBudW1iZXIuXHJcbiAqL1xyXG5jbGFzcyBUcnl0ZU51bWJlciB7XHJcbiAgICAvKiBAaW50ZXJuYWwgKi9cclxuICAgIGNvbnN0cnVjdG9yKHRyeXRlcykge1xyXG4gICAgICAgIHRoaXMuX3RyeXRlcyA9IHRyeXRlcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIHRyeXRlIG51bWJlciBmcm9tIG51bWJlci5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgbnVtYmVyIHZhbHVlIHRvIGNyZWF0ZSB0aGUgb2JqZWN0IGZyb20uXHJcbiAgICAgKiBAcGFyYW0gbGVuZ3RoIFRoZSB0cnl0ZSBsZW5ndGggdG8gcGFkIHRoZSBudW1iZXIgd2l0aC5cclxuICAgICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIFRyeXRlTnVtYmVyLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbU51bWJlcih2YWx1ZSwgbGVuZ3RoID0gVHJ5dGVOdW1iZXIuTEVOR1RIXzkpIHtcclxuICAgICAgICBsZXQgdHJ5dGVzO1xyXG4gICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihsZW5ndGgpIHx8IGxlbmd0aCA8PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXCJUaGUgbGVuZ3RoIHNob3VsZCBiZSBhIG51bWJlciA+IDBcIiwgeyBsZW5ndGggfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNFbXB0eSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgdHJ5dGVzID0gXCI5XCIucmVwZWF0KGxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFwiVGhlIHZhbHVlIGlzIG5vdCBhbiBpbnRlZ2VyXCIsIHsgdmFsdWUgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgdHJpdHMgPSB0cml0c18xLlRyaXRzLmZyb21OdW1iZXIodmFsdWUpLnRvTnVtYmVyQXJyYXkoKTtcclxuICAgICAgICAgICAgd2hpbGUgKHRyaXRzLmxlbmd0aCA8IGxlbmd0aCAqIDMpIHtcclxuICAgICAgICAgICAgICAgIHRyaXRzLnB1c2goMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHJ5dGVzID0gdHJpdHNfMS5Ucml0cy5mcm9tTnVtYmVyQXJyYXkodHJpdHMpLnRvVHJ5dGVzKCkudG9TdHJpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUcnl0ZU51bWJlcih0cnl0ZXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgdHJ5dGUgbnVtYmVyIGZyb20gdHJ5dGVzLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBudW1iZXIgdmFsdWUgdG8gY3JlYXRlIHRoZSBvYmplY3QgZnJvbS5cclxuICAgICAqIEBwYXJhbSBsZW5ndGggVGhlIHRyeXRlIGxlbmd0aCB0byBwYWQgdGhlIG51bWJlciB3aXRoLlxyXG4gICAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgVHJ5dGVOdW1iZXIuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tVHJ5dGVzKHZhbHVlLCBsZW5ndGggPSBUcnl0ZU51bWJlci5MRU5HVEhfOSkge1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZSh2YWx1ZSwgdHJ5dGVzXzEuVHJ5dGVzKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFwiVGhlIHZhbHVlIHNob3VsZCBiZSBhIHZhbGlkIFRyeXRlcyBvYmplY3RcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB0cnl0ZVN0cmluZyA9IHZhbHVlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKGxlbmd0aCkgfHwgbGVuZ3RoIDw9IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihcIlRoZSBsZW5ndGggc2hvdWxkIGJlIGEgbnVtYmVyID4gMFwiLCB7IGxlbmd0aCB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRyeXRlU3RyaW5nLmxlbmd0aCA+IGxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFwiVGhlIHZhbHVlIGNvbnRhaW5zIHRvbyBtYW55IGNoYXJhY3RlcnNcIiwgeyBsZW5ndGg6IHRyeXRlU3RyaW5nLmxlbmd0aCB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKHRyeXRlU3RyaW5nLmxlbmd0aCA8IGxlbmd0aCkge1xyXG4gICAgICAgICAgICB0cnl0ZVN0cmluZyArPSBcIjlcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUcnl0ZU51bWJlcih0cnl0ZVN0cmluZyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnQgdGhlIHRyeXRlIG51bWJlciB0byB0cnl0ZXMuXHJcbiAgICAgKiBAcmV0dXJucyBUcnl0ZXMgdmVyc2lvbiBvZiB0aGUgdHJ5dGUgbnVtYmVyLlxyXG4gICAgICovXHJcbiAgICB0b1RyeXRlcygpIHtcclxuICAgICAgICByZXR1cm4gdHJ5dGVzXzEuVHJ5dGVzLmZyb21TdHJpbmcodGhpcy5fdHJ5dGVzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydCB0aGUgdHJ5dGUgbnVtYmVyIHRvIG51bWJlci5cclxuICAgICAqIEByZXR1cm5zIG51bWJlciB2YWx1ZSBvZiB0aGUgdHJ5dGUgbnVtYmVyLlxyXG4gICAgICovXHJcbiAgICB0b051bWJlcigpIHtcclxuICAgICAgICByZXR1cm4gdHJpdHNfMS5Ucml0cy5mcm9tVHJ5dGVzKHRyeXRlc18xLlRyeXRlcy5mcm9tU3RyaW5nKHRoaXMuX3RyeXRlcykpLnRvTnVtYmVyKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgc3RyaW5nIHZpZXcgb2YgdGhlIG9iamVjdC5cclxuICAgICAqIEByZXR1cm5zIHN0cmluZyBvZiB0aGUgdHJ5dGVzLlxyXG4gICAgICovXHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdHJ5dGVzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHZhbHVlIG9mIHRoZSBvYmplY3QuXHJcbiAgICAgKiBAcmV0dXJucyBzdHJpbmcgb2YgdGhlIHRyeXRlcy5cclxuICAgICAqL1xyXG4gICAgdmFsdWVPZigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50b051bWJlcigpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBMZW5ndGggb2YgYSBudW1iZXIgdGhhdCB1c2VzIDkgdHJ5dGVzLlxyXG4gKi9cclxuVHJ5dGVOdW1iZXIuTEVOR1RIXzkgPSA5O1xyXG4vKipcclxuICogQW4gZW1wdHkgOSBsZW5ndGggdHJ5dGUgbnVtYmVyLlxyXG4gKi9cclxuVHJ5dGVOdW1iZXIuRU1QVFlfOSA9IFRyeXRlTnVtYmVyLmZyb21OdW1iZXIoMCwgVHJ5dGVOdW1iZXIuTEVOR1RIXzkpO1xyXG5leHBvcnRzLlRyeXRlTnVtYmVyID0gVHJ5dGVOdW1iZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWRISjVkR1ZPZFcxaVpYSXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOHVMaTl6Y21NdlpHRjBZUzkwY25sMFpVNTFiV0psY2k1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU8wRkJRVUVzTkVWQlFYbEZPMEZCUTNwRkxEUkZRVUY1UlR0QlFVTjZSU3hyUkVGQkswTTdRVUZETDBNc2JVTkJRV2RETzBGQlEyaERMSEZEUVVGclF6dEJRVVZzUXpzN1IwRkZSenRCUVVOSU8wbEJZVWtzWlVGQlpUdEpRVU5tTEZsQlFXOUNMRTFCUVdNN1VVRkRPVUlzU1VGQlNTeERRVUZETEU5QlFVOHNSMEZCUnl4TlFVRk5MRU5CUVVNN1NVRkRNVUlzUTBGQlF6dEpRVVZFT3pzN096dFBRVXRITzBsQlEwa3NUVUZCVFN4RFFVRkRMRlZCUVZVc1EwRkJReXhMUVVGaExFVkJRVVVzVTBGQmFVSXNWMEZCVnl4RFFVRkRMRkZCUVZFN1VVRkRla1VzU1VGQlNTeE5RVUZOTEVOQlFVTTdVVUZGV0N4SlFVRkpMRU5CUVVNc01rSkJRVmtzUTBGQlF5eFRRVUZUTEVOQlFVTXNUVUZCVFN4RFFVRkRMRWxCUVVrc1RVRkJUU3hKUVVGSkxFTkJRVU1zUlVGQlJUdFpRVU5vUkN4TlFVRk5MRWxCUVVrc2NVSkJRVk1zUTBGQlF5eHRRMEZCYlVNc1JVRkJSU3hGUVVGRkxFMUJRVTBzUlVGQlJTeERRVUZETEVOQlFVTTdVMEZEZUVVN1VVRkZSQ3hKUVVGSkxESkNRVUZaTEVOQlFVTXNUMEZCVHl4RFFVRkRMRXRCUVVzc1EwRkJReXhGUVVGRk8xbEJRemRDTEUxQlFVMHNSMEZCUnl4SFFVRkhMRU5CUVVNc1RVRkJUU3hEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETzFOQlF5OUNPMkZCUVUwN1dVRkRTQ3hKUVVGSkxFTkJRVU1zTWtKQlFWa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1MwRkJTeXhEUVVGRExFVkJRVVU3WjBKQlEyaERMRTFCUVUwc1NVRkJTU3h4UWtGQlV5eERRVUZETERaQ1FVRTJRaXhGUVVGRkxFVkJRVVVzUzBGQlN5eEZRVUZGTEVOQlFVTXNRMEZCUXp0aFFVTnFSVHRaUVVWRUxFMUJRVTBzUzBGQlN5eEhRVUZITEdGQlFVc3NRMEZCUXl4VlFVRlZMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zWVVGQllTeEZRVUZGTEVOQlFVTTdXVUZGZEVRc1QwRkJUeXhMUVVGTExFTkJRVU1zVFVGQlRTeEhRVUZITEUxQlFVMHNSMEZCUnl4RFFVRkRMRVZCUVVVN1owSkJRemxDTEV0QlFVc3NRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03WVVGRGFrSTdXVUZGUkN4TlFVRk5MRWRCUVVjc1lVRkJTeXhEUVVGRExHVkJRV1VzUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF6dFRRVU12UkR0UlFVVkVMRTlCUVU4c1NVRkJTU3hYUVVGWExFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTTdTVUZEYmtNc1EwRkJRenRKUVVWRU96czdPenRQUVV0SE8wbEJRMGtzVFVGQlRTeERRVUZETEZWQlFWVXNRMEZCUXl4TFFVRmhMRVZCUVVVc1UwRkJhVUlzVjBGQlZ5eERRVUZETEZGQlFWRTdVVUZEZWtVc1NVRkJTU3hEUVVGRExESkNRVUZaTEVOQlFVTXNUVUZCVFN4RFFVRkRMRXRCUVVzc1JVRkJSU3hsUVVGTkxFTkJRVU1zUlVGQlJUdFpRVU55UXl4TlFVRk5MRWxCUVVrc2NVSkJRVk1zUTBGQlF5d3lRMEZCTWtNc1EwRkJReXhEUVVGRE8xTkJRM0JGTzFGQlEwUXNTVUZCU1N4WFFVRlhMRWRCUVVjc1MwRkJTeXhEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETzFGQlJXNURMRWxCUVVrc1EwRkJReXd5UWtGQldTeERRVUZETEZOQlFWTXNRMEZCUXl4TlFVRk5MRU5CUVVNc1NVRkJTU3hOUVVGTkxFbEJRVWtzUTBGQlF5eEZRVUZGTzFsQlEyaEVMRTFCUVUwc1NVRkJTU3h4UWtGQlV5eERRVUZETEcxRFFVRnRReXhGUVVGRkxFVkJRVVVzVFVGQlRTeEZRVUZGTEVOQlFVTXNRMEZCUXp0VFFVTjRSVHRSUVVWRUxFbEJRVWtzVjBGQlZ5eERRVUZETEUxQlFVMHNSMEZCUnl4TlFVRk5MRVZCUVVVN1dVRkROMElzVFVGQlRTeEpRVUZKTEhGQ1FVRlRMRU5CUVVNc2QwTkJRWGRETEVWQlFVVXNSVUZCUlN4TlFVRk5MRVZCUVVVc1YwRkJWeXhEUVVGRExFMUJRVTBzUlVGQlJTeERRVUZETEVOQlFVTTdVMEZEYWtjN1VVRkZSQ3hQUVVGUExGZEJRVmNzUTBGQlF5eE5RVUZOTEVkQlFVY3NUVUZCVFN4RlFVRkZPMWxCUTJoRExGZEJRVmNzU1VGQlNTeEhRVUZITEVOQlFVTTdVMEZEZEVJN1VVRkZSQ3hQUVVGUExFbEJRVWtzVjBGQlZ5eERRVUZETEZkQlFWY3NRMEZCUXl4RFFVRkRPMGxCUTNoRExFTkJRVU03U1VGRlJEczdPMDlCUjBjN1NVRkRTU3hSUVVGUk8xRkJRMWdzVDBGQlR5eGxRVUZOTEVOQlFVTXNWVUZCVlN4RFFVRkRMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF6dEpRVU16UXl4RFFVRkRPMGxCUlVRN096dFBRVWRITzBsQlEwa3NVVUZCVVR0UlFVTllMRTlCUVU4c1lVRkJTeXhEUVVGRExGVkJRVlVzUTBGQlF5eGxRVUZOTEVOQlFVTXNWVUZCVlN4RFFVRkRMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF5eERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRPMGxCUTNoRkxFTkJRVU03U1VGRlJEczdPMDlCUjBjN1NVRkRTU3hSUVVGUk8xRkJRMWdzVDBGQlR5eEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRPMGxCUTNoQ0xFTkJRVU03U1VGRlJEczdPMDlCUjBjN1NVRkRTU3hQUVVGUE8xRkJRMVlzVDBGQlR5eEpRVUZKTEVOQlFVTXNVVUZCVVN4RlFVRkZMRU5CUVVNN1NVRkRNMElzUTBGQlF6czdRVUV4UjBRN08wZEJSVWM3UVVGRGIwSXNiMEpCUVZFc1IwRkJWeXhEUVVGRExFTkJRVU03UVVGRE5VTTdPMGRCUlVjN1FVRkRiMElzYlVKQlFVOHNSMEZCWjBJc1YwRkJWeXhEUVVGRExGVkJRVlVzUTBGQlF5eERRVUZETEVWQlFVVXNWMEZCVnl4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRE8wRkJVbXhITEd0RFFUUkhReUo5IiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBudW1iZXJIZWxwZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL251bWJlckhlbHBlclwiKTtcclxuY29uc3Qgc3RyaW5nSGVscGVyXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9zdHJpbmdIZWxwZXJcIik7XHJcbmNvbnN0IGRhdGFFcnJvcl8xID0gcmVxdWlyZShcIi4uL2Vycm9yL2RhdGFFcnJvclwiKTtcclxuLyoqXHJcbiAqIEEgY2xhc3MgZm9yIGhhbmRsaW5nIHRyeXRlcy5cclxuICovXHJcbmNsYXNzIFRyeXRlcyB7XHJcbiAgICAvKiBAaW50ZXJuYWwgKi9cclxuICAgIGNvbnN0cnVjdG9yKHRyeXRlcykge1xyXG4gICAgICAgIHRoaXMuX3RyeXRlcyA9IHRyeXRlcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIHRyeXRlcyBmcm9tIGEgc3RyaW5nLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIEEgc3RyaW5nIHRvIGNyZWF0ZSB0aGUgdHJ5dGVzIGZyb20uXHJcbiAgICAgKiBAcGFyYW0gbGVuZ3RoIEFuIG9wdGlvbmFsIHZhbGlkYXRpb24gbGVuZ3RoIGZvciB0aGUgdHJ5dGVzLCAwIG1lYW5zIGlnbm9yZSBsZW5ndGguXHJcbiAgICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBUcnl0ZXMuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tU3RyaW5nKHZhbHVlLCBsZW5ndGggPSAwKSB7XHJcbiAgICAgICAgaWYgKCFzdHJpbmdIZWxwZXJfMS5TdHJpbmdIZWxwZXIuaXNTdHJpbmcodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXCJUaGUgdmFsdWUgbXVzdCBiZSBhIG5vbiBlbXB0eSBzdHJpbmdcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihsZW5ndGgpIHx8IGxlbmd0aCA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihcIlRoZSBsZW5ndGggbXVzdCBiZSA+PSAwXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIVRyeXRlcy5pc1ZhbGlkKHZhbHVlLCBsZW5ndGgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXCJUaGUgdmFsdWUgYW5kIGxlbmd0aCBkbyBub3QgY29udGFpbiB2YWxpZCB0cnl0ZXNcIiwgeyB2YWx1ZSwgbGVuZ3RoIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFRyeXRlcyh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERvZXMgdGhlIHZhbHVlIGNvbnRhaW4gdmFsaWQgdHJ5dGVzLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIEEgc3RyaW5nIHRvIHZhbGlkYXRlIGFzIHRyeXRlcy5cclxuICAgICAqIEBwYXJhbSBsZW5ndGggQW4gb3B0aW9uYWwgdmFsaWRhdGlvbiBsZW5ndGggZm9yIHRoZSB0cnl0ZXMsIDAgbWVhbnMgaWdub3JlIGxlbmd0aC5cclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGlucHV0IHdhcyB2YWxpZCB0cnl0ZXMuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc1ZhbGlkKHZhbHVlLCBsZW5ndGggPSAwKSB7XHJcbiAgICAgICAgaWYgKCFzdHJpbmdIZWxwZXJfMS5TdHJpbmdIZWxwZXIuaXNTdHJpbmcodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKGBeWzlBLVpdeyR7bGVuZ3RoID8gbGVuZ3RoIDogXCIwLFwifX0kYCkudGVzdCh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0IHRoZSB0cnl0ZXMgdG8gYSBzdHJpbmcuXHJcbiAgICAgKiBAcmV0dXJucyBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRyeXRlcy5cclxuICAgICAqL1xyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyeXRlcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBsZW5ndGggb2YgdGhlIHRyeXRlcy5cclxuICAgICAqIEByZXR1cm5zIFRoZSBsZW5ndGggb2YgdGhlIHRyeXRlcy5cclxuICAgICAqL1xyXG4gICAgbGVuZ3RoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90cnl0ZXMubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgYSBzdWIgb2YgdGhlIHRyeXRlcy5cclxuICAgICAqIEBwYXJhbSBzdGFydCBUaGUgc3RhcnQgcG9zaXRpb24gdG8gZ2V0IHRoZSBzdWIuXHJcbiAgICAgKiBAcGFyYW0gbGVuZ3RoIFRoZSBsZW5ndGggb2YgdGhlIHN1Yi5cclxuICAgICAqIEByZXR1cm5zIFRoZSB0cnl0ZXMgc3ViLlxyXG4gICAgICovXHJcbiAgICBzdWIoc3RhcnQsIGxlbmd0aCkge1xyXG4gICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihzdGFydCkgfHwgc3RhcnQgPCAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXCJUaGUgc3RhcnQgbXVzdCBiZSBhIG51bWJlciA+PSAwXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIobGVuZ3RoKSB8fCAoc3RhcnQgKyBsZW5ndGgpID4gdGhpcy5fdHJ5dGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKGBUaGUgc3RhcnQgKyBsZW5ndGggbXVzdCA8PSAke3RoaXMuX3RyeXRlcy5sZW5ndGh9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBUcnl0ZXMuZnJvbVN0cmluZyh0aGlzLl90cnl0ZXMuc3Vic3RyKHN0YXJ0LCBsZW5ndGgpKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQWxsIHRoZSBjaGFyYWN0ZXJzIHRoYXQgY2FuIGJlIHVzZWQgaW4gdHJ5dGVzLlxyXG4gKi9cclxuVHJ5dGVzLkFMUEhBQkVUID0gXCI5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpcIjtcclxuZXhwb3J0cy5Ucnl0ZXMgPSBUcnl0ZXM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWRISjVkR1Z6TG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhNaU9sc2lMaTR2TGk0dmMzSmpMMlJoZEdFdmRISjVkR1Z6TG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN1FVRkJRU3cwUlVGQmVVVTdRVUZEZWtVc05FVkJRWGxGTzBGQlEzcEZMR3RFUVVFclF6dEJRVVV2UXpzN1IwRkZSenRCUVVOSU8wbEJVMGtzWlVGQlpUdEpRVU5tTEZsQlFXOUNMRTFCUVdNN1VVRkRPVUlzU1VGQlNTeERRVUZETEU5QlFVOHNSMEZCUnl4TlFVRk5MRU5CUVVNN1NVRkRNVUlzUTBGQlF6dEpRVVZFT3pzN096dFBRVXRITzBsQlEwa3NUVUZCVFN4RFFVRkRMRlZCUVZVc1EwRkJReXhMUVVGaExFVkJRVVVzVTBGQmFVSXNRMEZCUXp0UlFVTjBSQ3hKUVVGSkxFTkJRVU1zTWtKQlFWa3NRMEZCUXl4UlFVRlJMRU5CUVVNc1MwRkJTeXhEUVVGRExFVkJRVVU3V1VGREwwSXNUVUZCVFN4SlFVRkpMSEZDUVVGVExFTkJRVU1zYzBOQlFYTkRMRU5CUVVNc1EwRkJRenRUUVVNdlJEdFJRVU5FTEVsQlFVa3NRMEZCUXl3eVFrRkJXU3hEUVVGRExGTkJRVk1zUTBGQlF5eE5RVUZOTEVOQlFVTXNTVUZCU1N4TlFVRk5MRWRCUVVjc1EwRkJReXhGUVVGRk8xbEJReTlETEUxQlFVMHNTVUZCU1N4eFFrRkJVeXhEUVVGRExIbENRVUY1UWl4RFFVRkRMRU5CUVVNN1UwRkRiRVE3VVVGRFJDeEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRTlCUVU4c1EwRkJReXhMUVVGTExFVkJRVVVzVFVGQlRTeERRVUZETEVWQlFVVTdXVUZEYUVNc1RVRkJUU3hKUVVGSkxIRkNRVUZUTEVOQlFVTXNhMFJCUVd0RUxFVkJRVVVzUlVGQlJTeExRVUZMTEVWQlFVVXNUVUZCVFN4RlFVRkZMRU5CUVVNc1EwRkJRenRUUVVNNVJqdFJRVU5FTEU5QlFVOHNTVUZCU1N4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU03U1VGRE4wSXNRMEZCUXp0SlFVVkVPenM3T3p0UFFVdEhPMGxCUTBrc1RVRkJUU3hEUVVGRExFOUJRVThzUTBGQlF5eExRVUZoTEVWQlFVVXNVMEZCYVVJc1EwRkJRenRSUVVOdVJDeEpRVUZKTEVOQlFVTXNNa0pCUVZrc1EwRkJReXhSUVVGUkxFTkJRVU1zUzBGQlN5eERRVUZETEVWQlFVVTdXVUZETDBJc1QwRkJUeXhMUVVGTExFTkJRVU03VTBGRGFFSTdZVUZCVFR0WlFVTklMRTlCUVU4c1NVRkJTU3hOUVVGTkxFTkJRVU1zVjBGQlZ5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU1zU1VGQlNTeEpRVUZKTEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU03VTBGRGVFVTdTVUZEVEN4RFFVRkRPMGxCUlVRN096dFBRVWRITzBsQlEwa3NVVUZCVVR0UlFVTllMRTlCUVU4c1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF6dEpRVU40UWl4RFFVRkRPMGxCUlVRN096dFBRVWRITzBsQlEwa3NUVUZCVFR0UlFVTlVMRTlCUVU4c1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eE5RVUZOTEVOQlFVTTdTVUZETDBJc1EwRkJRenRKUVVWRU96czdPenRQUVV0SE8wbEJRMGtzUjBGQlJ5eERRVUZETEV0QlFXRXNSVUZCUlN4TlFVRmpPMUZCUTNCRExFbEJRVWtzUTBGQlF5d3lRa0ZCV1N4RFFVRkRMRk5CUVZNc1EwRkJReXhMUVVGTExFTkJRVU1zU1VGQlNTeExRVUZMTEVkQlFVY3NRMEZCUXl4RlFVRkZPMWxCUXpkRExFMUJRVTBzU1VGQlNTeHhRa0ZCVXl4RFFVRkRMR2xEUVVGcFF5eERRVUZETEVOQlFVTTdVMEZETVVRN1VVRkRSQ3hKUVVGSkxFTkJRVU1zTWtKQlFWa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eExRVUZMTEVkQlFVY3NUVUZCVFN4RFFVRkRMRWRCUVVjc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eE5RVUZOTEVWQlFVVTdXVUZETTBVc1RVRkJUU3hKUVVGSkxIRkNRVUZUTEVOQlFVTXNPRUpCUVRoQ0xFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNUVUZCVFN4RlFVRkZMRU5CUVVNc1EwRkJRenRUUVVNMVJUdFJRVU5FTEU5QlFVOHNUVUZCVFN4RFFVRkRMRlZCUVZVc1EwRkJReXhKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEUxQlFVMHNRMEZCUXl4TFFVRkxMRVZCUVVVc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF6dEpRVU5xUlN4RFFVRkRPenRCUVRWRlJEczdSMEZGUnp0QlFVTlhMR1ZCUVZFc1IwRkJWeXcyUWtGQk5rSXNRMEZCUXp0QlFVcHVSU3gzUWtFNFJVTWlmUT09IiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBjb3JlRXJyb3JfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9lcnJvci9jb3JlRXJyb3JcIik7XHJcbi8qKlxyXG4gKiBBIGRhdGEgaW1wbGVtZW50YXRpb24gb2YgYW4gZXJyb3IuXHJcbiAqL1xyXG5jbGFzcyBEYXRhRXJyb3IgZXh0ZW5kcyBjb3JlRXJyb3JfMS5Db3JlRXJyb3Ige1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgRGF0YUVycm9yLlxyXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgVGhlIG1lc3NhZ2UgZm9yIHRoZSBlcnJvci5cclxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsIEFkZGl0aW9uYWwgZGV0YWlscyBhYm91dCB0aGUgZXJyb3IuXHJcbiAgICAgKiBAcGFyYW0gaW5uZXJFcnJvciBBZGQgaW5mb3JtYXRpb24gZnJvbSBpbm5lciBlcnJvciBpZiB0aGVyZSB3YXMgb25lLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBhZGRpdGlvbmFsLCBpbm5lckVycm9yKSB7XHJcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgYWRkaXRpb25hbCwgaW5uZXJFcnJvcik7XHJcbiAgICAgICAgdGhpcy5kb21haW4gPSBcIkRhdGFcIjtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkRhdGFFcnJvciA9IERhdGFFcnJvcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pWkdGMFlVVnljbTl5TG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhNaU9sc2lMaTR2TGk0dmMzSmpMMlZ5Y205eUwyUmhkR0ZGY25KdmNpNTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPMEZCUVVFc2IwVkJRV2xGTzBGQlJXcEZPenRIUVVWSE8wRkJRMGdzWlVGQmRVSXNVMEZCVVN4eFFrRkJVenRKUVVOd1F6czdPenM3VDBGTFJ6dEpRVU5JTEZsQlFWa3NUMEZCWlN4RlFVRkZMRlZCUVd0RExFVkJRVVVzVlVGQmEwSTdVVUZETDBVc1MwRkJTeXhEUVVGRExFOUJRVThzUlVGQlJTeFZRVUZWTEVWQlFVVXNWVUZCVlN4RFFVRkRMRU5CUVVNN1VVRkRka01zU1VGQlNTeERRVUZETEUxQlFVMHNSMEZCUnl4TlFVRk5MRU5CUVVNN1NVRkRla0lzUTBGQlF6dERRVU5LTzBGQldFUXNPRUpCVjBNaWZRPT0iLCJmdW5jdGlvbiBfX2V4cG9ydChtKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKipcclxuICogQ29tYmluZWQgaW5kZXggb2YgYWxsIHRoZSBtb2R1bGVzLlxyXG4gKi9cclxuX19leHBvcnQocmVxdWlyZShcIi4vcHJvb2ZPZldvcmtXYXNtXCIpKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYVc1a1pYZ3Vhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOXpjbU12YVc1a1pYZ3VkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanM3T3p0QlFVRkJPenRIUVVWSE8wRkJRMGdzZFVOQlFXdERJbjA9IiwidmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vLy8gPHJlZmVyZW5jZSB0eXBlcz1cImVtc2NyaXB0ZW5cIiAvPlxyXG5jb25zdCBudW1iZXJIZWxwZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL251bWJlckhlbHBlclwiKTtcclxuY29uc3Qgb2JqZWN0SGVscGVyXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9vYmplY3RIZWxwZXJcIik7XHJcbmNvbnN0IGNyeXB0b0Vycm9yXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jcnlwdG8vZGlzdC9lcnJvci9jcnlwdG9FcnJvclwiKTtcclxuY29uc3QgcHJvb2ZPZldvcmtCYXNlXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jcnlwdG8vZGlzdC9wcm9vZk9mV29yay9wcm9vZk9mV29ya0Jhc2VcIik7XHJcbmNvbnN0IHRyeXRlc18xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvdHJ5dGVzXCIpO1xyXG4vLyBAdHMtaWdub3JlXHJcbmNvbnN0IGlvdGFfcGljb19wb3dfd2FzbV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi93YXNtL2lvdGEtcGljby1wb3ctd2FzbVwiKSk7XHJcbi8qKlxyXG4gKiBQcm9vZk9mV29yayBpbXBsZW1lbnRhdGlvbiB1c2luZyBXZWJBc3NlbWJseS5cclxuICovXHJcbmNsYXNzIFByb29mT2ZXb3JrV2FzbSBleHRlbmRzIHByb29mT2ZXb3JrQmFzZV8xLlByb29mT2ZXb3JrQmFzZSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBQcm9vZk9mV29yay5cclxuICAgICAqIEBwYXJhbSB3ZWJQbGF0Zm9ybSBQcm92aWRlcyBwbGF0Zm9ybSBzcGVjaWZpYyBmdW5jdGlvbnMsIG9wdGlvbmFsIG1vc3RseSB1c2VkIGZvciB0ZXN0aW5nLlxyXG4gICAgICogQHBhcmFtIHRpbWVTZXJ2aWNlIFNlcnZpY2UgdG8gZ2V0IHRoZSB0aW1lIGZvciBhdHRhY2htZW50cy5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Iod2ViUGxhdGZvcm0sIHRpbWVTZXJ2aWNlKSB7XHJcbiAgICAgICAgc3VwZXIodGltZVNlcnZpY2UpO1xyXG4gICAgICAgIGlmIChvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNFbXB0eSh3ZWJQbGF0Zm9ybSkpIHtcclxuICAgICAgICAgICAgdGhpcy5fd2ViUGxhdGZvcm0gPSB7XHJcbiAgICAgICAgICAgICAgICB3ZWJBc3NlbWJseVR5cGU6IHR5cGVvZiBXZWJBc3NlbWJseSxcclxuICAgICAgICAgICAgICAgIHdhc21Nb2R1bGVMb2FkZXI6IGlvdGFfcGljb19wb3dfd2FzbV8xLmRlZmF1bHRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3dlYlBsYXRmb3JtID0gd2ViUGxhdGZvcm07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGxvdyB0aGUgcHJvb2Ygb2Ygd29yayB0byBwZXJmb3JtIGFueSBpbml0aWFsaXphdGlvbi5cclxuICAgICAqIFdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIHRoZSBpbXBsZW1lbnRhdGlvbiBpcyBub3Qgc3VwcG9ydGVkLlxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZS5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgaW5pdGlhbGl6ZSgpIHtcclxuICAgICAgICBhd2FpdCBzdXBlci5pbml0aWFsaXplKCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgaWYgKG9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc0VtcHR5KHRoaXMuX3dlYlBsYXRmb3JtLndlYkFzc2VtYmx5VHlwZSkgfHwgdGhpcy5fd2ViUGxhdGZvcm0ud2ViQXNzZW1ibHlUeXBlID09PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJObyBXZWJBc3NlbWJseSBzdXBwb3J0IGRldGVjdGVkXCIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBtb2R1bGUgPSB7fTtcclxuICAgICAgICAgICAgbW9kdWxlLm9uUnVudGltZUluaXRpYWxpemVkID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2N1cmxQb3cgPSBtb2R1bGUuY3dyYXAoXCJjY3VybF9wb3dcIiwgXCJzdHJpbmdcIiwgW1wic3RyaW5nXCIsIFwibnVtYmVyXCJdKTtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3dlYlBsYXRmb3JtLndhc21Nb2R1bGVMb2FkZXIobW9kdWxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJUaGVyZSB3YXMgYSBwcm9ibGVtIGludGlhbGl6aW5nIHRoZSBXZWJBc3NlbWJseSBNb2R1bGVcIiwgdW5kZWZpbmVkLCBlcnIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQZXJmb3JtIGEgcHJvb2Ygb2Ygd29yayBvbiBhIHNpbmdsZSBpdGVtLlxyXG4gICAgICogQHBhcmFtIHRyeXRlcyBUaGUgdHJ5dGVzIHRvIHBlcmZvcm0gdGhlIHBvdyBvbi5cclxuICAgICAqIEBwYXJhbSBtaW5XZWlnaHRNYWduaXR1ZGUgVGhlIG1pbmltdW0gd2VpZ2h0IG1hZ25pdHVkZS5cclxuICAgICAqIEByZXR1cm5zIFRoZSB0cnl0ZXMgcHJvZHVjZWQgYnkgdGhlIHByb29mIG9mIHdvcmsuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHNpbmdsZVBvdyh0cnl0ZXMsIG1pbldlaWdodE1hZ25pdHVkZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNFbXB0eSh0aGlzLl9jY3VybFBvdykpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiV2ViQXNzZW1ibHkgbm90IGxvYWRlZCwgaGF2ZSB5b3UgY2FsbGVkIGluaXRpYWxpemVcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHRyeXRlcywgdHJ5dGVzXzEuVHJ5dGVzKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJUaGUgdHJ5dGVzIG11c3QgYmUgYW4gb2JqZWN0IG9mIHR5cGUgVHJ5dGVzXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihtaW5XZWlnaHRNYWduaXR1ZGUpIHx8IG1pbldlaWdodE1hZ25pdHVkZSA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIlRoZSBtaW5XZWlnaHRNYWduaXR1ZGUgbXVzdCBiZSA+IDBcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2NjdXJsUG93KHRyeXRlcy50b1N0cmluZygpLCBtaW5XZWlnaHRNYWduaXR1ZGUpO1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0cnl0ZXNfMS5Ucnl0ZXMuZnJvbVN0cmluZyhyZXN1bHQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuUHJvb2ZPZldvcmtXYXNtID0gUHJvb2ZPZldvcmtXYXNtO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2ljSEp2YjJaUFpsZHZjbXRYWVhOdExtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dmMzSmpMM0J5YjI5bVQyWlhiM0pyVjJGemJTNTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPenM3TzBGQlFVRXNiME5CUVc5RE8wRkJRM0JETERSRlFVRjVSVHRCUVVONlJTdzBSVUZCZVVVN1FVRkZla1VzTUVWQlFYVkZPMEZCUTNaRkxIZEdRVUZ4Ump0QlFVTnlSaXcyUkVGQk1FUTdRVUZETVVRc1lVRkJZVHRCUVVOaUxHOUdRVUY1UkR0QlFVZDZSRHM3UjBGRlJ6dEJRVU5JTEhGQ1FVRTJRaXhUUVVGUkxHbERRVUZsTzBsQlQyaEVPenM3TzA5QlNVYzdTVUZEU0N4WlFVRlpMRmRCUVRCQ0xFVkJRVVVzVjBGQk1FSTdVVUZET1VRc1MwRkJTeXhEUVVGRExGZEJRVmNzUTBGQlF5eERRVUZETzFGQlJXNUNMRWxCUVVrc01rSkJRVmtzUTBGQlF5eFBRVUZQTEVOQlFVTXNWMEZCVnl4RFFVRkRMRVZCUVVVN1dVRkRia01zU1VGQlNTeERRVUZETEZsQlFWa3NSMEZCUnp0blFrRkRhRUlzWlVGQlpTeEZRVUZGTEU5QlFVOHNWMEZCVnp0blFrRkRia01zWjBKQlFXZENMRVZCUVVVc05FSkJRV1U3WVVGRGNFTXNRMEZCUXp0VFFVTk1PMkZCUVUwN1dVRkRTQ3hKUVVGSkxFTkJRVU1zV1VGQldTeEhRVUZITEZkQlFWY3NRMEZCUXp0VFFVTnVRenRKUVVOTUxFTkJRVU03U1VGRlJEczdPenRQUVVsSE8wbEJRMGtzUzBGQlN5eERRVUZETEZWQlFWVTdVVUZEYmtJc1RVRkJUU3hMUVVGTExFTkJRVU1zVlVGQlZTeEZRVUZGTEVOQlFVTTdVVUZEZWtJc1QwRkJUeXhKUVVGSkxFOUJRVThzUTBGQlR5eExRVUZMTEVWQlFVVXNUMEZCVHl4RlFVRkZMRTFCUVUwc1JVRkJSU3hGUVVGRk8xbEJReTlETEVsQlFVa3NNa0pCUVZrc1EwRkJReXhQUVVGUExFTkJRVU1zU1VGQlNTeERRVUZETEZsQlFWa3NRMEZCUXl4bFFVRmxMRU5CUVVNc1NVRkJTU3hKUVVGSkxFTkJRVU1zV1VGQldTeERRVUZETEdWQlFXVXNTMEZCU3l4WFFVRlhMRVZCUVVVN1owSkJRemxITEUxQlFVMHNRMEZCUXl4SlFVRkpMSGxDUVVGWExFTkJRVU1zYVVOQlFXbERMRU5CUVVNc1EwRkJReXhEUVVGRE8yRkJRemxFTzFsQlJVUXNUVUZCVFN4TlFVRk5MRWRCUVZFc1JVRkJSU3hEUVVGRE8xbEJSWFpDTEUxQlFVMHNRMEZCUXl4dlFrRkJiMElzUjBGQlJ5eEhRVUZITEVWQlFVVTdaMEpCUXk5Q0xFbEJRVWtzUTBGQlF5eFRRVUZUTEVkQlFVY3NUVUZCVFN4RFFVRkRMRXRCUVVzc1EwRkJReXhYUVVGWExFVkJRVVVzVVVGQlVTeEZRVUZGTEVOQlFVTXNVVUZCVVN4RlFVRkZMRkZCUVZFc1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlF6TkZMRTlCUVU4c1JVRkJSU3hEUVVGRE8xbEJRMlFzUTBGQlF5eERRVUZETzFsQlJVWXNTVUZCU1R0blFrRkRRU3hKUVVGSkxFTkJRVU1zV1VGQldTeERRVUZETEdkQ1FVRm5RaXhEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETzJGQlF6bERPMWxCUVVNc1QwRkJUeXhIUVVGSExFVkJRVVU3WjBKQlExWXNUVUZCVFN4RFFVRkRMRWxCUVVrc2VVSkJRVmNzUTBGQlF5eDNSRUZCZDBRc1JVRkJSU3hUUVVGVExFVkJRVVVzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXp0aFFVTnlSenRSUVVOTUxFTkJRVU1zUTBGQlF5eERRVUZETzBsQlExQXNRMEZCUXp0SlFVVkVPenM3T3p0UFFVdEhPMGxCUTBrc1MwRkJTeXhEUVVGRExGTkJRVk1zUTBGQlF5eE5RVUZqTEVWQlFVVXNhMEpCUVRCQ08xRkJRemRFTEU5QlFVOHNTVUZCU1N4UFFVRlBMRU5CUVZNc1EwRkJReXhQUVVGUExFVkJRVVVzVFVGQlRTeEZRVUZGTEVWQlFVVTdXVUZETTBNc1NVRkJTU3d5UWtGQldTeERRVUZETEU5QlFVOHNRMEZCUXl4SlFVRkpMRU5CUVVNc1UwRkJVeXhEUVVGRExFVkJRVVU3WjBKQlEzUkRMRTFCUVUwc1NVRkJTU3g1UWtGQlZ5eERRVUZETEc5RVFVRnZSQ3hEUVVGRExFTkJRVU03WVVGREwwVTdXVUZEUkN4SlFVRkpMRU5CUVVNc01rSkJRVmtzUTBGQlF5eE5RVUZOTEVOQlFVTXNUVUZCVFN4RlFVRkZMR1ZCUVUwc1EwRkJReXhGUVVGRk8yZENRVU4wUXl4TlFVRk5MRWxCUVVrc2VVSkJRVmNzUTBGQlF5dzJRMEZCTmtNc1EwRkJReXhEUVVGRE8yRkJRM2hGTzFsQlEwUXNTVUZCU1N4RFFVRkRMREpDUVVGWkxFTkJRVU1zVTBGQlV5eERRVUZETEd0Q1FVRnJRaXhEUVVGRExFbEJRVWtzYTBKQlFXdENMRWxCUVVrc1EwRkJReXhGUVVGRk8yZENRVU40UlN4TlFVRk5MRWxCUVVrc2VVSkJRVmNzUTBGQlF5eHZRMEZCYjBNc1EwRkJReXhEUVVGRE8yRkJReTlFTzFsQlJVUXNTVUZCU1R0blFrRkRRU3hOUVVGTkxFMUJRVTBzUjBGQlJ5eEpRVUZKTEVOQlFVTXNVMEZCVXl4RFFVRkRMRTFCUVUwc1EwRkJReXhSUVVGUkxFVkJRVVVzUlVGQlJTeHJRa0ZCYTBJc1EwRkJReXhEUVVGRE8yZENRVVZ5UlN4UFFVRlBMRU5CUVVNc1pVRkJUU3hEUVVGRExGVkJRVlVzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRPMkZCUTNSRE8xbEJRVU1zVDBGQlR5eEhRVUZITEVWQlFVVTdaMEpCUTFZc1RVRkJUU3hEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETzJGQlEyWTdVVUZEVEN4RFFVRkRMRU5CUVVNc1EwRkJRenRKUVVOUUxFTkJRVU03UTBGRFNqdEJRUzlGUkN3d1EwRXJSVU1pZlE9PSIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlZ2VuZXJhdG9yLXJ1bnRpbWVcIik7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbi8vIFRoaXMgbWV0aG9kIG9mIG9idGFpbmluZyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdCBuZWVkcyB0byBiZVxuLy8ga2VwdCBpZGVudGljYWwgdG8gdGhlIHdheSBpdCBpcyBvYnRhaW5lZCBpbiBydW50aW1lLmpzXG52YXIgZyA9IChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMgfSkoKSB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG5cbi8vIFVzZSBgZ2V0T3duUHJvcGVydHlOYW1lc2AgYmVjYXVzZSBub3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgY2FsbGluZ1xuLy8gYGhhc093blByb3BlcnR5YCBvbiB0aGUgZ2xvYmFsIGBzZWxmYCBvYmplY3QgaW4gYSB3b3JrZXIuIFNlZSAjMTgzLlxudmFyIGhhZFJ1bnRpbWUgPSBnLnJlZ2VuZXJhdG9yUnVudGltZSAmJlxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhnKS5pbmRleE9mKFwicmVnZW5lcmF0b3JSdW50aW1lXCIpID49IDA7XG5cbi8vIFNhdmUgdGhlIG9sZCByZWdlbmVyYXRvclJ1bnRpbWUgaW4gY2FzZSBpdCBuZWVkcyB0byBiZSByZXN0b3JlZCBsYXRlci5cbnZhciBvbGRSdW50aW1lID0gaGFkUnVudGltZSAmJiBnLnJlZ2VuZXJhdG9yUnVudGltZTtcblxuLy8gRm9yY2UgcmVldmFsdXRhdGlvbiBvZiBydW50aW1lLmpzLlxuZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSB1bmRlZmluZWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vcnVudGltZVwiKTtcblxuaWYgKGhhZFJ1bnRpbWUpIHtcbiAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgcnVudGltZS5cbiAgZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSBvbGRSdW50aW1lO1xufSBlbHNlIHtcbiAgLy8gUmVtb3ZlIHRoZSBnbG9iYWwgcHJvcGVydHkgYWRkZWQgYnkgcnVudGltZS5qcy5cbiAgdHJ5IHtcbiAgICBkZWxldGUgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIH0gY2F0Y2goZSkge1xuICAgIGcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuICB9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbiEoZnVuY3Rpb24oZ2xvYmFsKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgdmFyIGluTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIjtcbiAgdmFyIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lO1xuICBpZiAocnVudGltZSkge1xuICAgIGlmIChpbk1vZHVsZSkge1xuICAgICAgLy8gSWYgcmVnZW5lcmF0b3JSdW50aW1lIGlzIGRlZmluZWQgZ2xvYmFsbHkgYW5kIHdlJ3JlIGluIGEgbW9kdWxlLFxuICAgICAgLy8gbWFrZSB0aGUgZXhwb3J0cyBvYmplY3QgaWRlbnRpY2FsIHRvIHJlZ2VuZXJhdG9yUnVudGltZS5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gcnVudGltZTtcbiAgICB9XG4gICAgLy8gRG9uJ3QgYm90aGVyIGV2YWx1YXRpbmcgdGhlIHJlc3Qgb2YgdGhpcyBmaWxlIGlmIHRoZSBydW50aW1lIHdhc1xuICAgIC8vIGFscmVhZHkgZGVmaW5lZCBnbG9iYWxseS5cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBEZWZpbmUgdGhlIHJ1bnRpbWUgZ2xvYmFsbHkgKGFzIGV4cGVjdGVkIGJ5IGdlbmVyYXRlZCBjb2RlKSBhcyBlaXRoZXJcbiAgLy8gbW9kdWxlLmV4cG9ydHMgKGlmIHdlJ3JlIGluIGEgbW9kdWxlKSBvciBhIG5ldywgZW1wdHkgb2JqZWN0LlxuICBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZSA9IGluTW9kdWxlID8gbW9kdWxlLmV4cG9ydHMgOiB7fTtcblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBydW50aW1lLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZVt0b1N0cmluZ1RhZ1N5bWJvbF0gPVxuICAgIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIHJ1bnRpbWUubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICBydW50aW1lLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi4gSWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQsIGhvd2V2ZXIsIHRoZVxuICAgICAgICAgIC8vIHJlc3VsdCBmb3IgdGhpcyBpdGVyYXRpb24gd2lsbCBiZSByZWplY3RlZCB3aXRoIHRoZSBzYW1lXG4gICAgICAgICAgLy8gcmVhc29uLiBOb3RlIHRoYXQgcmVqZWN0aW9ucyBvZiB5aWVsZGVkIFByb21pc2VzIGFyZSBub3RcbiAgICAgICAgICAvLyB0aHJvd24gYmFjayBpbnRvIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIGFzIGlzIHRoZSBjYXNlXG4gICAgICAgICAgLy8gd2hlbiBhbiBhd2FpdGVkIFByb21pc2UgaXMgcmVqZWN0ZWQuIFRoaXMgZGlmZmVyZW5jZSBpblxuICAgICAgICAgIC8vIGJlaGF2aW9yIGJldHdlZW4geWllbGQgYW5kIGF3YWl0IGlzIGltcG9ydGFudCwgYmVjYXVzZSBpdFxuICAgICAgICAgIC8vIGFsbG93cyB0aGUgY29uc3VtZXIgdG8gZGVjaWRlIHdoYXQgdG8gZG8gd2l0aCB0aGUgeWllbGRlZFxuICAgICAgICAgIC8vIHJlamVjdGlvbiAoc3dhbGxvdyBpdCBhbmQgY29udGludWUsIG1hbnVhbGx5IC50aHJvdyBpdCBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgZ2VuZXJhdG9yLCBhYmFuZG9uIGl0ZXJhdGlvbiwgd2hhdGV2ZXIpLiBXaXRoXG4gICAgICAgICAgLy8gYXdhaXQsIGJ5IGNvbnRyYXN0LCB0aGVyZSBpcyBubyBvcHBvcnR1bml0eSB0byBleGFtaW5lIHRoZVxuICAgICAgICAgIC8vIHJlamVjdGlvbiByZWFzb24gb3V0c2lkZSB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBzbyB0aGVcbiAgICAgICAgICAvLyBvbmx5IG9wdGlvbiBpcyB0byB0aHJvdyBpdCBmcm9tIHRoZSBhd2FpdCBleHByZXNzaW9uLCBhbmRcbiAgICAgICAgICAvLyBsZXQgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiBoYW5kbGUgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgQXN5bmNJdGVyYXRvci5wcm90b3R5cGVbYXN5bmNJdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIHJ1bnRpbWUuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIHJ1bnRpbWUuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KVxuICAgICk7XG5cbiAgICByZXR1cm4gcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICBpZiAoISBpbmZvKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIEdwW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yXCI7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgcnVudGltZS5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIHJ1bnRpbWUudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG59KShcbiAgLy8gSW4gc2xvcHB5IG1vZGUsIHVuYm91bmQgYHRoaXNgIHJlZmVycyB0byB0aGUgZ2xvYmFsIG9iamVjdCwgZmFsbGJhY2sgdG9cbiAgLy8gRnVuY3Rpb24gY29uc3RydWN0b3IgaWYgd2UncmUgaW4gZ2xvYmFsIHN0cmljdCBtb2RlLiBUaGF0IGlzIHNhZGx5IGEgZm9ybVxuICAvLyBvZiBpbmRpcmVjdCBldmFsIHdoaWNoIHZpb2xhdGVzIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5LlxuICAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzIH0pKCkgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpXG4pO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdH1cclxuXHRyZXR1cm4gbW9kdWxlO1xyXG59O1xyXG4iLCJ2YXIgTW9kdWxlID0gZnVuY3Rpb24oTW9kdWxlKSB7XHJcbiAgTW9kdWxlID0gTW9kdWxlIHx8IHt9O1xyXG5cclxuLy8gVGhlIE1vZHVsZSBvYmplY3Q6IE91ciBpbnRlcmZhY2UgdG8gdGhlIG91dHNpZGUgd29ybGQuIFdlIGltcG9ydFxyXG4vLyBhbmQgZXhwb3J0IHZhbHVlcyBvbiBpdC4gVGhlcmUgYXJlIHZhcmlvdXMgd2F5cyBNb2R1bGUgY2FuIGJlIHVzZWQ6XHJcbi8vIDEuIE5vdCBkZWZpbmVkLiBXZSBjcmVhdGUgaXQgaGVyZVxyXG4vLyAyLiBBIGZ1bmN0aW9uIHBhcmFtZXRlciwgZnVuY3Rpb24oTW9kdWxlKSB7IC4uZ2VuZXJhdGVkIGNvZGUuLiB9XHJcbi8vIDMuIHByZS1ydW4gYXBwZW5kZWQgaXQsIHZhciBNb2R1bGUgPSB7fTsgLi5nZW5lcmF0ZWQgY29kZS4uXHJcbi8vIDQuIEV4dGVybmFsIHNjcmlwdCB0YWcgZGVmaW5lcyB2YXIgTW9kdWxlLlxyXG4vLyBXZSBuZWVkIHRvIGNoZWNrIGlmIE1vZHVsZSBhbHJlYWR5IGV4aXN0cyAoZS5nLiBjYXNlIDMgYWJvdmUpLlxyXG4vLyBTdWJzdGl0dXRpb24gd2lsbCBiZSByZXBsYWNlZCB3aXRoIGFjdHVhbCBjb2RlIG9uIGxhdGVyIHN0YWdlIG9mIHRoZSBidWlsZCxcclxuLy8gdGhpcyB3YXkgQ2xvc3VyZSBDb21waWxlciB3aWxsIG5vdCBtYW5nbGUgaXQgKGUuZy4gY2FzZSA0LiBhYm92ZSkuXHJcbi8vIE5vdGUgdGhhdCBpZiB5b3Ugd2FudCB0byBydW4gY2xvc3VyZSwgYW5kIGFsc28gdG8gdXNlIE1vZHVsZVxyXG4vLyBhZnRlciB0aGUgZ2VuZXJhdGVkIGNvZGUsIHlvdSB3aWxsIG5lZWQgdG8gZGVmaW5lICAgdmFyIE1vZHVsZSA9IHt9O1xyXG4vLyBiZWZvcmUgdGhlIGNvZGUuIFRoZW4gdGhhdCBvYmplY3Qgd2lsbCBiZSB1c2VkIGluIHRoZSBjb2RlLCBhbmQgeW91XHJcbi8vIGNhbiBjb250aW51ZSB0byB1c2UgTW9kdWxlIGFmdGVyd2FyZHMgYXMgd2VsbC5cclxudmFyIE1vZHVsZSA9IHR5cGVvZiBNb2R1bGUgIT09ICd1bmRlZmluZWQnID8gTW9kdWxlIDoge307XHJcblxyXG4vLyAtLXByZS1qc2VzIGFyZSBlbWl0dGVkIGFmdGVyIHRoZSBNb2R1bGUgaW50ZWdyYXRpb24gY29kZSwgc28gdGhhdCB0aGV5IGNhblxyXG4vLyByZWZlciB0byBNb2R1bGUgKGlmIHRoZXkgY2hvb3NlOyB0aGV5IGNhbiBhbHNvIGRlZmluZSBNb2R1bGUpXHJcbi8vIHt7UFJFX0pTRVN9fVxyXG5cclxuLy8gU29tZXRpbWVzIGFuIGV4aXN0aW5nIE1vZHVsZSBvYmplY3QgZXhpc3RzIHdpdGggcHJvcGVydGllc1xyXG4vLyBtZWFudCB0byBvdmVyd3JpdGUgdGhlIGRlZmF1bHQgbW9kdWxlIGZ1bmN0aW9uYWxpdHkuIEhlcmVcclxuLy8gd2UgY29sbGVjdCB0aG9zZSBwcm9wZXJ0aWVzIGFuZCByZWFwcGx5IF9hZnRlcl8gd2UgY29uZmlndXJlXHJcbi8vIHRoZSBjdXJyZW50IGVudmlyb25tZW50J3MgZGVmYXVsdHMgdG8gYXZvaWQgaGF2aW5nIHRvIGJlIHNvXHJcbi8vIGRlZmVuc2l2ZSBkdXJpbmcgaW5pdGlhbGl6YXRpb24uXHJcbnZhciBtb2R1bGVPdmVycmlkZXMgPSB7fTtcclxudmFyIGtleTtcclxuZm9yIChrZXkgaW4gTW9kdWxlKSB7XHJcbiAgaWYgKE1vZHVsZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICBtb2R1bGVPdmVycmlkZXNba2V5XSA9IE1vZHVsZVtrZXldO1xyXG4gIH1cclxufVxyXG5cclxuTW9kdWxlWydhcmd1bWVudHMnXSA9IFtdO1xyXG5Nb2R1bGVbJ3RoaXNQcm9ncmFtJ10gPSAnLi90aGlzLnByb2dyYW0nO1xyXG5Nb2R1bGVbJ3F1aXQnXSA9IGZ1bmN0aW9uKHN0YXR1cywgdG9UaHJvdykge1xyXG4gIHRocm93IHRvVGhyb3c7XHJcbn07XHJcbk1vZHVsZVsncHJlUnVuJ10gPSBbXTtcclxuTW9kdWxlWydwb3N0UnVuJ10gPSBbXTtcclxuXHJcbi8vIFRoZSBlbnZpcm9ubWVudCBzZXR1cCBjb2RlIGJlbG93IGlzIGN1c3RvbWl6ZWQgdG8gdXNlIE1vZHVsZS5cclxuLy8gKioqIEVudmlyb25tZW50IHNldHVwIGNvZGUgKioqXHJcbnZhciBFTlZJUk9OTUVOVF9JU19XRUIgPSBmYWxzZTtcclxudmFyIEVOVklST05NRU5UX0lTX1dPUktFUiA9IGZhbHNlO1xyXG52YXIgRU5WSVJPTk1FTlRfSVNfTk9ERSA9IGZhbHNlO1xyXG52YXIgRU5WSVJPTk1FTlRfSVNfU0hFTEwgPSBmYWxzZTtcclxuXHJcbi8vIFRocmVlIGNvbmZpZ3VyYXRpb25zIHdlIGNhbiBiZSBydW5uaW5nIGluOlxyXG4vLyAxKSBXZSBjb3VsZCBiZSB0aGUgYXBwbGljYXRpb24gbWFpbigpIHRocmVhZCBydW5uaW5nIGluIHRoZSBtYWluIEpTIFVJIHRocmVhZC4gKEVOVklST05NRU5UX0lTX1dPUktFUiA9PSBmYWxzZSBhbmQgRU5WSVJPTk1FTlRfSVNfUFRIUkVBRCA9PSBmYWxzZSlcclxuLy8gMikgV2UgY291bGQgYmUgdGhlIGFwcGxpY2F0aW9uIG1haW4oKSB0aHJlYWQgcHJveGllZCB0byB3b3JrZXIuICh3aXRoIEVtc2NyaXB0ZW4gLXMgUFJPWFlfVE9fV09SS0VSPTEpIChFTlZJUk9OTUVOVF9JU19XT1JLRVIgPT0gdHJ1ZSwgRU5WSVJPTk1FTlRfSVNfUFRIUkVBRCA9PSBmYWxzZSlcclxuLy8gMykgV2UgY291bGQgYmUgYW4gYXBwbGljYXRpb24gcHRocmVhZCBydW5uaW5nIGluIGEgd29ya2VyLiAoRU5WSVJPTk1FTlRfSVNfV09SS0VSID09IHRydWUgYW5kIEVOVklST05NRU5UX0lTX1BUSFJFQUQgPT0gdHJ1ZSlcclxuXHJcbmlmIChNb2R1bGVbJ0VOVklST05NRU5UJ10pIHtcclxuICBpZiAoTW9kdWxlWydFTlZJUk9OTUVOVCddID09PSAnV0VCJykge1xyXG4gICAgRU5WSVJPTk1FTlRfSVNfV0VCID0gdHJ1ZTtcclxuICB9IGVsc2UgaWYgKE1vZHVsZVsnRU5WSVJPTk1FTlQnXSA9PT0gJ1dPUktFUicpIHtcclxuICAgIEVOVklST05NRU5UX0lTX1dPUktFUiA9IHRydWU7XHJcbiAgfSBlbHNlIGlmIChNb2R1bGVbJ0VOVklST05NRU5UJ10gPT09ICdOT0RFJykge1xyXG4gICAgRU5WSVJPTk1FTlRfSVNfTk9ERSA9IHRydWU7XHJcbiAgfSBlbHNlIGlmIChNb2R1bGVbJ0VOVklST05NRU5UJ10gPT09ICdTSEVMTCcpIHtcclxuICAgIEVOVklST05NRU5UX0lTX1NIRUxMID0gdHJ1ZTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdNb2R1bGVbXFwnRU5WSVJPTk1FTlRcXCddIHZhbHVlIGlzIG5vdCB2YWxpZC4gbXVzdCBiZSBvbmUgb2Y6IFdFQnxXT1JLRVJ8Tk9ERXxTSEVMTC4nKTtcclxuICB9XHJcbn0gZWxzZSB7XHJcbiAgRU5WSVJPTk1FTlRfSVNfV0VCID0gdHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCc7XHJcbiAgRU5WSVJPTk1FTlRfSVNfV09SS0VSID0gdHlwZW9mIGltcG9ydFNjcmlwdHMgPT09ICdmdW5jdGlvbic7XHJcbiAgRU5WSVJPTk1FTlRfSVNfTk9ERSA9IHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyAmJiAhRU5WSVJPTk1FTlRfSVNfV0VCICYmICFFTlZJUk9OTUVOVF9JU19XT1JLRVI7XHJcbiAgRU5WSVJPTk1FTlRfSVNfU0hFTEwgPSAhRU5WSVJPTk1FTlRfSVNfV0VCICYmICFFTlZJUk9OTUVOVF9JU19OT0RFICYmICFFTlZJUk9OTUVOVF9JU19XT1JLRVI7XHJcbn1cclxuXHJcblxyXG5pZiAoRU5WSVJPTk1FTlRfSVNfTk9ERSkge1xyXG4gIC8vIEV4cG9zZSBmdW5jdGlvbmFsaXR5IGluIHRoZSBzYW1lIHNpbXBsZSB3YXkgdGhhdCB0aGUgc2hlbGxzIHdvcmtcclxuICAvLyBOb3RlIHRoYXQgd2UgcG9sbHV0ZSB0aGUgZ2xvYmFsIG5hbWVzcGFjZSBoZXJlLCBvdGhlcndpc2Ugd2UgYnJlYWsgaW4gbm9kZVxyXG4gIHZhciBub2RlRlM7XHJcbiAgdmFyIG5vZGVQYXRoO1xyXG5cclxuICBNb2R1bGVbJ3JlYWQnXSA9IGZ1bmN0aW9uIHNoZWxsX3JlYWQoZmlsZW5hbWUsIGJpbmFyeSkge1xyXG4gICAgdmFyIHJldDtcclxuICAgIHJldCA9IHRyeVBhcnNlQXNEYXRhVVJJKGZpbGVuYW1lKTtcclxuICAgIGlmICghcmV0KSB7XHJcbiAgICAgIGlmICghbm9kZUZTKSBub2RlRlMgPSByZXF1aXJlKCdmcycpO1xyXG4gICAgICBpZiAoIW5vZGVQYXRoKSBub2RlUGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcclxuICAgICAgZmlsZW5hbWUgPSBub2RlUGF0aFsnbm9ybWFsaXplJ10oZmlsZW5hbWUpO1xyXG4gICAgICByZXQgPSBub2RlRlNbJ3JlYWRGaWxlU3luYyddKGZpbGVuYW1lKTtcclxuICAgIH1cclxuICAgIHJldHVybiBiaW5hcnkgPyByZXQgOiByZXQudG9TdHJpbmcoKTtcclxuICB9O1xyXG5cclxuICBNb2R1bGVbJ3JlYWRCaW5hcnknXSA9IGZ1bmN0aW9uIHJlYWRCaW5hcnkoZmlsZW5hbWUpIHtcclxuICAgIHZhciByZXQgPSBNb2R1bGVbJ3JlYWQnXShmaWxlbmFtZSwgdHJ1ZSk7XHJcbiAgICBpZiAoIXJldC5idWZmZXIpIHtcclxuICAgICAgcmV0ID0gbmV3IFVpbnQ4QXJyYXkocmV0KTtcclxuICAgIH1cclxuICAgIGFzc2VydChyZXQuYnVmZmVyKTtcclxuICAgIHJldHVybiByZXQ7XHJcbiAgfTtcclxuXHJcbiAgaWYgKHByb2Nlc3NbJ2FyZ3YnXS5sZW5ndGggPiAxKSB7XHJcbiAgICBNb2R1bGVbJ3RoaXNQcm9ncmFtJ10gPSBwcm9jZXNzWydhcmd2J11bMV0ucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xyXG4gIH1cclxuXHJcbiAgTW9kdWxlWydhcmd1bWVudHMnXSA9IHByb2Nlc3NbJ2FyZ3YnXS5zbGljZSgyKTtcclxuXHJcbiAgLy8gTU9EVUxBUklaRSB3aWxsIGV4cG9ydCB0aGUgbW9kdWxlIGluIHRoZSBwcm9wZXIgcGxhY2Ugb3V0c2lkZSwgd2UgZG9uJ3QgbmVlZCB0byBleHBvcnQgaGVyZVxyXG5cclxuICBwcm9jZXNzWydvbiddKCd1bmNhdWdodEV4Y2VwdGlvbicsIGZ1bmN0aW9uKGV4KSB7XHJcbiAgICAvLyBzdXBwcmVzcyBFeGl0U3RhdHVzIGV4Y2VwdGlvbnMgZnJvbSBzaG93aW5nIGFuIGVycm9yXHJcbiAgICBpZiAoIShleCBpbnN0YW5jZW9mIEV4aXRTdGF0dXMpKSB7XHJcbiAgICAgIHRocm93IGV4O1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIC8vIEN1cnJlbnRseSBub2RlIHdpbGwgc3dhbGxvdyB1bmhhbmRsZWQgcmVqZWN0aW9ucywgYnV0IHRoaXMgYmVoYXZpb3IgaXNcclxuICAvLyBkZXByZWNhdGVkLCBhbmQgaW4gdGhlIGZ1dHVyZSBpdCB3aWxsIGV4aXQgd2l0aCBlcnJvciBzdGF0dXMuXHJcbiAgcHJvY2Vzc1snb24nXSgndW5oYW5kbGVkUmVqZWN0aW9uJywgZnVuY3Rpb24ocmVhc29uLCBwKSB7XHJcbiAgICBNb2R1bGVbJ3ByaW50RXJyJ10oJ25vZGUuanMgZXhpdGluZyBkdWUgdG8gdW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJyk7XHJcbiAgICBwcm9jZXNzWydleGl0J10oMSk7XHJcbiAgfSk7XHJcblxyXG4gIE1vZHVsZVsnaW5zcGVjdCddID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ1tFbXNjcmlwdGVuIE1vZHVsZSBvYmplY3RdJzsgfTtcclxufVxyXG5lbHNlIGlmIChFTlZJUk9OTUVOVF9JU19TSEVMTCkge1xyXG4gIGlmICh0eXBlb2YgcmVhZCAhPSAndW5kZWZpbmVkJykge1xyXG4gICAgTW9kdWxlWydyZWFkJ10gPSBmdW5jdGlvbiBzaGVsbF9yZWFkKGYpIHtcclxuICAgICAgdmFyIGRhdGEgPSB0cnlQYXJzZUFzRGF0YVVSSShmKTtcclxuICAgICAgaWYgKGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gaW50QXJyYXlUb1N0cmluZyhkYXRhKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcmVhZChmKTtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBNb2R1bGVbJ3JlYWRCaW5hcnknXSA9IGZ1bmN0aW9uIHJlYWRCaW5hcnkoZikge1xyXG4gICAgdmFyIGRhdGE7XHJcbiAgICBkYXRhID0gdHJ5UGFyc2VBc0RhdGFVUkkoZik7XHJcbiAgICBpZiAoZGF0YSkge1xyXG4gICAgICByZXR1cm4gZGF0YTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgcmVhZGJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocmVhZGJ1ZmZlcihmKSk7XHJcbiAgICB9XHJcbiAgICBkYXRhID0gcmVhZChmLCAnYmluYXJ5Jyk7XHJcbiAgICBhc3NlcnQodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnKTtcclxuICAgIHJldHVybiBkYXRhO1xyXG4gIH07XHJcblxyXG4gIGlmICh0eXBlb2Ygc2NyaXB0QXJncyAhPSAndW5kZWZpbmVkJykge1xyXG4gICAgTW9kdWxlWydhcmd1bWVudHMnXSA9IHNjcmlwdEFyZ3M7XHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnRzICE9ICd1bmRlZmluZWQnKSB7XHJcbiAgICBNb2R1bGVbJ2FyZ3VtZW50cyddID0gYXJndW1lbnRzO1xyXG4gIH1cclxuXHJcbiAgaWYgKHR5cGVvZiBxdWl0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICBNb2R1bGVbJ3F1aXQnXSA9IGZ1bmN0aW9uKHN0YXR1cywgdG9UaHJvdykge1xyXG4gICAgICBxdWl0KHN0YXR1cyk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbmVsc2UgaWYgKEVOVklST05NRU5UX0lTX1dFQiB8fCBFTlZJUk9OTUVOVF9JU19XT1JLRVIpIHtcclxuICBNb2R1bGVbJ3JlYWQnXSA9IGZ1bmN0aW9uIHNoZWxsX3JlYWQodXJsKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIGZhbHNlKTtcclxuICAgICAgeGhyLnNlbmQobnVsbCk7XHJcbiAgICAgIHJldHVybiB4aHIucmVzcG9uc2VUZXh0O1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIHZhciBkYXRhID0gdHJ5UGFyc2VBc0RhdGFVUkkodXJsKTtcclxuICAgICAgaWYgKGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gaW50QXJyYXlUb1N0cmluZyhkYXRhKTtcclxuICAgICAgfVxyXG4gICAgICB0aHJvdyBlcnI7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgaWYgKEVOVklST05NRU5UX0lTX1dPUktFUikge1xyXG4gICAgTW9kdWxlWydyZWFkQmluYXJ5J10gPSBmdW5jdGlvbiByZWFkQmluYXJ5KHVybCkge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgICAgICB4aHIub3BlbignR0VUJywgdXJsLCBmYWxzZSk7XHJcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XHJcbiAgICAgICAgeGhyLnNlbmQobnVsbCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHhoci5yZXNwb25zZSk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgIHZhciBkYXRhID0gdHJ5UGFyc2VBc0RhdGFVUkkodXJsKTtcclxuICAgICAgICBpZiAoZGF0YSkge1xyXG4gICAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IGVycjtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIE1vZHVsZVsncmVhZEFzeW5jJ10gPSBmdW5jdGlvbiByZWFkQXN5bmModXJsLCBvbmxvYWQsIG9uZXJyb3IpIHtcclxuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xyXG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XHJcbiAgICB4aHIub25sb2FkID0gZnVuY3Rpb24geGhyX29ubG9hZCgpIHtcclxuICAgICAgaWYgKHhoci5zdGF0dXMgPT0gMjAwIHx8ICh4aHIuc3RhdHVzID09IDAgJiYgeGhyLnJlc3BvbnNlKSkgeyAvLyBmaWxlIFVSTHMgY2FuIHJldHVybiAwXHJcbiAgICAgICAgb25sb2FkKHhoci5yZXNwb25zZSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBkYXRhID0gdHJ5UGFyc2VBc0RhdGFVUkkodXJsKTtcclxuICAgICAgaWYgKGRhdGEpIHtcclxuICAgICAgICBvbmxvYWQoZGF0YS5idWZmZXIpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBvbmVycm9yKCk7XHJcbiAgICB9O1xyXG4gICAgeGhyLm9uZXJyb3IgPSBvbmVycm9yO1xyXG4gICAgeGhyLnNlbmQobnVsbCk7XHJcbiAgfTtcclxuXHJcbiAgaWYgKHR5cGVvZiBhcmd1bWVudHMgIT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIE1vZHVsZVsnYXJndW1lbnRzJ10gPSBhcmd1bWVudHM7XHJcbiAgfVxyXG5cclxuICBNb2R1bGVbJ3NldFdpbmRvd1RpdGxlJ10gPSBmdW5jdGlvbih0aXRsZSkgeyBkb2N1bWVudC50aXRsZSA9IHRpdGxlIH07XHJcbn1cclxuZWxzZSB7XHJcbiAgLy8gVW5yZWFjaGFibGUgYmVjYXVzZSBTSEVMTCBpcyBkZXBlbmRlbnQgb24gdGhlIG90aGVyc1xyXG4gIHRocm93IG5ldyBFcnJvcigndW5rbm93biBydW50aW1lIGVudmlyb25tZW50Jyk7XHJcbn1cclxuXHJcbi8vIGNvbnNvbGUubG9nIGlzIGNoZWNrZWQgZmlyc3QsIGFzICdwcmludCcgb24gdGhlIHdlYiB3aWxsIG9wZW4gYSBwcmludCBkaWFsb2d1ZVxyXG4vLyBwcmludEVyciBpcyBwcmVmZXJhYmxlIHRvIGNvbnNvbGUud2FybiAod29ya3MgYmV0dGVyIGluIHNoZWxscylcclxuTW9kdWxlWydwcmludCddID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnID8gY29uc29sZS5sb2cgOiAodHlwZW9mIHByaW50ICE9PSAndW5kZWZpbmVkJyA/IHByaW50IDogbnVsbCk7XHJcbk1vZHVsZVsncHJpbnRFcnInXSA9IHR5cGVvZiBwcmludEVyciAhPT0gJ3VuZGVmaW5lZCcgPyBwcmludEVyciA6ICgodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUud2FybikgfHwgTW9kdWxlWydwcmludCddKTtcclxuXHJcbi8vICoqKiBFbnZpcm9ubWVudCBzZXR1cCBjb2RlICoqKlxyXG5cclxuLy8gQ2xvc3VyZSBoZWxwZXJzXHJcbk1vZHVsZS5wcmludCA9IE1vZHVsZVsncHJpbnQnXTtcclxuTW9kdWxlLnByaW50RXJyID0gTW9kdWxlWydwcmludEVyciddO1xyXG5cclxuLy8gTWVyZ2UgYmFjayBpbiB0aGUgb3ZlcnJpZGVzXHJcbmZvciAoa2V5IGluIG1vZHVsZU92ZXJyaWRlcykge1xyXG4gIGlmIChtb2R1bGVPdmVycmlkZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgTW9kdWxlW2tleV0gPSBtb2R1bGVPdmVycmlkZXNba2V5XTtcclxuICB9XHJcbn1cclxuLy8gRnJlZSB0aGUgb2JqZWN0IGhpZXJhcmNoeSBjb250YWluZWQgaW4gdGhlIG92ZXJyaWRlcywgdGhpcyBsZXRzIHRoZSBHQ1xyXG4vLyByZWNsYWltIGRhdGEgdXNlZCBlLmcuIGluIG1lbW9yeUluaXRpYWxpemVyUmVxdWVzdCwgd2hpY2ggaXMgYSBsYXJnZSB0eXBlZCBhcnJheS5cclxubW9kdWxlT3ZlcnJpZGVzID0gdW5kZWZpbmVkO1xyXG5cclxuXHJcblxyXG4vLyB7e1BSRUFNQkxFX0FERElUSU9OU319XHJcblxyXG52YXIgU1RBQ0tfQUxJR04gPSAxNjtcclxuXHJcbi8vIHN0YWNrIG1hbmFnZW1lbnQsIGFuZCBvdGhlciBmdW5jdGlvbmFsaXR5IHRoYXQgaXMgcHJvdmlkZWQgYnkgdGhlIGNvbXBpbGVkIGNvZGUsXHJcbi8vIHNob3VsZCBub3QgYmUgdXNlZCBiZWZvcmUgaXQgaXMgcmVhZHlcclxuc3RhY2tTYXZlID0gc3RhY2tSZXN0b3JlID0gc3RhY2tBbGxvYyA9IHNldFRlbXBSZXQwID0gZ2V0VGVtcFJldDAgPSBmdW5jdGlvbigpIHtcclxuICBhYm9ydCgnY2Fubm90IHVzZSB0aGUgc3RhY2sgYmVmb3JlIGNvbXBpbGVkIGNvZGUgaXMgcmVhZHkgdG8gcnVuLCBhbmQgaGFzIHByb3ZpZGVkIHN0YWNrIGFjY2VzcycpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gc3RhdGljQWxsb2Moc2l6ZSkge1xyXG4gIGFzc2VydCghc3RhdGljU2VhbGVkKTtcclxuICB2YXIgcmV0ID0gU1RBVElDVE9QO1xyXG4gIFNUQVRJQ1RPUCA9IChTVEFUSUNUT1AgKyBzaXplICsgMTUpICYgLTE2O1xyXG4gIHJldHVybiByZXQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGR5bmFtaWNBbGxvYyhzaXplKSB7XHJcbiAgYXNzZXJ0KERZTkFNSUNUT1BfUFRSKTtcclxuICB2YXIgcmV0ID0gSEVBUDMyW0RZTkFNSUNUT1BfUFRSPj4yXTtcclxuICB2YXIgZW5kID0gKHJldCArIHNpemUgKyAxNSkgJiAtMTY7XHJcbiAgSEVBUDMyW0RZTkFNSUNUT1BfUFRSPj4yXSA9IGVuZDtcclxuICBpZiAoZW5kID49IFRPVEFMX01FTU9SWSkge1xyXG4gICAgdmFyIHN1Y2Nlc3MgPSBlbmxhcmdlTWVtb3J5KCk7XHJcbiAgICBpZiAoIXN1Y2Nlc3MpIHtcclxuICAgICAgSEVBUDMyW0RZTkFNSUNUT1BfUFRSPj4yXSA9IHJldDtcclxuICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByZXQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFsaWduTWVtb3J5KHNpemUsIGZhY3Rvcikge1xyXG4gIGlmICghZmFjdG9yKSBmYWN0b3IgPSBTVEFDS19BTElHTjsgLy8gc3RhY2sgYWxpZ25tZW50ICgxNi1ieXRlKSBieSBkZWZhdWx0XHJcbiAgdmFyIHJldCA9IHNpemUgPSBNYXRoLmNlaWwoc2l6ZSAvIGZhY3RvcikgKiBmYWN0b3I7XHJcbiAgcmV0dXJuIHJldDtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0TmF0aXZlVHlwZVNpemUodHlwZSkge1xyXG4gIHN3aXRjaCAodHlwZSkge1xyXG4gICAgY2FzZSAnaTEnOiBjYXNlICdpOCc6IHJldHVybiAxO1xyXG4gICAgY2FzZSAnaTE2JzogcmV0dXJuIDI7XHJcbiAgICBjYXNlICdpMzInOiByZXR1cm4gNDtcclxuICAgIGNhc2UgJ2k2NCc6IHJldHVybiA4O1xyXG4gICAgY2FzZSAnZmxvYXQnOiByZXR1cm4gNDtcclxuICAgIGNhc2UgJ2RvdWJsZSc6IHJldHVybiA4O1xyXG4gICAgZGVmYXVsdDoge1xyXG4gICAgICBpZiAodHlwZVt0eXBlLmxlbmd0aC0xXSA9PT0gJyonKSB7XHJcbiAgICAgICAgcmV0dXJuIDQ7IC8vIEEgcG9pbnRlclxyXG4gICAgICB9IGVsc2UgaWYgKHR5cGVbMF0gPT09ICdpJykge1xyXG4gICAgICAgIHZhciBiaXRzID0gcGFyc2VJbnQodHlwZS5zdWJzdHIoMSkpO1xyXG4gICAgICAgIGFzc2VydChiaXRzICUgOCA9PT0gMCk7XHJcbiAgICAgICAgcmV0dXJuIGJpdHMgLyA4O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiB3YXJuT25jZSh0ZXh0KSB7XHJcbiAgaWYgKCF3YXJuT25jZS5zaG93bikgd2Fybk9uY2Uuc2hvd24gPSB7fTtcclxuICBpZiAoIXdhcm5PbmNlLnNob3duW3RleHRdKSB7XHJcbiAgICB3YXJuT25jZS5zaG93blt0ZXh0XSA9IDE7XHJcbiAgICBNb2R1bGUucHJpbnRFcnIodGV4dCk7XHJcbiAgfVxyXG59XHJcblxyXG5cclxuXHJcbnZhciBmdW5jdGlvblBvaW50ZXJzID0gbmV3IEFycmF5KDApO1xyXG5cclxuZnVuY3Rpb24gYWRkRnVuY3Rpb24oZnVuYykge1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZnVuY3Rpb25Qb2ludGVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgaWYgKCFmdW5jdGlvblBvaW50ZXJzW2ldKSB7XHJcbiAgICAgIGZ1bmN0aW9uUG9pbnRlcnNbaV0gPSBmdW5jO1xyXG4gICAgICByZXR1cm4gMSArIGk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHRocm93ICdGaW5pc2hlZCB1cCBhbGwgcmVzZXJ2ZWQgZnVuY3Rpb24gcG9pbnRlcnMuIFVzZSBhIGhpZ2hlciB2YWx1ZSBmb3IgUkVTRVJWRURfRlVOQ1RJT05fUE9JTlRFUlMuJztcclxufVxyXG5cclxuZnVuY3Rpb24gcmVtb3ZlRnVuY3Rpb24oaW5kZXgpIHtcclxuICBmdW5jdGlvblBvaW50ZXJzW2luZGV4LTFdID0gbnVsbDtcclxufVxyXG5cclxudmFyIGZ1bmNXcmFwcGVycyA9IHt9O1xyXG5cclxuZnVuY3Rpb24gZ2V0RnVuY1dyYXBwZXIoZnVuYywgc2lnKSB7XHJcbiAgaWYgKCFmdW5jKSByZXR1cm47IC8vIG9uIG51bGwgcG9pbnRlciwgcmV0dXJuIHVuZGVmaW5lZFxyXG4gIGFzc2VydChzaWcpO1xyXG4gIGlmICghZnVuY1dyYXBwZXJzW3NpZ10pIHtcclxuICAgIGZ1bmNXcmFwcGVyc1tzaWddID0ge307XHJcbiAgfVxyXG4gIHZhciBzaWdDYWNoZSA9IGZ1bmNXcmFwcGVyc1tzaWddO1xyXG4gIGlmICghc2lnQ2FjaGVbZnVuY10pIHtcclxuICAgIC8vIG9wdGltaXplIGF3YXkgYXJndW1lbnRzIHVzYWdlIGluIGNvbW1vbiBjYXNlc1xyXG4gICAgaWYgKHNpZy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgc2lnQ2FjaGVbZnVuY10gPSBmdW5jdGlvbiBkeW5DYWxsX3dyYXBwZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIGR5bkNhbGwoc2lnLCBmdW5jKTtcclxuICAgICAgfTtcclxuICAgIH0gZWxzZSBpZiAoc2lnLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICBzaWdDYWNoZVtmdW5jXSA9IGZ1bmN0aW9uIGR5bkNhbGxfd3JhcHBlcihhcmcpIHtcclxuICAgICAgICByZXR1cm4gZHluQ2FsbChzaWcsIGZ1bmMsIFthcmddKTtcclxuICAgICAgfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIGdlbmVyYWwgY2FzZVxyXG4gICAgICBzaWdDYWNoZVtmdW5jXSA9IGZ1bmN0aW9uIGR5bkNhbGxfd3JhcHBlcigpIHtcclxuICAgICAgICByZXR1cm4gZHluQ2FsbChzaWcsIGZ1bmMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gc2lnQ2FjaGVbZnVuY107XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBtYWtlQmlnSW50KGxvdywgaGlnaCwgdW5zaWduZWQpIHtcclxuICByZXR1cm4gdW5zaWduZWQgPyAoKCsoKGxvdz4+PjApKSkrKCgrKChoaWdoPj4+MCkpKSo0Mjk0OTY3Mjk2LjApKSA6ICgoKygobG93Pj4+MCkpKSsoKCsoKGhpZ2h8MCkpKSo0Mjk0OTY3Mjk2LjApKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZHluQ2FsbChzaWcsIHB0ciwgYXJncykge1xyXG4gIGlmIChhcmdzICYmIGFyZ3MubGVuZ3RoKSB7XHJcbiAgICBhc3NlcnQoYXJncy5sZW5ndGggPT0gc2lnLmxlbmd0aC0xKTtcclxuICAgIGFzc2VydCgoJ2R5bkNhbGxfJyArIHNpZykgaW4gTW9kdWxlLCAnYmFkIGZ1bmN0aW9uIHBvaW50ZXIgdHlwZSAtIG5vIHRhYmxlIGZvciBzaWcgXFwnJyArIHNpZyArICdcXCcnKTtcclxuICAgIHJldHVybiBNb2R1bGVbJ2R5bkNhbGxfJyArIHNpZ10uYXBwbHkobnVsbCwgW3B0cl0uY29uY2F0KGFyZ3MpKTtcclxuICB9IGVsc2Uge1xyXG4gICAgYXNzZXJ0KHNpZy5sZW5ndGggPT0gMSk7XHJcbiAgICBhc3NlcnQoKCdkeW5DYWxsXycgKyBzaWcpIGluIE1vZHVsZSwgJ2JhZCBmdW5jdGlvbiBwb2ludGVyIHR5cGUgLSBubyB0YWJsZSBmb3Igc2lnIFxcJycgKyBzaWcgKyAnXFwnJyk7XHJcbiAgICByZXR1cm4gTW9kdWxlWydkeW5DYWxsXycgKyBzaWddLmNhbGwobnVsbCwgcHRyKTtcclxuICB9XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBnZXRDb21waWxlclNldHRpbmcobmFtZSkge1xyXG4gIHRocm93ICdZb3UgbXVzdCBidWlsZCB3aXRoIC1zIFJFVEFJTl9DT01QSUxFUl9TRVRUSU5HUz0xIGZvciBnZXRDb21waWxlclNldHRpbmcgb3IgZW1zY3JpcHRlbl9nZXRfY29tcGlsZXJfc2V0dGluZyB0byB3b3JrJztcclxufVxyXG5cclxudmFyIFJ1bnRpbWUgPSB7XHJcbiAgLy8gRklYTUUgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgbGF5ZXIgZm9yIHBvcnRzLiBTdXBwb3J0IHNvbWUgUnVudGltZS4qXHJcbiAgLy8gICAgICAgZm9yIG5vdywgZml4IGl0IHRoZXJlLCB0aGVuIHJlbW92ZSBpdCBmcm9tIGhlcmUuIFRoYXQgd2F5IHdlXHJcbiAgLy8gICAgICAgY2FuIG1pbmltaXplIGFueSBwZXJpb2Qgb2YgYnJlYWthZ2UuXHJcbiAgZHluQ2FsbDogZHluQ2FsbCwgLy8gZm9yIFNETDIgcG9ydFxyXG4gIC8vIGhlbHBmdWwgZXJyb3JzXHJcbiAgZ2V0VGVtcFJldDA6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnZ2V0VGVtcFJldDAoKSBpcyBub3cgYSB0b3AtbGV2ZWwgZnVuY3Rpb24sIGFmdGVyIHJlbW92aW5nIHRoZSBSdW50aW1lIG9iamVjdC4gUmVtb3ZlIFwiUnVudGltZS5cIicpIH0sXHJcbiAgc3RhdGljQWxsb2M6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnc3RhdGljQWxsb2MoKSBpcyBub3cgYSB0b3AtbGV2ZWwgZnVuY3Rpb24sIGFmdGVyIHJlbW92aW5nIHRoZSBSdW50aW1lIG9iamVjdC4gUmVtb3ZlIFwiUnVudGltZS5cIicpIH0sXHJcbiAgc3RhY2tBbGxvYzogZnVuY3Rpb24oKSB7IGFib3J0KCdzdGFja0FsbG9jKCkgaXMgbm93IGEgdG9wLWxldmVsIGZ1bmN0aW9uLCBhZnRlciByZW1vdmluZyB0aGUgUnVudGltZSBvYmplY3QuIFJlbW92ZSBcIlJ1bnRpbWUuXCInKSB9LFxyXG59O1xyXG5cclxuLy8gVGhlIGFkZHJlc3MgZ2xvYmFscyBiZWdpbiBhdC4gVmVyeSBsb3cgaW4gbWVtb3J5LCBmb3IgY29kZSBzaXplIGFuZCBvcHRpbWl6YXRpb24gb3Bwb3J0dW5pdGllcy5cclxuLy8gQWJvdmUgMCBpcyBzdGF0aWMgbWVtb3J5LCBzdGFydGluZyB3aXRoIGdsb2JhbHMuXHJcbi8vIFRoZW4gdGhlIHN0YWNrLlxyXG4vLyBUaGVuICdkeW5hbWljJyBtZW1vcnkgZm9yIHNicmsuXHJcbnZhciBHTE9CQUxfQkFTRSA9IDEwMjQ7XHJcblxyXG5cclxuXHJcbi8vID09PSBQcmVhbWJsZSBsaWJyYXJ5IHN0dWZmID09PVxyXG5cclxuLy8gRG9jdW1lbnRhdGlvbiBmb3IgdGhlIHB1YmxpYyBBUElzIGRlZmluZWQgaW4gdGhpcyBmaWxlIG11c3QgYmUgdXBkYXRlZCBpbjpcclxuLy8gICAgc2l0ZS9zb3VyY2UvZG9jcy9hcGlfcmVmZXJlbmNlL3ByZWFtYmxlLmpzLnJzdFxyXG4vLyBBIHByZWJ1aWx0IGxvY2FsIHZlcnNpb24gb2YgdGhlIGRvY3VtZW50YXRpb24gaXMgYXZhaWxhYmxlIGF0OlxyXG4vLyAgICBzaXRlL2J1aWxkL3RleHQvZG9jcy9hcGlfcmVmZXJlbmNlL3ByZWFtYmxlLmpzLnR4dFxyXG4vLyBZb3UgY2FuIGFsc28gYnVpbGQgZG9jcyBsb2NhbGx5IGFzIEhUTUwgb3Igb3RoZXIgZm9ybWF0cyBpbiBzaXRlL1xyXG4vLyBBbiBvbmxpbmUgSFRNTCB2ZXJzaW9uICh3aGljaCBtYXkgYmUgb2YgYSBkaWZmZXJlbnQgdmVyc2lvbiBvZiBFbXNjcmlwdGVuKVxyXG4vLyAgICBpcyB1cCBhdCBodHRwOi8va3JpcGtlbi5naXRodWIuaW8vZW1zY3JpcHRlbi1zaXRlL2RvY3MvYXBpX3JlZmVyZW5jZS9wcmVhbWJsZS5qcy5odG1sXHJcblxyXG5cclxuXHJcbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBSdW50aW1lIGVzc2VudGlhbHNcclxuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG52YXIgQUJPUlQgPSAwOyAvLyB3aGV0aGVyIHdlIGFyZSBxdWl0dGluZyB0aGUgYXBwbGljYXRpb24uIG5vIGNvZGUgc2hvdWxkIHJ1biBhZnRlciB0aGlzLiBzZXQgaW4gZXhpdCgpIGFuZCBhYm9ydCgpXHJcbnZhciBFWElUU1RBVFVTID0gMDtcclxuXHJcbi8qKiBAdHlwZSB7ZnVuY3Rpb24oKiwgc3RyaW5nPSl9ICovXHJcbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIHRleHQpIHtcclxuICBpZiAoIWNvbmRpdGlvbikge1xyXG4gICAgYWJvcnQoJ0Fzc2VydGlvbiBmYWlsZWQ6ICcgKyB0ZXh0KTtcclxuICB9XHJcbn1cclxuXHJcbnZhciBnbG9iYWxTY29wZSA9IHRoaXM7XHJcblxyXG4vLyBSZXR1cm5zIHRoZSBDIGZ1bmN0aW9uIHdpdGggYSBzcGVjaWZpZWQgaWRlbnRpZmllciAoZm9yIEMrKywgeW91IG5lZWQgdG8gZG8gbWFudWFsIG5hbWUgbWFuZ2xpbmcpXHJcbmZ1bmN0aW9uIGdldENGdW5jKGlkZW50KSB7XHJcbiAgdmFyIGZ1bmMgPSBNb2R1bGVbJ18nICsgaWRlbnRdOyAvLyBjbG9zdXJlIGV4cG9ydGVkIGZ1bmN0aW9uXHJcbiAgYXNzZXJ0KGZ1bmMsICdDYW5ub3QgY2FsbCB1bmtub3duIGZ1bmN0aW9uICcgKyBpZGVudCArICcsIG1ha2Ugc3VyZSBpdCBpcyBleHBvcnRlZCcpO1xyXG4gIHJldHVybiBmdW5jO1xyXG59XHJcblxyXG52YXIgSlNmdW5jcyA9IHtcclxuICAvLyBIZWxwZXJzIGZvciBjd3JhcCAtLSBpdCBjYW4ndCByZWZlciB0byBSdW50aW1lIGRpcmVjdGx5IGJlY2F1c2UgaXQgbWlnaHRcclxuICAvLyBiZSByZW5hbWVkIGJ5IGNsb3N1cmUsIGluc3RlYWQgaXQgY2FsbHMgSlNmdW5jc1snc3RhY2tTYXZlJ10uYm9keSB0byBmaW5kXHJcbiAgLy8gb3V0IHdoYXQgdGhlIG1pbmlmaWVkIGZ1bmN0aW9uIG5hbWUgaXMuXHJcbiAgJ3N0YWNrU2F2ZSc6IGZ1bmN0aW9uKCkge1xyXG4gICAgc3RhY2tTYXZlKClcclxuICB9LFxyXG4gICdzdGFja1Jlc3RvcmUnOiBmdW5jdGlvbigpIHtcclxuICAgIHN0YWNrUmVzdG9yZSgpXHJcbiAgfSxcclxuICAvLyB0eXBlIGNvbnZlcnNpb24gZnJvbSBqcyB0byBjXHJcbiAgJ2FycmF5VG9DJyA6IGZ1bmN0aW9uKGFycikge1xyXG4gICAgdmFyIHJldCA9IHN0YWNrQWxsb2MoYXJyLmxlbmd0aCk7XHJcbiAgICB3cml0ZUFycmF5VG9NZW1vcnkoYXJyLCByZXQpO1xyXG4gICAgcmV0dXJuIHJldDtcclxuICB9LFxyXG4gICdzdHJpbmdUb0MnIDogZnVuY3Rpb24oc3RyKSB7XHJcbiAgICB2YXIgcmV0ID0gMDtcclxuICAgIGlmIChzdHIgIT09IG51bGwgJiYgc3RyICE9PSB1bmRlZmluZWQgJiYgc3RyICE9PSAwKSB7IC8vIG51bGwgc3RyaW5nXHJcbiAgICAgIC8vIGF0IG1vc3QgNCBieXRlcyBwZXIgVVRGLTggY29kZSBwb2ludCwgKzEgZm9yIHRoZSB0cmFpbGluZyAnXFwwJ1xyXG4gICAgICB2YXIgbGVuID0gKHN0ci5sZW5ndGggPDwgMikgKyAxO1xyXG4gICAgICByZXQgPSBzdGFja0FsbG9jKGxlbik7XHJcbiAgICAgIHN0cmluZ1RvVVRGOChzdHIsIHJldCwgbGVuKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXQ7XHJcbiAgfVxyXG59O1xyXG4vLyBGb3IgZmFzdCBsb29rdXAgb2YgY29udmVyc2lvbiBmdW5jdGlvbnNcclxudmFyIHRvQyA9IHsnc3RyaW5nJyA6IEpTZnVuY3NbJ3N0cmluZ1RvQyddLCAnYXJyYXknIDogSlNmdW5jc1snYXJyYXlUb0MnXX07XHJcblxyXG4vLyBDIGNhbGxpbmcgaW50ZXJmYWNlLlxyXG5mdW5jdGlvbiBjY2FsbCAoaWRlbnQsIHJldHVyblR5cGUsIGFyZ1R5cGVzLCBhcmdzLCBvcHRzKSB7XHJcbiAgdmFyIGZ1bmMgPSBnZXRDRnVuYyhpZGVudCk7XHJcbiAgdmFyIGNBcmdzID0gW107XHJcbiAgdmFyIHN0YWNrID0gMDtcclxuICBhc3NlcnQocmV0dXJuVHlwZSAhPT0gJ2FycmF5JywgJ1JldHVybiB0eXBlIHNob3VsZCBub3QgYmUgXCJhcnJheVwiLicpO1xyXG4gIGlmIChhcmdzKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIGNvbnZlcnRlciA9IHRvQ1thcmdUeXBlc1tpXV07XHJcbiAgICAgIGlmIChjb252ZXJ0ZXIpIHtcclxuICAgICAgICBpZiAoc3RhY2sgPT09IDApIHN0YWNrID0gc3RhY2tTYXZlKCk7XHJcbiAgICAgICAgY0FyZ3NbaV0gPSBjb252ZXJ0ZXIoYXJnc1tpXSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY0FyZ3NbaV0gPSBhcmdzW2ldO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHZhciByZXQgPSBmdW5jLmFwcGx5KG51bGwsIGNBcmdzKTtcclxuICBpZiAocmV0dXJuVHlwZSA9PT0gJ3N0cmluZycpIHJldCA9IFBvaW50ZXJfc3RyaW5naWZ5KHJldCk7XHJcbiAgaWYgKHN0YWNrICE9PSAwKSB7XHJcbiAgICBzdGFja1Jlc3RvcmUoc3RhY2spO1xyXG4gIH1cclxuICByZXR1cm4gcmV0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjd3JhcCAoaWRlbnQsIHJldHVyblR5cGUsIGFyZ1R5cGVzKSB7XHJcbiAgYXJnVHlwZXMgPSBhcmdUeXBlcyB8fCBbXTtcclxuICB2YXIgY2Z1bmMgPSBnZXRDRnVuYyhpZGVudCk7XHJcbiAgLy8gV2hlbiB0aGUgZnVuY3Rpb24gdGFrZXMgbnVtYmVycyBhbmQgcmV0dXJucyBhIG51bWJlciwgd2UgY2FuIGp1c3QgcmV0dXJuXHJcbiAgLy8gdGhlIG9yaWdpbmFsIGZ1bmN0aW9uXHJcbiAgdmFyIG51bWVyaWNBcmdzID0gYXJnVHlwZXMuZXZlcnkoZnVuY3Rpb24odHlwZSl7IHJldHVybiB0eXBlID09PSAnbnVtYmVyJ30pO1xyXG4gIHZhciBudW1lcmljUmV0ID0gcmV0dXJuVHlwZSAhPT0gJ3N0cmluZyc7XHJcbiAgaWYgKG51bWVyaWNSZXQgJiYgbnVtZXJpY0FyZ3MpIHtcclxuICAgIHJldHVybiBjZnVuYztcclxuICB9XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIGNjYWxsKGlkZW50LCByZXR1cm5UeXBlLCBhcmdUeXBlcywgYXJndW1lbnRzKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyLCBudW1iZXIsIHN0cmluZywgYm9vbGVhbj0pfSAqL1xyXG5mdW5jdGlvbiBzZXRWYWx1ZShwdHIsIHZhbHVlLCB0eXBlLCBub1NhZmUpIHtcclxuICB0eXBlID0gdHlwZSB8fCAnaTgnO1xyXG4gIGlmICh0eXBlLmNoYXJBdCh0eXBlLmxlbmd0aC0xKSA9PT0gJyonKSB0eXBlID0gJ2kzMic7IC8vIHBvaW50ZXJzIGFyZSAzMi1iaXRcclxuICAgIHN3aXRjaCh0eXBlKSB7XHJcbiAgICAgIGNhc2UgJ2kxJzogSEVBUDhbKChwdHIpPj4wKV09dmFsdWU7IGJyZWFrO1xyXG4gICAgICBjYXNlICdpOCc6IEhFQVA4WygocHRyKT4+MCldPXZhbHVlOyBicmVhaztcclxuICAgICAgY2FzZSAnaTE2JzogSEVBUDE2WygocHRyKT4+MSldPXZhbHVlOyBicmVhaztcclxuICAgICAgY2FzZSAnaTMyJzogSEVBUDMyWygocHRyKT4+MildPXZhbHVlOyBicmVhaztcclxuICAgICAgY2FzZSAnaTY0JzogKHRlbXBJNjQgPSBbdmFsdWU+Pj4wLCh0ZW1wRG91YmxlPXZhbHVlLCgrKE1hdGhfYWJzKHRlbXBEb3VibGUpKSkgPj0gMS4wID8gKHRlbXBEb3VibGUgPiAwLjAgPyAoKE1hdGhfbWluKCgrKE1hdGhfZmxvb3IoKHRlbXBEb3VibGUpLzQyOTQ5NjcyOTYuMCkpKSwgNDI5NDk2NzI5NS4wKSl8MCk+Pj4wIDogKH5+KCgrKE1hdGhfY2VpbCgodGVtcERvdWJsZSAtICsoKCh+fih0ZW1wRG91YmxlKSkpPj4+MCkpLzQyOTQ5NjcyOTYuMCkpKSkpPj4+MCkgOiAwKV0sSEVBUDMyWygocHRyKT4+MildPXRlbXBJNjRbMF0sSEVBUDMyWygoKHB0cikrKDQpKT4+MildPXRlbXBJNjRbMV0pOyBicmVhaztcclxuICAgICAgY2FzZSAnZmxvYXQnOiBIRUFQRjMyWygocHRyKT4+MildPXZhbHVlOyBicmVhaztcclxuICAgICAgY2FzZSAnZG91YmxlJzogSEVBUEY2NFsoKHB0cik+PjMpXT12YWx1ZTsgYnJlYWs7XHJcbiAgICAgIGRlZmF1bHQ6IGFib3J0KCdpbnZhbGlkIHR5cGUgZm9yIHNldFZhbHVlOiAnICsgdHlwZSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyLCBzdHJpbmcsIGJvb2xlYW49KX0gKi9cclxuZnVuY3Rpb24gZ2V0VmFsdWUocHRyLCB0eXBlLCBub1NhZmUpIHtcclxuICB0eXBlID0gdHlwZSB8fCAnaTgnO1xyXG4gIGlmICh0eXBlLmNoYXJBdCh0eXBlLmxlbmd0aC0xKSA9PT0gJyonKSB0eXBlID0gJ2kzMic7IC8vIHBvaW50ZXJzIGFyZSAzMi1iaXRcclxuICAgIHN3aXRjaCh0eXBlKSB7XHJcbiAgICAgIGNhc2UgJ2kxJzogcmV0dXJuIEhFQVA4WygocHRyKT4+MCldO1xyXG4gICAgICBjYXNlICdpOCc6IHJldHVybiBIRUFQOFsoKHB0cik+PjApXTtcclxuICAgICAgY2FzZSAnaTE2JzogcmV0dXJuIEhFQVAxNlsoKHB0cik+PjEpXTtcclxuICAgICAgY2FzZSAnaTMyJzogcmV0dXJuIEhFQVAzMlsoKHB0cik+PjIpXTtcclxuICAgICAgY2FzZSAnaTY0JzogcmV0dXJuIEhFQVAzMlsoKHB0cik+PjIpXTtcclxuICAgICAgY2FzZSAnZmxvYXQnOiByZXR1cm4gSEVBUEYzMlsoKHB0cik+PjIpXTtcclxuICAgICAgY2FzZSAnZG91YmxlJzogcmV0dXJuIEhFQVBGNjRbKChwdHIpPj4zKV07XHJcbiAgICAgIGRlZmF1bHQ6IGFib3J0KCdpbnZhbGlkIHR5cGUgZm9yIGdldFZhbHVlOiAnICsgdHlwZSk7XHJcbiAgICB9XHJcbiAgcmV0dXJuIG51bGw7XHJcbn1cclxuXHJcbnZhciBBTExPQ19OT1JNQUwgPSAwOyAvLyBUcmllcyB0byB1c2UgX21hbGxvYygpXHJcbnZhciBBTExPQ19TVEFDSyA9IDE7IC8vIExpdmVzIGZvciB0aGUgZHVyYXRpb24gb2YgdGhlIGN1cnJlbnQgZnVuY3Rpb24gY2FsbFxyXG52YXIgQUxMT0NfU1RBVElDID0gMjsgLy8gQ2Fubm90IGJlIGZyZWVkXHJcbnZhciBBTExPQ19EWU5BTUlDID0gMzsgLy8gQ2Fubm90IGJlIGZyZWVkIGV4Y2VwdCB0aHJvdWdoIHNicmtcclxudmFyIEFMTE9DX05PTkUgPSA0OyAvLyBEbyBub3QgYWxsb2NhdGVcclxuXHJcbi8vIGFsbG9jYXRlKCk6IFRoaXMgaXMgZm9yIGludGVybmFsIHVzZS4gWW91IGNhbiB1c2UgaXQgeW91cnNlbGYgYXMgd2VsbCwgYnV0IHRoZSBpbnRlcmZhY2VcclxuLy8gICAgICAgICAgICAgaXMgYSBsaXR0bGUgdHJpY2t5IChzZWUgZG9jcyByaWdodCBiZWxvdykuIFRoZSByZWFzb24gaXMgdGhhdCBpdCBpcyBvcHRpbWl6ZWRcclxuLy8gICAgICAgICAgICAgZm9yIG11bHRpcGxlIHN5bnRheGVzIHRvIHNhdmUgc3BhY2UgaW4gZ2VuZXJhdGVkIGNvZGUuIFNvIHlvdSBzaG91bGRcclxuLy8gICAgICAgICAgICAgbm9ybWFsbHkgbm90IHVzZSBhbGxvY2F0ZSgpLCBhbmQgaW5zdGVhZCBhbGxvY2F0ZSBtZW1vcnkgdXNpbmcgX21hbGxvYygpLFxyXG4vLyAgICAgICAgICAgICBpbml0aWFsaXplIGl0IHdpdGggc2V0VmFsdWUoKSwgYW5kIHNvIGZvcnRoLlxyXG4vLyBAc2xhYjogQW4gYXJyYXkgb2YgZGF0YSwgb3IgYSBudW1iZXIuIElmIGEgbnVtYmVyLCB0aGVuIHRoZSBzaXplIG9mIHRoZSBibG9jayB0byBhbGxvY2F0ZSxcclxuLy8gICAgICAgIGluICpieXRlcyogKG5vdGUgdGhhdCB0aGlzIGlzIHNvbWV0aW1lcyBjb25mdXNpbmc6IHRoZSBuZXh0IHBhcmFtZXRlciBkb2VzIG5vdFxyXG4vLyAgICAgICAgYWZmZWN0IHRoaXMhKVxyXG4vLyBAdHlwZXM6IEVpdGhlciBhbiBhcnJheSBvZiB0eXBlcywgb25lIGZvciBlYWNoIGJ5dGUgKG9yIDAgaWYgbm8gdHlwZSBhdCB0aGF0IHBvc2l0aW9uKSxcclxuLy8gICAgICAgICBvciBhIHNpbmdsZSB0eXBlIHdoaWNoIGlzIHVzZWQgZm9yIHRoZSBlbnRpcmUgYmxvY2suIFRoaXMgb25seSBtYXR0ZXJzIGlmIHRoZXJlXHJcbi8vICAgICAgICAgaXMgaW5pdGlhbCBkYXRhIC0gaWYgQHNsYWIgaXMgYSBudW1iZXIsIHRoZW4gdGhpcyBkb2VzIG5vdCBtYXR0ZXIgYXQgYWxsIGFuZCBpc1xyXG4vLyAgICAgICAgIGlnbm9yZWQuXHJcbi8vIEBhbGxvY2F0b3I6IEhvdyB0byBhbGxvY2F0ZSBtZW1vcnksIHNlZSBBTExPQ18qXHJcbi8qKiBAdHlwZSB7ZnVuY3Rpb24oKFR5cGVkQXJyYXl8QXJyYXk8bnVtYmVyPnxudW1iZXIpLCBzdHJpbmcsIG51bWJlciwgbnVtYmVyPSl9ICovXHJcbmZ1bmN0aW9uIGFsbG9jYXRlKHNsYWIsIHR5cGVzLCBhbGxvY2F0b3IsIHB0cikge1xyXG4gIHZhciB6ZXJvaW5pdCwgc2l6ZTtcclxuICBpZiAodHlwZW9mIHNsYWIgPT09ICdudW1iZXInKSB7XHJcbiAgICB6ZXJvaW5pdCA9IHRydWU7XHJcbiAgICBzaXplID0gc2xhYjtcclxuICB9IGVsc2Uge1xyXG4gICAgemVyb2luaXQgPSBmYWxzZTtcclxuICAgIHNpemUgPSBzbGFiLmxlbmd0aDtcclxuICB9XHJcblxyXG4gIHZhciBzaW5nbGVUeXBlID0gdHlwZW9mIHR5cGVzID09PSAnc3RyaW5nJyA/IHR5cGVzIDogbnVsbDtcclxuXHJcbiAgdmFyIHJldDtcclxuICBpZiAoYWxsb2NhdG9yID09IEFMTE9DX05PTkUpIHtcclxuICAgIHJldCA9IHB0cjtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0ID0gW3R5cGVvZiBfbWFsbG9jID09PSAnZnVuY3Rpb24nID8gX21hbGxvYyA6IHN0YXRpY0FsbG9jLCBzdGFja0FsbG9jLCBzdGF0aWNBbGxvYywgZHluYW1pY0FsbG9jXVthbGxvY2F0b3IgPT09IHVuZGVmaW5lZCA/IEFMTE9DX1NUQVRJQyA6IGFsbG9jYXRvcl0oTWF0aC5tYXgoc2l6ZSwgc2luZ2xlVHlwZSA/IDEgOiB0eXBlcy5sZW5ndGgpKTtcclxuICB9XHJcblxyXG4gIGlmICh6ZXJvaW5pdCkge1xyXG4gICAgdmFyIHN0b3A7XHJcbiAgICBwdHIgPSByZXQ7XHJcbiAgICBhc3NlcnQoKHJldCAmIDMpID09IDApO1xyXG4gICAgc3RvcCA9IHJldCArIChzaXplICYgfjMpO1xyXG4gICAgZm9yICg7IHB0ciA8IHN0b3A7IHB0ciArPSA0KSB7XHJcbiAgICAgIEhFQVAzMlsoKHB0cik+PjIpXT0wO1xyXG4gICAgfVxyXG4gICAgc3RvcCA9IHJldCArIHNpemU7XHJcbiAgICB3aGlsZSAocHRyIDwgc3RvcCkge1xyXG4gICAgICBIRUFQOFsoKHB0cisrKT4+MCldPTA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG4gIH1cclxuXHJcbiAgaWYgKHNpbmdsZVR5cGUgPT09ICdpOCcpIHtcclxuICAgIGlmIChzbGFiLnN1YmFycmF5IHx8IHNsYWIuc2xpY2UpIHtcclxuICAgICAgSEVBUFU4LnNldCgvKiogQHR5cGUgeyFVaW50OEFycmF5fSAqLyAoc2xhYiksIHJldCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBIRUFQVTguc2V0KG5ldyBVaW50OEFycmF5KHNsYWIpLCByZXQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldDtcclxuICB9XHJcblxyXG4gIHZhciBpID0gMCwgdHlwZSwgdHlwZVNpemUsIHByZXZpb3VzVHlwZTtcclxuICB3aGlsZSAoaSA8IHNpemUpIHtcclxuICAgIHZhciBjdXJyID0gc2xhYltpXTtcclxuXHJcbiAgICB0eXBlID0gc2luZ2xlVHlwZSB8fCB0eXBlc1tpXTtcclxuICAgIGlmICh0eXBlID09PSAwKSB7XHJcbiAgICAgIGkrKztcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcbiAgICBhc3NlcnQodHlwZSwgJ011c3Qga25vdyB3aGF0IHR5cGUgdG8gc3RvcmUgaW4gYWxsb2NhdGUhJyk7XHJcblxyXG4gICAgaWYgKHR5cGUgPT0gJ2k2NCcpIHR5cGUgPSAnaTMyJzsgLy8gc3BlY2lhbCBjYXNlOiB3ZSBoYXZlIG9uZSBpMzIgaGVyZSwgYW5kIG9uZSBpMzIgbGF0ZXJcclxuXHJcbiAgICBzZXRWYWx1ZShyZXQraSwgY3VyciwgdHlwZSk7XHJcblxyXG4gICAgLy8gbm8gbmVlZCB0byBsb29rIHVwIHNpemUgdW5sZXNzIHR5cGUgY2hhbmdlcywgc28gY2FjaGUgaXRcclxuICAgIGlmIChwcmV2aW91c1R5cGUgIT09IHR5cGUpIHtcclxuICAgICAgdHlwZVNpemUgPSBnZXROYXRpdmVUeXBlU2l6ZSh0eXBlKTtcclxuICAgICAgcHJldmlvdXNUeXBlID0gdHlwZTtcclxuICAgIH1cclxuICAgIGkgKz0gdHlwZVNpemU7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmV0O1xyXG59XHJcblxyXG4vLyBBbGxvY2F0ZSBtZW1vcnkgZHVyaW5nIGFueSBzdGFnZSBvZiBzdGFydHVwIC0gc3RhdGljIG1lbW9yeSBlYXJseSBvbiwgZHluYW1pYyBtZW1vcnkgbGF0ZXIsIG1hbGxvYyB3aGVuIHJlYWR5XHJcbmZ1bmN0aW9uIGdldE1lbW9yeShzaXplKSB7XHJcbiAgaWYgKCFzdGF0aWNTZWFsZWQpIHJldHVybiBzdGF0aWNBbGxvYyhzaXplKTtcclxuICBpZiAoIXJ1bnRpbWVJbml0aWFsaXplZCkgcmV0dXJuIGR5bmFtaWNBbGxvYyhzaXplKTtcclxuICByZXR1cm4gX21hbGxvYyhzaXplKTtcclxufVxyXG5cclxuLyoqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIsIG51bWJlcj0pfSAqL1xyXG5mdW5jdGlvbiBQb2ludGVyX3N0cmluZ2lmeShwdHIsIGxlbmd0aCkge1xyXG4gIGlmIChsZW5ndGggPT09IDAgfHwgIXB0cikgcmV0dXJuICcnO1xyXG4gIC8vIFRPRE86IHVzZSBUZXh0RGVjb2RlclxyXG4gIC8vIEZpbmQgdGhlIGxlbmd0aCwgYW5kIGNoZWNrIGZvciBVVEYgd2hpbGUgZG9pbmcgc29cclxuICB2YXIgaGFzVXRmID0gMDtcclxuICB2YXIgdDtcclxuICB2YXIgaSA9IDA7XHJcbiAgd2hpbGUgKDEpIHtcclxuICAgIGFzc2VydChwdHIgKyBpIDwgVE9UQUxfTUVNT1JZKTtcclxuICAgIHQgPSBIRUFQVThbKCgocHRyKSsoaSkpPj4wKV07XHJcbiAgICBoYXNVdGYgfD0gdDtcclxuICAgIGlmICh0ID09IDAgJiYgIWxlbmd0aCkgYnJlYWs7XHJcbiAgICBpKys7XHJcbiAgICBpZiAobGVuZ3RoICYmIGkgPT0gbGVuZ3RoKSBicmVhaztcclxuICB9XHJcbiAgaWYgKCFsZW5ndGgpIGxlbmd0aCA9IGk7XHJcblxyXG4gIHZhciByZXQgPSAnJztcclxuXHJcbiAgaWYgKGhhc1V0ZiA8IDEyOCkge1xyXG4gICAgdmFyIE1BWF9DSFVOSyA9IDEwMjQ7IC8vIHNwbGl0IHVwIGludG8gY2h1bmtzLCBiZWNhdXNlIC5hcHBseSBvbiBhIGh1Z2Ugc3RyaW5nIGNhbiBvdmVyZmxvdyB0aGUgc3RhY2tcclxuICAgIHZhciBjdXJyO1xyXG4gICAgd2hpbGUgKGxlbmd0aCA+IDApIHtcclxuICAgICAgY3VyciA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBIRUFQVTguc3ViYXJyYXkocHRyLCBwdHIgKyBNYXRoLm1pbihsZW5ndGgsIE1BWF9DSFVOSykpKTtcclxuICAgICAgcmV0ID0gcmV0ID8gcmV0ICsgY3VyciA6IGN1cnI7XHJcbiAgICAgIHB0ciArPSBNQVhfQ0hVTks7XHJcbiAgICAgIGxlbmd0aCAtPSBNQVhfQ0hVTks7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG4gIH1cclxuICByZXR1cm4gVVRGOFRvU3RyaW5nKHB0cik7XHJcbn1cclxuXHJcbi8vIEdpdmVuIGEgcG9pbnRlciAncHRyJyB0byBhIG51bGwtdGVybWluYXRlZCBBU0NJSS1lbmNvZGVkIHN0cmluZyBpbiB0aGUgZW1zY3JpcHRlbiBIRUFQLCByZXR1cm5zXHJcbi8vIGEgY29weSBvZiB0aGF0IHN0cmluZyBhcyBhIEphdmFzY3JpcHQgU3RyaW5nIG9iamVjdC5cclxuXHJcbmZ1bmN0aW9uIEFzY2lpVG9TdHJpbmcocHRyKSB7XHJcbiAgdmFyIHN0ciA9ICcnO1xyXG4gIHdoaWxlICgxKSB7XHJcbiAgICB2YXIgY2ggPSBIRUFQOFsoKHB0cisrKT4+MCldO1xyXG4gICAgaWYgKCFjaCkgcmV0dXJuIHN0cjtcclxuICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIENvcGllcyB0aGUgZ2l2ZW4gSmF2YXNjcmlwdCBTdHJpbmcgb2JqZWN0ICdzdHInIHRvIHRoZSBlbXNjcmlwdGVuIEhFQVAgYXQgYWRkcmVzcyAnb3V0UHRyJyxcclxuLy8gbnVsbC10ZXJtaW5hdGVkIGFuZCBlbmNvZGVkIGluIEFTQ0lJIGZvcm0uIFRoZSBjb3B5IHdpbGwgcmVxdWlyZSBhdCBtb3N0IHN0ci5sZW5ndGgrMSBieXRlcyBvZiBzcGFjZSBpbiB0aGUgSEVBUC5cclxuXHJcbmZ1bmN0aW9uIHN0cmluZ1RvQXNjaWkoc3RyLCBvdXRQdHIpIHtcclxuICByZXR1cm4gd3JpdGVBc2NpaVRvTWVtb3J5KHN0ciwgb3V0UHRyLCBmYWxzZSk7XHJcbn1cclxuXHJcbi8vIEdpdmVuIGEgcG9pbnRlciAncHRyJyB0byBhIG51bGwtdGVybWluYXRlZCBVVEY4LWVuY29kZWQgc3RyaW5nIGluIHRoZSBnaXZlbiBhcnJheSB0aGF0IGNvbnRhaW5zIHVpbnQ4IHZhbHVlcywgcmV0dXJuc1xyXG4vLyBhIGNvcHkgb2YgdGhhdCBzdHJpbmcgYXMgYSBKYXZhc2NyaXB0IFN0cmluZyBvYmplY3QuXHJcblxyXG52YXIgVVRGOERlY29kZXIgPSB0eXBlb2YgVGV4dERlY29kZXIgIT09ICd1bmRlZmluZWQnID8gbmV3IFRleHREZWNvZGVyKCd1dGY4JykgOiB1bmRlZmluZWQ7XHJcbmZ1bmN0aW9uIFVURjhBcnJheVRvU3RyaW5nKHU4QXJyYXksIGlkeCkge1xyXG4gIHZhciBlbmRQdHIgPSBpZHg7XHJcbiAgLy8gVGV4dERlY29kZXIgbmVlZHMgdG8ga25vdyB0aGUgYnl0ZSBsZW5ndGggaW4gYWR2YW5jZSwgaXQgZG9lc24ndCBzdG9wIG9uIG51bGwgdGVybWluYXRvciBieSBpdHNlbGYuXHJcbiAgLy8gQWxzbywgdXNlIHRoZSBsZW5ndGggaW5mbyB0byBhdm9pZCBydW5uaW5nIHRpbnkgc3RyaW5ncyB0aHJvdWdoIFRleHREZWNvZGVyLCBzaW5jZSAuc3ViYXJyYXkoKSBhbGxvY2F0ZXMgZ2FyYmFnZS5cclxuICB3aGlsZSAodThBcnJheVtlbmRQdHJdKSArK2VuZFB0cjtcclxuXHJcbiAgaWYgKGVuZFB0ciAtIGlkeCA+IDE2ICYmIHU4QXJyYXkuc3ViYXJyYXkgJiYgVVRGOERlY29kZXIpIHtcclxuICAgIHJldHVybiBVVEY4RGVjb2Rlci5kZWNvZGUodThBcnJheS5zdWJhcnJheShpZHgsIGVuZFB0cikpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB2YXIgdTAsIHUxLCB1MiwgdTMsIHU0LCB1NTtcclxuXHJcbiAgICB2YXIgc3RyID0gJyc7XHJcbiAgICB3aGlsZSAoMSkge1xyXG4gICAgICAvLyBGb3IgVVRGOCBieXRlIHN0cnVjdHVyZSwgc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVRGLTgjRGVzY3JpcHRpb24gYW5kIGh0dHBzOi8vd3d3LmlldGYub3JnL3JmYy9yZmMyMjc5LnR4dCBhbmQgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM2MjlcclxuICAgICAgdTAgPSB1OEFycmF5W2lkeCsrXTtcclxuICAgICAgaWYgKCF1MCkgcmV0dXJuIHN0cjtcclxuICAgICAgaWYgKCEodTAgJiAweDgwKSkgeyBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1MCk7IGNvbnRpbnVlOyB9XHJcbiAgICAgIHUxID0gdThBcnJheVtpZHgrK10gJiA2MztcclxuICAgICAgaWYgKCh1MCAmIDB4RTApID09IDB4QzApIHsgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKCh1MCAmIDMxKSA8PCA2KSB8IHUxKTsgY29udGludWU7IH1cclxuICAgICAgdTIgPSB1OEFycmF5W2lkeCsrXSAmIDYzO1xyXG4gICAgICBpZiAoKHUwICYgMHhGMCkgPT0gMHhFMCkge1xyXG4gICAgICAgIHUwID0gKCh1MCAmIDE1KSA8PCAxMikgfCAodTEgPDwgNikgfCB1MjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB1MyA9IHU4QXJyYXlbaWR4KytdICYgNjM7XHJcbiAgICAgICAgaWYgKCh1MCAmIDB4RjgpID09IDB4RjApIHtcclxuICAgICAgICAgIHUwID0gKCh1MCAmIDcpIDw8IDE4KSB8ICh1MSA8PCAxMikgfCAodTIgPDwgNikgfCB1MztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdTQgPSB1OEFycmF5W2lkeCsrXSAmIDYzO1xyXG4gICAgICAgICAgaWYgKCh1MCAmIDB4RkMpID09IDB4RjgpIHtcclxuICAgICAgICAgICAgdTAgPSAoKHUwICYgMykgPDwgMjQpIHwgKHUxIDw8IDE4KSB8ICh1MiA8PCAxMikgfCAodTMgPDwgNikgfCB1NDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHU1ID0gdThBcnJheVtpZHgrK10gJiA2MztcclxuICAgICAgICAgICAgdTAgPSAoKHUwICYgMSkgPDwgMzApIHwgKHUxIDw8IDI0KSB8ICh1MiA8PCAxOCkgfCAodTMgPDwgMTIpIHwgKHU0IDw8IDYpIHwgdTU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmICh1MCA8IDB4MTAwMDApIHtcclxuICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1MCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIGNoID0gdTAgLSAweDEwMDAwO1xyXG4gICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RDgwMCB8IChjaCA+PiAxMCksIDB4REMwMCB8IChjaCAmIDB4M0ZGKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8vIEdpdmVuIGEgcG9pbnRlciAncHRyJyB0byBhIG51bGwtdGVybWluYXRlZCBVVEY4LWVuY29kZWQgc3RyaW5nIGluIHRoZSBlbXNjcmlwdGVuIEhFQVAsIHJldHVybnNcclxuLy8gYSBjb3B5IG9mIHRoYXQgc3RyaW5nIGFzIGEgSmF2YXNjcmlwdCBTdHJpbmcgb2JqZWN0LlxyXG5cclxuZnVuY3Rpb24gVVRGOFRvU3RyaW5nKHB0cikge1xyXG4gIHJldHVybiBVVEY4QXJyYXlUb1N0cmluZyhIRUFQVTgscHRyKTtcclxufVxyXG5cclxuLy8gQ29waWVzIHRoZSBnaXZlbiBKYXZhc2NyaXB0IFN0cmluZyBvYmplY3QgJ3N0cicgdG8gdGhlIGdpdmVuIGJ5dGUgYXJyYXkgYXQgYWRkcmVzcyAnb3V0SWR4JyxcclxuLy8gZW5jb2RlZCBpbiBVVEY4IGZvcm0gYW5kIG51bGwtdGVybWluYXRlZC4gVGhlIGNvcHkgd2lsbCByZXF1aXJlIGF0IG1vc3Qgc3RyLmxlbmd0aCo0KzEgYnl0ZXMgb2Ygc3BhY2UgaW4gdGhlIEhFQVAuXHJcbi8vIFVzZSB0aGUgZnVuY3Rpb24gbGVuZ3RoQnl0ZXNVVEY4IHRvIGNvbXB1dGUgdGhlIGV4YWN0IG51bWJlciBvZiBieXRlcyAoZXhjbHVkaW5nIG51bGwgdGVybWluYXRvcikgdGhhdCB0aGlzIGZ1bmN0aW9uIHdpbGwgd3JpdGUuXHJcbi8vIFBhcmFtZXRlcnM6XHJcbi8vICAgc3RyOiB0aGUgSmF2YXNjcmlwdCBzdHJpbmcgdG8gY29weS5cclxuLy8gICBvdXRVOEFycmF5OiB0aGUgYXJyYXkgdG8gY29weSB0by4gRWFjaCBpbmRleCBpbiB0aGlzIGFycmF5IGlzIGFzc3VtZWQgdG8gYmUgb25lIDgtYnl0ZSBlbGVtZW50LlxyXG4vLyAgIG91dElkeDogVGhlIHN0YXJ0aW5nIG9mZnNldCBpbiB0aGUgYXJyYXkgdG8gYmVnaW4gdGhlIGNvcHlpbmcuXHJcbi8vICAgbWF4Qnl0ZXNUb1dyaXRlOiBUaGUgbWF4aW11bSBudW1iZXIgb2YgYnl0ZXMgdGhpcyBmdW5jdGlvbiBjYW4gd3JpdGUgdG8gdGhlIGFycmF5LiBUaGlzIGNvdW50IHNob3VsZCBpbmNsdWRlIHRoZSBudWxsXHJcbi8vICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hdG9yLCBpLmUuIGlmIG1heEJ5dGVzVG9Xcml0ZT0xLCBvbmx5IHRoZSBudWxsIHRlcm1pbmF0b3Igd2lsbCBiZSB3cml0dGVuIGFuZCBub3RoaW5nIGVsc2UuXHJcbi8vICAgICAgICAgICAgICAgICAgICBtYXhCeXRlc1RvV3JpdGU9MCBkb2VzIG5vdCB3cml0ZSBhbnkgYnl0ZXMgdG8gdGhlIG91dHB1dCwgbm90IGV2ZW4gdGhlIG51bGwgdGVybWluYXRvci5cclxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4sIEVYQ0xVRElORyB0aGUgbnVsbCB0ZXJtaW5hdG9yLlxyXG5cclxuZnVuY3Rpb24gc3RyaW5nVG9VVEY4QXJyYXkoc3RyLCBvdXRVOEFycmF5LCBvdXRJZHgsIG1heEJ5dGVzVG9Xcml0ZSkge1xyXG4gIGlmICghKG1heEJ5dGVzVG9Xcml0ZSA+IDApKSAvLyBQYXJhbWV0ZXIgbWF4Qnl0ZXNUb1dyaXRlIGlzIG5vdCBvcHRpb25hbC4gTmVnYXRpdmUgdmFsdWVzLCAwLCBudWxsLCB1bmRlZmluZWQgYW5kIGZhbHNlIGVhY2ggZG9uJ3Qgd3JpdGUgb3V0IGFueSBieXRlcy5cclxuICAgIHJldHVybiAwO1xyXG5cclxuICB2YXIgc3RhcnRJZHggPSBvdXRJZHg7XHJcbiAgdmFyIGVuZElkeCA9IG91dElkeCArIG1heEJ5dGVzVG9Xcml0ZSAtIDE7IC8vIC0xIGZvciBzdHJpbmcgbnVsbCB0ZXJtaW5hdG9yLlxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XHJcbiAgICAvLyBHb3RjaGE6IGNoYXJDb2RlQXQgcmV0dXJucyBhIDE2LWJpdCB3b3JkIHRoYXQgaXMgYSBVVEYtMTYgZW5jb2RlZCBjb2RlIHVuaXQsIG5vdCBhIFVuaWNvZGUgY29kZSBwb2ludCBvZiB0aGUgY2hhcmFjdGVyISBTbyBkZWNvZGUgVVRGMTYtPlVURjMyLT5VVEY4LlxyXG4gICAgLy8gU2VlIGh0dHA6Ly91bmljb2RlLm9yZy9mYXEvdXRmX2JvbS5odG1sI3V0ZjE2LTNcclxuICAgIC8vIEZvciBVVEY4IGJ5dGUgc3RydWN0dXJlLCBzZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VVEYtOCNEZXNjcmlwdGlvbiBhbmQgaHR0cHM6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzIyNzkudHh0IGFuZCBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzYyOVxyXG4gICAgdmFyIHUgPSBzdHIuY2hhckNvZGVBdChpKTsgLy8gcG9zc2libHkgYSBsZWFkIHN1cnJvZ2F0ZVxyXG4gICAgaWYgKHUgPj0gMHhEODAwICYmIHUgPD0gMHhERkZGKSB1ID0gMHgxMDAwMCArICgodSAmIDB4M0ZGKSA8PCAxMCkgfCAoc3RyLmNoYXJDb2RlQXQoKytpKSAmIDB4M0ZGKTtcclxuICAgIGlmICh1IDw9IDB4N0YpIHtcclxuICAgICAgaWYgKG91dElkeCA+PSBlbmRJZHgpIGJyZWFrO1xyXG4gICAgICBvdXRVOEFycmF5W291dElkeCsrXSA9IHU7XHJcbiAgICB9IGVsc2UgaWYgKHUgPD0gMHg3RkYpIHtcclxuICAgICAgaWYgKG91dElkeCArIDEgPj0gZW5kSWR4KSBicmVhaztcclxuICAgICAgb3V0VThBcnJheVtvdXRJZHgrK10gPSAweEMwIHwgKHUgPj4gNik7XHJcbiAgICAgIG91dFU4QXJyYXlbb3V0SWR4KytdID0gMHg4MCB8ICh1ICYgNjMpO1xyXG4gICAgfSBlbHNlIGlmICh1IDw9IDB4RkZGRikge1xyXG4gICAgICBpZiAob3V0SWR4ICsgMiA+PSBlbmRJZHgpIGJyZWFrO1xyXG4gICAgICBvdXRVOEFycmF5W291dElkeCsrXSA9IDB4RTAgfCAodSA+PiAxMik7XHJcbiAgICAgIG91dFU4QXJyYXlbb3V0SWR4KytdID0gMHg4MCB8ICgodSA+PiA2KSAmIDYzKTtcclxuICAgICAgb3V0VThBcnJheVtvdXRJZHgrK10gPSAweDgwIHwgKHUgJiA2Myk7XHJcbiAgICB9IGVsc2UgaWYgKHUgPD0gMHgxRkZGRkYpIHtcclxuICAgICAgaWYgKG91dElkeCArIDMgPj0gZW5kSWR4KSBicmVhaztcclxuICAgICAgb3V0VThBcnJheVtvdXRJZHgrK10gPSAweEYwIHwgKHUgPj4gMTgpO1xyXG4gICAgICBvdXRVOEFycmF5W291dElkeCsrXSA9IDB4ODAgfCAoKHUgPj4gMTIpICYgNjMpO1xyXG4gICAgICBvdXRVOEFycmF5W291dElkeCsrXSA9IDB4ODAgfCAoKHUgPj4gNikgJiA2Myk7XHJcbiAgICAgIG91dFU4QXJyYXlbb3V0SWR4KytdID0gMHg4MCB8ICh1ICYgNjMpO1xyXG4gICAgfSBlbHNlIGlmICh1IDw9IDB4M0ZGRkZGRikge1xyXG4gICAgICBpZiAob3V0SWR4ICsgNCA+PSBlbmRJZHgpIGJyZWFrO1xyXG4gICAgICBvdXRVOEFycmF5W291dElkeCsrXSA9IDB4RjggfCAodSA+PiAyNCk7XHJcbiAgICAgIG91dFU4QXJyYXlbb3V0SWR4KytdID0gMHg4MCB8ICgodSA+PiAxOCkgJiA2Myk7XHJcbiAgICAgIG91dFU4QXJyYXlbb3V0SWR4KytdID0gMHg4MCB8ICgodSA+PiAxMikgJiA2Myk7XHJcbiAgICAgIG91dFU4QXJyYXlbb3V0SWR4KytdID0gMHg4MCB8ICgodSA+PiA2KSAmIDYzKTtcclxuICAgICAgb3V0VThBcnJheVtvdXRJZHgrK10gPSAweDgwIHwgKHUgJiA2Myk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAob3V0SWR4ICsgNSA+PSBlbmRJZHgpIGJyZWFrO1xyXG4gICAgICBvdXRVOEFycmF5W291dElkeCsrXSA9IDB4RkMgfCAodSA+PiAzMCk7XHJcbiAgICAgIG91dFU4QXJyYXlbb3V0SWR4KytdID0gMHg4MCB8ICgodSA+PiAyNCkgJiA2Myk7XHJcbiAgICAgIG91dFU4QXJyYXlbb3V0SWR4KytdID0gMHg4MCB8ICgodSA+PiAxOCkgJiA2Myk7XHJcbiAgICAgIG91dFU4QXJyYXlbb3V0SWR4KytdID0gMHg4MCB8ICgodSA+PiAxMikgJiA2Myk7XHJcbiAgICAgIG91dFU4QXJyYXlbb3V0SWR4KytdID0gMHg4MCB8ICgodSA+PiA2KSAmIDYzKTtcclxuICAgICAgb3V0VThBcnJheVtvdXRJZHgrK10gPSAweDgwIHwgKHUgJiA2Myk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8vIE51bGwtdGVybWluYXRlIHRoZSBwb2ludGVyIHRvIHRoZSBidWZmZXIuXHJcbiAgb3V0VThBcnJheVtvdXRJZHhdID0gMDtcclxuICByZXR1cm4gb3V0SWR4IC0gc3RhcnRJZHg7XHJcbn1cclxuXHJcbi8vIENvcGllcyB0aGUgZ2l2ZW4gSmF2YXNjcmlwdCBTdHJpbmcgb2JqZWN0ICdzdHInIHRvIHRoZSBlbXNjcmlwdGVuIEhFQVAgYXQgYWRkcmVzcyAnb3V0UHRyJyxcclxuLy8gbnVsbC10ZXJtaW5hdGVkIGFuZCBlbmNvZGVkIGluIFVURjggZm9ybS4gVGhlIGNvcHkgd2lsbCByZXF1aXJlIGF0IG1vc3Qgc3RyLmxlbmd0aCo0KzEgYnl0ZXMgb2Ygc3BhY2UgaW4gdGhlIEhFQVAuXHJcbi8vIFVzZSB0aGUgZnVuY3Rpb24gbGVuZ3RoQnl0ZXNVVEY4IHRvIGNvbXB1dGUgdGhlIGV4YWN0IG51bWJlciBvZiBieXRlcyAoZXhjbHVkaW5nIG51bGwgdGVybWluYXRvcikgdGhhdCB0aGlzIGZ1bmN0aW9uIHdpbGwgd3JpdGUuXHJcbi8vIFJldHVybnMgdGhlIG51bWJlciBvZiBieXRlcyB3cml0dGVuLCBFWENMVURJTkcgdGhlIG51bGwgdGVybWluYXRvci5cclxuXHJcbmZ1bmN0aW9uIHN0cmluZ1RvVVRGOChzdHIsIG91dFB0ciwgbWF4Qnl0ZXNUb1dyaXRlKSB7XHJcbiAgYXNzZXJ0KHR5cGVvZiBtYXhCeXRlc1RvV3JpdGUgPT0gJ251bWJlcicsICdzdHJpbmdUb1VURjgoc3RyLCBvdXRQdHIsIG1heEJ5dGVzVG9Xcml0ZSkgaXMgbWlzc2luZyB0aGUgdGhpcmQgcGFyYW1ldGVyIHRoYXQgc3BlY2lmaWVzIHRoZSBsZW5ndGggb2YgdGhlIG91dHB1dCBidWZmZXIhJyk7XHJcbiAgcmV0dXJuIHN0cmluZ1RvVVRGOEFycmF5KHN0ciwgSEVBUFU4LG91dFB0ciwgbWF4Qnl0ZXNUb1dyaXRlKTtcclxufVxyXG5cclxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBnaXZlbiBKYXZhc2NyaXB0IHN0cmluZyB0YWtlcyBpZiBlbmNvZGVkIGFzIGEgVVRGOCBieXRlIGFycmF5LCBFWENMVURJTkcgdGhlIG51bGwgdGVybWluYXRvciBieXRlLlxyXG5cclxuZnVuY3Rpb24gbGVuZ3RoQnl0ZXNVVEY4KHN0cikge1xyXG4gIHZhciBsZW4gPSAwO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XHJcbiAgICAvLyBHb3RjaGE6IGNoYXJDb2RlQXQgcmV0dXJucyBhIDE2LWJpdCB3b3JkIHRoYXQgaXMgYSBVVEYtMTYgZW5jb2RlZCBjb2RlIHVuaXQsIG5vdCBhIFVuaWNvZGUgY29kZSBwb2ludCBvZiB0aGUgY2hhcmFjdGVyISBTbyBkZWNvZGUgVVRGMTYtPlVURjMyLT5VVEY4LlxyXG4gICAgLy8gU2VlIGh0dHA6Ly91bmljb2RlLm9yZy9mYXEvdXRmX2JvbS5odG1sI3V0ZjE2LTNcclxuICAgIHZhciB1ID0gc3RyLmNoYXJDb2RlQXQoaSk7IC8vIHBvc3NpYmx5IGEgbGVhZCBzdXJyb2dhdGVcclxuICAgIGlmICh1ID49IDB4RDgwMCAmJiB1IDw9IDB4REZGRikgdSA9IDB4MTAwMDAgKyAoKHUgJiAweDNGRikgPDwgMTApIHwgKHN0ci5jaGFyQ29kZUF0KCsraSkgJiAweDNGRik7XHJcbiAgICBpZiAodSA8PSAweDdGKSB7XHJcbiAgICAgICsrbGVuO1xyXG4gICAgfSBlbHNlIGlmICh1IDw9IDB4N0ZGKSB7XHJcbiAgICAgIGxlbiArPSAyO1xyXG4gICAgfSBlbHNlIGlmICh1IDw9IDB4RkZGRikge1xyXG4gICAgICBsZW4gKz0gMztcclxuICAgIH0gZWxzZSBpZiAodSA8PSAweDFGRkZGRikge1xyXG4gICAgICBsZW4gKz0gNDtcclxuICAgIH0gZWxzZSBpZiAodSA8PSAweDNGRkZGRkYpIHtcclxuICAgICAgbGVuICs9IDU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBsZW4gKz0gNjtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGxlbjtcclxufVxyXG5cclxuLy8gR2l2ZW4gYSBwb2ludGVyICdwdHInIHRvIGEgbnVsbC10ZXJtaW5hdGVkIFVURjE2TEUtZW5jb2RlZCBzdHJpbmcgaW4gdGhlIGVtc2NyaXB0ZW4gSEVBUCwgcmV0dXJuc1xyXG4vLyBhIGNvcHkgb2YgdGhhdCBzdHJpbmcgYXMgYSBKYXZhc2NyaXB0IFN0cmluZyBvYmplY3QuXHJcblxyXG52YXIgVVRGMTZEZWNvZGVyID0gdHlwZW9mIFRleHREZWNvZGVyICE9PSAndW5kZWZpbmVkJyA/IG5ldyBUZXh0RGVjb2RlcigndXRmLTE2bGUnKSA6IHVuZGVmaW5lZDtcclxuZnVuY3Rpb24gVVRGMTZUb1N0cmluZyhwdHIpIHtcclxuICBhc3NlcnQocHRyICUgMiA9PSAwLCAnUG9pbnRlciBwYXNzZWQgdG8gVVRGMTZUb1N0cmluZyBtdXN0IGJlIGFsaWduZWQgdG8gdHdvIGJ5dGVzIScpO1xyXG4gIHZhciBlbmRQdHIgPSBwdHI7XHJcbiAgLy8gVGV4dERlY29kZXIgbmVlZHMgdG8ga25vdyB0aGUgYnl0ZSBsZW5ndGggaW4gYWR2YW5jZSwgaXQgZG9lc24ndCBzdG9wIG9uIG51bGwgdGVybWluYXRvciBieSBpdHNlbGYuXHJcbiAgLy8gQWxzbywgdXNlIHRoZSBsZW5ndGggaW5mbyB0byBhdm9pZCBydW5uaW5nIHRpbnkgc3RyaW5ncyB0aHJvdWdoIFRleHREZWNvZGVyLCBzaW5jZSAuc3ViYXJyYXkoKSBhbGxvY2F0ZXMgZ2FyYmFnZS5cclxuICB2YXIgaWR4ID0gZW5kUHRyID4+IDE7XHJcbiAgd2hpbGUgKEhFQVAxNltpZHhdKSArK2lkeDtcclxuICBlbmRQdHIgPSBpZHggPDwgMTtcclxuXHJcbiAgaWYgKGVuZFB0ciAtIHB0ciA+IDMyICYmIFVURjE2RGVjb2Rlcikge1xyXG4gICAgcmV0dXJuIFVURjE2RGVjb2Rlci5kZWNvZGUoSEVBUFU4LnN1YmFycmF5KHB0ciwgZW5kUHRyKSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHZhciBpID0gMDtcclxuXHJcbiAgICB2YXIgc3RyID0gJyc7XHJcbiAgICB3aGlsZSAoMSkge1xyXG4gICAgICB2YXIgY29kZVVuaXQgPSBIRUFQMTZbKCgocHRyKSsoaSoyKSk+PjEpXTtcclxuICAgICAgaWYgKGNvZGVVbml0ID09IDApIHJldHVybiBzdHI7XHJcbiAgICAgICsraTtcclxuICAgICAgLy8gZnJvbUNoYXJDb2RlIGNvbnN0cnVjdHMgYSBjaGFyYWN0ZXIgZnJvbSBhIFVURi0xNiBjb2RlIHVuaXQsIHNvIHdlIGNhbiBwYXNzIHRoZSBVVEYxNiBzdHJpbmcgcmlnaHQgdGhyb3VnaC5cclxuICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVVuaXQpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8gQ29waWVzIHRoZSBnaXZlbiBKYXZhc2NyaXB0IFN0cmluZyBvYmplY3QgJ3N0cicgdG8gdGhlIGVtc2NyaXB0ZW4gSEVBUCBhdCBhZGRyZXNzICdvdXRQdHInLFxyXG4vLyBudWxsLXRlcm1pbmF0ZWQgYW5kIGVuY29kZWQgaW4gVVRGMTYgZm9ybS4gVGhlIGNvcHkgd2lsbCByZXF1aXJlIGF0IG1vc3Qgc3RyLmxlbmd0aCo0KzIgYnl0ZXMgb2Ygc3BhY2UgaW4gdGhlIEhFQVAuXHJcbi8vIFVzZSB0aGUgZnVuY3Rpb24gbGVuZ3RoQnl0ZXNVVEYxNigpIHRvIGNvbXB1dGUgdGhlIGV4YWN0IG51bWJlciBvZiBieXRlcyAoZXhjbHVkaW5nIG51bGwgdGVybWluYXRvcikgdGhhdCB0aGlzIGZ1bmN0aW9uIHdpbGwgd3JpdGUuXHJcbi8vIFBhcmFtZXRlcnM6XHJcbi8vICAgc3RyOiB0aGUgSmF2YXNjcmlwdCBzdHJpbmcgdG8gY29weS5cclxuLy8gICBvdXRQdHI6IEJ5dGUgYWRkcmVzcyBpbiBFbXNjcmlwdGVuIEhFQVAgd2hlcmUgdG8gd3JpdGUgdGhlIHN0cmluZyB0by5cclxuLy8gICBtYXhCeXRlc1RvV3JpdGU6IFRoZSBtYXhpbXVtIG51bWJlciBvZiBieXRlcyB0aGlzIGZ1bmN0aW9uIGNhbiB3cml0ZSB0byB0aGUgYXJyYXkuIFRoaXMgY291bnQgc2hvdWxkIGluY2x1ZGUgdGhlIG51bGxcclxuLy8gICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0b3IsIGkuZS4gaWYgbWF4Qnl0ZXNUb1dyaXRlPTIsIG9ubHkgdGhlIG51bGwgdGVybWluYXRvciB3aWxsIGJlIHdyaXR0ZW4gYW5kIG5vdGhpbmcgZWxzZS5cclxuLy8gICAgICAgICAgICAgICAgICAgIG1heEJ5dGVzVG9Xcml0ZTwyIGRvZXMgbm90IHdyaXRlIGFueSBieXRlcyB0byB0aGUgb3V0cHV0LCBub3QgZXZlbiB0aGUgbnVsbCB0ZXJtaW5hdG9yLlxyXG4vLyBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbiwgRVhDTFVESU5HIHRoZSBudWxsIHRlcm1pbmF0b3IuXHJcblxyXG5mdW5jdGlvbiBzdHJpbmdUb1VURjE2KHN0ciwgb3V0UHRyLCBtYXhCeXRlc1RvV3JpdGUpIHtcclxuICBhc3NlcnQob3V0UHRyICUgMiA9PSAwLCAnUG9pbnRlciBwYXNzZWQgdG8gc3RyaW5nVG9VVEYxNiBtdXN0IGJlIGFsaWduZWQgdG8gdHdvIGJ5dGVzIScpO1xyXG4gIGFzc2VydCh0eXBlb2YgbWF4Qnl0ZXNUb1dyaXRlID09ICdudW1iZXInLCAnc3RyaW5nVG9VVEYxNihzdHIsIG91dFB0ciwgbWF4Qnl0ZXNUb1dyaXRlKSBpcyBtaXNzaW5nIHRoZSB0aGlyZCBwYXJhbWV0ZXIgdGhhdCBzcGVjaWZpZXMgdGhlIGxlbmd0aCBvZiB0aGUgb3V0cHV0IGJ1ZmZlciEnKTtcclxuICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eTogaWYgbWF4IGJ5dGVzIGlzIG5vdCBzcGVjaWZpZWQsIGFzc3VtZSB1bnNhZmUgdW5ib3VuZGVkIHdyaXRlIGlzIGFsbG93ZWQuXHJcbiAgaWYgKG1heEJ5dGVzVG9Xcml0ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICBtYXhCeXRlc1RvV3JpdGUgPSAweDdGRkZGRkZGO1xyXG4gIH1cclxuICBpZiAobWF4Qnl0ZXNUb1dyaXRlIDwgMikgcmV0dXJuIDA7XHJcbiAgbWF4Qnl0ZXNUb1dyaXRlIC09IDI7IC8vIE51bGwgdGVybWluYXRvci5cclxuICB2YXIgc3RhcnRQdHIgPSBvdXRQdHI7XHJcbiAgdmFyIG51bUNoYXJzVG9Xcml0ZSA9IChtYXhCeXRlc1RvV3JpdGUgPCBzdHIubGVuZ3RoKjIpID8gKG1heEJ5dGVzVG9Xcml0ZSAvIDIpIDogc3RyLmxlbmd0aDtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUNoYXJzVG9Xcml0ZTsgKytpKSB7XHJcbiAgICAvLyBjaGFyQ29kZUF0IHJldHVybnMgYSBVVEYtMTYgZW5jb2RlZCBjb2RlIHVuaXQsIHNvIGl0IGNhbiBiZSBkaXJlY3RseSB3cml0dGVuIHRvIHRoZSBIRUFQLlxyXG4gICAgdmFyIGNvZGVVbml0ID0gc3RyLmNoYXJDb2RlQXQoaSk7IC8vIHBvc3NpYmx5IGEgbGVhZCBzdXJyb2dhdGVcclxuICAgIEhFQVAxNlsoKG91dFB0cik+PjEpXT1jb2RlVW5pdDtcclxuICAgIG91dFB0ciArPSAyO1xyXG4gIH1cclxuICAvLyBOdWxsLXRlcm1pbmF0ZSB0aGUgcG9pbnRlciB0byB0aGUgSEVBUC5cclxuICBIRUFQMTZbKChvdXRQdHIpPj4xKV09MDtcclxuICByZXR1cm4gb3V0UHRyIC0gc3RhcnRQdHI7XHJcbn1cclxuXHJcbi8vIFJldHVybnMgdGhlIG51bWJlciBvZiBieXRlcyB0aGUgZ2l2ZW4gSmF2YXNjcmlwdCBzdHJpbmcgdGFrZXMgaWYgZW5jb2RlZCBhcyBhIFVURjE2IGJ5dGUgYXJyYXksIEVYQ0xVRElORyB0aGUgbnVsbCB0ZXJtaW5hdG9yIGJ5dGUuXHJcblxyXG5mdW5jdGlvbiBsZW5ndGhCeXRlc1VURjE2KHN0cikge1xyXG4gIHJldHVybiBzdHIubGVuZ3RoKjI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIFVURjMyVG9TdHJpbmcocHRyKSB7XHJcbiAgYXNzZXJ0KHB0ciAlIDQgPT0gMCwgJ1BvaW50ZXIgcGFzc2VkIHRvIFVURjMyVG9TdHJpbmcgbXVzdCBiZSBhbGlnbmVkIHRvIGZvdXIgYnl0ZXMhJyk7XHJcbiAgdmFyIGkgPSAwO1xyXG5cclxuICB2YXIgc3RyID0gJyc7XHJcbiAgd2hpbGUgKDEpIHtcclxuICAgIHZhciB1dGYzMiA9IEhFQVAzMlsoKChwdHIpKyhpKjQpKT4+MildO1xyXG4gICAgaWYgKHV0ZjMyID09IDApXHJcbiAgICAgIHJldHVybiBzdHI7XHJcbiAgICArK2k7XHJcbiAgICAvLyBHb3RjaGE6IGZyb21DaGFyQ29kZSBjb25zdHJ1Y3RzIGEgY2hhcmFjdGVyIGZyb20gYSBVVEYtMTYgZW5jb2RlZCBjb2RlIChwYWlyKSwgbm90IGZyb20gYSBVbmljb2RlIGNvZGUgcG9pbnQhIFNvIGVuY29kZSB0aGUgY29kZSBwb2ludCB0byBVVEYtMTYgZm9yIGNvbnN0cnVjdGluZy5cclxuICAgIC8vIFNlZSBodHRwOi8vdW5pY29kZS5vcmcvZmFxL3V0Zl9ib20uaHRtbCN1dGYxNi0zXHJcbiAgICBpZiAodXRmMzIgPj0gMHgxMDAwMCkge1xyXG4gICAgICB2YXIgY2ggPSB1dGYzMiAtIDB4MTAwMDA7XHJcbiAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RDgwMCB8IChjaCA+PiAxMCksIDB4REMwMCB8IChjaCAmIDB4M0ZGKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1dGYzMik7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vLyBDb3BpZXMgdGhlIGdpdmVuIEphdmFzY3JpcHQgU3RyaW5nIG9iamVjdCAnc3RyJyB0byB0aGUgZW1zY3JpcHRlbiBIRUFQIGF0IGFkZHJlc3MgJ291dFB0cicsXHJcbi8vIG51bGwtdGVybWluYXRlZCBhbmQgZW5jb2RlZCBpbiBVVEYzMiBmb3JtLiBUaGUgY29weSB3aWxsIHJlcXVpcmUgYXQgbW9zdCBzdHIubGVuZ3RoKjQrNCBieXRlcyBvZiBzcGFjZSBpbiB0aGUgSEVBUC5cclxuLy8gVXNlIHRoZSBmdW5jdGlvbiBsZW5ndGhCeXRlc1VURjMyKCkgdG8gY29tcHV0ZSB0aGUgZXhhY3QgbnVtYmVyIG9mIGJ5dGVzIChleGNsdWRpbmcgbnVsbCB0ZXJtaW5hdG9yKSB0aGF0IHRoaXMgZnVuY3Rpb24gd2lsbCB3cml0ZS5cclxuLy8gUGFyYW1ldGVyczpcclxuLy8gICBzdHI6IHRoZSBKYXZhc2NyaXB0IHN0cmluZyB0byBjb3B5LlxyXG4vLyAgIG91dFB0cjogQnl0ZSBhZGRyZXNzIGluIEVtc2NyaXB0ZW4gSEVBUCB3aGVyZSB0byB3cml0ZSB0aGUgc3RyaW5nIHRvLlxyXG4vLyAgIG1heEJ5dGVzVG9Xcml0ZTogVGhlIG1heGltdW0gbnVtYmVyIG9mIGJ5dGVzIHRoaXMgZnVuY3Rpb24gY2FuIHdyaXRlIHRvIHRoZSBhcnJheS4gVGhpcyBjb3VudCBzaG91bGQgaW5jbHVkZSB0aGUgbnVsbFxyXG4vLyAgICAgICAgICAgICAgICAgICAgdGVybWluYXRvciwgaS5lLiBpZiBtYXhCeXRlc1RvV3JpdGU9NCwgb25seSB0aGUgbnVsbCB0ZXJtaW5hdG9yIHdpbGwgYmUgd3JpdHRlbiBhbmQgbm90aGluZyBlbHNlLlxyXG4vLyAgICAgICAgICAgICAgICAgICAgbWF4Qnl0ZXNUb1dyaXRlPDQgZG9lcyBub3Qgd3JpdGUgYW55IGJ5dGVzIHRvIHRoZSBvdXRwdXQsIG5vdCBldmVuIHRoZSBudWxsIHRlcm1pbmF0b3IuXHJcbi8vIFJldHVybnMgdGhlIG51bWJlciBvZiBieXRlcyB3cml0dGVuLCBFWENMVURJTkcgdGhlIG51bGwgdGVybWluYXRvci5cclxuXHJcbmZ1bmN0aW9uIHN0cmluZ1RvVVRGMzIoc3RyLCBvdXRQdHIsIG1heEJ5dGVzVG9Xcml0ZSkge1xyXG4gIGFzc2VydChvdXRQdHIgJSA0ID09IDAsICdQb2ludGVyIHBhc3NlZCB0byBzdHJpbmdUb1VURjMyIG11c3QgYmUgYWxpZ25lZCB0byBmb3VyIGJ5dGVzIScpO1xyXG4gIGFzc2VydCh0eXBlb2YgbWF4Qnl0ZXNUb1dyaXRlID09ICdudW1iZXInLCAnc3RyaW5nVG9VVEYzMihzdHIsIG91dFB0ciwgbWF4Qnl0ZXNUb1dyaXRlKSBpcyBtaXNzaW5nIHRoZSB0aGlyZCBwYXJhbWV0ZXIgdGhhdCBzcGVjaWZpZXMgdGhlIGxlbmd0aCBvZiB0aGUgb3V0cHV0IGJ1ZmZlciEnKTtcclxuICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eTogaWYgbWF4IGJ5dGVzIGlzIG5vdCBzcGVjaWZpZWQsIGFzc3VtZSB1bnNhZmUgdW5ib3VuZGVkIHdyaXRlIGlzIGFsbG93ZWQuXHJcbiAgaWYgKG1heEJ5dGVzVG9Xcml0ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICBtYXhCeXRlc1RvV3JpdGUgPSAweDdGRkZGRkZGO1xyXG4gIH1cclxuICBpZiAobWF4Qnl0ZXNUb1dyaXRlIDwgNCkgcmV0dXJuIDA7XHJcbiAgdmFyIHN0YXJ0UHRyID0gb3V0UHRyO1xyXG4gIHZhciBlbmRQdHIgPSBzdGFydFB0ciArIG1heEJ5dGVzVG9Xcml0ZSAtIDQ7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcclxuICAgIC8vIEdvdGNoYTogY2hhckNvZGVBdCByZXR1cm5zIGEgMTYtYml0IHdvcmQgdGhhdCBpcyBhIFVURi0xNiBlbmNvZGVkIGNvZGUgdW5pdCwgbm90IGEgVW5pY29kZSBjb2RlIHBvaW50IG9mIHRoZSBjaGFyYWN0ZXIhIFdlIG11c3QgZGVjb2RlIHRoZSBzdHJpbmcgdG8gVVRGLTMyIHRvIHRoZSBoZWFwLlxyXG4gICAgLy8gU2VlIGh0dHA6Ly91bmljb2RlLm9yZy9mYXEvdXRmX2JvbS5odG1sI3V0ZjE2LTNcclxuICAgIHZhciBjb2RlVW5pdCA9IHN0ci5jaGFyQ29kZUF0KGkpOyAvLyBwb3NzaWJseSBhIGxlYWQgc3Vycm9nYXRlXHJcbiAgICBpZiAoY29kZVVuaXQgPj0gMHhEODAwICYmIGNvZGVVbml0IDw9IDB4REZGRikge1xyXG4gICAgICB2YXIgdHJhaWxTdXJyb2dhdGUgPSBzdHIuY2hhckNvZGVBdCgrK2kpO1xyXG4gICAgICBjb2RlVW5pdCA9IDB4MTAwMDAgKyAoKGNvZGVVbml0ICYgMHgzRkYpIDw8IDEwKSB8ICh0cmFpbFN1cnJvZ2F0ZSAmIDB4M0ZGKTtcclxuICAgIH1cclxuICAgIEhFQVAzMlsoKG91dFB0cik+PjIpXT1jb2RlVW5pdDtcclxuICAgIG91dFB0ciArPSA0O1xyXG4gICAgaWYgKG91dFB0ciArIDQgPiBlbmRQdHIpIGJyZWFrO1xyXG4gIH1cclxuICAvLyBOdWxsLXRlcm1pbmF0ZSB0aGUgcG9pbnRlciB0byB0aGUgSEVBUC5cclxuICBIRUFQMzJbKChvdXRQdHIpPj4yKV09MDtcclxuICByZXR1cm4gb3V0UHRyIC0gc3RhcnRQdHI7XHJcbn1cclxuXHJcbi8vIFJldHVybnMgdGhlIG51bWJlciBvZiBieXRlcyB0aGUgZ2l2ZW4gSmF2YXNjcmlwdCBzdHJpbmcgdGFrZXMgaWYgZW5jb2RlZCBhcyBhIFVURjE2IGJ5dGUgYXJyYXksIEVYQ0xVRElORyB0aGUgbnVsbCB0ZXJtaW5hdG9yIGJ5dGUuXHJcblxyXG5mdW5jdGlvbiBsZW5ndGhCeXRlc1VURjMyKHN0cikge1xyXG4gIHZhciBsZW4gPSAwO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XHJcbiAgICAvLyBHb3RjaGE6IGNoYXJDb2RlQXQgcmV0dXJucyBhIDE2LWJpdCB3b3JkIHRoYXQgaXMgYSBVVEYtMTYgZW5jb2RlZCBjb2RlIHVuaXQsIG5vdCBhIFVuaWNvZGUgY29kZSBwb2ludCBvZiB0aGUgY2hhcmFjdGVyISBXZSBtdXN0IGRlY29kZSB0aGUgc3RyaW5nIHRvIFVURi0zMiB0byB0aGUgaGVhcC5cclxuICAgIC8vIFNlZSBodHRwOi8vdW5pY29kZS5vcmcvZmFxL3V0Zl9ib20uaHRtbCN1dGYxNi0zXHJcbiAgICB2YXIgY29kZVVuaXQgPSBzdHIuY2hhckNvZGVBdChpKTtcclxuICAgIGlmIChjb2RlVW5pdCA+PSAweEQ4MDAgJiYgY29kZVVuaXQgPD0gMHhERkZGKSArK2k7IC8vIHBvc3NpYmx5IGEgbGVhZCBzdXJyb2dhdGUsIHNvIHNraXAgb3ZlciB0aGUgdGFpbCBzdXJyb2dhdGUuXHJcbiAgICBsZW4gKz0gNDtcclxuICB9XHJcblxyXG4gIHJldHVybiBsZW47XHJcbn1cclxuXHJcbi8vIEFsbG9jYXRlIGhlYXAgc3BhY2UgZm9yIGEgSlMgc3RyaW5nLCBhbmQgd3JpdGUgaXQgdGhlcmUuXHJcbi8vIEl0IGlzIHRoZSByZXNwb25zaWJpbGl0eSBvZiB0aGUgY2FsbGVyIHRvIGZyZWUoKSB0aGF0IG1lbW9yeS5cclxuZnVuY3Rpb24gYWxsb2NhdGVVVEY4KHN0cikge1xyXG4gIHZhciBzaXplID0gbGVuZ3RoQnl0ZXNVVEY4KHN0cikgKyAxO1xyXG4gIHZhciByZXQgPSBfbWFsbG9jKHNpemUpO1xyXG4gIGlmIChyZXQpIHN0cmluZ1RvVVRGOEFycmF5KHN0ciwgSEVBUDgsIHJldCwgc2l6ZSk7XHJcbiAgcmV0dXJuIHJldDtcclxufVxyXG5cclxuLy8gQWxsb2NhdGUgc3RhY2sgc3BhY2UgZm9yIGEgSlMgc3RyaW5nLCBhbmQgd3JpdGUgaXQgdGhlcmUuXHJcbmZ1bmN0aW9uIGFsbG9jYXRlVVRGOE9uU3RhY2soc3RyKSB7XHJcbiAgdmFyIHNpemUgPSBsZW5ndGhCeXRlc1VURjgoc3RyKSArIDE7XHJcbiAgdmFyIHJldCA9IHN0YWNrQWxsb2Moc2l6ZSk7XHJcbiAgc3RyaW5nVG9VVEY4QXJyYXkoc3RyLCBIRUFQOCwgcmV0LCBzaXplKTtcclxuICByZXR1cm4gcmV0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBkZW1hbmdsZShmdW5jKSB7XHJcbiAgd2Fybk9uY2UoJ3dhcm5pbmc6IGJ1aWxkIHdpdGggIC1zIERFTUFOR0xFX1NVUFBPUlQ9MSAgdG8gbGluayBpbiBsaWJjeHhhYmkgZGVtYW5nbGluZycpO1xyXG4gIHJldHVybiBmdW5jO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkZW1hbmdsZUFsbCh0ZXh0KSB7XHJcbiAgdmFyIHJlZ2V4ID1cclxuICAgIC9fX1pbXFx3XFxkX10rL2c7XHJcbiAgcmV0dXJuIHRleHQucmVwbGFjZShyZWdleCxcclxuICAgIGZ1bmN0aW9uKHgpIHtcclxuICAgICAgdmFyIHkgPSBkZW1hbmdsZSh4KTtcclxuICAgICAgcmV0dXJuIHggPT09IHkgPyB4IDogKHggKyAnIFsnICsgeSArICddJyk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24ganNTdGFja1RyYWNlKCkge1xyXG4gIHZhciBlcnIgPSBuZXcgRXJyb3IoKTtcclxuICBpZiAoIWVyci5zdGFjaykge1xyXG4gICAgLy8gSUUxMCsgc3BlY2lhbCBjYXNlczogSXQgZG9lcyBoYXZlIGNhbGxzdGFjayBpbmZvLCBidXQgaXQgaXMgb25seSBwb3B1bGF0ZWQgaWYgYW4gRXJyb3Igb2JqZWN0IGlzIHRocm93bixcclxuICAgIC8vIHNvIHRyeSB0aGF0IGFzIGEgc3BlY2lhbC1jYXNlLlxyXG4gICAgdHJ5IHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKDApO1xyXG4gICAgfSBjYXRjaChlKSB7XHJcbiAgICAgIGVyciA9IGU7XHJcbiAgICB9XHJcbiAgICBpZiAoIWVyci5zdGFjaykge1xyXG4gICAgICByZXR1cm4gJyhubyBzdGFjayB0cmFjZSBhdmFpbGFibGUpJztcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGVyci5zdGFjay50b1N0cmluZygpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzdGFja1RyYWNlKCkge1xyXG4gIHZhciBqcyA9IGpzU3RhY2tUcmFjZSgpO1xyXG4gIGlmIChNb2R1bGVbJ2V4dHJhU3RhY2tUcmFjZSddKSBqcyArPSAnXFxuJyArIE1vZHVsZVsnZXh0cmFTdGFja1RyYWNlJ10oKTtcclxuICByZXR1cm4gZGVtYW5nbGVBbGwoanMpO1xyXG59XHJcblxyXG4vLyBNZW1vcnkgbWFuYWdlbWVudFxyXG5cclxudmFyIFBBR0VfU0laRSA9IDE2Mzg0O1xyXG52YXIgV0FTTV9QQUdFX1NJWkUgPSA2NTUzNjtcclxudmFyIEFTTUpTX1BBR0VfU0laRSA9IDE2Nzc3MjE2O1xyXG52YXIgTUlOX1RPVEFMX01FTU9SWSA9IDE2Nzc3MjE2O1xyXG5cclxuZnVuY3Rpb24gYWxpZ25VcCh4LCBtdWx0aXBsZSkge1xyXG4gIGlmICh4ICUgbXVsdGlwbGUgPiAwKSB7XHJcbiAgICB4ICs9IG11bHRpcGxlIC0gKHggJSBtdWx0aXBsZSk7XHJcbiAgfVxyXG4gIHJldHVybiB4O1xyXG59XHJcblxyXG52YXIgSEVBUCxcclxuLyoqIEB0eXBlIHtBcnJheUJ1ZmZlcn0gKi9cclxuICBidWZmZXIsXHJcbi8qKiBAdHlwZSB7SW50OEFycmF5fSAqL1xyXG4gIEhFQVA4LFxyXG4vKiogQHR5cGUge1VpbnQ4QXJyYXl9ICovXHJcbiAgSEVBUFU4LFxyXG4vKiogQHR5cGUge0ludDE2QXJyYXl9ICovXHJcbiAgSEVBUDE2LFxyXG4vKiogQHR5cGUge1VpbnQxNkFycmF5fSAqL1xyXG4gIEhFQVBVMTYsXHJcbi8qKiBAdHlwZSB7SW50MzJBcnJheX0gKi9cclxuICBIRUFQMzIsXHJcbi8qKiBAdHlwZSB7VWludDMyQXJyYXl9ICovXHJcbiAgSEVBUFUzMixcclxuLyoqIEB0eXBlIHtGbG9hdDMyQXJyYXl9ICovXHJcbiAgSEVBUEYzMixcclxuLyoqIEB0eXBlIHtGbG9hdDY0QXJyYXl9ICovXHJcbiAgSEVBUEY2NDtcclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZUdsb2JhbEJ1ZmZlcihidWYpIHtcclxuICBNb2R1bGVbJ2J1ZmZlciddID0gYnVmZmVyID0gYnVmO1xyXG59XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVHbG9iYWxCdWZmZXJWaWV3cygpIHtcclxuICBNb2R1bGVbJ0hFQVA4J10gPSBIRUFQOCA9IG5ldyBJbnQ4QXJyYXkoYnVmZmVyKTtcclxuICBNb2R1bGVbJ0hFQVAxNiddID0gSEVBUDE2ID0gbmV3IEludDE2QXJyYXkoYnVmZmVyKTtcclxuICBNb2R1bGVbJ0hFQVAzMiddID0gSEVBUDMyID0gbmV3IEludDMyQXJyYXkoYnVmZmVyKTtcclxuICBNb2R1bGVbJ0hFQVBVOCddID0gSEVBUFU4ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcclxuICBNb2R1bGVbJ0hFQVBVMTYnXSA9IEhFQVBVMTYgPSBuZXcgVWludDE2QXJyYXkoYnVmZmVyKTtcclxuICBNb2R1bGVbJ0hFQVBVMzInXSA9IEhFQVBVMzIgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyKTtcclxuICBNb2R1bGVbJ0hFQVBGMzInXSA9IEhFQVBGMzIgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlcik7XHJcbiAgTW9kdWxlWydIRUFQRjY0J10gPSBIRUFQRjY0ID0gbmV3IEZsb2F0NjRBcnJheShidWZmZXIpO1xyXG59XHJcblxyXG52YXIgU1RBVElDX0JBU0UsIFNUQVRJQ1RPUCwgc3RhdGljU2VhbGVkOyAvLyBzdGF0aWMgYXJlYVxyXG52YXIgU1RBQ0tfQkFTRSwgU1RBQ0tUT1AsIFNUQUNLX01BWDsgLy8gc3RhY2sgYXJlYVxyXG52YXIgRFlOQU1JQ19CQVNFLCBEWU5BTUlDVE9QX1BUUjsgLy8gZHluYW1pYyBhcmVhIGhhbmRsZWQgYnkgc2Jya1xyXG5cclxuICBTVEFUSUNfQkFTRSA9IFNUQVRJQ1RPUCA9IFNUQUNLX0JBU0UgPSBTVEFDS1RPUCA9IFNUQUNLX01BWCA9IERZTkFNSUNfQkFTRSA9IERZTkFNSUNUT1BfUFRSID0gMDtcclxuICBzdGF0aWNTZWFsZWQgPSBmYWxzZTtcclxuXHJcblxyXG4vLyBJbml0aWFsaXplcyB0aGUgc3RhY2sgY29va2llLiBDYWxsZWQgYXQgdGhlIHN0YXJ0dXAgb2YgbWFpbiBhbmQgYXQgdGhlIHN0YXJ0dXAgb2YgZWFjaCB0aHJlYWQgaW4gcHRocmVhZHMgbW9kZS5cclxuZnVuY3Rpb24gd3JpdGVTdGFja0Nvb2tpZSgpIHtcclxuICBhc3NlcnQoKFNUQUNLX01BWCAmIDMpID09IDApO1xyXG4gIEhFQVBVMzJbKFNUQUNLX01BWCA+PiAyKS0xXSA9IDB4MDIxMzU0Njc7XHJcbiAgSEVBUFUzMlsoU1RBQ0tfTUFYID4+IDIpLTJdID0gMHg4OUJBQ0RGRTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2hlY2tTdGFja0Nvb2tpZSgpIHtcclxuICBpZiAoSEVBUFUzMlsoU1RBQ0tfTUFYID4+IDIpLTFdICE9IDB4MDIxMzU0NjcgfHwgSEVBUFUzMlsoU1RBQ0tfTUFYID4+IDIpLTJdICE9IDB4ODlCQUNERkUpIHtcclxuICAgIGFib3J0KCdTdGFjayBvdmVyZmxvdyEgU3RhY2sgY29va2llIGhhcyBiZWVuIG92ZXJ3cml0dGVuLCBleHBlY3RlZCBoZXggZHdvcmRzIDB4ODlCQUNERkUgYW5kIDB4MDIxMzU0NjcsIGJ1dCByZWNlaXZlZCAweCcgKyBIRUFQVTMyWyhTVEFDS19NQVggPj4gMiktMl0udG9TdHJpbmcoMTYpICsgJyAnICsgSEVBUFUzMlsoU1RBQ0tfTUFYID4+IDIpLTFdLnRvU3RyaW5nKDE2KSk7XHJcbiAgfVxyXG4gIC8vIEFsc28gdGVzdCB0aGUgZ2xvYmFsIGFkZHJlc3MgMCBmb3IgaW50ZWdyaXR5LiBUaGlzIGNoZWNrIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggU0FGRV9TUExJVF9NRU1PUlkgdGhvdWdoLCBzaW5jZSB0aGF0IG1vZGUgYWxyZWFkeSB0ZXN0cyBhbGwgYWRkcmVzcyAwIGFjY2Vzc2VzIG9uIGl0cyBvd24uXHJcbiAgaWYgKEhFQVAzMlswXSAhPT0gMHg2MzczNmQ2NSAvKiAnZW1zYycgKi8pIHRocm93ICdSdW50aW1lIGVycm9yOiBUaGUgYXBwbGljYXRpb24gaGFzIGNvcnJ1cHRlZCBpdHMgaGVhcCBtZW1vcnkgYXJlYSAoYWRkcmVzcyB6ZXJvKSEnO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhYm9ydFN0YWNrT3ZlcmZsb3coYWxsb2NTaXplKSB7XHJcbiAgYWJvcnQoJ1N0YWNrIG92ZXJmbG93ISBBdHRlbXB0ZWQgdG8gYWxsb2NhdGUgJyArIGFsbG9jU2l6ZSArICcgYnl0ZXMgb24gdGhlIHN0YWNrLCBidXQgc3RhY2sgaGFzIG9ubHkgJyArIChTVEFDS19NQVggLSBzdGFja1NhdmUoKSArIGFsbG9jU2l6ZSkgKyAnIGJ5dGVzIGF2YWlsYWJsZSEnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gYWJvcnRPbkNhbm5vdEdyb3dNZW1vcnkoKSB7XHJcbiAgYWJvcnQoJ0Nhbm5vdCBlbmxhcmdlIG1lbW9yeSBhcnJheXMuIEVpdGhlciAoMSkgY29tcGlsZSB3aXRoICAtcyBUT1RBTF9NRU1PUlk9WCAgd2l0aCBYIGhpZ2hlciB0aGFuIHRoZSBjdXJyZW50IHZhbHVlICcgKyBUT1RBTF9NRU1PUlkgKyAnLCAoMikgY29tcGlsZSB3aXRoICAtcyBBTExPV19NRU1PUllfR1JPV1RIPTEgIHdoaWNoIGFsbG93cyBpbmNyZWFzaW5nIHRoZSBzaXplIGF0IHJ1bnRpbWUsIG9yICgzKSBpZiB5b3Ugd2FudCBtYWxsb2MgdG8gcmV0dXJuIE5VTEwgKDApIGluc3RlYWQgb2YgdGhpcyBhYm9ydCwgY29tcGlsZSB3aXRoICAtcyBBQk9SVElOR19NQUxMT0M9MCAnKTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGVubGFyZ2VNZW1vcnkoKSB7XHJcbiAgYWJvcnRPbkNhbm5vdEdyb3dNZW1vcnkoKTtcclxufVxyXG5cclxuXHJcbnZhciBUT1RBTF9TVEFDSyA9IE1vZHVsZVsnVE9UQUxfU1RBQ0snXSB8fCA1MjQyODgwO1xyXG52YXIgVE9UQUxfTUVNT1JZID0gTW9kdWxlWydUT1RBTF9NRU1PUlknXSB8fCAxNjc3NzIxNjtcclxuaWYgKFRPVEFMX01FTU9SWSA8IFRPVEFMX1NUQUNLKSBNb2R1bGUucHJpbnRFcnIoJ1RPVEFMX01FTU9SWSBzaG91bGQgYmUgbGFyZ2VyIHRoYW4gVE9UQUxfU1RBQ0ssIHdhcyAnICsgVE9UQUxfTUVNT1JZICsgJyEgKFRPVEFMX1NUQUNLPScgKyBUT1RBTF9TVEFDSyArICcpJyk7XHJcblxyXG4vLyBJbml0aWFsaXplIHRoZSBydW50aW1lJ3MgbWVtb3J5XHJcbi8vIGNoZWNrIGZvciBmdWxsIGVuZ2luZSBzdXBwb3J0ICh1c2Ugc3RyaW5nICdzdWJhcnJheScgdG8gYXZvaWQgY2xvc3VyZSBjb21waWxlciBjb25mdXNpb24pXHJcbmFzc2VydCh0eXBlb2YgSW50MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEZsb2F0NjRBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgSW50MzJBcnJheS5wcm90b3R5cGUuc3ViYXJyYXkgIT09IHVuZGVmaW5lZCAmJiBJbnQzMkFycmF5LnByb3RvdHlwZS5zZXQgIT09IHVuZGVmaW5lZCxcclxuICAgICAgICdKUyBlbmdpbmUgZG9lcyBub3QgcHJvdmlkZSBmdWxsIHR5cGVkIGFycmF5IHN1cHBvcnQnKTtcclxuXHJcblxyXG5cclxuLy8gVXNlIGEgcHJvdmlkZWQgYnVmZmVyLCBpZiB0aGVyZSBpcyBvbmUsIG9yIGVsc2UgYWxsb2NhdGUgYSBuZXcgb25lXHJcbmlmIChNb2R1bGVbJ2J1ZmZlciddKSB7XHJcbiAgYnVmZmVyID0gTW9kdWxlWydidWZmZXInXTtcclxuICBhc3NlcnQoYnVmZmVyLmJ5dGVMZW5ndGggPT09IFRPVEFMX01FTU9SWSwgJ3Byb3ZpZGVkIGJ1ZmZlciBzaG91bGQgYmUgJyArIFRPVEFMX01FTU9SWSArICcgYnl0ZXMsIGJ1dCBpdCBpcyAnICsgYnVmZmVyLmJ5dGVMZW5ndGgpO1xyXG59IGVsc2Uge1xyXG4gIC8vIFVzZSBhIFdlYkFzc2VtYmx5IG1lbW9yeSB3aGVyZSBhdmFpbGFibGVcclxuICBpZiAodHlwZW9mIFdlYkFzc2VtYmx5ID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgV2ViQXNzZW1ibHkuTWVtb3J5ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICBhc3NlcnQoVE9UQUxfTUVNT1JZICUgV0FTTV9QQUdFX1NJWkUgPT09IDApO1xyXG4gICAgTW9kdWxlWyd3YXNtTWVtb3J5J10gPSBuZXcgV2ViQXNzZW1ibHkuTWVtb3J5KHsgJ2luaXRpYWwnOiBUT1RBTF9NRU1PUlkgLyBXQVNNX1BBR0VfU0laRSwgJ21heGltdW0nOiBUT1RBTF9NRU1PUlkgLyBXQVNNX1BBR0VfU0laRSB9KTtcclxuICAgIGJ1ZmZlciA9IE1vZHVsZVsnd2FzbU1lbW9yeSddLmJ1ZmZlcjtcclxuICB9IGVsc2VcclxuICB7XHJcbiAgICBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoVE9UQUxfTUVNT1JZKTtcclxuICB9XHJcbiAgYXNzZXJ0KGJ1ZmZlci5ieXRlTGVuZ3RoID09PSBUT1RBTF9NRU1PUlkpO1xyXG4gIE1vZHVsZVsnYnVmZmVyJ10gPSBidWZmZXI7XHJcbn1cclxudXBkYXRlR2xvYmFsQnVmZmVyVmlld3MoKTtcclxuXHJcblxyXG5mdW5jdGlvbiBnZXRUb3RhbE1lbW9yeSgpIHtcclxuICByZXR1cm4gVE9UQUxfTUVNT1JZO1xyXG59XHJcblxyXG4vLyBFbmRpYW5uZXNzIGNoZWNrIChub3RlOiBhc3N1bWVzIGNvbXBpbGVyIGFyY2ggd2FzIGxpdHRsZS1lbmRpYW4pXHJcbiAgSEVBUDMyWzBdID0gMHg2MzczNmQ2NTsgLyogJ2Vtc2MnICovXHJcbkhFQVAxNlsxXSA9IDB4NjM3MztcclxuaWYgKEhFQVBVOFsyXSAhPT0gMHg3MyB8fCBIRUFQVThbM10gIT09IDB4NjMpIHRocm93ICdSdW50aW1lIGVycm9yOiBleHBlY3RlZCB0aGUgc3lzdGVtIHRvIGJlIGxpdHRsZS1lbmRpYW4hJztcclxuXHJcbmZ1bmN0aW9uIGNhbGxSdW50aW1lQ2FsbGJhY2tzKGNhbGxiYWNrcykge1xyXG4gIHdoaWxlKGNhbGxiYWNrcy5sZW5ndGggPiAwKSB7XHJcbiAgICB2YXIgY2FsbGJhY2sgPSBjYWxsYmFja3Muc2hpZnQoKTtcclxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBjYWxsYmFjaygpO1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIHZhciBmdW5jID0gY2FsbGJhY2suZnVuYztcclxuICAgIGlmICh0eXBlb2YgZnVuYyA9PT0gJ251bWJlcicpIHtcclxuICAgICAgaWYgKGNhbGxiYWNrLmFyZyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgTW9kdWxlWydkeW5DYWxsX3YnXShmdW5jKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBNb2R1bGVbJ2R5bkNhbGxfdmknXShmdW5jLCBjYWxsYmFjay5hcmcpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBmdW5jKGNhbGxiYWNrLmFyZyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNhbGxiYWNrLmFyZyk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG52YXIgX19BVFBSRVJVTl9fICA9IFtdOyAvLyBmdW5jdGlvbnMgY2FsbGVkIGJlZm9yZSB0aGUgcnVudGltZSBpcyBpbml0aWFsaXplZFxyXG52YXIgX19BVElOSVRfXyAgICA9IFtdOyAvLyBmdW5jdGlvbnMgY2FsbGVkIGR1cmluZyBzdGFydHVwXHJcbnZhciBfX0FUTUFJTl9fICAgID0gW107IC8vIGZ1bmN0aW9ucyBjYWxsZWQgd2hlbiBtYWluKCkgaXMgdG8gYmUgcnVuXHJcbnZhciBfX0FURVhJVF9fICAgID0gW107IC8vIGZ1bmN0aW9ucyBjYWxsZWQgZHVyaW5nIHNodXRkb3duXHJcbnZhciBfX0FUUE9TVFJVTl9fID0gW107IC8vIGZ1bmN0aW9ucyBjYWxsZWQgYWZ0ZXIgdGhlIHJ1bnRpbWUgaGFzIGV4aXRlZFxyXG5cclxudmFyIHJ1bnRpbWVJbml0aWFsaXplZCA9IGZhbHNlO1xyXG52YXIgcnVudGltZUV4aXRlZCA9IGZhbHNlO1xyXG5cclxuXHJcbmZ1bmN0aW9uIHByZVJ1bigpIHtcclxuICAvLyBjb21wYXRpYmlsaXR5IC0gbWVyZ2UgaW4gYW55dGhpbmcgZnJvbSBNb2R1bGVbJ3ByZVJ1biddIGF0IHRoaXMgdGltZVxyXG4gIGlmIChNb2R1bGVbJ3ByZVJ1biddKSB7XHJcbiAgICBpZiAodHlwZW9mIE1vZHVsZVsncHJlUnVuJ10gPT0gJ2Z1bmN0aW9uJykgTW9kdWxlWydwcmVSdW4nXSA9IFtNb2R1bGVbJ3ByZVJ1biddXTtcclxuICAgIHdoaWxlIChNb2R1bGVbJ3ByZVJ1biddLmxlbmd0aCkge1xyXG4gICAgICBhZGRPblByZVJ1bihNb2R1bGVbJ3ByZVJ1biddLnNoaWZ0KCkpO1xyXG4gICAgfVxyXG4gIH1cclxuICBjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUUFJFUlVOX18pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBlbnN1cmVJbml0UnVudGltZSgpIHtcclxuICBjaGVja1N0YWNrQ29va2llKCk7XHJcbiAgaWYgKHJ1bnRpbWVJbml0aWFsaXplZCkgcmV0dXJuO1xyXG4gIHJ1bnRpbWVJbml0aWFsaXplZCA9IHRydWU7XHJcbiAgY2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVElOSVRfXyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHByZU1haW4oKSB7XHJcbiAgY2hlY2tTdGFja0Nvb2tpZSgpO1xyXG4gIGNhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRNQUlOX18pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBleGl0UnVudGltZSgpIHtcclxuICBjaGVja1N0YWNrQ29va2llKCk7XHJcbiAgY2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVEVYSVRfXyk7XHJcbiAgcnVudGltZUV4aXRlZCA9IHRydWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBvc3RSdW4oKSB7XHJcbiAgY2hlY2tTdGFja0Nvb2tpZSgpO1xyXG4gIC8vIGNvbXBhdGliaWxpdHkgLSBtZXJnZSBpbiBhbnl0aGluZyBmcm9tIE1vZHVsZVsncG9zdFJ1biddIGF0IHRoaXMgdGltZVxyXG4gIGlmIChNb2R1bGVbJ3Bvc3RSdW4nXSkge1xyXG4gICAgaWYgKHR5cGVvZiBNb2R1bGVbJ3Bvc3RSdW4nXSA9PSAnZnVuY3Rpb24nKSBNb2R1bGVbJ3Bvc3RSdW4nXSA9IFtNb2R1bGVbJ3Bvc3RSdW4nXV07XHJcbiAgICB3aGlsZSAoTW9kdWxlWydwb3N0UnVuJ10ubGVuZ3RoKSB7XHJcbiAgICAgIGFkZE9uUG9zdFJ1bihNb2R1bGVbJ3Bvc3RSdW4nXS5zaGlmdCgpKTtcclxuICAgIH1cclxuICB9XHJcbiAgY2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVFBPU1RSVU5fXyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZE9uUHJlUnVuKGNiKSB7XHJcbiAgX19BVFBSRVJVTl9fLnVuc2hpZnQoY2IpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRPbkluaXQoY2IpIHtcclxuICBfX0FUSU5JVF9fLnVuc2hpZnQoY2IpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRPblByZU1haW4oY2IpIHtcclxuICBfX0FUTUFJTl9fLnVuc2hpZnQoY2IpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRPbkV4aXQoY2IpIHtcclxuICBfX0FURVhJVF9fLnVuc2hpZnQoY2IpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRPblBvc3RSdW4oY2IpIHtcclxuICBfX0FUUE9TVFJVTl9fLnVuc2hpZnQoY2IpO1xyXG59XHJcblxyXG4vLyBEZXByZWNhdGVkOiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBub3QgYmUgY2FsbGVkIGJlY2F1c2UgaXQgaXMgdW5zYWZlIGFuZCBkb2VzIG5vdCBwcm92aWRlXHJcbi8vIGEgbWF4aW11bSBsZW5ndGggbGltaXQgb2YgaG93IG1hbnkgYnl0ZXMgaXQgaXMgYWxsb3dlZCB0byB3cml0ZS4gUHJlZmVyIGNhbGxpbmcgdGhlXHJcbi8vIGZ1bmN0aW9uIHN0cmluZ1RvVVRGOEFycmF5KCkgaW5zdGVhZCwgd2hpY2ggdGFrZXMgaW4gYSBtYXhpbXVtIGxlbmd0aCB0aGF0IGNhbiBiZSB1c2VkXHJcbi8vIHRvIGJlIHNlY3VyZSBmcm9tIG91dCBvZiBib3VuZHMgd3JpdGVzLlxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZnVuY3Rpb24gd3JpdGVTdHJpbmdUb01lbW9yeShzdHJpbmcsIGJ1ZmZlciwgZG9udEFkZE51bGwpIHtcclxuICB3YXJuT25jZSgnd3JpdGVTdHJpbmdUb01lbW9yeSBpcyBkZXByZWNhdGVkIGFuZCBzaG91bGQgbm90IGJlIGNhbGxlZCEgVXNlIHN0cmluZ1RvVVRGOCgpIGluc3RlYWQhJyk7XHJcblxyXG4gIHZhciAvKiogQHR5cGUge251bWJlcn0gKi8gbGFzdENoYXIsIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyBlbmQ7XHJcbiAgaWYgKGRvbnRBZGROdWxsKSB7XHJcbiAgICAvLyBzdHJpbmdUb1VURjhBcnJheSBhbHdheXMgYXBwZW5kcyBudWxsLiBJZiB3ZSBkb24ndCB3YW50IHRvIGRvIHRoYXQsIHJlbWVtYmVyIHRoZVxyXG4gICAgLy8gY2hhcmFjdGVyIHRoYXQgZXhpc3RlZCBhdCB0aGUgbG9jYXRpb24gd2hlcmUgdGhlIG51bGwgd2lsbCBiZSBwbGFjZWQsIGFuZCByZXN0b3JlXHJcbiAgICAvLyB0aGF0IGFmdGVyIHRoZSB3cml0ZSAoYmVsb3cpLlxyXG4gICAgZW5kID0gYnVmZmVyICsgbGVuZ3RoQnl0ZXNVVEY4KHN0cmluZyk7XHJcbiAgICBsYXN0Q2hhciA9IEhFQVA4W2VuZF07XHJcbiAgfVxyXG4gIHN0cmluZ1RvVVRGOChzdHJpbmcsIGJ1ZmZlciwgSW5maW5pdHkpO1xyXG4gIGlmIChkb250QWRkTnVsbCkgSEVBUDhbZW5kXSA9IGxhc3RDaGFyOyAvLyBSZXN0b3JlIHRoZSB2YWx1ZSB1bmRlciB0aGUgbnVsbCBjaGFyYWN0ZXIuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHdyaXRlQXJyYXlUb01lbW9yeShhcnJheSwgYnVmZmVyKSB7XHJcbiAgYXNzZXJ0KGFycmF5Lmxlbmd0aCA+PSAwLCAnd3JpdGVBcnJheVRvTWVtb3J5IGFycmF5IG11c3QgaGF2ZSBhIGxlbmd0aCAoc2hvdWxkIGJlIGFuIGFycmF5IG9yIHR5cGVkIGFycmF5KScpXHJcbiAgSEVBUDguc2V0KGFycmF5LCBidWZmZXIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiB3cml0ZUFzY2lpVG9NZW1vcnkoc3RyLCBidWZmZXIsIGRvbnRBZGROdWxsKSB7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcclxuICAgIGFzc2VydChzdHIuY2hhckNvZGVBdChpKSA9PT0gc3RyLmNoYXJDb2RlQXQoaSkmMHhmZik7XHJcbiAgICBIRUFQOFsoKGJ1ZmZlcisrKT4+MCldPXN0ci5jaGFyQ29kZUF0KGkpO1xyXG4gIH1cclxuICAvLyBOdWxsLXRlcm1pbmF0ZSB0aGUgcG9pbnRlciB0byB0aGUgSEVBUC5cclxuICBpZiAoIWRvbnRBZGROdWxsKSBIRUFQOFsoKGJ1ZmZlcik+PjApXT0wO1xyXG59XHJcblxyXG5mdW5jdGlvbiB1blNpZ24odmFsdWUsIGJpdHMsIGlnbm9yZSkge1xyXG4gIGlmICh2YWx1ZSA+PSAwKSB7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbiAgfVxyXG4gIHJldHVybiBiaXRzIDw9IDMyID8gMipNYXRoLmFicygxIDw8IChiaXRzLTEpKSArIHZhbHVlIC8vIE5lZWQgc29tZSB0cmlja2VyeSwgc2luY2UgaWYgYml0cyA9PSAzMiwgd2UgYXJlIHJpZ2h0IGF0IHRoZSBsaW1pdCBvZiB0aGUgYml0cyBKUyB1c2VzIGluIGJpdHNoaWZ0c1xyXG4gICAgICAgICAgICAgICAgICAgIDogTWF0aC5wb3coMiwgYml0cykgICAgICAgICArIHZhbHVlO1xyXG59XHJcbmZ1bmN0aW9uIHJlU2lnbih2YWx1ZSwgYml0cywgaWdub3JlKSB7XHJcbiAgaWYgKHZhbHVlIDw9IDApIHtcclxuICAgIHJldHVybiB2YWx1ZTtcclxuICB9XHJcbiAgdmFyIGhhbGYgPSBiaXRzIDw9IDMyID8gTWF0aC5hYnMoMSA8PCAoYml0cy0xKSkgLy8gYWJzIGlzIG5lZWRlZCBpZiBiaXRzID09IDMyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogTWF0aC5wb3coMiwgYml0cy0xKTtcclxuICBpZiAodmFsdWUgPj0gaGFsZiAmJiAoYml0cyA8PSAzMiB8fCB2YWx1ZSA+IGhhbGYpKSB7IC8vIGZvciBodWdlIHZhbHVlcywgd2UgY2FuIGhpdCB0aGUgcHJlY2lzaW9uIGxpbWl0IGFuZCBhbHdheXMgZ2V0IHRydWUgaGVyZS4gc28gZG9uJ3QgZG8gdGhhdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0LCBpbiBnZW5lcmFsIHRoZXJlIGlzIG5vIHBlcmZlY3Qgc29sdXRpb24gaGVyZS4gV2l0aCA2NC1iaXQgaW50cywgd2UgZ2V0IHJvdW5kaW5nIGFuZCBlcnJvcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IEluIGk2NCBtb2RlIDEsIHJlc2lnbiB0aGUgdHdvIHBhcnRzIHNlcGFyYXRlbHkgYW5kIHNhZmVseVxyXG4gICAgdmFsdWUgPSAtMipoYWxmICsgdmFsdWU7IC8vIENhbm5vdCBiaXRzaGlmdCBoYWxmLCBhcyBpdCBtYXkgYmUgYXQgdGhlIGxpbWl0IG9mIHRoZSBiaXRzIEpTIHVzZXMgaW4gYml0c2hpZnRzXHJcbiAgfVxyXG4gIHJldHVybiB2YWx1ZTtcclxufVxyXG5cclxuYXNzZXJ0KE1hdGhbJ2ltdWwnXSAmJiBNYXRoWydmcm91bmQnXSAmJiBNYXRoWydjbHozMiddICYmIE1hdGhbJ3RydW5jJ10sICd0aGlzIGlzIGEgbGVnYWN5IGJyb3dzZXIsIGJ1aWxkIHdpdGggTEVHQUNZX1ZNX1NVUFBPUlQnKTtcclxuXHJcbnZhciBNYXRoX2FicyA9IE1hdGguYWJzO1xyXG52YXIgTWF0aF9jb3MgPSBNYXRoLmNvcztcclxudmFyIE1hdGhfc2luID0gTWF0aC5zaW47XHJcbnZhciBNYXRoX3RhbiA9IE1hdGgudGFuO1xyXG52YXIgTWF0aF9hY29zID0gTWF0aC5hY29zO1xyXG52YXIgTWF0aF9hc2luID0gTWF0aC5hc2luO1xyXG52YXIgTWF0aF9hdGFuID0gTWF0aC5hdGFuO1xyXG52YXIgTWF0aF9hdGFuMiA9IE1hdGguYXRhbjI7XHJcbnZhciBNYXRoX2V4cCA9IE1hdGguZXhwO1xyXG52YXIgTWF0aF9sb2cgPSBNYXRoLmxvZztcclxudmFyIE1hdGhfc3FydCA9IE1hdGguc3FydDtcclxudmFyIE1hdGhfY2VpbCA9IE1hdGguY2VpbDtcclxudmFyIE1hdGhfZmxvb3IgPSBNYXRoLmZsb29yO1xyXG52YXIgTWF0aF9wb3cgPSBNYXRoLnBvdztcclxudmFyIE1hdGhfaW11bCA9IE1hdGguaW11bDtcclxudmFyIE1hdGhfZnJvdW5kID0gTWF0aC5mcm91bmQ7XHJcbnZhciBNYXRoX3JvdW5kID0gTWF0aC5yb3VuZDtcclxudmFyIE1hdGhfbWluID0gTWF0aC5taW47XHJcbnZhciBNYXRoX21heCA9IE1hdGgubWF4O1xyXG52YXIgTWF0aF9jbHozMiA9IE1hdGguY2x6MzI7XHJcbnZhciBNYXRoX3RydW5jID0gTWF0aC50cnVuYztcclxuXHJcbi8vIEEgY291bnRlciBvZiBkZXBlbmRlbmNpZXMgZm9yIGNhbGxpbmcgcnVuKCkuIElmIHdlIG5lZWQgdG9cclxuLy8gZG8gYXN5bmNocm9ub3VzIHdvcmsgYmVmb3JlIHJ1bm5pbmcsIGluY3JlbWVudCB0aGlzIGFuZFxyXG4vLyBkZWNyZW1lbnQgaXQuIEluY3JlbWVudGluZyBtdXN0IGhhcHBlbiBpbiBhIHBsYWNlIGxpa2VcclxuLy8gUFJFX1JVTl9BRERJVElPTlMgKHVzZWQgYnkgZW1jYyB0byBhZGQgZmlsZSBwcmVsb2FkaW5nKS5cclxuLy8gTm90ZSB0aGF0IHlvdSBjYW4gYWRkIGRlcGVuZGVuY2llcyBpbiBwcmVSdW4sIGV2ZW4gdGhvdWdoXHJcbi8vIGl0IGhhcHBlbnMgcmlnaHQgYmVmb3JlIHJ1biAtIHJ1biB3aWxsIGJlIHBvc3Rwb25lZCB1bnRpbFxyXG4vLyB0aGUgZGVwZW5kZW5jaWVzIGFyZSBtZXQuXHJcbnZhciBydW5EZXBlbmRlbmNpZXMgPSAwO1xyXG52YXIgcnVuRGVwZW5kZW5jeVdhdGNoZXIgPSBudWxsO1xyXG52YXIgZGVwZW5kZW5jaWVzRnVsZmlsbGVkID0gbnVsbDsgLy8gb3ZlcnJpZGRlbiB0byB0YWtlIGRpZmZlcmVudCBhY3Rpb25zIHdoZW4gYWxsIHJ1biBkZXBlbmRlbmNpZXMgYXJlIGZ1bGZpbGxlZFxyXG52YXIgcnVuRGVwZW5kZW5jeVRyYWNraW5nID0ge307XHJcblxyXG5mdW5jdGlvbiBnZXRVbmlxdWVSdW5EZXBlbmRlbmN5KGlkKSB7XHJcbiAgdmFyIG9yaWcgPSBpZDtcclxuICB3aGlsZSAoMSkge1xyXG4gICAgaWYgKCFydW5EZXBlbmRlbmN5VHJhY2tpbmdbaWRdKSByZXR1cm4gaWQ7XHJcbiAgICBpZCA9IG9yaWcgKyBNYXRoLnJhbmRvbSgpO1xyXG4gIH1cclxuICByZXR1cm4gaWQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFJ1bkRlcGVuZGVuY3koaWQpIHtcclxuICBydW5EZXBlbmRlbmNpZXMrKztcclxuICBpZiAoTW9kdWxlWydtb25pdG9yUnVuRGVwZW5kZW5jaWVzJ10pIHtcclxuICAgIE1vZHVsZVsnbW9uaXRvclJ1bkRlcGVuZGVuY2llcyddKHJ1bkRlcGVuZGVuY2llcyk7XHJcbiAgfVxyXG4gIGlmIChpZCkge1xyXG4gICAgYXNzZXJ0KCFydW5EZXBlbmRlbmN5VHJhY2tpbmdbaWRdKTtcclxuICAgIHJ1bkRlcGVuZGVuY3lUcmFja2luZ1tpZF0gPSAxO1xyXG4gICAgaWYgKHJ1bkRlcGVuZGVuY3lXYXRjaGVyID09PSBudWxsICYmIHR5cGVvZiBzZXRJbnRlcnZhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgLy8gQ2hlY2sgZm9yIG1pc3NpbmcgZGVwZW5kZW5jaWVzIGV2ZXJ5IGZldyBzZWNvbmRzXHJcbiAgICAgIHJ1bkRlcGVuZGVuY3lXYXRjaGVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKEFCT1JUKSB7XHJcbiAgICAgICAgICBjbGVhckludGVydmFsKHJ1bkRlcGVuZGVuY3lXYXRjaGVyKTtcclxuICAgICAgICAgIHJ1bkRlcGVuZGVuY3lXYXRjaGVyID0gbnVsbDtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNob3duID0gZmFsc2U7XHJcbiAgICAgICAgZm9yICh2YXIgZGVwIGluIHJ1bkRlcGVuZGVuY3lUcmFja2luZykge1xyXG4gICAgICAgICAgaWYgKCFzaG93bikge1xyXG4gICAgICAgICAgICBzaG93biA9IHRydWU7XHJcbiAgICAgICAgICAgIE1vZHVsZS5wcmludEVycignc3RpbGwgd2FpdGluZyBvbiBydW4gZGVwZW5kZW5jaWVzOicpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgTW9kdWxlLnByaW50RXJyKCdkZXBlbmRlbmN5OiAnICsgZGVwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNob3duKSB7XHJcbiAgICAgICAgICBNb2R1bGUucHJpbnRFcnIoJyhlbmQgb2YgbGlzdCknKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sIDEwMDAwKTtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgTW9kdWxlLnByaW50RXJyKCd3YXJuaW5nOiBydW4gZGVwZW5kZW5jeSBhZGRlZCB3aXRob3V0IElEJyk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiByZW1vdmVSdW5EZXBlbmRlbmN5KGlkKSB7XHJcbiAgcnVuRGVwZW5kZW5jaWVzLS07XHJcbiAgaWYgKE1vZHVsZVsnbW9uaXRvclJ1bkRlcGVuZGVuY2llcyddKSB7XHJcbiAgICBNb2R1bGVbJ21vbml0b3JSdW5EZXBlbmRlbmNpZXMnXShydW5EZXBlbmRlbmNpZXMpO1xyXG4gIH1cclxuICBpZiAoaWQpIHtcclxuICAgIGFzc2VydChydW5EZXBlbmRlbmN5VHJhY2tpbmdbaWRdKTtcclxuICAgIGRlbGV0ZSBydW5EZXBlbmRlbmN5VHJhY2tpbmdbaWRdO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBNb2R1bGUucHJpbnRFcnIoJ3dhcm5pbmc6IHJ1biBkZXBlbmRlbmN5IHJlbW92ZWQgd2l0aG91dCBJRCcpO1xyXG4gIH1cclxuICBpZiAocnVuRGVwZW5kZW5jaWVzID09IDApIHtcclxuICAgIGlmIChydW5EZXBlbmRlbmN5V2F0Y2hlciAhPT0gbnVsbCkge1xyXG4gICAgICBjbGVhckludGVydmFsKHJ1bkRlcGVuZGVuY3lXYXRjaGVyKTtcclxuICAgICAgcnVuRGVwZW5kZW5jeVdhdGNoZXIgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgaWYgKGRlcGVuZGVuY2llc0Z1bGZpbGxlZCkge1xyXG4gICAgICB2YXIgY2FsbGJhY2sgPSBkZXBlbmRlbmNpZXNGdWxmaWxsZWQ7XHJcbiAgICAgIGRlcGVuZGVuY2llc0Z1bGZpbGxlZCA9IG51bGw7XHJcbiAgICAgIGNhbGxiYWNrKCk7IC8vIGNhbiBhZGQgYW5vdGhlciBkZXBlbmRlbmNpZXNGdWxmaWxsZWRcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbk1vZHVsZVtcInByZWxvYWRlZEltYWdlc1wiXSA9IHt9OyAvLyBtYXBzIHVybCB0byBpbWFnZSBkYXRhXHJcbk1vZHVsZVtcInByZWxvYWRlZEF1ZGlvc1wiXSA9IHt9OyAvLyBtYXBzIHVybCB0byBhdWRpbyBkYXRhXHJcblxyXG5cclxuXHJcbnZhciBtZW1vcnlJbml0aWFsaXplciA9IG51bGw7XHJcblxyXG5cclxuXHJcbnZhciAvKiBzaG93IGVycm9ycyBvbiBsaWtlbHkgY2FsbHMgdG8gRlMgd2hlbiBpdCB3YXMgbm90IGluY2x1ZGVkICovIEZTID0ge1xyXG4gIGVycm9yOiBmdW5jdGlvbigpIHtcclxuICAgIGFib3J0KCdGaWxlc3lzdGVtIHN1cHBvcnQgKEZTKSB3YXMgbm90IGluY2x1ZGVkLiBUaGUgcHJvYmxlbSBpcyB0aGF0IHlvdSBhcmUgdXNpbmcgZmlsZXMgZnJvbSBKUywgYnV0IGZpbGVzIHdlcmUgbm90IHVzZWQgZnJvbSBDL0MrKywgc28gZmlsZXN5c3RlbSBzdXBwb3J0IHdhcyBub3QgYXV0by1pbmNsdWRlZC4gWW91IGNhbiBmb3JjZS1pbmNsdWRlIGZpbGVzeXN0ZW0gc3VwcG9ydCB3aXRoICAtcyBGT1JDRV9GSUxFU1lTVEVNPTEnKTtcclxuICB9LFxyXG4gIGluaXQ6IGZ1bmN0aW9uKCkgeyBGUy5lcnJvcigpIH0sXHJcbiAgY3JlYXRlRGF0YUZpbGU6IGZ1bmN0aW9uKCkgeyBGUy5lcnJvcigpIH0sXHJcbiAgY3JlYXRlUHJlbG9hZGVkRmlsZTogZnVuY3Rpb24oKSB7IEZTLmVycm9yKCkgfSxcclxuICBjcmVhdGVMYXp5RmlsZTogZnVuY3Rpb24oKSB7IEZTLmVycm9yKCkgfSxcclxuICBvcGVuOiBmdW5jdGlvbigpIHsgRlMuZXJyb3IoKSB9LFxyXG4gIG1rZGV2OiBmdW5jdGlvbigpIHsgRlMuZXJyb3IoKSB9LFxyXG4gIHJlZ2lzdGVyRGV2aWNlOiBmdW5jdGlvbigpIHsgRlMuZXJyb3IoKSB9LFxyXG4gIGFuYWx5emVQYXRoOiBmdW5jdGlvbigpIHsgRlMuZXJyb3IoKSB9LFxyXG4gIGxvYWRGaWxlc0Zyb21EQjogZnVuY3Rpb24oKSB7IEZTLmVycm9yKCkgfSxcclxuXHJcbiAgRXJybm9FcnJvcjogZnVuY3Rpb24gRXJybm9FcnJvcigpIHsgRlMuZXJyb3IoKSB9LFxyXG59O1xyXG5Nb2R1bGVbJ0ZTX2NyZWF0ZURhdGFGaWxlJ10gPSBGUy5jcmVhdGVEYXRhRmlsZTtcclxuTW9kdWxlWydGU19jcmVhdGVQcmVsb2FkZWRGaWxlJ10gPSBGUy5jcmVhdGVQcmVsb2FkZWRGaWxlO1xyXG5cclxuXHJcblxyXG4vLyBQcmVmaXggb2YgZGF0YSBVUklzIGVtaXR0ZWQgYnkgU0lOR0xFX0ZJTEUgYW5kIHJlbGF0ZWQgb3B0aW9ucy5cclxudmFyIGRhdGFVUklQcmVmaXggPSAnZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LCc7XHJcblxyXG4vLyBJbmRpY2F0ZXMgd2hldGhlciBmaWxlbmFtZSBpcyBhIGJhc2U2NCBkYXRhIFVSSS5cclxuZnVuY3Rpb24gaXNEYXRhVVJJKGZpbGVuYW1lKSB7XHJcbiAgcmV0dXJuIFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aCA/XHJcbiAgICAgIGZpbGVuYW1lLnN0YXJ0c1dpdGgoZGF0YVVSSVByZWZpeCkgOlxyXG4gICAgICBmaWxlbmFtZS5pbmRleE9mKGRhdGFVUklQcmVmaXgpID09PSAwO1xyXG59XHJcblxyXG5cclxuXHJcblxyXG5mdW5jdGlvbiBpbnRlZ3JhdGVXYXNtSlMoKSB7XHJcbiAgLy8gd2FzbS5qcyBoYXMgc2V2ZXJhbCBtZXRob2RzIGZvciBjcmVhdGluZyB0aGUgY29tcGlsZWQgY29kZSBtb2R1bGUgaGVyZTpcclxuICAvLyAgKiAnbmF0aXZlLXdhc20nIDogdXNlIG5hdGl2ZSBXZWJBc3NlbWJseSBzdXBwb3J0IGluIHRoZSBicm93c2VyXHJcbiAgLy8gICogJ2ludGVycHJldC1zLWV4cHInOiBsb2FkIHMtZXhwcmVzc2lvbiBjb2RlIGZyb20gYSAud2FzdCBhbmQgaW50ZXJwcmV0XHJcbiAgLy8gICogJ2ludGVycHJldC1iaW5hcnknOiBsb2FkIGJpbmFyeSB3YXNtIGFuZCBpbnRlcnByZXRcclxuICAvLyAgKiAnaW50ZXJwcmV0LWFzbTJ3YXNtJzogbG9hZCBhc20uanMgY29kZSwgdHJhbnNsYXRlIHRvIHdhc20sIGFuZCBpbnRlcnByZXRcclxuICAvLyAgKiAnYXNtanMnOiBubyB3YXNtLCBqdXN0IGxvYWQgdGhlIGFzbS5qcyBjb2RlIGFuZCB1c2UgdGhhdCAoZ29vZCBmb3IgdGVzdGluZylcclxuICAvLyBUaGUgbWV0aG9kIGlzIHNldCBhdCBjb21waWxlIHRpbWUgKEJJTkFSWUVOX01FVEhPRClcclxuICAvLyBUaGUgbWV0aG9kIGNhbiBiZSBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0LCBpbiB3aGljaCBjYXNlLCB3ZSB3aWxsIHRyeSB0aGVcclxuICAvLyBvcHRpb25zIG9uZSBieSBvbmUuIFNvbWUgb2YgdGhlbSBjYW4gZmFpbCBncmFjZWZ1bGx5LCBhbmQgdGhlbiB3ZSBjYW4gdHJ5XHJcbiAgLy8gdGhlIG5leHQuXHJcblxyXG4gIC8vIGlucHV0c1xyXG5cclxuICB2YXIgbWV0aG9kID0gJ25hdGl2ZS13YXNtJztcclxuXHJcbiAgdmFyIHdhc21UZXh0RmlsZSA9ICcnO1xyXG4gIHZhciB3YXNtQmluYXJ5RmlsZSA9ICdkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsQUdGemJRRUFBQUFCY2hKZ0EzOS9md0YvWUFGL0FYOWdBQUYvWUFGL0FHQUNmMzhCZjJBRWYzOS9md0YvWUFKL2Z3QmdBMzkvZndCZ0JIOS9mMzhBWUFOL2YzOEJmbUFBQUdBRmYzOS9mMzhCZjJBRGZuOS9BWDlnQW41L0FYOWdCWDkvZjM5L0FHQUdmM3gvZjM5L0FYOWdBWHdCZm1BQ2ZIOEJmQUtYQlNFRFpXNTJCbTFsYlc5eWVRSUJnQUtBQWdObGJuWUZkR0ZpYkdVQmNBRVFFQU5sYm5ZS2JXVnRiM0o1UW1GelpRTi9BQU5sYm5ZSmRHRmliR1ZDWVhObEEzOEFBMlZ1ZGc1RVdVNUJUVWxEVkU5UVgxQlVVZ04vQUFObGJuWU5kR1Z0Y0VSdmRXSnNaVkIwY2dOL0FBTmxibllGUVVKUFVsUURmd0FEWlc1MkNGTlVRVU5MVkU5UUEzOEFBMlZ1ZGdsVFZFRkRTMTlOUVZnRGZ3QURaVzUyQjJOMGRIcGZhVGdEZndBR1oyeHZZbUZzQTA1aFRnTjhBQVpuYkc5aVlXd0lTVzVtYVc1cGRIa0RmQUFEWlc1MkRXVnViR0Z5WjJWTlpXMXZjbmtBQWdObGJuWU9aMlYwVkc5MFlXeE5aVzF2Y25rQUFnTmxibllYWVdKdmNuUlBia05oYm01dmRFZHliM2ROWlcxdmNua0FBZ05sYm5ZU1lXSnZjblJUZEdGamEwOTJaWEptYkc5M0FBTURaVzUyQzI1MWJHeEdkVzVqWDJscEFBTURaVzUyRFc1MWJHeEdkVzVqWDJscGFXa0FBd05sYm5ZSFgxOWZiRzlqYXdBREEyVnVkZ3RmWDE5elpYUkZjbkpPYndBREEyVnVkZzFmWDE5emVYTmpZV3hzTVRRd0FBUURaVzUyRFY5ZlgzTjVjMk5oYkd3eE5EWUFCQU5sYm5ZTVgxOWZjM2x6WTJGc2JEVTBBQVFEWlc1MkMxOWZYM041YzJOaGJHdzJBQVFEWlc1MkNWOWZYM1Z1Ykc5amF3QURBMlZ1ZGlGZlpXMXpZM0pwY0hSbGJsOW9ZWE5mZEdoeVpXRmthVzVuWDNOMWNIQnZjblFBQWdObGJuWVdYMlZ0YzJOeWFYQjBaVzVmYldWdFkzQjVYMkpwWndBQUEyVnVkaEpmYkd4MmJWOXpkR0ZqYTNKbGMzUnZjbVVBQXdObGJuWVBYMnhzZG0xZmMzUmhZMnR6WVhabEFBSURaVzUyRDE5d2RHaHlaV0ZrWDJOeVpXRjBaUUFGQTJWdWRnMWZjSFJvY21WaFpGOXFiMmx1QUFRRFpXNTJFMTl3ZEdoeVpXRmtYMjExZEdWNFgybHVhWFFBQkFObGJuWUlYM041YzJOdmJtWUFBUU5TVVFFQ0F3WUdBd0lFQXdjRENBY0JDQUFJQ1FRQUNnWUJBd0VBQUFFQ0FRQUVBQXNCQXdjQkJ3d05EUUVBRGdRUEVCRVJBQUlDQWdRRUJBQUVBQUVFQVFRRUFnb0JBUUFLQVFBQUFRRUJCQVVCQUFaeUZIOEJJd0lMZndFakF3dC9BU01FQzM4Qkl3VUxmd0VqQmd0L0FTTUhDMzhCUVFBTGZ3RkJBQXQvQVVFQUMzOEJRUUFMZkFFakNBdDhBU01KQzM4QlFRQUxmd0ZCQUF0L0FVRUFDMzhCUVFBTGZBRkVBQUFBQUFBQUFBQUxmd0ZCQUF0OUFVTUFBQUFBQzMwQlF3QUFBQUFMQjZrQ0ZSRmZYMTlsY25KdWIxOXNiMk5oZEdsdmJnQXhDbDlqWTNWeWJGOXdiM2NBSEFkZlptWnNkWE5vQUZnRlgyWnlaV1VBTEE5ZmJHeDJiVjlpYzNkaGNGOXBNeklBWEFkZmJXRnNiRzlqQUNzSFgyMWxiV053ZVFCZEIxOXRaVzF6WlhRQVhoTmZjSFJvY21WaFpGOXRkWFJsZUY5c2IyTnJBRjhWWDNCMGFISmxZV1JmYlhWMFpYaGZkVzVzYjJOckFHQUZYM05pY21zQVlRcGtlVzVEWVd4c1gybHBBR0lNWkhsdVEyRnNiRjlwYVdscEFHTVRaWE4wWVdKc2FYTm9VM1JoWTJ0VGNHRmpaUUFZQzJkbGRGUmxiWEJTWlhRd0FCc0xjblZ1VUc5emRGTmxkSE1BV3d0elpYUlVaVzF3VW1WME1BQWFDSE5sZEZSb2NtVjNBQmtLYzNSaFkydEJiR3h2WXdBVkRITjBZV05yVW1WemRHOXlaUUFYQ1hOMFlXTnJVMkYyWlFBV0NSWUJBQ01CQ3hCa0xXUmtaQ0prWkdWbExpOHpaV1ZsQ3NiMEFsRW9BUUYvSXcwaEFTTU5JQUJxSkEwakRVRVBha0Z3Y1NRTkl3MGpEazRFUUNBQUVBTUxJQUVQQ3dVQUl3MFBDd1lBSUFBa0RRc0tBQ0FBSkEwZ0FTUU9DeElBSXhCQkFFWUVRQ0FBSkJBZ0FTUVJDd3NHQUNBQUpCc0xCUUFqR3c4THpBRUJHSDhqRFNFWkl3MUJvQVpxSkEwakRTTU9UZ1JBUWFBR0VBTUxJQmxCT0dvaEZTQVpJUllnQUNFTUlBRWhFUkFwUVFBaEVpQU1JUmNnRjBIeEZCQlNJUUlnQWlFVElBd2hBeUFUSVFRZ0F5QUVFQ2NoQlNBRklSUWdGUkFkSUJRaEJpQVZJQVpCNER3UUhpQVVJUWNnQjBIZ1BHb2hDQ0FWSUFoQjh3RVFYUm9nRVNFSklCWWdGU0FKUVg4UUlDQVVJUW9nQ2tIZ1BHb2hDeUFMSUJWQjh3RVFYUm9nRkNFTklBMUJBRUhUUGhBb0lRNGdEaUVTSUJRaER5QVBFQ3dnRWlFUUlCa2tEU0FRRHdzeUFRUi9JdzBoQkNNTlFSQnFKQTBqRFNNT1RnUkFRUkFRQXdzZ0FDRUJJQUVoQWlBQ1FRQkIyUVVRWGhvZ0JDUU5Ed3VzQVFFVmZ5TU5JUmNqRFVFUWFpUU5JdzBqRGs0RVFFRVFFQU1MSUFBaER5QUJJUkFnQWlFUlFRQWhFZ05BQWtBZ0R5RVRJQkFoRkNBU0lSVWdGQ0FWYWlFRElCRWhCQ0FFUWZNQlNDRUZJQkVoQmlBRkJIOGdCZ1ZCOHdFTElRY2dCeUVJSUJNZ0F5QUlFRjBhSUE4aENTQUpFQjhnRWlFS0lBcEI4d0ZxSVFzZ0N5RVNJQkVoRENBTVFmTUJheUVOSUEwaEVTQU5RUUJLSVE0Z0RrVUVRQXdCQ3d3QkN3c2dGeVFORHd2QkFnRWxmeU1OSVNVakRVSHdCV29rRFNNTkl3NU9CRUJCOEFVUUF3c2dKVUVNYWlFZUlBQWhBVUVBSVF3RFFBSkFJQXdoSHlBZlFkRUFTQ0VnSUNCRkJFQU1BUXNnQVNFaElCNGdJVUhaQlJCZEdrRUFJUmNEUUFKQUlCY2hJaUFpUWRrRlNDRWpJQ05GQkVBTUFRc2dGeUVDUVlBSUlBSkJBblJxSVFNZ0F5Z0NBQ0VFSUI0Z0JHb2hCU0FGTEFBQUlRWWdCa0VZZEVFWWRTRUhJQmNoQ0NBSVFRRnFJUWxCZ0FnZ0NVRUNkR29oQ2lBS0tBSUFJUXNnSGlBTGFpRU5JQTBzQUFBaERpQU9RUmgwUVJoMUlROGdEMEVDZENFUUlBY2dFR29oRVNBUlFRVnFJUkpCNkI0Z0VrRUNkR29oRXlBVEtBSUFJUlFnRkVIL0FYRWhGU0FCSVJZZ0Z5RVlJQllnR0dvaEdTQVpJQlU2QUFBZ0Z5RWFJQnBCQVdvaEd5QWJJUmNNQVFzTElBd2hIQ0FjUVFGcUlSMGdIU0VNREFFTEN5QWxKQTBQQzlzR0FWVi9JdzBoV0NNTlFmQzJBV29rRFNNTkl3NU9CRUJCOExZQkVBTUxJRmhCb0xZQmFpRldJRmdoQnlCWVFiaTJBV29oQ1NCWVFhUzJBV29oQ2lBQUlTVWdBU0V3SUFJaE95QURJVVlnT3lFTElBdEJBRWdoRENBN0lRMGdEVUh6QVVvaERpQU1JQTV5SVZVZ0pTRVBJRlVFUUNBUFFRVTJBZ0JCbEI4b0FnQWhFQ0E3SVJFZ1ZpQVJOZ0lBSUJCQmlDTWdWaEJhR2lCWUpBMFBDeUFQUVFFMkFnQWdNQ0VTSUFjZ0VrR2lBUkFoRUEwaEV5QWxJUlFnRkVFRWFpRVZJQlVnRXpZQ0FDQWxJUllnRmtFRWFpRVhJQmNvQWdBaEdDQVlRUUJISVJrZ0dVVUVRQ0FLSUFjMkFnQWdNQ0ZMSUFwQkJHb2hUQ0JNSUVzMkFnQWdPeUZOSUFwQkNHb2hUaUJPSUUwMkFnQWdWQ0ZQSUFwQkRHb2hVQ0JRSUU4MkFnQWdKU0ZTSUFwQkVHb2hVeUJUSUZJMkFnQWdDaEFpR2lCWUpBMFBDeUJHSVJvZ0drRUFUQ0ViSUJzRVFFSFVBQkFVSVJ3Z0hFRUJheUVkSUIwaFJpQkdJUjRnSGtFQlNDRWZJQjhFZjBFQkJTQWRDeUVFSUFRaFJnc2dKU0VnSUNCQkNHb2hJU0FoUVFBUUV4b2dSaUVpRUJBaEl5QWpJUWdnSWtFQ2RDRUZJdzBoSkNNTlFRRWdCV3hCRDJwQmNIRnFKQTBqRFNNT1RnUkFRUUVnQld4QkQycEJjSEVRQXdzZ1JpRW1JQ1pCRkd3aEJpTU5JU2NqRFVFQklBWnNRUTlxUVhCeGFpUU5JdzBqRGs0RVFFRUJJQVpzUVE5cVFYQnhFQU1MUVFBaFZBTkFBa0FnVkNFb0lFWWhLU0FvSUNsSUlTb2dLa1VFUUF3QkN5QlVJU3NnSnlBclFSUnNhaUVzSUFrZ0J6WUNBQ0FKUVFScUlTMGdNQ0V1SUMwZ0xqWUNBQ0FKUVFocUlTOGdPeUV4SUM4Z01UWUNBQ0FKUVF4cUlUSWdWQ0V6SURJZ016WUNBQ0FKUVJCcUlUUWdKU0UxSURRZ05UWUNBQ0FzSUFrcEFnQTNBZ0FnTEVFSWFpQUpRUWhxS1FJQU53SUFJQ3hCRUdvZ0NVRVFhaWdDQURZQ0FDQlVJVFlnSkNBMlFRSjBhaUUzSUZRaE9DQW5JRGhCRkd4cUlUa2dOMEVBUVFVZ09SQVJHaUJVSVRvZ09rRUJhaUU4SUR3aFZBd0JDd3RCQUNGUkEwQUNRQ0JSSVQwZ1ZDRStJRDBnUGtnaFB5QS9SUVJBREFFTElGRWhRQ0FrSUVCQkFuUnFJVUVnUVNnQ0FDRkNJRUpCQUVjaFF5QkRCRUFnVVNGRUlDUWdSRUVDZEdvaFJTQkZLQUlBSVVjZ1IwRUFFQklhQ3lCUklVZ2dTRUVCYWlGSklFa2hVUXdCQ3dzZ0NDRktJRW9RRHlCWUpBMFBDNjRGQWtkL0FYNGpEU0ZKSXcxQkVHb2tEU01OSXc1T0JFQkJFQkFEQ3lBQUlSZ2dBU0VqSUFJaExrRUFJVGtEUUFKQUlEa2hSQ0JFUWRrRlNDRkdJRVpGQkVBTUFRc2dJeUZISURraEJDQkhJQVJxSVFVZ0JTd0FBQ0VHSUFaQkdIUkJHSFVoQndKQUFrQUNRQUpBSUFkQkFHc09BZ0FCQWdzQ1FDQVlJUWdnT1NFSklBZ2dDVUVEZEdvaENpQUtRbjgzQXdBZ0dDRUxJQXRCeUMxcUlRd2dPU0VOSUF3Z0RVRURkR29oRGtKL0lVb2dEaUVEREFNQUN3QUxBa0FnR0NFUElEa2hFQ0FQSUJCQkEzUnFJUkVnRVVJQU53TUFJQmdoRWlBU1FjZ3RhaUVUSURraEZDQVRJQlJCQTNScUlSVkNmeUZLSUJVaEF3d0NBQXNBQ3dKQUlCZ2hGaUE1SVJjZ0ZpQVhRUU4wYWlFWklCbENmemNEQUNBWUlSb2dHa0hJTFdvaEd5QTVJUndnR3lBY1FRTjBhaUVkUWdBaFNpQWRJUU1MQ3lBRElFbzNBd0FnT1NFZUlCNUJBV29oSHlBZklUa01BUXNMSUJnaElDQXVJU0VnSUNBaFFRTjBhaUVpSUNKQzdiYmI3YmJiN2JaYk53TUFJQmdoSkNBa1FjZ3RhaUVsSUM0aEppQWxJQ1pCQTNScUlTY2dKMExiN2JiYjdiYmI3YlovTndNQUlCZ2hLQ0F1SVNrZ0tVRUJhaUVxSUNnZ0trRURkR29oS3lBclFzZWYvdmpqajcvOGNUY0RBQ0FZSVN3Z0xFSElMV29oTFNBdUlTOGdMMEVCYWlFd0lDMGdNRUVEZEdvaE1TQXhRci84OGNlZi92ampqMzgzQXdBZ0dDRXlJQzRoTXlBelFRSnFJVFFnTWlBMFFRTjBhaUUxSURWQy80UHcvLytCK1AvL0FEY0RBQ0FZSVRZZ05rSElMV29oTnlBdUlUZ2dPRUVDYWlFNklEY2dPa0VEZEdvaE95QTdRdi8vajhELy80ZGdOd01BSUJnaFBDQXVJVDBnUFVFRGFpRStJRHdnUGtFRGRHb2hQeUEvUXYvLy83K0FnSUJnTndNQUlCZ2hRQ0JBUWNndGFpRkJJQzRoUWlCQ1FRTnFJVU1nUVNCRFFRTjBhaUZGSUVWQy8vLy8vLy8vL3g4M0F3QWdTU1FORHd2ckJnSlNmd3grSXcwaFVpTU5RZUNSQW1va0RTTU5JdzVPQkVCQjRKRUNFQU1MSUZKQitPTUJhaUVvSUZKQnNMWUJhaUV6SUZKQjJJZ0JhaUVESUZKQmtOc0FhaUVFSUZKQnlDMXFJUVVnVWlFR0lBQWhDeUFMSVFnZ0NDRVdJQlloQ1NBSlFSQnFJUW9nQ2lnQ0FDRU1JQXdoSVNBV0lRMGdEVUVFYWlFT0lBNG9BZ0FoRHlBUElRSWdLRUVBUWNndEVGNGFJRE5CQUVISUxSQmVHaUFXSVJBZ0VDZ0NBQ0VSSUNnZ0VVSElMUkJkR2lBV0lSSWdFaWdDQUNFVElCTkJ5QzFxSVJRZ015QVVRY2d0RUYwYUlCWWhGU0FWUVF4cUlSY2dGeWdDQUNFWUlCZ2hPd05BQWtBZ095RVpJQmxCZjJvaEdpQWFJVHNnR1VFQVNpRWJJQnRGQkVBTUFRc2dLQ0F6UWFZQlFjRUJFQ01NQVFzTElBVkJBRUhJTFJCZUdpQUdRUUJCeUMwUVhob2dBMEVBUWNndEVGNGFJQVJCQUVISUxSQmVHa0VBSVFjRFFBSkFJQlloSENBaElSMGdIQ0FkUVFFUUpDRWVJQjVCR0hSQkdIVkJBRWNoSHlBZlJRUkFRUkloVVF3QkN5QW9JRE5Cd1FGQjh3RVFJeUFGSUNoQnlDMFFYUm9nQmlBelFjZ3RFRjBhSUFVZ0JpQURJQVFRSlNBV0lTQWdJRUVJYWlFaUlDSW9BZ0FoSXlBRklBWWdJeEFtSVZRZ1ZDRmVJRlJDQUZFaEpDQWtSUVJBREFFTERBRUxDeUJSUVJKR0JFQkJBQ0VCSUFFaFVDQlNKQTBnVUE4TElGNGhWU0JWZWlGV0lGYW5JU1VnSlNGRElFTWhKa0VCSUNaMElTY2dKNndoVnlCWElWTWdJU0VwSUNsQkJHb2hLaUFxS0FJQUlTc2dLMEVBUnlFc0lDd0VRQ0FXSVMwZ0xVRVFhaUV1SUM0b0FnQWhMeUF2UVFocUlUQWdNQkJmR2dzZ0lTRXhJREVvQWdBaE1pQXlRUU5ISVRRQ1FDQTBCRUFnSVNFMUlEVkJBellDQUVFQUlUc0RRQ0E3SVRZZ05rSHpBVWdoTnlBM1JRUkFEQU1MSURzaE9DQW9JRGhCQTNScUlUa2dPU2tEQUNGWUlGTWhXU0JZSUZtRElWb2dXa0lBVVNFNklEb0VRRUVCSVVFRklEc2hQQ0F6SUR4QkEzUnFJVDBnUFNrREFDRmJJRk1oWENCYklGeURJVjBnWFVJQVVTRStJRDRFZjBGL0JVRUFDeUUvSUQ4aFFRc2dRVUgvQVhFaFFDQUNJVUlnT3lGRUlFSWdSR29oUlNCRklFQTZBQUFnT3lGR0lFWkJBV29oUnlCSElUc01BQXNBQ3dzZ0lTRklJRWhCQkdvaFNTQkpLQUlBSVVvZ1NrRUFSeUZMSUVzRVFDQVdJVXdnVEVFUWFpRk5JRTBvQWdBaFRpQk9RUWhxSVU4Z1R4QmdHZ3RCQUNFQklBRWhVQ0JTSkEwZ1VBOExuQUlDRzM4T2ZpTU5JUjRqRFVFd2FpUU5JdzBqRGs0RVFFRXdFQU1MSUFBaEZpQUJJUmtnQWlFYUlBTWhHMElCSVN3Z0dpRUVJQVFoSEFOQUFrQWdIQ0VGSUJzaEJpQUZJQVpKSVFjZ0xDRWhJQ0ZDQUZJaENDQUhCSDhnQ0FWQkFBc2hDU0FKUlFSQURBRUxJQlloQ2lBY0lRc2dDaUFMUVFOMGFpRU1JQXdwQXdBaElpQWlJUjhnR1NFTklCd2hEaUFOSUE1QkEzUnFJUThnRHlrREFDRWpJQ01oSUNBZ0lTUWdIeUVsSUNRZ0pZVWhKaUFXSVJBZ0hDRVJJQkFnRVVFRGRHb2hFaUFTSUNZM0F3QWdIeUVuSUJraEV5QWNJUlFnRXlBVVFRTjBhaUVWSUJVZ0p6Y0RBQ0FnSVNnZ0h5RXBJQ2xDZjRVaEtpQW9JQ3FESVNzZ0t5RXNJQndoRnlBWFFRRnFJUmdnR0NFY0RBRUxDeUFlSkEwUEMvWUJBU0YvSXcwaEl5TU5RUkJxSkEwakRTTU9UZ1JBUVJBUUF3c2dBQ0VjSUFFaEhTQUNJUjRnSFNFZ0lDQkJCR29oSVNBaEtBSUFJUU1nQTBFQVJ5RUVJQVFFUUNBY0lRVWdCVUVRYWlFR0lBWW9BZ0FoQnlBSFFRaHFJUWdnQ0JCZkdpQWRJUWtnQ1NnQ0FDRUtJQjRoQ3lBS0lBdEdJUXdnREVFQmNTRU5JQTFCL3dGeElRNGdEaUVmSUJ3aER5QVBRUkJxSVJBZ0VDZ0NBQ0VSSUJGQkNHb2hFaUFTRUdBYUlCOGhFeUFUSVJjZ0Z5RWJJQ01rRFNBYkR3VWdIU0VVSUJRb0FnQWhGU0FlSVJZZ0ZTQVdSaUVZSUJoQkFYRWhHU0FaUWY4QmNTRWFJQm9oRnlBWElSc2dJeVFOSUJzUEN3QkJBQThMekFNQ0tuOFdmaU1OSVMwakRVSEFBR29rRFNNTkl3NU9CRUJCd0FBUUF3c2dBQ0ViSUFFaEh5QUNJU01nQXlFcFFRQWhLa0hSQUNFckEwQUNRQ0FySVFVZ0JVRi9haUVHSUFZaEt5QUZRUUJLSVFjZ0IwVUVRQXdCQ3lBaklRZ2dHeUVKSUFnZ0NVSElMUkJkR2lBcElRb2dIeUVMSUFvZ0MwSElMUkJkR2tFQUlRUURRQ0FFSVF3Z0RFSFpCVWdoRFNBTlJRUkFEQU1MSUNNaERpQXFJUThnRGlBUFFRTjBhaUVRSUJBcEF3QWhNaUF5SVM0Z0tTRVJJQ29oRWlBUklCSkJBM1JxSVJNZ0V5a0RBQ0V6SURNaEx5QXBJUlFnS2lFVklCVkI3UUpJSVJZZ0ZnUi9RZXdDQlVHVGZRc2hGeUFxSVJnZ0dDQVhhaUVaSUJraEtpQVVJQmxCQTNScUlSb2dHaWtEQUNFMElEUWhNQ0F1SVRVZ01DRTJJRFpDZjRVaE55QTFJRGVFSVRnZ0l5RWNJQ29oSFNBY0lCMUJBM1JxSVI0Z0hpa0RBQ0U1SUM4aE9pQTVJRHFGSVRzZ09DQTdneUU4SUR3aE1TQXhJVDBnUFVKL2hTRStJQnNoSUNBRUlTRWdJQ0FoUVFOMGFpRWlJQ0lnUGpjREFDQXVJVDhnTUNGQUlEOGdRSVVoUVNBeElVSWdRU0JDaENGRElCOGhKQ0FFSVNVZ0pDQWxRUU4wYWlFbUlDWWdRemNEQUNBRUlTY2dKMEVCYWlFb0lDZ2hCQXdBQ3dBTUFRc0xJQzBrRFE4TGlnSUNFMzhMZmlNTklSVWpEVUVnYWlRTkl3MGpEazRFUUVFZ0VBTUxJQUFoRHlBQklSQWdBaUVSUW44aElDQVJJUk1nRXlFU0EwQUNRQ0FTSVFNZ0EwRi9haUVFSUFRaEVpQURRUUJLSVFVZ0JVVUVRRUVGSVJRTUFRc2dEeUVHSUJJaEIwSHlBU0FIYXlFSUlBWWdDRUVEZEdvaENTQUpLUU1BSVJZZ0VDRUtJQkloQzBIeUFTQUxheUVNSUFvZ0RFRURkR29oRFNBTktRTUFJUmNnRmlBWGhTRVlJQmhDZjRVaEdTQWdJUm9nR2lBWmd5RWJJQnNoSUNBZ0lSd2dIRUlBVVNFT0lBNEVRRUVFSVJRTUFRc01BUXNMSUJSQkJFWUVRRUlBSVI0Z0hpRWZJQlVrRFNBZkR3VWdGRUVGUmdSQUlDQWhIU0FkSVI0Z0hpRWZJQlVrRFNBZkR3c0xRZ0FQQytvQkFSMS9JdzBoSGlNTlFSQnFKQTBqRFNNT1RnUkFRUkFRQXdzZ0FDRU1JQUVoRmlBV0lSa2dHVUVEYkNFYUlCb2hHeUFiRUNzaEhDQWNJUmhCQUNFWEEwQUNRQ0FYSVFJZ0ZpRURJQUlnQTBnaEJDQVlJUVVnQkVVRVFBd0JDeUFYSVFZZ0JrRURiQ0VISUFVZ0Iyb2hDQ0FNSVFrZ0Z5RUtJQWtnQ21vaEN5QUxMQUFBSVEwZ0RVRVlkRUVZZFNFT1FhWWpJQTRRVkNFUElBOGhFRUdtSXlFUklCQWdFV3NoRWtHN3hBQWdFa0VEYkdvaEV5QUlJQk11QUFBN0FBQWdDRUVDYWlBVFFRSnFMQUFBT2dBQUlCY2hGQ0FVUVFGcUlSVWdGU0VYREFFTEN5QWVKQTBnQlE4TDdRTUJSMzhqRFNGSkl3MUJJR29rRFNNTkl3NU9CRUJCSUJBREN5QUFJUmNnQVNFaUlBSWhMU0F0SVFNZ0EwRURhaUVFSUFSQkFXc2hCU0FGUVFOdFFYOXhJUVlnQmlGRElFTWhCeUFIUVFGcUlRZ2dDQ0VKSUFrUUt5RUtJQW9oUmlCR0lRc2dReUVNSUFzZ0RHb2hEU0FOUVFBNkFBQkJBQ0U0QTBBQ1FDQTRJUTRnUXlFUElBNGdEMGdoRUNBUVJRUkFEQUVMSUJjaEVTQWlJUklnT0NFVElCTkJBMndoRkNBU0lCUnFJUlVnRVNBVmFpRVdJQllzQUFBaEdDQVlRUmgwUVJoMUlSa2dGeUVhSUNJaEd5QTRJUndnSEVFRGJDRWRJQnNnSFdvaEhpQWVRUUZxSVI4Z0dpQWZhaUVnSUNBc0FBQWhJU0FoUVJoMFFSaDFJU01nSTBFRGJDRWtJQmtnSkdvaEpTQVhJU1lnSWlFbklEZ2hLQ0FvUVFOc0lTa2dKeUFwYWlFcUlDcEJBbW9oS3lBbUlDdHFJU3dnTEN3QUFDRXVJQzVCR0hSQkdIVWhMeUF2UVFsc0lUQWdKU0F3YWlFeElERkIvd0Z4SVRJZ01pRkhJRWNoTXlBelFSaDBRUmgxSVRRZ05FRUFTQ0UxSURVRVFDQkhJVFlnTmtFWWRFRVlkU0UzSURkQkcyb2hPU0E1UWY4QmNTRTZJRG9oUndzZ1J5RTdJRHRCR0hSQkdIVWhQRUdtSXlBOGFpRTlJRDBzQUFBaFBpQkdJVDhnT0NGQUlEOGdRR29oUVNCQklENDZBQUFnT0NGQ0lFSkJBV29oUkNCRUlUZ01BUXNMSUVZaFJTQkpKQTBnUlE4TDlBRUJFSDhqRFNFUEl3MUJFR29rRFNNTkl3NU9CRUJCRUJBREN5QVBRUVJxSVFFZ0FVRUFOZ0FBSUFGQkJHcEJBRG9BQUVFQUlRQURRQUpBSUFBaEJpQUdRZk1CU0NFSElBZEZCRUFNQVFzZ0FDRUlRZnc2SUFoQkJXeHFJUWtnQ1NBQktBQUFOZ0FBSUFsQkJHb2dBVUVFYWl3QUFEb0FBQ0FCUVFVUUtpQUFJUW9nQ2tFQmFpRUxJQXNoQUF3QkN3dEJBQ0VBQTBBQ1FDQUFJUXdnREVFYlNDRU5JQTFGQkVBTUFRc2dBQ0VDUWJ2RUFDQUNRUU5zYWlFRElBTWdBUzRBQURzQUFDQURRUUpxSUFGQkFtb3NBQUE2QUFBZ0FVRURFQ29nQUNFRUlBUkJBV29oQlNBRklRQU1BUXNMSUE4a0RROEx3d0VCRkg4akRTRVZJdzFCRUdva0RTTU5JdzVPQkVCQkVCQURDeUFBSVF3Z0FTRU5RUUFoRGdOQUFrQWdEaUVQSUEwaEVDQVBJQkJJSVJFZ0VVVUVRRUVGSVJRTUFRc2dEQ0VTSUE0aEV5QVNJQk5xSVFJZ0Fpd0FBQ0VESUFOQkFXcEJHSFJCR0hVaEJDQUNJQVE2QUFBZ0JFRVlkRUVZZFNFRklBVkJBVW9oQmlBR1JRUkFRUVVoRkF3QkN5QU1JUWNnRGlFSUlBY2dDR29oQ1NBSlFYODZBQUFnRGlFS0lBcEJBV29oQ3lBTElRNE1BUXNMSUJSQkJVWUVRQ0FWSkEwUEN3dXRiZ0d6Q0g4akRTR3pDQ01OUVJCcUpBMGpEU01PVGdSQVFSQVFBd3Nnc3dnaFZTQUFRZlVCU1NIRUFRSkFJTVFCQkVBZ0FFRUxTU0d6QWlBQVFRdHFJYUlESUtJRFFYaHhJWkVFSUxNQ0JIOUJFQVVna1FRTElZQUZJSUFGUVFOMkllOEZRYncyS0FJQUlkNEdJTjRHSU84RmRpSE5CeUROQjBFRGNTRldJRlpCQUVZaFlTQmhSUVJBSU0wSFFRRnhJV3dnYkVFQmN5RjNJSGNnN3dWcUlZSUJJSUlCUVFGMElZMEJRZVEySUkwQlFRSjBhaUdZQVNDWUFVRUlhaUdqQVNDakFTZ0NBQ0d1QVNDdUFVRUlhaUc1QVNDNUFTZ0NBQ0hGQVNERkFTQ1lBVVloMEFFZzBBRUVRRUVCSUlJQmRDSGJBU0RiQVVGL2N5SG1BU0RlQmlEbUFYRWg4UUZCdkRZZzhRRTJBZ0FGSU1VQlFReHFJZndCSVB3QklKZ0JOZ0lBSUtNQklNVUJOZ0lBQ3lDQ0FVRURkQ0dIQWlDSEFrRURjaUdTQWlDdUFVRUVhaUdkQWlDZEFpQ1NBallDQUNDdUFTQ0hBbW9ocUFJZ3FBSkJCR29odEFJZ3RBSW9BZ0FodndJZ3Z3SkJBWEloeWdJZ3RBSWd5Z0kyQWdBZ3VRRWhCaUN6Q0NRTklBWVBDMEhFTmlnQ0FDSFZBaUNBQlNEVkFrc2g0QUlnNEFJRVFDRE5CMEVBUmlIckFpRHJBa1VFUUNETkJ5RHZCWFFoOWdKQkFpRHZCWFFoZ1FOQkFDQ0JBMnNoakFNZ2dRTWdqQU55SVpjRElQWUNJSmNEY1NHakEwRUFJS01EYXlHdUF5Q2pBeUN1QTNFaHVRTWd1UU5CZjJvaHhBTWd4QU5CREhZaHp3TWd6d05CRUhFaDJnTWd4QU1nMmdOMkllVURJT1VEUVFWMklmQURJUEFEUVFoeElmc0RJUHNESU5vRGNpR0dCQ0RsQXlEN0EzWWhrZ1Fna2dSQkFuWWhuUVFnblFSQkJIRWhxQVFnaGdRZ3FBUnlJYk1FSUpJRUlLZ0VkaUcrQkNDK0JFRUJkaUhKQkNESkJFRUNjU0hVQkNDekJDRFVCSEloM3dRZ3ZnUWcxQVIySWVvRUlPb0VRUUYySWZVRUlQVUVRUUZ4SVlFRklOOEVJSUVGY2lHTUJTRHFCQ0NCQlhZaGx3VWdqQVVnbHdWcUlhSUZJS0lGUVFGMElhMEZRZVEySUswRlFRSjBhaUc0QlNDNEJVRUlhaUhEQlNEREJTZ0NBQ0hPQlNET0JVRUlhaUhaQlNEWkJTZ0NBQ0hrQlNEa0JTQzRCVVloOEFVZzhBVUVRRUVCSUtJRmRDSDdCU0Q3QlVGL2N5R0dCaURlQmlDR0JuRWhrUVpCdkRZZ2tRWTJBZ0Fna1FZaHpnY0ZJT1FGUVF4cUlad0dJSndHSUxnRk5nSUFJTU1GSU9RRk5nSUFJTjRHSWM0SEN5Q2lCVUVEZENHbkJpQ25CaUNBQldzaHNnWWdnQVZCQTNJaHZRWWd6Z1ZCQkdvaHlBWWd5QVlndlFZMkFnQWd6Z1VnZ0FWcUlkTUdJTElHUVFGeUlkOEdJTk1HUVFScUllb0dJT29HSU44R05nSUFJTTRGSUtjR2FpSDFCaUQxQmlDeUJqWUNBQ0RWQWtFQVJpR0FCeUNBQjBVRVFFSFFOaWdDQUNHTEJ5RFZBa0VEZGlHV0J5Q1dCMEVCZENHaEIwSGtOaUNoQjBFQ2RHb2hyQWRCQVNDV0IzUWh0d2NnemdjZ3R3ZHhJY0lISU1JSFFRQkdJZGtISU5rSEJFQWd6Z2NndHdkeUllUUhRYncySU9RSE5nSUFJS3dIUVFocUlVUWdyQWNoRUNCRUlVNEZJS3dIUVFocUllOEhJTzhIS0FJQUlmb0hJUG9ISVJBZzd3Y2hUZ3NnVGlDTEJ6WUNBQ0FRUVF4cUlZVUlJSVVJSUlzSE5nSUFJSXNIUVFocUlaQUlJSkFJSUJBMkFnQWdpd2RCREdvaG13Z2dtd2dnckFjMkFnQUxRY1EySUxJR05nSUFRZEEySU5NR05nSUFJTmtGSVFZZ3N3Z2tEU0FHRHd0QndEWW9BZ0FobmdnZ25naEJBRVlobndnZ253Z0VRQ0NBQlNFUEJVRUFJSjRJYXlGWElKNElJRmR4SVZnZ1dFRi9haUZaSUZsQkRIWWhXaUJhUVJCeElWc2dXU0JiZGlGY0lGeEJCWFloWFNCZFFRaHhJVjRnWGlCYmNpRmZJRndnWG5ZaFlDQmdRUUoySVdJZ1lrRUVjU0ZqSUY4Z1kzSWhaQ0JnSUdOMklXVWdaVUVCZGlGbUlHWkJBbkVoWnlCa0lHZHlJV2dnWlNCbmRpRnBJR2xCQVhZaGFpQnFRUUZ4SVdzZ2FDQnJjaUZ0SUdrZ2EzWWhiaUJ0SUc1cUlXOUI3RGdnYjBFQ2RHb2hjQ0J3S0FJQUlYRWdjVUVFYWlGeUlISW9BZ0FoY3lCelFYaHhJWFFnZENDQUJXc2hkU0J4UVJCcUlYWWdkaWdDQUNGNElIaEJBRVloZVNCNVFRRnhJVkVnY1VFUWFpQlJRUUowYWlGNklIb29BZ0FoZXlCN1FRQkdJWHdnZkFSQUlIRWhDeUIxSVEwRklIRWhEQ0IxSVE0Z2V5RitBMEFDUUNCK1FRUnFJWDBnZlNnQ0FDRi9JSDlCZUhFaGdBRWdnQUVnZ0FWcklZRUJJSUVCSUE1SklZTUJJSU1CQkg4Z2dRRUZJQTRMSVFJZ2d3RUVmeUIrQlNBTUN5RUJJSDVCRUdvaGhBRWdoQUVvQWdBaGhRRWdoUUZCQUVZaGhnRWdoZ0ZCQVhFaFR5QitRUkJxSUU5QkFuUnFJWWNCSUljQktBSUFJWWdCSUlnQlFRQkdJWWtCSUlrQkJFQWdBU0VMSUFJaERRd0JCU0FCSVF3Z0FpRU9JSWdCSVg0TERBRUxDd3NnQ3lDQUJXb2hpZ0VnaWdFZ0Mwc2hpd0VnaXdFRVFDQUxRUmhxSVl3QklJd0JLQUlBSVk0QklBdEJER29oandFZ2p3RW9BZ0Foa0FFZ2tBRWdDMFloa1FFQ1FDQ1JBUVJBSUF0QkZHb2hsZ0VnbGdFb0FnQWhsd0VnbHdGQkFFWWhtUUVnbVFFRVFDQUxRUkJxSVpvQklKb0JLQUlBSVpzQklKc0JRUUJHSVp3QklKd0JCRUJCQUNFMERBTUZJSnNCSVNZZ21nRWhKd3NGSUpjQklTWWdsZ0VoSndzRFFBSkFJQ1pCRkdvaG5RRWduUUVvQWdBaG5nRWduZ0ZCQUVZaG53RWdud0ZGQkVBZ25nRWhKaUNkQVNFbkRBSUxJQ1pCRUdvaG9BRWdvQUVvQWdBaG9RRWdvUUZCQUVZaG9nRWdvZ0VFUUF3QkJTQ2hBU0VtSUtBQklTY0xEQUVMQ3lBblFRQTJBZ0FnSmlFMEJTQUxRUWhxSVpJQklKSUJLQUlBSVpNQklKTUJRUXhxSVpRQklKUUJJSkFCTmdJQUlKQUJRUWhxSVpVQklKVUJJSk1CTmdJQUlKQUJJVFFMQ3lDT0FVRUFSaUdrQVFKQUlLUUJSUVJBSUF0QkhHb2hwUUVncFFFb0FnQWhwZ0ZCN0RnZ3BnRkJBblJxSWFjQklLY0JLQUlBSWFnQklBc2dxQUZHSWFrQklLa0JCRUFncHdFZ05EWUNBQ0EwUVFCR0lhQUlJS0FJQkVCQkFTQ21BWFFocWdFZ3FnRkJmM01ocXdFZ25nZ2dxd0Z4SWF3QlFjQTJJS3dCTmdJQURBTUxCU0NPQVVFUWFpR3RBU0N0QVNnQ0FDR3ZBU0N2QVNBTFJ5R3dBU0N3QVVFQmNTRlNJSTRCUVJCcUlGSkJBblJxSWJFQklMRUJJRFEyQWdBZ05FRUFSaUd5QVNDeUFRUkFEQU1MQ3lBMFFSaHFJYk1CSUxNQklJNEJOZ0lBSUF0QkVHb2h0QUVndEFFb0FnQWh0UUVndFFGQkFFWWh0Z0VndGdGRkJFQWdORUVRYWlHM0FTQzNBU0MxQVRZQ0FDQzFBVUVZYWlHNEFTQzRBU0EwTmdJQUN5QUxRUlJxSWJvQklMb0JLQUlBSWJzQklMc0JRUUJHSWJ3QklMd0JSUVJBSURSQkZHb2h2UUVndlFFZ3V3RTJBZ0FndXdGQkdHb2h2Z0VndmdFZ05EWUNBQXNMQ3lBTlFSQkpJYjhCSUw4QkJFQWdEU0NBQldvaHdBRWd3QUZCQTNJaHdRRWdDMEVFYWlIQ0FTRENBU0RCQVRZQ0FDQUxJTUFCYWlIREFTRERBVUVFYWlIR0FTREdBU2dDQUNISEFTREhBVUVCY2lISUFTREdBU0RJQVRZQ0FBVWdnQVZCQTNJaHlRRWdDMEVFYWlIS0FTREtBU0RKQVRZQ0FDQU5RUUZ5SWNzQklJb0JRUVJxSWN3QklNd0JJTXNCTmdJQUlJb0JJQTFxSWMwQklNMEJJQTAyQWdBZzFRSkJBRVloemdFZ3pnRkZCRUJCMERZb0FnQWh6d0VnMVFKQkEzWWgwUUVnMFFGQkFYUWgwZ0ZCNURZZzBnRkJBblJxSWRNQlFRRWcwUUYwSWRRQklONEdJTlFCY1NIVkFTRFZBVUVBUmlIV0FTRFdBUVJBSU40R0lOUUJjaUhYQVVHOE5pRFhBVFlDQUNEVEFVRUlhaUZGSU5NQklRY2dSU0ZOQlNEVEFVRUlhaUhZQVNEWUFTZ0NBQ0haQVNEWkFTRUhJTmdCSVUwTElFMGd6d0UyQWdBZ0IwRU1haUhhQVNEYUFTRFBBVFlDQUNEUEFVRUlhaUhjQVNEY0FTQUhOZ0lBSU04QlFReHFJZDBCSU4wQklOTUJOZ0lBQzBIRU5pQU5OZ0lBUWRBMklJb0JOZ0lBQ3lBTFFRaHFJZDRCSU40QklRWWdzd2drRFNBR0R3VWdnQVVoRHdzTEJTQ0FCU0VQQ3dVZ0FFRy9mMHNoM3dFZzN3RUVRRUYvSVE4RklBQkJDMm9oNEFFZzRBRkJlSEVoNFFGQndEWW9BZ0FoNGdFZzRnRkJBRVloNHdFZzR3RUVRQ0RoQVNFUEJVRUFJT0VCYXlIa0FTRGdBVUVJZGlIbEFTRGxBVUVBUmlIbkFTRG5BUVJBUVFBaElBVWc0UUZCLy8vL0Iwc2g2QUVnNkFFRVFFRWZJU0FGSU9VQlFZRCtQMm9oNlFFZzZRRkJFSFloNmdFZzZnRkJDSEVoNndFZzVRRWc2d0YwSWV3QklPd0JRWURnSDJvaDdRRWc3UUZCRUhZaDdnRWc3Z0ZCQkhFaDd3RWc3d0VnNndGeUlmQUJJT3dCSU84QmRDSHlBU0R5QVVHQWdBOXFJZk1CSVBNQlFSQjJJZlFCSVBRQlFRSnhJZlVCSVBBQklQVUJjaUgyQVVFT0lQWUJheUgzQVNEeUFTRDFBWFFoK0FFZytBRkJEM1loK1FFZzl3RWcrUUZxSWZvQklQb0JRUUYwSWZzQklQb0JRUWRxSWYwQklPRUJJUDBCZGlIK0FTRCtBVUVCY1NIL0FTRC9BU0Q3QVhJaGdBSWdnQUloSUFzTFFldzRJQ0JCQW5ScUlZRUNJSUVDS0FJQUlZSUNJSUlDUVFCR0lZTUNBa0FnZ3dJRVFFRUFJVE5CQUNFMklPUUJJVGRCT1NHeUNBVWdJRUVmUmlHRUFpQWdRUUYySVlVQ1FSa2doUUpySVlZQ0lJUUNCSDlCQUFVZ2hnSUxJWWdDSU9FQklJZ0NkQ0dKQWtFQUlSc2c1QUVoSGlDQ0FpRWZJSWtDSVNKQkFDRWtBMEFDUUNBZlFRUnFJWW9DSUlvQ0tBSUFJWXNDSUlzQ1FYaHhJWXdDSUl3Q0lPRUJheUdOQWlDTkFpQWVTU0dPQWlDT0FnUkFJSTBDUVFCR0lZOENJSThDQkVCQkFDRTlJQjhoUUNBZklVRkJQU0d5Q0F3RkJTQWZJU3NnalFJaExBc0ZJQnNoS3lBZUlTd0xJQjlCRkdvaGtBSWdrQUlvQWdBaGtRSWdJa0VmZGlHVEFpQWZRUkJxSUpNQ1FRSjBhaUdVQWlDVUFpZ0NBQ0dWQWlDUkFrRUFSaUdXQWlDUkFpQ1ZBa1lobHdJZ2xnSWdsd0p5SWFnSUlLZ0lCSDhnSkFVZ2tRSUxJUzBnbFFKQkFFWWhtQUlnbUFKQkFYTWhwQWdncEFoQkFYRWhtUUlnSWlDWkFuUWhJU0NZQWdSQUlDMGhNeUFySVRZZ0xDRTNRVGtoc2dnTUFRVWdLeUViSUN3aEhpQ1ZBaUVmSUNFaElpQXRJU1FMREFFTEN3c0xJTElJUVRsR0JFQWdNMEVBUmlHYUFpQTJRUUJHSVpzQ0lKb0NJSnNDY1NHbUNDQ21DQVJBUVFJZ0lIUWhuQUpCQUNDY0Ftc2huZ0lnbkFJZ25nSnlJWjhDSU9JQklKOENjU0dnQWlDZ0FrRUFSaUdoQWlDaEFnUkFJT0VCSVE4TUJndEJBQ0NnQW1zaG9nSWdvQUlnb2dKeElhTUNJS01DUVg5cUlhUUNJS1FDUVF4MklhVUNJS1VDUVJCeElhWUNJS1FDSUtZQ2RpR25BaUNuQWtFRmRpR3BBaUNwQWtFSWNTR3FBaUNxQWlDbUFuSWhxd0lncHdJZ3FnSjJJYXdDSUt3Q1FRSjJJYTBDSUswQ1FRUnhJYTRDSUtzQ0lLNENjaUd2QWlDc0FpQ3VBblloc0FJZ3NBSkJBWFloc1FJZ3NRSkJBbkVoc2dJZ3J3SWdzZ0p5SWJVQ0lMQUNJTElDZGlHMkFpQzJBa0VCZGlHM0FpQzNBa0VCY1NHNEFpQzFBaUM0QW5JaHVRSWd0Z0lndUFKMklib0NJTGtDSUxvQ2FpRzdBa0hzT0NDN0FrRUNkR29odkFJZ3ZBSW9BZ0FodlFKQkFDRTZJTDBDSVQ4RklEWWhPaUF6SVQ4TElEOUJBRVlodmdJZ3ZnSUVRQ0E2SVRrZ055RThCU0EzSVQwZ1B5RkFJRG9oUVVFOUliSUlDd3Nnc2doQlBVWUVRQU5BQWtCQkFDR3lDQ0JBUVFScUljQUNJTUFDS0FJQUljRUNJTUVDUVhoeEljSUNJTUlDSU9FQmF5SERBaUREQWlBOVNTSEVBaURFQWdSL0lNTUNCU0E5Q3lFRUlNUUNCSDhnUUFVZ1FRc2hQaUJBUVJCcUljVUNJTVVDS0FJQUljWUNJTVlDUVFCR0ljY0NJTWNDUVFGeElWTWdRRUVRYWlCVFFRSjBhaUhJQWlESUFpZ0NBQ0hKQWlESkFrRUFSaUhMQWlETEFnUkFJRDRoT1NBRUlUd01BUVVnQkNFOUlNa0NJVUFnUGlGQlFUMGhzZ2dMREFFTEN3c2dPVUVBUmlITUFpRE1BZ1JBSU9FQklROEZRY1EyS0FJQUljMENJTTBDSU9FQmF5SE9BaUE4SU00Q1NTSFBBaURQQWdSQUlEa2c0UUZxSWRBQ0lOQUNJRGxMSWRFQ0lORUNSUVJBUVFBaEJpQ3pDQ1FOSUFZUEN5QTVRUmhxSWRJQ0lOSUNLQUlBSWRNQ0lEbEJER29oMUFJZzFBSW9BZ0FoMWdJZzFnSWdPVVloMXdJQ1FDRFhBZ1JBSURsQkZHb2gzQUlnM0FJb0FnQWgzUUlnM1FKQkFFWWgzZ0lnM2dJRVFDQTVRUkJxSWQ4Q0lOOENLQUlBSWVFQ0lPRUNRUUJHSWVJQ0lPSUNCRUJCQUNFNERBTUZJT0VDSVM0ZzN3SWhMd3NGSU4wQ0lTNGczQUloTHdzRFFBSkFJQzVCRkdvaDR3SWc0d0lvQWdBaDVBSWc1QUpCQUVZaDVRSWc1UUpGQkVBZzVBSWhMaURqQWlFdkRBSUxJQzVCRUdvaDVnSWc1Z0lvQWdBaDV3SWc1d0pCQUVZaDZBSWc2QUlFUUF3QkJTRG5BaUV1SU9ZQ0lTOExEQUVMQ3lBdlFRQTJBZ0FnTGlFNEJTQTVRUWhxSWRnQ0lOZ0NLQUlBSWRrQ0lOa0NRUXhxSWRvQ0lOb0NJTllDTmdJQUlOWUNRUWhxSWRzQ0lOc0NJTmtDTmdJQUlOWUNJVGdMQ3lEVEFrRUFSaUhwQWdKQUlPa0NCRUFnNGdFaHhnTUZJRGxCSEdvaDZnSWc2Z0lvQWdBaDdBSkI3RGdnN0FKQkFuUnFJZTBDSU8wQ0tBSUFJZTRDSURrZzdnSkdJZThDSU84Q0JFQWc3UUlnT0RZQ0FDQTRRUUJHSWFJSUlLSUlCRUJCQVNEc0FuUWg4QUlnOEFKQmYzTWg4UUlnNGdFZzhRSnhJZklDUWNBMklQSUNOZ0lBSVBJQ0ljWUREQU1MQlNEVEFrRVFhaUh6QWlEekFpZ0NBQ0gwQWlEMEFpQTVSeUgxQWlEMUFrRUJjU0ZVSU5NQ1FSQnFJRlJCQW5ScUlmY0NJUGNDSURnMkFnQWdPRUVBUmlINEFpRDRBZ1JBSU9JQkljWUREQU1MQ3lBNFFSaHFJZmtDSVBrQ0lOTUNOZ0lBSURsQkVHb2grZ0lnK2dJb0FnQWgrd0lnK3dKQkFFWWgvQUlnL0FKRkJFQWdPRUVRYWlIOUFpRDlBaUQ3QWpZQ0FDRDdBa0VZYWlIK0FpRCtBaUE0TmdJQUN5QTVRUlJxSWY4Q0lQOENLQUlBSVlBRElJQURRUUJHSVlJRElJSURCRUFnNGdFaHhnTUZJRGhCRkdvaGd3TWdnd01nZ0FNMkFnQWdnQU5CR0dvaGhBTWdoQU1nT0RZQ0FDRGlBU0hHQXdzTEN5QThRUkJKSVlVREFrQWdoUU1FUUNBOElPRUJhaUdHQXlDR0EwRURjaUdIQXlBNVFRUnFJWWdESUlnRElJY0ROZ0lBSURrZ2hnTnFJWWtESUlrRFFRUnFJWW9ESUlvREtBSUFJWXNESUlzRFFRRnlJWTBESUlvRElJMEROZ0lBQlNEaEFVRURjaUdPQXlBNVFRUnFJWThESUk4RElJNEROZ0lBSUR4QkFYSWhrQU1nMEFKQkJHb2hrUU1na1FNZ2tBTTJBZ0FnMEFJZ1BHb2hrZ01na2dNZ1BEWUNBQ0E4UVFOMklaTURJRHhCZ0FKSklaUURJSlFEQkVBZ2t3TkJBWFFobFFOQjVEWWdsUU5CQW5ScUlaWURRYncyS0FJQUlaZ0RRUUVna3dOMElaa0RJSmdESUprRGNTR2FBeUNhQTBFQVJpR2JBeUNiQXdSQUlKZ0RJSmtEY2lHY0EwRzhOaUNjQXpZQ0FDQ1dBMEVJYWlGSklKWURJU1VnU1NGTUJTQ1dBMEVJYWlHZEF5Q2RBeWdDQUNHZUF5Q2VBeUVsSUowRElVd0xJRXdnMEFJMkFnQWdKVUVNYWlHZkF5Q2ZBeURRQWpZQ0FDRFFBa0VJYWlHZ0F5Q2dBeUFsTmdJQUlOQUNRUXhxSWFFRElLRURJSllETmdJQURBSUxJRHhCQ0hZaHBBTWdwQU5CQUVZaHBRTWdwUU1FUUVFQUlTTUZJRHhCLy8vL0Iwc2hwZ01ncGdNRVFFRWZJU01GSUtRRFFZRCtQMm9ocHdNZ3B3TkJFSFlocUFNZ3FBTkJDSEVocVFNZ3BBTWdxUU4wSWFvRElLb0RRWURnSDJvaHF3TWdxd05CRUhZaHJBTWdyQU5CQkhFaHJRTWdyUU1ncVFOeUlhOERJS29ESUswRGRDR3dBeUN3QTBHQWdBOXFJYkVESUxFRFFSQjJJYklESUxJRFFRSnhJYk1ESUs4RElMTURjaUcwQTBFT0lMUURheUcxQXlDd0F5Q3pBM1FodGdNZ3RnTkJEM1lodHdNZ3RRTWd0d05xSWJnRElMZ0RRUUYwSWJvRElMZ0RRUWRxSWJzRElEd2d1d04ySWJ3RElMd0RRUUZ4SWIwRElMMERJTG9EY2lHK0F5QytBeUVqQ3d0QjdEZ2dJMEVDZEdvaHZ3TWcwQUpCSEdvaHdBTWd3QU1nSXpZQ0FDRFFBa0VRYWlIQkF5REJBMEVFYWlIQ0F5RENBMEVBTmdJQUlNRURRUUEyQWdCQkFTQWpkQ0hEQXlER0F5RERBM0VoeFFNZ3hRTkJBRVloeHdNZ3h3TUVRQ0RHQXlEREEzSWh5QU5Cd0RZZ3lBTTJBZ0FndndNZzBBSTJBZ0FnMEFKQkdHb2h5UU1neVFNZ3Z3TTJBZ0FnMEFKQkRHb2h5Z01neWdNZzBBSTJBZ0FnMEFKQkNHb2h5d01neXdNZzBBSTJBZ0FNQWdzZ3Z3TW9BZ0FoekFNZ0kwRWZSaUhOQXlBalFRRjJJYzREUVJrZ3pnTnJJZEFESU0wREJIOUJBQVVnMEFNTElkRURJRHdnMFFOMElkSURJTklESVJ3Z3pBTWhIUU5BQWtBZ0hVRUVhaUhUQXlEVEF5Z0NBQ0hVQXlEVUEwRjRjU0hWQXlEVkF5QThSaUhXQXlEV0F3UkFRZUVBSWJJSURBRUxJQnhCSDNZaDF3TWdIVUVRYWlEWEEwRUNkR29oMkFNZ0hFRUJkQ0haQXlEWUF5Z0NBQ0hiQXlEYkEwRUFSaUhjQXlEY0F3UkFRZUFBSWJJSURBRUZJTmtESVJ3ZzJ3TWhIUXNNQVFzTElMSUlRZUFBUmdSQUlOZ0RJTkFDTmdJQUlOQUNRUmhxSWQwRElOMERJQjAyQWdBZzBBSkJER29oM2dNZzNnTWcwQUkyQWdBZzBBSkJDR29oM3dNZzN3TWcwQUkyQWdBTUFnVWdzZ2hCNFFCR0JFQWdIVUVJYWlIZ0F5RGdBeWdDQUNIaEF5RGhBMEVNYWlIaUF5RGlBeURRQWpZQ0FDRGdBeURRQWpZQ0FDRFFBa0VJYWlIakF5RGpBeURoQXpZQ0FDRFFBa0VNYWlIa0F5RGtBeUFkTmdJQUlOQUNRUmhxSWVZRElPWURRUUEyQWdBTUF3c0xDd3NnT1VFSWFpSG5BeURuQXlFR0lMTUlKQTBnQmc4RklPRUJJUThMQ3dzTEN3dEJ4RFlvQWdBaDZBTWc2QU1nRDBraDZRTWc2UU5GQkVBZzZBTWdEMnNoNmdOQjBEWW9BZ0FoNndNZzZnTkJEMHNoN0FNZzdBTUVRQ0RyQXlBUGFpSHRBMEhRTmlEdEF6WUNBRUhFTmlEcUF6WUNBQ0RxQTBFQmNpSHVBeUR0QTBFRWFpSHZBeUR2QXlEdUF6WUNBQ0RyQXlEb0Eyb2g4UU1nOFFNZzZnTTJBZ0FnRDBFRGNpSHlBeURyQTBFRWFpSHpBeUR6QXlEeUF6WUNBQVZCeERaQkFEWUNBRUhRTmtFQU5nSUFJT2dEUVFOeUlmUURJT3NEUVFScUlmVURJUFVESVBRRE5nSUFJT3NESU9nRGFpSDJBeUQyQTBFRWFpSDNBeUQzQXlnQ0FDSDRBeUQ0QTBFQmNpSDVBeUQzQXlENUF6WUNBQXNnNndOQkNHb2grZ01nK2dNaEJpQ3pDQ1FOSUFZUEMwSElOaWdDQUNIOEF5RDhBeUFQU3lIOUF5RDlBd1JBSVB3RElBOXJJZjREUWNnMklQNEROZ0lBUWRRMktBSUFJZjhESVA4RElBOXFJWUFFUWRRMklJQUVOZ0lBSVA0RFFRRnlJWUVFSUlBRVFRUnFJWUlFSUlJRUlJRUVOZ0lBSUE5QkEzSWhnd1FnL3dOQkJHb2hoQVFnaEFRZ2d3UTJBZ0FnL3dOQkNHb2hoUVFnaFFRaEJpQ3pDQ1FOSUFZUEMwR1VPaWdDQUNHSEJDQ0hCRUVBUmlHSUJDQ0lCQVJBUVp3NlFZQWdOZ0lBUVpnNlFZQWdOZ0lBUWFBNlFYODJBZ0JCcERwQmZ6WUNBRUdvT2tFQU5nSUFRZmc1UVFBMkFnQWdWU0dKQkNDSkJFRndjU0dLQkNDS0JFSFlxdFdxQlhNaGl3UkJsRG9naXdRMkFnQkJnQ0FoandRRlFadzZLQUlBSVVnZ1NDR1BCQXNnRDBFd2FpR01CQ0FQUVM5cUlZMEVJSThFSUkwRWFpR09CRUVBSUk4RWF5R1FCQ0NPQkNDUUJIRWhrd1Fna3dRZ0Qwc2hsQVFnbEFSRkJFQkJBQ0VHSUxNSUpBMGdCZzhMUWZRNUtBSUFJWlVFSUpVRVFRQkdJWllFSUpZRVJRUkFRZXc1S0FJQUlaY0VJSmNFSUpNRWFpR1lCQ0NZQkNDWEJFMGhtUVFnbUFRZ2xRUkxJWm9FSUprRUlKb0VjaUduQ0NDbkNBUkFRUUFoQmlDekNDUU5JQVlQQ3d0QitEa29BZ0FobXdRZ213UkJCSEVobkFRZ25BUkJBRVlobmdRQ1FDQ2VCQVJBUWRRMktBSUFJWjhFSUo4RVFRQkdJYUFFQWtBZ29BUUVRRUgyQUNHeUNBVkIvRGtoQ2dOQUFrQWdDaWdDQUNHaEJDQ2hCQ0NmQkVzaG9nUWdvZ1JGQkVBZ0NrRUVhaUdqQkNDakJDZ0NBQ0drQkNDaEJDQ2tCR29ocFFRZ3BRUWdud1JMSWFZRUlLWUVCRUFNQWdzTElBcEJDR29ocHdRZ3B3UW9BZ0FocVFRZ3FRUkJBRVlocWdRZ3FnUUVRRUgyQUNHeUNBd0VCU0NwQkNFS0N3d0JDd3NnamdRZy9BTnJJY01FSU1NRUlKQUVjU0hFQkNERUJFSC8vLy8vQjBraHhRUWd4UVFFUUNERUJCQmhJY1lFSUFvb0FnQWh4d1Fnb3dRb0FnQWh5QVFneHdRZ3lBUnFJY29FSU1ZRUlNb0VSaUhMQkNETEJBUkFJTVlFUVg5R0ljd0VJTXdFQkVBZ3hBUWhNQVVneEFRaFFpREdCQ0ZEUVljQkliSUlEQVlMQlNER0JDRXhJTVFFSVRKQi9nQWhzZ2dMQlVFQUlUQUxDd3NDUUNDeUNFSDJBRVlFUUVFQUVHRWhxd1FncXdSQmYwWWhyQVFnckFRRVFFRUFJVEFGSUtzRUlhMEVRWmc2S0FJQUlhNEVJSzRFUVg5cUlhOEVJSzhFSUswRWNTR3dCQ0N3QkVFQVJpR3hCQ0N2QkNDdEJHb2hzZ1JCQUNDdUJHc2h0QVFnc2dRZ3RBUnhJYlVFSUxVRUlLMEVheUcyQkNDeEJBUi9RUUFGSUxZRUN5RzNCQ0MzQkNDVEJHb2hCVUhzT1NnQ0FDRzRCQ0FGSUxnRWFpRzVCQ0FGSUE5TElib0VJQVZCLy8vLy93ZEpJYnNFSUxvRUlMc0VjU0dsQ0NDbENBUkFRZlE1S0FJQUlid0VJTHdFUVFCR0liMEVJTDBFUlFSQUlMa0VJTGdFVFNHL0JDQzVCQ0M4QkVzaHdBUWd2d1Fnd0FSeUlhMElJSzBJQkVCQkFDRXdEQVVMQ3lBRkVHRWh3UVFnd1FRZ3F3UkdJY0lFSU1JRUJFQWdCU0ZDSUtzRUlVTkJod0Voc2dnTUJnVWd3UVFoTVNBRklUSkIvZ0Foc2dnTEJVRUFJVEFMQ3dzTEFrQWdzZ2hCL2dCR0JFQkJBQ0F5YXlITkJDQXhRWDlISWM0RUlESkIvLy8vL3dkSkljOEVJTThFSU00RWNTR3hDQ0NNQkNBeVN5SFFCQ0RRQkNDeENIRWhxUWdncVFoRkJFQWdNVUYvUmlIYkJDRGJCQVJBUVFBaE1Bd0RCU0F5SVVJZ01TRkRRWWNCSWJJSURBVUxBQXRCbkRvb0FnQWgwUVFnalFRZ01tc2gwZ1FnMGdRZzBRUnFJZE1FUVFBZzBRUnJJZFVFSU5NRUlOVUVjU0hXQkNEV0JFSC8vLy8vQjBraDF3UWcxd1JGQkVBZ01pRkNJREVoUTBHSEFTR3lDQXdFQ3lEV0JCQmhJZGdFSU5nRVFYOUdJZGtFSU5rRUJFQWd6UVFRWVJwQkFDRXdEQUlGSU5ZRUlESnFJZG9FSU5vRUlVSWdNU0ZEUVljQkliSUlEQVFMQUFzTFFmZzVLQUlBSWR3RUlOd0VRUVJ5SWQwRVFmZzVJTjBFTmdJQUlEQWhPMEdGQVNHeUNBVkJBQ0U3UVlVQkliSUlDd3Nnc2doQmhRRkdCRUFna3dSQi8vLy8vd2RKSWQ0RUlONEVCRUFna3dRUVlTSGdCRUVBRUdFaDRRUWc0QVJCZjBjaDRnUWc0UVJCZjBjaDR3UWc0Z1FnNHdSeElhOElJT0FFSU9FRVNTSGtCQ0RrQkNDdkNIRWhxZ2dnNFFRaDVRUWc0QVFoNWdRZzVRUWc1Z1JySWVjRUlBOUJLR29oNkFRZzV3UWc2QVJMSWVrRUlPa0VCSDhnNXdRRklEc0xJUU1ncWdoQkFYTWhxd2dnNEFSQmYwWWg2d1FnNlFSQkFYTWhvd2dnNndRZ293aHlJZXdFSU93RUlLc0ljaUd1Q0NDdUNFVUVRQ0FESVVJZzRBUWhRMEdIQVNHeUNBc0xDeUN5Q0VHSEFVWUVRRUhzT1NnQ0FDSHRCQ0R0QkNCQ2FpSHVCRUhzT1NEdUJEWUNBRUh3T1NnQ0FDSHZCQ0R1QkNEdkJFc2g4QVFnOEFRRVFFSHdPU0R1QkRZQ0FBdEIxRFlvQWdBaDhRUWc4UVJCQUVZaDhnUUNRQ0R5QkFSQVFjdzJLQUlBSWZNRUlQTUVRUUJHSWZRRUlFTWc4d1JKSWZZRUlQUUVJUFlFY2lHc0NDQ3NDQVJBUWN3MklFTTJBZ0FMUWZ3NUlFTTJBZ0JCZ0RvZ1FqWUNBRUdJT2tFQU5nSUFRWlE2S0FJQUlmY0VRZUEySVBjRU5nSUFRZHcyUVg4MkFnQkI4RFpCNURZMkFnQkI3RFpCNURZMkFnQkIrRFpCN0RZMkFnQkI5RFpCN0RZMkFnQkJnRGRCOURZMkFnQkIvRFpCOURZMkFnQkJpRGRCL0RZMkFnQkJoRGRCL0RZMkFnQkJrRGRCaERjMkFnQkJqRGRCaERjMkFnQkJtRGRCakRjMkFnQkJsRGRCakRjMkFnQkJvRGRCbERjMkFnQkJuRGRCbERjMkFnQkJxRGRCbkRjMkFnQkJwRGRCbkRjMkFnQkJzRGRCcERjMkFnQkJyRGRCcERjMkFnQkJ1RGRCckRjMkFnQkJ0RGRCckRjMkFnQkJ3RGRCdERjMkFnQkJ2RGRCdERjMkFnQkJ5RGRCdkRjMkFnQkJ4RGRCdkRjMkFnQkIwRGRCeERjMkFnQkJ6RGRCeERjMkFnQkIyRGRCekRjMkFnQkIxRGRCekRjMkFnQkI0RGRCMURjMkFnQkIzRGRCMURjMkFnQkI2RGRCM0RjMkFnQkI1RGRCM0RjMkFnQkI4RGRCNURjMkFnQkI3RGRCNURjMkFnQkIrRGRCN0RjMkFnQkI5RGRCN0RjMkFnQkJnRGhCOURjMkFnQkIvRGRCOURjMkFnQkJpRGhCL0RjMkFnQkJoRGhCL0RjMkFnQkJrRGhCaERnMkFnQkJqRGhCaERnMkFnQkJtRGhCakRnMkFnQkJsRGhCakRnMkFnQkJvRGhCbERnMkFnQkJuRGhCbERnMkFnQkJxRGhCbkRnMkFnQkJwRGhCbkRnMkFnQkJzRGhCcERnMkFnQkJyRGhCcERnMkFnQkJ1RGhCckRnMkFnQkJ0RGhCckRnMkFnQkJ3RGhCdERnMkFnQkJ2RGhCdERnMkFnQkJ5RGhCdkRnMkFnQkJ4RGhCdkRnMkFnQkIwRGhCeERnMkFnQkJ6RGhCeERnMkFnQkIyRGhCekRnMkFnQkIxRGhCekRnMkFnQkI0RGhCMURnMkFnQkIzRGhCMURnMkFnQkI2RGhCM0RnMkFnQkI1RGhCM0RnMkFnQWdRa0ZZYWlINEJDQkRRUWhxSWZrRUlQa0VJZm9FSVBvRVFRZHhJZnNFSVBzRVFRQkdJZndFUVFBZytnUnJJZjBFSVAwRVFRZHhJZjRFSVB3RUJIOUJBQVVnL2dRTElmOEVJRU1nL3dScUlZSUZJUGdFSVA4RWF5R0RCVUhVTmlDQ0JUWUNBRUhJTmlDREJUWUNBQ0NEQlVFQmNpR0VCU0NDQlVFRWFpR0ZCU0NGQlNDRUJUWUNBQ0JESVBnRWFpR0dCU0NHQlVFRWFpR0hCU0NIQlVFb05nSUFRYVE2S0FJQUlZZ0ZRZGcySUlnRk5nSUFCVUg4T1NFVkEwQUNRQ0FWS0FJQUlZa0ZJQlZCQkdvaGlnVWdpZ1VvQWdBaGl3VWdpUVVnaXdWcUlZMEZJRU1nalFWR0lZNEZJSTRGQkVCQmp3RWhzZ2dNQVFzZ0ZVRUlhaUdQQlNDUEJTZ0NBQ0dRQlNDUUJVRUFSaUdSQlNDUkJRUkFEQUVGSUpBRklSVUxEQUVMQ3lDeUNFR1BBVVlFUUNBVlFReHFJWklGSUpJRktBSUFJWk1GSUpNRlFRaHhJWlFGSUpRRlFRQkdJWlVGSUpVRkJFQWdpUVVnOFFSTklaWUZJRU1nOFFSTElaZ0ZJSmdGSUpZRmNTR3dDQ0N3Q0FSQUlJc0ZJRUpxSVprRklJb0ZJSmtGTmdJQVFjZzJLQUlBSVpvRklKb0ZJRUpxSVpzRklQRUVRUWhxSVp3RklKd0ZJWjBGSUowRlFRZHhJWjRGSUo0RlFRQkdJWjhGUVFBZ25RVnJJYUFGSUtBRlFRZHhJYUVGSUo4RkJIOUJBQVVnb1FVTElhTUZJUEVFSUtNRmFpR2tCU0NiQlNDakJXc2hwUVZCMURZZ3BBVTJBZ0JCeURZZ3BRVTJBZ0FncFFWQkFYSWhwZ1VncEFWQkJHb2hwd1VncHdVZ3BnVTJBZ0FnOFFRZ213VnFJYWdGSUtnRlFRUnFJYWtGSUtrRlFTZzJBZ0JCcERvb0FnQWhxZ1ZCMkRZZ3FnVTJBZ0FNQkFzTEMwSE1OaWdDQUNHckJTQkRJS3NGU1NHc0JTQ3NCUVJBUWN3MklFTTJBZ0FMSUVNZ1Ftb2hyZ1ZCL0RraEtBTkFBa0FnS0NnQ0FDR3ZCU0N2QlNDdUJVWWhzQVVnc0FVRVFFR1hBU0d5Q0F3QkN5QW9RUWhxSWJFRklMRUZLQUlBSWJJRklMSUZRUUJHSWJNRklMTUZCRUJCL0RraENRd0JCU0N5QlNFb0N3d0JDd3Nnc2doQmx3RkdCRUFnS0VFTWFpRzBCU0MwQlNnQ0FDRzFCU0MxQlVFSWNTRzJCU0MyQlVFQVJpRzNCU0MzQlFSQUlDZ2dRellDQUNBb1FRUnFJYmtGSUxrRktBSUFJYm9GSUxvRklFSnFJYnNGSUxrRklMc0ZOZ0lBSUVOQkNHb2h2QVVndkFVaHZRVWd2UVZCQjNFaHZnVWd2Z1ZCQUVZaHZ3VkJBQ0M5QldzaHdBVWd3QVZCQjNFaHdRVWd2d1VFZjBFQUJTREJCUXNod2dVZ1F5RENCV29oeEFVZ3JnVkJDR29oeFFVZ3hRVWh4Z1VneGdWQkIzRWh4d1VneHdWQkFFWWh5QVZCQUNER0JXc2h5UVVneVFWQkIzRWh5Z1VneUFVRWYwRUFCU0RLQlFzaHl3VWdyZ1VneXdWcUljd0ZJTXdGSWMwRklNUUZJYzhGSU0wRklNOEZheUhRQlNERUJTQVBhaUhSQlNEUUJTQVBheUhTQlNBUFFRTnlJZE1GSU1RRlFRUnFJZFFGSU5RRklOTUZOZ0lBSVBFRUlNd0ZSaUhWQlFKQUlOVUZCRUJCeURZb0FnQWgxZ1VnMWdVZzBnVnFJZGNGUWNnMklOY0ZOZ0lBUWRRMklORUZOZ0lBSU5jRlFRRnlJZGdGSU5FRlFRUnFJZG9GSU5vRklOZ0ZOZ0lBQlVIUU5pZ0NBQ0hiQlNEYkJTRE1CVVloM0FVZzNBVUVRRUhFTmlnQ0FDSGRCU0RkQlNEU0JXb2gzZ1ZCeERZZzNnVTJBZ0JCMERZZzBRVTJBZ0FnM2dWQkFYSWgzd1VnMFFWQkJHb2g0QVVnNEFVZzN3VTJBZ0FnMFFVZzNnVnFJZUVGSU9FRklONEZOZ0lBREFJTElNd0ZRUVJxSWVJRklPSUZLQUlBSWVNRklPTUZRUU54SWVVRklPVUZRUUZHSWVZRklPWUZCRUFnNHdWQmVIRWg1d1VnNHdWQkEzWWg2QVVnNHdWQmdBSkpJZWtGQWtBZzZRVUVRQ0RNQlVFSWFpSHFCU0RxQlNnQ0FDSHJCU0RNQlVFTWFpSHNCU0RzQlNnQ0FDSHRCU0R0QlNEckJVWWg3Z1VnN2dVRVFFRUJJT2dGZENIeEJTRHhCVUYvY3lIeUJVRzhOaWdDQUNIekJTRHpCU0R5QlhFaDlBVkJ2RFlnOUFVMkFnQU1BZ1VnNndWQkRHb2g5UVVnOVFVZzdRVTJBZ0FnN1FWQkNHb2g5Z1VnOWdVZzZ3VTJBZ0FNQWdzQUJTRE1CVUVZYWlIM0JTRDNCU2dDQUNINEJTRE1CVUVNYWlINUJTRDVCU2dDQUNINkJTRDZCU0RNQlVZaC9BVUNRQ0Q4QlFSQUlNd0ZRUkJxSVlFR0lJRUdRUVJxSVlJR0lJSUdLQUlBSVlNR0lJTUdRUUJHSVlRR0lJUUdCRUFnZ1FZb0FnQWhoUVlnaFFaQkFFWWhod1lnaHdZRVFFRUFJVFVNQXdVZ2hRWWhLU0NCQmlFcUN3VWdnd1loS1NDQ0JpRXFDd05BQWtBZ0tVRVVhaUdJQmlDSUJpZ0NBQ0dKQmlDSkJrRUFSaUdLQmlDS0JrVUVRQ0NKQmlFcElJZ0dJU29NQWdzZ0tVRVFhaUdMQmlDTEJpZ0NBQ0dNQmlDTUJrRUFSaUdOQmlDTkJnUkFEQUVGSUl3R0lTa2dpd1loS2dzTUFRc0xJQ3BCQURZQ0FDQXBJVFVGSU13RlFRaHFJZjBGSVAwRktBSUFJZjRGSVA0RlFReHFJZjhGSVA4RklQb0ZOZ0lBSVBvRlFRaHFJWUFHSUlBR0lQNEZOZ0lBSVBvRklUVUxDeUQ0QlVFQVJpR09CaUNPQmdSQURBSUxJTXdGUVJ4cUlZOEdJSThHS0FJQUlaQUdRZXc0SUpBR1FRSjBhaUdTQmlDU0JpZ0NBQ0dUQmlDVEJpRE1CVVlobEFZQ1FDQ1VCZ1JBSUpJR0lEVTJBZ0FnTlVFQVJpR2hDQ0NoQ0VVRVFBd0NDMEVCSUpBR2RDR1ZCaUNWQmtGL2N5R1dCa0hBTmlnQ0FDR1hCaUNYQmlDV0JuRWhtQVpCd0RZZ21BWTJBZ0FNQXdVZytBVkJFR29obVFZZ21RWW9BZ0FobWdZZ21nWWd6QVZISVpzR0lKc0dRUUZ4SVZBZytBVkJFR29nVUVFQ2RHb2huUVlnblFZZ05UWUNBQ0ExUVFCR0laNEdJSjRHQkVBTUJBc0xDeUExUVJocUlaOEdJSjhHSVBnRk5nSUFJTXdGUVJCcUlhQUdJS0FHS0FJQUlhRUdJS0VHUVFCR0lhSUdJS0lHUlFSQUlEVkJFR29ob3dZZ293WWdvUVkyQWdBZ29RWkJHR29ocEFZZ3BBWWdOVFlDQUFzZ29BWkJCR29ocFFZZ3BRWW9BZ0FocGdZZ3BnWkJBRVlocUFZZ3FBWUVRQXdDQ3lBMVFSUnFJYWtHSUtrR0lLWUdOZ0lBSUtZR1FSaHFJYW9HSUtvR0lEVTJBZ0FMQ3lETUJTRG5CV29ocXdZZzV3VWcwZ1ZxSWF3R0lLc0dJUWdnckFZaEZnVWd6QVVoQ0NEU0JTRVdDeUFJUVFScUlhMEdJSzBHS0FJQUlhNEdJSzRHUVg1eElhOEdJSzBHSUs4R05nSUFJQlpCQVhJaHNBWWcwUVZCQkdvaHNRWWdzUVlnc0FZMkFnQWcwUVVnRm1vaHN3WWdzd1lnRmpZQ0FDQVdRUU4ySWJRR0lCWkJnQUpKSWJVR0lMVUdCRUFndEFaQkFYUWh0Z1pCNURZZ3RnWkJBblJxSWJjR1FidzJLQUlBSWJnR1FRRWd0QVowSWJrR0lMZ0dJTGtHY1NHNkJpQzZCa0VBUmlHN0JpQzdCZ1JBSUxnR0lMa0djaUc4QmtHOE5pQzhCallDQUNDM0JrRUlhaUZISUxjR0lSa2dSeUZMQlNDM0JrRUlhaUcrQmlDK0JpZ0NBQ0cvQmlDL0JpRVpJTDRHSVVzTElFc2cwUVUyQWdBZ0dVRU1haUhBQmlEQUJpRFJCVFlDQUNEUkJVRUlhaUhCQmlEQkJpQVpOZ0lBSU5FRlFReHFJY0lHSU1JR0lMY0dOZ0lBREFJTElCWkJDSFlod3dZZ3d3WkJBRVloeEFZQ1FDREVCZ1JBUVFBaEdnVWdGa0gvLy84SFN5SEZCaURGQmdSQVFSOGhHZ3dDQ3lEREJrR0EvajlxSWNZR0lNWUdRUkIySWNjR0lNY0dRUWh4SWNrR0lNTUdJTWtHZENIS0JpREtCa0dBNEI5cUljc0dJTXNHUVJCMkljd0dJTXdHUVFSeEljMEdJTTBHSU1rR2NpSE9CaURLQmlETkJuUWh6d1lnendaQmdJQVBhaUhRQmlEUUJrRVFkaUhSQmlEUkJrRUNjU0hTQmlET0JpRFNCbkloMUFaQkRpRFVCbXNoMVFZZ3p3WWcwZ1owSWRZR0lOWUdRUTkySWRjR0lOVUdJTmNHYWlIWUJpRFlCa0VCZENIWkJpRFlCa0VIYWlIYUJpQVdJTm9HZGlIYkJpRGJCa0VCY1NIY0JpRGNCaURaQm5JaDNRWWczUVloR2dzTFFldzRJQnBCQW5ScUllQUdJTkVGUVJ4cUllRUdJT0VHSUJvMkFnQWcwUVZCRUdvaDRnWWc0Z1pCQkdvaDR3WWc0d1pCQURZQ0FDRGlCa0VBTmdJQVFjQTJLQUlBSWVRR1FRRWdHblFoNVFZZzVBWWc1UVp4SWVZR0lPWUdRUUJHSWVjR0lPY0dCRUFnNUFZZzVRWnlJZWdHUWNBMklPZ0dOZ0lBSU9BR0lORUZOZ0lBSU5FRlFSaHFJZWtHSU9rR0lPQUdOZ0lBSU5FRlFReHFJZXNHSU9zR0lORUZOZ0lBSU5FRlFRaHFJZXdHSU93R0lORUZOZ0lBREFJTElPQUdLQUlBSWUwR0lCcEJIMFloN2dZZ0drRUJkaUh2QmtFWklPOEdheUh3QmlEdUJnUi9RUUFGSVBBR0N5SHhCaUFXSVBFR2RDSHlCaUR5QmlFWElPMEdJUmdEUUFKQUlCaEJCR29oOHdZZzh3WW9BZ0FoOUFZZzlBWkJlSEVoOWdZZzlnWWdGa1loOXdZZzl3WUVRRUhBQVNHeUNBd0JDeUFYUVI5MklmZ0dJQmhCRUdvZytBWkJBblJxSWZrR0lCZEJBWFFoK2dZZytRWW9BZ0FoK3dZZyt3WkJBRVloL0FZZy9BWUVRRUcvQVNHeUNBd0JCU0Q2QmlFWElQc0dJUmdMREFFTEN5Q3lDRUcvQVVZRVFDRDVCaURSQlRZQ0FDRFJCVUVZYWlIOUJpRDlCaUFZTmdJQUlORUZRUXhxSWY0R0lQNEdJTkVGTmdJQUlORUZRUWhxSWY4R0lQOEdJTkVGTmdJQURBSUZJTElJUWNBQlJnUkFJQmhCQ0dvaGdRY2dnUWNvQWdBaGdnY2dnZ2RCREdvaGd3Y2dnd2NnMFFVMkFnQWdnUWNnMFFVMkFnQWcwUVZCQ0dvaGhBY2doQWNnZ2djMkFnQWcwUVZCREdvaGhRY2doUWNnR0RZQ0FDRFJCVUVZYWlHR0J5Q0dCMEVBTmdJQURBTUxDd3NMSU1RRlFRaHFJWkVJSUpFSUlRWWdzd2drRFNBR0R3VkIvRGtoQ1FzTEEwQUNRQ0FKS0FJQUlZY0hJSWNISVBFRVN5R0lCeUNJQjBVRVFDQUpRUVJxSVlrSElJa0hLQUlBSVlvSElJY0hJSW9IYWlHTUJ5Q01CeUR4QkVzaGpRY2dqUWNFUUF3Q0N3c2dDVUVJYWlHT0J5Q09CeWdDQUNHUEJ5Q1BCeUVKREFFTEN5Q01CMEZSYWlHUUJ5Q1FCMEVJYWlHUkJ5Q1JCeUdTQnlDU0IwRUhjU0dUQnlDVEIwRUFSaUdVQjBFQUlKSUhheUdWQnlDVkIwRUhjU0dYQnlDVUJ3Ui9RUUFGSUpjSEN5R1lCeUNRQnlDWUIyb2htUWNnOFFSQkVHb2htZ2NnbVFjZ21nZEpJWnNISUpzSEJIOGc4UVFGSUprSEN5R2NCeUNjQjBFSWFpR2RCeUNjQjBFWWFpR2VCeUJDUVZocUlaOEhJRU5CQ0dvaG9BY2dvQWNob2djZ29nZEJCM0Vob3djZ293ZEJBRVlocEFkQkFDQ2lCMnNocFFjZ3BRZEJCM0VocGdjZ3BBY0VmMEVBQlNDbUJ3c2hwd2NnUXlDbkIyb2hxQWNnbndjZ3B3ZHJJYWtIUWRRMklLZ0hOZ0lBUWNnMklLa0hOZ0lBSUtrSFFRRnlJYW9ISUtnSFFRUnFJYXNISUtzSElLb0hOZ0lBSUVNZ253ZHFJYTBISUswSFFRUnFJYTRISUs0SFFTZzJBZ0JCcERvb0FnQWhyd2RCMkRZZ3J3YzJBZ0FnbkFkQkJHb2hzQWNnc0FkQkd6WUNBQ0NkQjBIOE9Ta0NBRGNDQUNDZEIwRUlha0g4T1VFSWFpa0NBRGNDQUVIOE9TQkROZ0lBUVlBNklFSTJBZ0JCaURwQkFEWUNBRUdFT2lDZEJ6WUNBQ0NlQnlHeUJ3TkFBa0Fnc2dkQkJHb2hzUWNnc1FkQkJ6WUNBQ0N5QjBFSWFpR3pCeUN6QnlDTUIwa2h0QWNndEFjRVFDQ3hCeUd5QndVTUFRc01BUXNMSUp3SElQRUVSaUcxQnlDMUIwVUVRQ0NjQnlHMkJ5RHhCQ0c0QnlDMkJ5QzRCMnNodVFjZ3NBY29BZ0FodWdjZ3VnZEJmbkVodXdjZ3NBY2d1d2MyQWdBZ3VRZEJBWElodkFjZzhRUkJCR29odlFjZ3ZRY2d2QWMyQWdBZ25BY2d1UWMyQWdBZ3VRZEJBM1lodmdjZ3VRZEJnQUpKSWI4SElMOEhCRUFndmdkQkFYUWh3QWRCNURZZ3dBZEJBblJxSWNFSFFidzJLQUlBSWNNSFFRRWd2Z2QwSWNRSElNTUhJTVFIY1NIRkJ5REZCMEVBUmlIR0J5REdCd1JBSU1NSElNUUhjaUhIQjBHOE5pREhCellDQUNEQkIwRUlhaUZHSU1FSElSTWdSaUZLQlNEQkIwRUlhaUhJQnlESUJ5Z0NBQ0hKQnlESkJ5RVRJTWdISVVvTElFb2c4UVEyQWdBZ0UwRU1haUhLQnlES0J5RHhCRFlDQUNEeEJFRUlhaUhMQnlETEJ5QVROZ0lBSVBFRVFReHFJY3dISU13SElNRUhOZ0lBREFNTElMa0hRUWgySWM4SElNOEhRUUJHSWRBSElOQUhCRUJCQUNFVUJTQzVCMEgvLy84SFN5SFJCeURSQndSQVFSOGhGQVVnendkQmdQNC9haUhTQnlEU0IwRVFkaUhUQnlEVEIwRUljU0hVQnlEUEJ5RFVCM1FoMVFjZzFRZEJnT0FmYWlIV0J5RFdCMEVRZGlIWEJ5RFhCMEVFY1NIWUJ5RFlCeURVQjNJaDJnY2cxUWNnMkFkMElkc0hJTnNIUVlDQUQyb2gzQWNnM0FkQkVIWWgzUWNnM1FkQkFuRWgzZ2NnMmdjZzNnZHlJZDhIUVE0ZzN3ZHJJZUFISU5zSElONEhkQ0hoQnlEaEIwRVBkaUhpQnlEZ0J5RGlCMm9oNHdjZzR3ZEJBWFFoNVFjZzR3ZEJCMm9oNWdjZ3VRY2c1Z2QySWVjSElPY0hRUUZ4SWVnSElPZ0hJT1VIY2lIcEJ5RHBCeUVVQ3d0QjdEZ2dGRUVDZEdvaDZnY2c4UVJCSEdvaDZ3Y2c2d2NnRkRZQ0FDRHhCRUVVYWlIc0J5RHNCMEVBTmdJQUlKb0hRUUEyQWdCQndEWW9BZ0FoN1FkQkFTQVVkQ0h1QnlEdEJ5RHVCM0VoOEFjZzhBZEJBRVloOFFjZzhRY0VRQ0R0QnlEdUIzSWg4Z2RCd0RZZzhnYzJBZ0FnNmdjZzhRUTJBZ0FnOFFSQkdHb2g4d2NnOHdjZzZnYzJBZ0FnOFFSQkRHb2g5QWNnOUFjZzhRUTJBZ0FnOFFSQkNHb2g5UWNnOVFjZzhRUTJBZ0FNQXdzZzZnY29BZ0FoOWdjZ0ZFRWZSaUgzQnlBVVFRRjJJZmdIUVJrZytBZHJJZmtISVBjSEJIOUJBQVVnK1FjTElmc0hJTGtISVBzSGRDSDhCeUQ4QnlFUklQWUhJUklEUUFKQUlCSkJCR29oL1FjZy9RY29BZ0FoL2djZy9nZEJlSEVoL3djZy93Y2d1UWRHSVlBSUlJQUlCRUJCMVFFaHNnZ01BUXNnRVVFZmRpR0JDQ0FTUVJCcUlJRUlRUUowYWlHQ0NDQVJRUUYwSVlNSUlJSUlLQUlBSVlRSUlJUUlRUUJHSVlZSUlJWUlCRUJCMUFFaHNnZ01BUVVnZ3dnaEVTQ0VDQ0VTQ3d3QkN3c2dzZ2hCMUFGR0JFQWdnZ2dnOFFRMkFnQWc4UVJCR0dvaGh3Z2dod2dnRWpZQ0FDRHhCRUVNYWlHSUNDQ0lDQ0R4QkRZQ0FDRHhCRUVJYWlHSkNDQ0pDQ0R4QkRZQ0FBd0RCU0N5Q0VIVkFVWUVRQ0FTUVFocUlZb0lJSW9JS0FJQUlZc0lJSXNJUVF4cUlZd0lJSXdJSVBFRU5nSUFJSW9JSVBFRU5nSUFJUEVFUVFocUlZMElJSTBJSUlzSU5nSUFJUEVFUVF4cUlZNElJSTRJSUJJMkFnQWc4UVJCR0dvaGp3Z2dqd2hCQURZQ0FBd0VDd3NMQ3d0QnlEWW9BZ0Foa2dnZ2tnZ2dEMHNoa3dnZ2t3Z0VRQ0NTQ0NBUGF5R1VDRUhJTmlDVUNEWUNBRUhVTmlnQ0FDR1ZDQ0NWQ0NBUGFpR1dDRUhVTmlDV0NEWUNBQ0NVQ0VFQmNpR1hDQ0NXQ0VFRWFpR1lDQ0NZQ0NDWENEWUNBQ0FQUVFOeUlaa0lJSlVJUVFScUlab0lJSm9JSUprSU5nSUFJSlVJUVFocUlad0lJSndJSVFZZ3N3Z2tEU0FHRHdzTEVERWhuUWdnblFoQkREWUNBRUVBSVFZZ3N3Z2tEU0FHRHd1d0d3R2JBbjhqRFNHYkFpQUFRUUJHSVJRZ0ZBUkFEd3NnQUVGNGFpR0RBVUhNTmlnQ0FDSExBU0FBUVh4cUlkWUJJTllCS0FJQUllRUJJT0VCUVhoeElld0JJSU1CSU93QmFpSDNBU0RoQVVFQmNTR0NBaUNDQWtFQVJpR05BZ0pBSUkwQ0JFQWdnd0VvQWdBaEZTRGhBVUVEY1NFZ0lDQkJBRVloS3lBckJFQVBDMEVBSUJWcklUWWdnd0VnTm1vaFFTQVZJT3dCYWlGTUlFRWd5d0ZKSVZjZ1Z3UkFEd3RCMERZb0FnQWhZaUJpSUVGR0lXMGdiUVJBSVBjQlFRUnFJWUVDSUlFQ0tBSUFJWU1DSUlNQ1FRTnhJWVFDSUlRQ1FRTkdJWVVDSUlVQ1JRUkFJRUVoQnlCTUlRZ2dRU0dMQWd3REMwSEVOaUJNTmdJQUlJTUNRWDV4SVlZQ0lJRUNJSVlDTmdJQUlFeEJBWEloaHdJZ1FVRUVhaUdJQWlDSUFpQ0hBallDQUNCQklFeHFJWWtDSUlrQ0lFdzJBZ0FQQ3lBVlFRTjJJWGdnRlVHQUFra2hoQUVnaEFFRVFDQkJRUWhxSVk4QklJOEJLQUlBSVpvQklFRkJER29ocFFFZ3BRRW9BZ0Foc0FFZ3NBRWdtZ0ZHSWJzQklMc0JCRUJCQVNCNGRDSEdBU0RHQVVGL2N5SElBVUc4TmlnQ0FDSEpBU0RKQVNESUFYRWh5Z0ZCdkRZZ3lnRTJBZ0FnUVNFSElFd2hDQ0JCSVlzQ0RBTUZJSm9CUVF4cUljd0JJTXdCSUxBQk5nSUFJTEFCUVFocUljMEJJTTBCSUpvQk5nSUFJRUVoQnlCTUlRZ2dRU0dMQWd3REN3QUxJRUZCR0dvaHpnRWd6Z0VvQWdBaHp3RWdRVUVNYWlIUUFTRFFBU2dDQUNIUkFTRFJBU0JCUmlIU0FRSkFJTklCQkVBZ1FVRVFhaUhZQVNEWUFVRUVhaUhaQVNEWkFTZ0NBQ0hhQVNEYUFVRUFSaUhiQVNEYkFRUkFJTmdCS0FJQUlkd0JJTndCUVFCR0lkMEJJTjBCQkVCQkFDRU9EQU1GSU53QklRa2cyQUVoQ2dzRklOb0JJUWtnMlFFaENnc0RRQUpBSUFsQkZHb2gzZ0VnM2dFb0FnQWgzd0VnM3dGQkFFWWg0QUVnNEFGRkJFQWczd0VoQ1NEZUFTRUtEQUlMSUFsQkVHb2g0Z0VnNGdFb0FnQWg0d0VnNHdGQkFFWWg1QUVnNUFFRVFBd0JCU0RqQVNFSklPSUJJUW9MREFFTEN5QUtRUUEyQWdBZ0NTRU9CU0JCUVFocUlkTUJJTk1CS0FJQUlkUUJJTlFCUVF4cUlkVUJJTlVCSU5FQk5nSUFJTkVCUVFocUlkY0JJTmNCSU5RQk5nSUFJTkVCSVE0TEN5RFBBVUVBUmlIbEFTRGxBUVJBSUVFaEJ5Qk1JUWdnUVNHTEFnVWdRVUVjYWlIbUFTRG1BU2dDQUNIbkFVSHNPQ0RuQVVFQ2RHb2g2QUVnNkFFb0FnQWg2UUVnNlFFZ1FVWWg2Z0VnNmdFRVFDRG9BU0FPTmdJQUlBNUJBRVlobUFJZ21BSUVRRUVCSU9jQmRDSHJBU0RyQVVGL2N5SHRBVUhBTmlnQ0FDSHVBU0R1QVNEdEFYRWg3d0ZCd0RZZzd3RTJBZ0FnUVNFSElFd2hDQ0JCSVlzQ0RBUUxCU0RQQVVFUWFpSHdBU0R3QVNnQ0FDSHhBU0R4QVNCQlJ5SHlBU0R5QVVFQmNTRVNJTThCUVJCcUlCSkJBblJxSWZNQklQTUJJQTQyQWdBZ0RrRUFSaUgwQVNEMEFRUkFJRUVoQnlCTUlRZ2dRU0dMQWd3RUN3c2dEa0VZYWlIMUFTRDFBU0RQQVRZQ0FDQkJRUkJxSWZZQklQWUJLQUlBSWZnQklQZ0JRUUJHSWZrQklQa0JSUVJBSUE1QkVHb2grZ0VnK2dFZytBRTJBZ0FnK0FGQkdHb2grd0VnK3dFZ0RqWUNBQXNnOWdGQkJHb2gvQUVnL0FFb0FnQWgvUUVnL1FGQkFFWWgvZ0VnL2dFRVFDQkJJUWNnVENFSUlFRWhpd0lGSUE1QkZHb2gvd0VnL3dFZy9RRTJBZ0FnL1FGQkdHb2hnQUlnZ0FJZ0RqWUNBQ0JCSVFjZ1RDRUlJRUVoaXdJTEN3VWdnd0VoQnlEc0FTRUlJSU1CSVlzQ0N3c2dpd0lnOXdGSklZb0NJSW9DUlFSQUR3c2c5d0ZCQkdvaGpBSWdqQUlvQWdBaGpnSWdqZ0pCQVhFaGp3SWdqd0pCQUVZaGtBSWdrQUlFUUE4TElJNENRUUp4SVpFQ0lKRUNRUUJHSVpJQ0lKSUNCRUJCMURZb0FnQWhrd0lna3dJZzl3RkdJWlFDSUpRQ0JFQkJ5RFlvQWdBaGxRSWdsUUlnQ0dvaGxnSkJ5RFlnbGdJMkFnQkIxRFlnQnpZQ0FDQ1dBa0VCY2lHWEFpQUhRUVJxSVJZZ0ZpQ1hBallDQUVIUU5pZ0NBQ0VYSUFjZ0YwWWhHQ0FZUlFSQUR3dEIwRFpCQURZQ0FFSEVOa0VBTmdJQUR3dEIwRFlvQWdBaEdTQVpJUGNCUmlFYUlCb0VRRUhFTmlnQ0FDRWJJQnNnQ0dvaEhFSEVOaUFjTmdJQVFkQTJJSXNDTmdJQUlCeEJBWEloSFNBSFFRUnFJUjRnSGlBZE5nSUFJSXNDSUJ4cUlSOGdIeUFjTmdJQUR3c2dqZ0pCZUhFaElTQWhJQWhxSVNJZ2pnSkJBM1loSXlDT0FrR0FBa2toSkFKQUlDUUVRQ0QzQVVFSWFpRWxJQ1VvQWdBaEppRDNBVUVNYWlFbklDY29BZ0FoS0NBb0lDWkdJU2tnS1FSQVFRRWdJM1FoS2lBcVFYOXpJU3hCdkRZb0FnQWhMU0F0SUN4eElTNUJ2RFlnTGpZQ0FBd0NCU0FtUVF4cUlTOGdMeUFvTmdJQUlDaEJDR29oTUNBd0lDWTJBZ0FNQWdzQUJTRDNBVUVZYWlFeElERW9BZ0FoTWlEM0FVRU1haUV6SURNb0FnQWhOQ0EwSVBjQlJpRTFBa0FnTlFSQUlQY0JRUkJxSVRzZ08wRUVhaUU4SUR3b0FnQWhQU0E5UVFCR0lUNGdQZ1JBSURzb0FnQWhQeUEvUVFCR0lVQWdRQVJBUVFBaER3d0RCU0EvSVFzZ095RU1Dd1VnUFNFTElEd2hEQXNEUUFKQUlBdEJGR29oUWlCQ0tBSUFJVU1nUTBFQVJpRkVJRVJGQkVBZ1F5RUxJRUloREF3Q0N5QUxRUkJxSVVVZ1JTZ0NBQ0ZHSUVaQkFFWWhSeUJIQkVBTUFRVWdSaUVMSUVVaERBc01BUXNMSUF4QkFEWUNBQ0FMSVE4RklQY0JRUWhxSVRjZ055Z0NBQ0U0SURoQkRHb2hPU0E1SURRMkFnQWdORUVJYWlFNklEb2dPRFlDQUNBMElROExDeUF5UVFCR0lVZ2dTRVVFUUNEM0FVRWNhaUZKSUVrb0FnQWhTa0hzT0NCS1FRSjBhaUZMSUVzb0FnQWhUU0JOSVBjQlJpRk9JRTRFUUNCTElBODJBZ0FnRDBFQVJpR1pBaUNaQWdSQVFRRWdTblFoVHlCUFFYOXpJVkJCd0RZb0FnQWhVU0JSSUZCeElWSkJ3RFlnVWpZQ0FBd0VDd1VnTWtFUWFpRlRJRk1vQWdBaFZDQlVJUGNCUnlGVklGVkJBWEVoRXlBeVFSQnFJQk5CQW5ScUlWWWdWaUFQTmdJQUlBOUJBRVloV0NCWUJFQU1CQXNMSUE5QkdHb2hXU0JaSURJMkFnQWc5d0ZCRUdvaFdpQmFLQUlBSVZzZ1cwRUFSaUZjSUZ4RkJFQWdEMEVRYWlGZElGMGdXellDQUNCYlFSaHFJVjRnWGlBUE5nSUFDeUJhUVFScUlWOGdYeWdDQUNGZ0lHQkJBRVloWVNCaFJRUkFJQTlCRkdvaFl5QmpJR0EyQWdBZ1lFRVlhaUZrSUdRZ0R6WUNBQXNMQ3dzZ0lrRUJjaUZsSUFkQkJHb2haaUJtSUdVMkFnQWdpd0lnSW1vaFp5Qm5JQ0kyQWdCQjBEWW9BZ0FoYUNBSElHaEdJV2tnYVFSQVFjUTJJQ0kyQWdBUEJTQWlJUTBMQlNDT0FrRitjU0ZxSUl3Q0lHbzJBZ0FnQ0VFQmNpRnJJQWRCQkdvaGJDQnNJR3MyQWdBZ2l3SWdDR29oYmlCdUlBZzJBZ0FnQ0NFTkN5QU5RUU4ySVc4Z0RVR0FBa2toY0NCd0JFQWdiMEVCZENGeFFlUTJJSEZCQW5ScUlYSkJ2RFlvQWdBaGMwRUJJRzkwSVhRZ2N5QjBjU0YxSUhWQkFFWWhkaUIyQkVBZ2N5QjBjaUYzUWJ3MklIYzJBZ0FnY2tFSWFpRVFJSEloQmlBUUlSRUZJSEpCQ0dvaGVTQjVLQUlBSVhvZ2VpRUdJSGtoRVFzZ0VTQUhOZ0lBSUFaQkRHb2hleUI3SUFjMkFnQWdCMEVJYWlGOElId2dCallDQUNBSFFReHFJWDBnZlNCeU5nSUFEd3NnRFVFSWRpRitJSDVCQUVZaGZ5Qi9CRUJCQUNFRkJTQU5RZi8vL3dkTElZQUJJSUFCQkVCQkh5RUZCU0IrUVlEK1Ayb2hnUUVnZ1FGQkVIWWhnZ0VnZ2dGQkNIRWhoUUVnZmlDRkFYUWhoZ0VnaGdGQmdPQWZhaUdIQVNDSEFVRVFkaUdJQVNDSUFVRUVjU0dKQVNDSkFTQ0ZBWEloaWdFZ2hnRWdpUUYwSVlzQklJc0JRWUNBRDJvaGpBRWdqQUZCRUhZaGpRRWdqUUZCQW5FaGpnRWdpZ0VnamdGeUlaQUJRUTRna0FGcklaRUJJSXNCSUk0QmRDR1NBU0NTQVVFUGRpR1RBU0NSQVNDVEFXb2hsQUVnbEFGQkFYUWhsUUVnbEFGQkIyb2hsZ0VnRFNDV0FYWWhsd0VnbHdGQkFYRWhtQUVnbUFFZ2xRRnlJWmtCSUprQklRVUxDMEhzT0NBRlFRSjBhaUdiQVNBSFFSeHFJWndCSUp3QklBVTJBZ0FnQjBFUWFpR2RBU0FIUVJScUlaNEJJSjRCUVFBMkFnQWduUUZCQURZQ0FFSEFOaWdDQUNHZkFVRUJJQVYwSWFBQklKOEJJS0FCY1NHaEFTQ2hBVUVBUmlHaUFRSkFJS0lCQkVBZ253RWdvQUZ5SWFNQlFjQTJJS01CTmdJQUlKc0JJQWMyQWdBZ0IwRVlhaUdrQVNDa0FTQ2JBVFlDQUNBSFFReHFJYVlCSUtZQklBYzJBZ0FnQjBFSWFpR25BU0NuQVNBSE5nSUFCU0NiQVNnQ0FDR29BU0FGUVI5R0lha0JJQVZCQVhZaHFnRkJHU0NxQVdzaHF3RWdxUUVFZjBFQUJTQ3JBUXNockFFZ0RTQ3NBWFFoclFFZ3JRRWhBeUNvQVNFRUEwQUNRQ0FFUVFScUlhNEJJSzRCS0FJQUlhOEJJSzhCUVhoeEliRUJJTEVCSUExR0liSUJJTElCQkVCQnlRQWhtZ0lNQVFzZ0EwRWZkaUd6QVNBRVFSQnFJTE1CUVFKMGFpRzBBU0FEUVFGMEliVUJJTFFCS0FJQUliWUJJTFlCUVFCR0liY0JJTGNCQkVCQnlBQWhtZ0lNQVFVZ3RRRWhBeUMyQVNFRUN3d0JDd3NnbWdKQnlBQkdCRUFndEFFZ0J6WUNBQ0FIUVJocUliZ0JJTGdCSUFRMkFnQWdCMEVNYWlHNUFTQzVBU0FITmdJQUlBZEJDR29odWdFZ3VnRWdCellDQUF3Q0JTQ2FBa0hKQUVZRVFDQUVRUWhxSWJ3QklMd0JLQUlBSWIwQklMMEJRUXhxSWI0QklMNEJJQWMyQWdBZ3ZBRWdCellDQUNBSFFRaHFJYjhCSUw4QklMMEJOZ0lBSUFkQkRHb2h3QUVnd0FFZ0JEWUNBQ0FIUVJocUljRUJJTUVCUVFBMkFnQU1Bd3NMQ3d0QjNEWW9BZ0Fod2dFZ3dnRkJmMm9od3dGQjNEWWd3d0UyQWdBZ3d3RkJBRVloeEFFZ3hBRUVRRUdFT2lFQ0JROExBMEFDUUNBQ0tBSUFJUUVnQVVFQVJpSEZBU0FCUVFocUljY0JJTVVCQkVBTUFRVWd4d0VoQWdzTUFRc0xRZHcyUVg4MkFnQVBDMDhCQ0g4akRTRUlJdzFCRUdva0RTTU5JdzVPQkVCQkVCQURDeUFJSVFZZ0FFRThhaUVCSUFFb0FnQWhBaUFDRURJaEF5QUdJQU0yQWdCQkJpQUdFQXNoQkNBRUVEQWhCU0FJSkEwZ0JROExtd1VCUUg4akRTRkNJdzFCTUdva0RTTU5JdzVPQkVCQk1CQURDeUJDUVJCcUlUd2dRaUU3SUVKQklHb2hIaUFBUVJ4cUlTa2dLU2dDQUNFMElCNGdORFlDQUNBZVFRUnFJVGNnQUVFVWFpRTRJRGdvQWdBaE9TQTVJRFJySVRvZ055QTZOZ0lBSUI1QkNHb2hDaUFLSUFFMkFnQWdIa0VNYWlFTElBc2dBallDQUNBNklBSnFJUXdnQUVFOGFpRU5JQTBvQWdBaERpQWVJUThnT3lBT05nSUFJRHRCQkdvaFBTQTlJQTgyQWdBZ08wRUlhaUUrSUQ1QkFqWUNBRUdTQVNBN0VBa2hFQ0FRRURBaEVTQU1JQkZHSVJJQ1FDQVNCRUJCQXlGQkJVRUNJUVFnRENFRklCNGhCaUFSSVJzRFFBSkFJQnRCQUVnaEdpQWFCRUFNQVFzZ0JTQWJheUVrSUFaQkJHb2hKU0FsS0FJQUlTWWdHeUFtU3lFbklBWkJDR29oS0NBbkJIOGdLQVVnQmdzaENTQW5RUjkwUVI5MUlTb2dCQ0FxYWlFSUlDY0VmeUFtQlVFQUN5RXJJQnNnSzJzaEF5QUpLQUlBSVN3Z0xDQURhaUV0SUFrZ0xUWUNBQ0FKUVFScUlTNGdMaWdDQUNFdklDOGdBMnNoTUNBdUlEQTJBZ0FnRFNnQ0FDRXhJQWtoTWlBOElERTJBZ0FnUEVFRWFpRS9JRDhnTWpZQ0FDQThRUWhxSVVBZ1FDQUlOZ0lBUVpJQklEd1FDU0V6SURNUU1DRTFJQ1FnTlVZaE5pQTJCRUJCQXlGQkRBUUZJQWdoQkNBa0lRVWdDU0VHSURVaEd3c01BUXNMSUFCQkVHb2hIQ0FjUVFBMkFnQWdLVUVBTmdJQUlEaEJBRFlDQUNBQUtBSUFJUjBnSFVFZ2NpRWZJQUFnSHpZQ0FDQUVRUUpHSVNBZ0lBUkFRUUFoQndVZ0JrRUVhaUVoSUNFb0FnQWhJaUFDSUNKcklTTWdJeUVIQ3dzTElFRkJBMFlFUUNBQVFTeHFJUk1nRXlnQ0FDRVVJQUJCTUdvaEZTQVZLQUlBSVJZZ0ZDQVdhaUVYSUFCQkVHb2hHQ0FZSUJjMkFnQWdGQ0VaSUNrZ0dUWUNBQ0E0SUJrMkFnQWdBaUVIQ3lCQ0pBMGdCdzhMc0FFQkVIOGpEU0VTSXcxQklHb2tEU01OSXc1T0JFQkJJQkFEQ3lBU0lRd2dFa0VVYWlFRklBQkJQR29oQmlBR0tBSUFJUWNnQlNFSUlBd2dCellDQUNBTVFRUnFJUTBnRFVFQU5nSUFJQXhCQ0dvaERpQU9JQUUyQWdBZ0RFRU1haUVQSUE4Z0NEWUNBQ0FNUVJCcUlSQWdFQ0FDTmdJQVFZd0JJQXdRQ0NFSklBa1FNQ0VLSUFwQkFFZ2hDeUFMQkVBZ0JVRi9OZ0lBUVg4aEJBVWdCU2dDQUNFRElBTWhCQXNnRWlRTklBUVBDek1CQm44akRTRUdJQUJCZ0dCTElRSWdBZ1JBUVFBZ0FHc2hBeEF4SVFRZ0JDQUROZ0lBUVg4aEFRVWdBQ0VCQ3lBQkR3c01BUUovSXcwaEFVSHNPZzhMQ3dFQ2Z5TU5JUUlnQUE4THV3RUJFWDhqRFNFVEl3MUJJR29rRFNNTkl3NU9CRUJCSUJBREN5QVRJUThnRTBFUWFpRUlJQUJCSkdvaENTQUpRUUkyQWdBZ0FDZ0NBQ0VLSUFwQndBQnhJUXNnQzBFQVJpRU1JQXdFUUNBQVFUeHFJUTBnRFNnQ0FDRU9JQWdoQXlBUElBNDJBZ0FnRDBFRWFpRVFJQkJCazZnQk5nSUFJQTlCQ0dvaEVTQVJJQU0yQWdCQk5pQVBFQW9oQkNBRVFRQkdJUVVnQlVVRVFDQUFRY3NBYWlFR0lBWkJmem9BQUFzTElBQWdBU0FDRUM0aEJ5QVRKQTBnQnc4TDBBRUJGWDhqRFNFV0lBQXNBQUFoQ3lBQkxBQUFJUXdnQzBFWWRFRVlkU0FNUVJoMFFSaDFSeUVOSUF0QkdIUkJHSFZCQUVZaERpQU9JQTF5SVJRZ0ZBUkFJQXdoQkNBTElRVUZJQUVoQWlBQUlRTURRQUpBSUFOQkFXb2hEeUFDUVFGcUlSQWdEeXdBQUNFUklCQXNBQUFoRWlBUlFSaDBRUmgxSUJKQkdIUkJHSFZISVFZZ0VVRVlkRUVZZFVFQVJpRUhJQWNnQm5JaEV5QVRCRUFnRWlFRUlCRWhCUXdCQlNBUUlRSWdEeUVEQ3d3QkN3c0xJQVZCL3dGeElRZ2dCRUgvQVhFaENTQUlJQWxySVFvZ0NnOEx3d1FCTFg4akRTRXZJdzFCNEFGcUpBMGpEU01PVGdSQVFlQUJFQU1MSUM5QitBQnFJUnNnTDBIUUFHb2hKaUF2SVNnZ0wwR0lBV29oS1NBbVFnQTNBZ0FnSmtFSWFrSUFOd0lBSUNaQkVHcENBRGNDQUNBbVFSaHFRZ0EzQWdBZ0prRWdha0lBTndJQUlBSW9BZ0FoTFNBYklDMDJBZ0JCQUNBQklCc2dLQ0FtRURZaEtpQXFRUUJJSVNzZ0t3UkFRWDhoQkFVZ0FFSE1BR29oTENBc0tBSUFJUWNnQjBGL1NpRUlJQWdFUUNBQUVEY2hDU0FKSVNjRlFRQWhKd3NnQUNnQ0FDRUtJQXBCSUhFaEN5QUFRY29BYWlFTUlBd3NBQUFoRFNBTlFSaDBRUmgxUVFGSUlRNGdEZ1JBSUFwQlgzRWhEeUFBSUE4MkFnQUxJQUJCTUdvaEVDQVFLQUlBSVJFZ0VVRUFSaUVTSUJJRVFDQUFRU3hxSVJRZ0ZDZ0NBQ0VWSUJRZ0tUWUNBQ0FBUVJ4cUlSWWdGaUFwTmdJQUlBQkJGR29oRnlBWElDazJBZ0FnRUVIUUFEWUNBQ0FwUWRBQWFpRVlJQUJCRUdvaEdTQVpJQmcyQWdBZ0FDQUJJQnNnS0NBbUVEWWhHaUFWUVFCR0lSd2dIQVJBSUJvaEJRVWdBRUVrYWlFZElCMG9BZ0FoSGlBQVFRQkJBQ0FlUVFkeFFRaHFFUUFBR2lBWEtBSUFJUjhnSDBFQVJpRWdJQ0FFZjBGL0JTQWFDeUVESUJRZ0ZUWUNBQ0FRUVFBMkFnQWdHVUVBTmdJQUlCWkJBRFlDQUNBWFFRQTJBZ0FnQXlFRkN3VWdBQ0FCSUJzZ0tDQW1FRFloRXlBVElRVUxJQUFvQWdBaElTQWhRU0J4SVNJZ0lrRUFSaUVqSUNNRWZ5QUZCVUYvQ3lFR0lDRWdDM0loSkNBQUlDUTJBZ0FnSjBFQVJpRWxJQ1ZGQkVBZ0FCQTRDeUFHSVFRTElDOGtEU0FFRHd2b0tnUG5BbjhPZmdGOEl3MGg2d0lqRFVIQUFHb2tEU01OSXc1T0JFQkJ3QUFRQXdzZzZ3SkJFR29oa2dJZzZ3SWhuUUlnNndKQkdHb2hxQUlnNndKQkNHb2hzd0lnNndKQkZHb2h2UUlna2dJZ0FUWUNBQ0FBUVFCSElVOGdxQUpCS0dvaFdpQmFJV1FncUFKQkoyb2hieUN6QWtFRWFpRjZRUUFoRmtFQUlSZEJBQ0VoSUFFaHZRRURRQUpBSUJkQmYwb2hoQUVDUUNDRUFRUkFRZi8vLy84SElCZHJJWTRCSUJZZ2pnRktJWmNCSUpjQkJFQVFNU0doQVNDaEFVSExBRFlDQUVGL0lTb01BZ1VnRmlBWGFpR3FBU0NxQVNFcURBSUxBQVVnRnlFcUN3c2d2UUVzQUFBaHN3RWdzd0ZCR0hSQkdIVkJBRVloeHdFZ3h3RUVRRUhXQUNIcUFnd0JCU0N6QVNIU0FTQzlBU0huQVFzRFFBSkFBa0FDUUFKQUFrQWcwZ0ZCR0hSQkdIVkJBR3NPSmdFQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQUFnc0NRQ0RuQVNFWklPY0JJZnNCUVFraDZnSU1CQXdEQUFzQUN3SkFJT2NCSVJnZzV3RWhod0lNQXd3Q0FBc0FDd0VMSU9jQlFRRnFJZDBCSUpJQ0lOMEJOZ0lBSU4wQkxBQUFJVW9nU2lIU0FTRGRBU0huQVF3QkN3c0NRQ0RxQWtFSlJnUkFBMEFDUUVFQUllb0NJUHNCUVFGcUlmSUJJUElCTEFBQUlmd0JJUHdCUVJoMFFSaDFRU1ZHSWYwQklQMEJSUVJBSUJraEdDRDdBU0dIQWd3RUN5QVpRUUZxSWY0QklQc0JRUUpxSWY4QklKSUNJUDhCTmdJQUlQOEJMQUFBSVlBQ0lJQUNRUmgwUVJoMVFTVkdJWUVDSUlFQ0JFQWcvZ0VoR1NEL0FTSDdBVUVKSWVvQ0JTRCtBU0VZSVA4QklZY0NEQUVMREFFTEN3c0xJQmdoZ2dJZ3ZRRWhnd0lnZ2dJZ2d3SnJJWVFDSUU4RVFDQUFJTDBCSUlRQ0VEa0xJSVFDUVFCR0lZVUNJSVVDUlFSQUlDRWhJaUNFQWlFV0lDb2hGeUNIQWlHOUFTQWlJU0VNQWdzZ2h3SkJBV29oaGdJZ2hnSXNBQUFoaUFJZ2lBSkJHSFJCR0hVaGlRSWdpUUpCVUdvaDN3SWczd0pCQ2traDNBSWczQUlFUUNDSEFrRUNhaUdLQWlDS0Fpd0FBQ0dMQWlDTEFrRVlkRUVZZFVFa1JpR01BaUNIQWtFRGFpR05BaUNNQWdSL0lJMENCU0NHQWdzaFJDQ01BZ1IvUVFFRklDRUxJUWtnakFJRWZ5RGZBZ1ZCZndzaDRBSWc0QUloR3lBSklUQWdSQ0huQWdWQmZ5RWJJQ0VoTUNDR0FpSG5BZ3Nna2dJZzV3STJBZ0FnNXdJc0FBQWhqZ0lnamdKQkdIUkJHSFVoandJZ2p3SkJZR29oa0FJZ2tBSkJIMHNoa1FKQkFTQ1FBblFoa3dJZ2t3SkJpZEVFY1NHVUFpQ1VBa0VBUmlHVkFpQ1JBaUNWQW5JaHpRSWd6UUlFUUVFQUlSOGdqZ0loU1NEbkFpR25BZ1ZCQUNFZ0lJNENJWmNDSU9jQ0lad0NBMEFDUUNDWEFrRVlkRUVZZFNHV0FpQ1dBa0ZnYWlHWUFrRUJJSmdDZENHWkFpQ1pBaUFnY2lHYUFpQ2NBa0VCYWlHYkFpQ1NBaUNiQWpZQ0FDQ2JBaXdBQUNHZUFpQ2VBa0VZZEVFWWRTR2ZBaUNmQWtGZ2FpR2dBaUNnQWtFZlN5R2hBa0VCSUtBQ2RDR2lBaUNpQWtHSjBRUnhJYU1DSUtNQ1FRQkdJYVFDSUtFQ0lLUUNjaUhNQWlETUFnUkFJSm9DSVI4Z25nSWhTU0NiQWlHbkFnd0JCU0NhQWlFZ0lKNENJWmNDSUpzQ0lad0NDd3dCQ3dzTElFbEJHSFJCR0hWQktrWWhwUUlncFFJRVFDQ25Ba0VCYWlHbUFpQ21BaXdBQUNHcEFpQ3BBa0VZZEVFWWRTR3FBaUNxQWtGUWFpSGlBaURpQWtFS1NTSGVBaURlQWdSQUlLY0NRUUpxSWFzQ0lLc0NMQUFBSWF3Q0lLd0NRUmgwUVJoMVFTUkdJYTBDSUswQ0JFQWdCQ0RpQWtFQ2RHb2hyZ0lncmdKQkNqWUNBQ0NtQWl3QUFDR3ZBaUN2QWtFWWRFRVlkU0d3QWlDd0FrRlFhaUd4QWlBRElMRUNRUU4wYWlHeUFpQ3lBaWtEQUNINUFpRDVBcWNodEFJZ3B3SkJBMm9odFFJZ3RBSWhIa0VCSVR3Z3RRSWg2QUlGUVJZaDZnSUxCVUVXSWVvQ0N5RHFBa0VXUmdSQVFRQWg2Z0lnTUVFQVJpRzJBaUMyQWtVRVFFRi9JUXdNQXdzZ1R3UkFJQUlvQWdBaHlBSWd5QUlodHdKQkFFRUVhaUhYQWlEWEFpSFdBaURXQWtFQmF5SE9BaUMzQWlET0Ftb2h1QUpCQUVFRWFpSGJBaURiQWlIYUFpRGFBa0VCYXlIWkFpRFpBa0YvY3lIWUFpQzRBaURZQW5FaHVRSWd1UUlodWdJZ3VnSW9BZ0FodXdJZ3VnSkJCR29oeWdJZ0FpREtBallDQUNDN0FpRWVRUUFoUENDbUFpSG9BZ1ZCQUNFZVFRQWhQQ0NtQWlIb0Fnc0xJSklDSU9nQ05nSUFJQjVCQUVnaHZBSWdIMEdBd0FCeUliNENRUUFnSG1zaHZ3SWd2QUlFZnlDK0FnVWdId3NoQ0NDOEFnUi9JTDhDQlNBZUN5RUhJQWNoTFNBSUlTNGdQQ0ZDSU9nQ0ljTUNCU0NTQWhBNkljQUNJTUFDUVFCSUljRUNJTUVDQkVCQmZ5RU1EQUlMSUpJQ0tBSUFJVXNnd0FJaExTQWZJUzRnTUNGQ0lFc2h3d0lMSU1NQ0xBQUFJY0lDSU1JQ1FSaDBRUmgxUVM1R0ljUUNBa0FneEFJRVFDRERBa0VCYWlIRkFpREZBaXdBQUNIR0FpREdBa0VZZEVFWWRVRXFSaUhIQWlESEFrVUVRQ0REQWtFQmFpRmxJSklDSUdVMkFnQWdrZ0lRT2lGbUlKSUNLQUlBSVUwZ1ppRWNJRTBoVEF3Q0N5RERBa0VDYWlGUUlGQXNBQUFoVVNCUlFSaDBRUmgxSVZJZ1VrRlFhaUhoQWlEaEFrRUtTU0hkQWlEZEFnUkFJTU1DUVFOcUlWTWdVeXdBQUNGVUlGUkJHSFJCR0hWQkpFWWhWU0JWQkVBZ0JDRGhBa0VDZEdvaFZpQldRUW8yQWdBZ1VDd0FBQ0ZYSUZkQkdIUkJHSFVoV0NCWVFWQnFJVmtnQXlCWlFRTjBhaUZiSUZzcEF3QWg3UUlnN1FLbklWd2d3d0pCQkdvaFhTQ1NBaUJkTmdJQUlGd2hIQ0JkSVV3TUF3c0xJRUpCQUVZaFhpQmVSUVJBUVg4aERBd0RDeUJQQkVBZ0FpZ0NBQ0hKQWlESkFpRmZRUUJCQkdvaDBRSWcwUUloMEFJZzBBSkJBV3NoendJZ1h5RFBBbW9oWUVFQVFRUnFJZFVDSU5VQ0lkUUNJTlFDUVFGcklkTUNJTk1DUVg5eklkSUNJR0FnMGdKeElXRWdZU0ZpSUdJb0FnQWhZeUJpUVFScUljc0NJQUlneXdJMkFnQWdZeUg1QVFWQkFDSDVBUXNna2dJZ1VEWUNBQ0Q1QVNFY0lGQWhUQVZCZnlFY0lNTUNJVXdMQzBFQUlSb2dUQ0ZvQTBBQ1FDQm9MQUFBSVdjZ1owRVlkRUVZZFNGcElHbEJ2MzlxSVdvZ2FrRTVTeUZySUdzRVFFRi9JUXdNQXdzZ2FFRUJhaUZzSUpJQ0lHdzJBZ0FnYUN3QUFDRnRJRzFCR0hSQkdIVWhiaUJ1UWI5L2FpRndRY0lqSUJwQk9teHFJSEJxSVhFZ2NTd0FBQ0Z5SUhKQi93RnhJWE1nYzBGL2FpRjBJSFJCQ0VraGRTQjFCRUFnY3lFYUlHd2hhQVVNQVFzTUFRc0xJSEpCR0hSQkdIVkJBRVloZGlCMkJFQkJmeUVNREFFTElISkJHSFJCR0hWQkUwWWhkeUFiUVg5S0lYZ0NRQ0IzQkVBZ2VBUkFRWDhoREF3REJVRXdJZW9DQ3dVZ2VBUkFJQVFnRzBFQ2RHb2hlU0I1SUhNMkFnQWdBeUFiUVFOMGFpRjdJSHNwQXdBaDdnSWduUUlnN2dJM0F3QkJNQ0hxQWd3Q0N5QlBSUVJBUVFBaERBd0RDeUNkQWlCeklBSVFPd3NMSU9vQ1FUQkdCRUJCQUNIcUFpQlBSUVJBUVFBaEZpQXFJUmNnUWlFaElHd2h2UUVNQXdzTElHZ3NBQUFoZkNCOFFSaDBRUmgxSVgwZ0drRUFSeUYrSUgxQkQzRWhmeUIvUVFOR0lZQUJJSDRnZ0FGeEllUUNJSDFCWDNFaGdRRWc1QUlFZnlDQkFRVWdmUXNoRVNBdVFZREFBSEVoZ2dFZ2dnRkJBRVloZ3dFZ0xrSC8vM3R4SVlVQklJTUJCSDhnTGdVZ2hRRUxJUzhDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBZ0VVSEJBR3NPT0EwVkN4VVFEdzRWRlJVVkZSVVZGUlVWRlF3VkZSVVZBaFVWRlJVVkZSVVZFUlVJQmhRVEVoVUZGUlVWQ1FBRUFSVVZDaFVIRlJVREZRc0NRQ0FhUWY4QmNTSHBBZ0pBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQ0RwQWtFWWRFRVlkVUVBYXc0SUFBRUNBd1FIQlFZSEN3SkFJSjBDS0FJQUlZWUJJSVlCSUNvMkFnQkJBQ0VXSUNvaEZ5QkNJU0VnYkNHOUFRd2lEQWdBQ3dBTEFrQWduUUlvQWdBaGh3RWdod0VnS2pZQ0FFRUFJUllnS2lFWElFSWhJU0JzSWIwQkRDRU1Cd0FMQUFzQ1FDQXFyQ0h2QWlDZEFpZ0NBQ0dJQVNDSUFTRHZBamNEQUVFQUlSWWdLaUVYSUVJaElTQnNJYjBCRENBTUJnQUxBQXNDUUNBcVFmLy9BM0VoaVFFZ25RSW9BZ0FoaWdFZ2lnRWdpUUU3QVFCQkFDRVdJQ29oRnlCQ0lTRWdiQ0c5QVF3ZkRBVUFDd0FMQWtBZ0trSC9BWEVoaXdFZ25RSW9BZ0FoakFFZ2pBRWdpd0U2QUFCQkFDRVdJQ29oRnlCQ0lTRWdiQ0c5QVF3ZURBUUFDd0FMQWtBZ25RSW9BZ0FoalFFZ2pRRWdLallDQUVFQUlSWWdLaUVYSUVJaElTQnNJYjBCREIwTUF3QUxBQXNDUUNBcXJDSHdBaUNkQWlnQ0FDR1BBU0NQQVNEd0FqY0RBRUVBSVJZZ0tpRVhJRUloSVNCc0liMEJEQndNQWdBTEFBc0NRRUVBSVJZZ0tpRVhJRUloSVNCc0liMEJEQnNBQ3dBTERCWUFDd0FMQWtBZ0hFRUlTeUdRQVNDUUFRUi9JQndGUVFnTElaRUJJQzlCQ0hJaGtnRkIrQUFoSmlDUkFTRXNJSklCSVVGQlBDSHFBZ3dWQUFzQUN3RUxBa0FnRVNFbUlCd2hMQ0F2SVVGQlBDSHFBZ3dUQUFzQUN3SkFJSjBDS1FNQUlmSUNJUElDSUZvUVBTR2JBU0F2UVFoeElad0JJSndCUVFCR0laMEJJSnNCSVo0QklHUWduZ0ZySVo4QklCd2dud0ZLSWFBQklKOEJRUUZxSWFJQklKMEJJS0FCY2lHakFTQ2pBUVIvSUJ3RklLSUJDeUVkSUpzQklRMUJBQ0VsUVpJbklTY2dIU0U0SUM4aFJpRHlBaUgyQWtIQ0FDSHFBZ3dTQUFzQUN3RUxBa0FnblFJcEF3QWg4d0lnOHdKQ0FGTWhwQUVncEFFRVFFSUFJUE1DZlNIMEFpQ2RBaUQwQWpjREFFRUJJUkJCa2ljaEVpRDBBaUgxQWtIQkFDSHFBZ3dTQlNBdlFZQVFjU0dsQVNDbEFVRUFSaUdtQVNBdlFRRnhJYWNCSUtjQlFRQkdJYWdCSUtnQkJIOUJraWNGUVpRbkN5RUZJS1lCQkg4Z0JRVkJreWNMSVFZZ0wwR0JFSEVocVFFZ3FRRkJBRWNocXdFZ3F3RkJBWEVoUFNBOUlSQWdCaUVTSVBNQ0lmVUNRY0VBSWVvQ0RCSUxBQXdRQUFzQUN3SkFJSjBDS1FNQUlld0NRUUFoRUVHU0p5RVNJT3dDSWZVQ1FjRUFJZW9DREE4QUN3QUxBa0FnblFJcEF3QWg5d0lnOXdLblFmOEJjU0c0QVNCdklMZ0JPZ0FBSUc4aE1VRUFJVEpCa2ljaE15QmFJVGRCQVNGSElJVUJJVWdNRGdBTEFBc0NRQkF4SWJrQklMa0JLQUlBSWJvQklMb0JFRDhodXdFZ3V3RWhJMEhHQUNIcUFnd05BQXNBQ3dKQUlKMENLQUlBSWJ3QklMd0JRUUJISWI0QklMNEJCSDhndkFFRlFad25DeUcvQVNDL0FTRWpRY1lBSWVvQ0RBd0FDd0FMQWtBZ25RSXBBd0FoK0FJZytBS25JY1lCSUxNQ0lNWUJOZ0lBSUhwQkFEWUNBQ0NkQWlDekFqWUNBRUYvSVVVZ3N3SWgrZ0ZCeWdBaDZnSU1Dd0FMQUFzQ1FDQ2RBaWdDQUNGT0lCeEJBRVloeUFFZ3lBRUVRQ0FBUVNBZ0xVRUFJQzhRUVVFQUlSUkIwd0FoNmdJRklCd2hSU0JPSWZvQlFjb0FJZW9DQ3d3S0FBc0FDd0VMQVFzQkN3RUxBUXNCQ3dFTEFrQWduUUlyQXdBaCtnSWdBQ0Q2QWlBdElCd2dMeUFSRUVNaDRBRWc0QUVoRmlBcUlSY2dRaUVoSUd3aHZRRU1CUXdDQUFzQUN3SkFJTDBCSVRGQkFDRXlRWkluSVRNZ1dpRTNJQndoUnlBdklVZ0xDd3NDUUNEcUFrRThSZ1JBUVFBaDZnSWduUUlwQXdBaDhRSWdKa0VnY1NHVEFTRHhBaUJhSUpNQkVEd2hsQUVnOFFKQ0FGRWhsUUVnUVVFSWNTR1dBU0NXQVVFQVJpR1lBU0NZQVNDVkFYSWg1UUlnSmtFRWRTR1pBVUdTSnlDWkFXb2htZ0VnNVFJRWYwR1NKd1VnbWdFTElUNGc1UUlFZjBFQUJVRUNDeUUvSUpRQklRMGdQeUVsSUQ0aEp5QXNJVGdnUVNGR0lQRUNJZllDUWNJQUllb0NCU0RxQWtIQkFFWUVRRUVBSWVvQ0lQVUNJRm9RUGlHc0FTQ3NBU0VOSUJBaEpTQVNJU2NnSENFNElDOGhSaUQxQWlIMkFrSENBQ0hxQWdVZzZnSkJ4Z0JHQkVCQkFDSHFBaUFqUVFBZ0hCQkFJY0FCSU1BQlFRQkdJY0VCSU1BQkljSUJJQ01od3dFZ3dnRWd3d0ZySWNRQklDTWdIR29oeFFFZ3dRRUVmeUFjQlNERUFRc2hRQ0RCQVFSL0lNVUJCU0RBQVFzaEt5QWpJVEZCQUNFeVFaSW5JVE1nS3lFM0lFQWhSeUNGQVNGSUJTRHFBa0hLQUVZRVFFRUFJZW9DSVBvQklROUJBQ0VWUVFBaEtRTkFBa0FnRHlnQ0FDSEpBU0RKQVVFQVJpSEtBU0RLQVFSQUlCVWhFeUFwSVRZTUFRc2d2UUlneVFFUVFpSExBU0RMQVVFQVNDSE1BU0JGSUJWckljMEJJTXNCSU0wQlN5SE9BU0RNQVNET0FYSWg1Z0lnNWdJRVFDQVZJUk1neXdFaE5nd0JDeUFQUVFScUljOEJJTXNCSUJWcUlkQUJJRVVnMEFGTElkRUJJTkVCQkVBZ3p3RWhEeURRQVNFVklNc0JJU2tGSU5BQklSTWd5d0VoTmd3QkN3d0JDd3NnTmtFQVNDSFRBU0RUQVFSQVFYOGhEQXdHQ3lBQVFTQWdMU0FUSUM4UVFTQVRRUUJHSWRRQklOUUJCRUJCQUNFVVFkTUFJZW9DQlNENkFTRWtRUUFoS0FOQUFrQWdKQ2dDQUNIVkFTRFZBVUVBUmlIV0FTRFdBUVJBSUJNaEZFSFRBQ0hxQWd3SUN5QzlBaURWQVJCQ0lkY0JJTmNCSUNocUlkZ0JJTmdCSUJOS0lka0JJTmtCQkVBZ0V5RVVRZE1BSWVvQ0RBZ0xJQ1JCQkdvaDJnRWdBQ0M5QWlEWEFSQTVJTmdCSUJOSklkc0JJTnNCQkVBZzJnRWhKQ0RZQVNFb0JTQVRJUlJCMHdBaDZnSU1BUXNNQVFzTEN3c0xDd3NMSU9vQ1FjSUFSZ1JBUVFBaDZnSWdPRUYvU2lHdEFTQkdRZi8vZTNFaHJnRWdyUUVFZnlDdUFRVWdSZ3NoQ2lEMkFrSUFVaUd2QVNBNFFRQkhJYkFCSUxBQklLOEJjaUhqQWlBTkliRUJJR1Fnc1FGckliSUJJSzhCUVFGekliUUJJTFFCUVFGeEliVUJJTElCSUxVQmFpRzJBU0E0SUxZQlNpRzNBU0MzQVFSL0lEZ0ZJTFlCQ3lFNUlPTUNCSDhnT1FVZ09Bc2hPaURqQWdSL0lBMEZJRm9MSVE0Z0RpRXhJQ1VoTWlBbklUTWdXaUUzSURvaFJ5QUtJVWdGSU9vQ1FkTUFSZ1JBUVFBaDZnSWdMMEdBd0FCeklkd0JJQUJCSUNBdElCUWczQUVRUVNBdElCUktJZDRCSU40QkJIOGdMUVVnRkFzaDN3RWczd0VoRmlBcUlSY2dRaUVoSUd3aHZRRU1Bd3NMSURjaDRRRWdNU0hpQVNEaEFTRGlBV3NoNHdFZ1J5RGpBVWdoNUFFZzVBRUVmeURqQVFVZ1J3c2hDeUFMSURKcUllVUJJQzBnNVFGSUllWUJJT1lCQkg4ZzVRRUZJQzBMSVRzZ0FFRWdJRHNnNVFFZ1NCQkJJQUFnTXlBeUVEa2dTRUdBZ0FSekllZ0JJQUJCTUNBN0lPVUJJT2dCRUVFZ0FFRXdJQXNnNHdGQkFCQkJJQUFnTVNEakFSQTVJRWhCZ01BQWN5SHBBU0FBUVNBZ095RGxBU0RwQVJCQklEc2hGaUFxSVJjZ1FpRWhJR3dodlFFTUFRc0xBa0FnNmdKQjFnQkdCRUFnQUVFQVJpSHFBU0RxQVFSQUlDRkJBRVloNndFZzZ3RUVRRUVBSVF3RlFRRWhOUU5BQWtBZ0JDQTFRUUowYWlIc0FTRHNBU2dDQUNIdEFTRHRBVUVBUmlIdUFTRHVBUVJBSURVaE5Bd0JDeUFESURWQkEzUnFJZkFCSVBBQklPMEJJQUlRT3lBMVFRRnFJZkVCSURWQkNVZ2g4d0VnOHdFRVFDRHhBU0UxQlNEeEFTRTBEQUVMREFFTEN5QTBRUXBJSWU4QklPOEJCRUFnTkNGREEwQUNRQ0FFSUVOQkFuUnFJZllCSVBZQktBSUFJZmNCSVBjQlFRQkdJZmdCSVBnQlJRUkFRWDhoREF3SEN5QkRRUUZxSWZRQklFTkJDVWdoOVFFZzlRRUVRQ0QwQVNGREJVRUJJUXdNQVFzTUFRc0xCVUVCSVF3TEN3VWdLaUVNQ3dzTElPc0NKQTBnREE4TEN3RUNmeU1OSVFKQkFBOExDUUVDZnlNTklRSVBDeXdCQlg4akRTRUhJQUFvQWdBaEF5QURRU0J4SVFRZ0JFRUFSaUVGSUFVRVFDQUJJQUlnQUJCUUdnc1BDNklCQVJKL0l3MGhFaUFBS0FJQUlRTWdBeXdBQUNFRUlBUkJHSFJCR0hVaEJTQUZRVkJxSVE4Z0QwRUtTU0VOSUEwRVFFRUFJUUlnQXlFSklBOGhFQU5BQWtBZ0FrRUtiQ0VHSUJBZ0Jtb2hCeUFKUVFGcUlRZ2dBQ0FJTmdJQUlBZ3NBQUFoQ2lBS1FSaDBRUmgxSVFzZ0MwRlFhaUVPSUE1QkNra2hEQ0FNQkVBZ0J5RUNJQWdoQ1NBT0lSQUZJQWNoQVF3QkN3d0JDd3NGUVFBaEFRc2dBUThMbVFvRGtBRi9CMzRDZkNNTklaSUJJQUZCRkVzaEZnSkFJQlpGQkVBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FnQVVFSmF3NEtBQUVDQXdRRkJnY0lDUW9MQWtBZ0FpZ0NBQ0UzSURjaEgwRUFRUVJxSVUwZ1RTRk1JRXhCQVdzaFN5QWZJRXRxSVNsQkFFRUVhaUZSSUZFaFVDQlFRUUZySVU4Z1QwRi9jeUZPSUNrZ1RuRWhNaUF5SVRRZ05DZ0NBQ0UxSURSQkJHb2hRU0FDSUVFMkFnQWdBQ0ExTmdJQURBME1Dd0FMQUFzQ1FDQUNLQUlBSVRzZ095RTJRUUJCQkdvaFZDQlVJVk1nVTBFQmF5RlNJRFlnVW1vaEJVRUFRUVJxSVZnZ1dDRlhJRmRCQVdzaFZpQldRWDl6SVZVZ0JTQlZjU0VHSUFZaEJ5QUhLQUlBSVFnZ0IwRUVhaUZJSUFJZ1NEWUNBQ0FJckNHVEFTQUFJSk1CTndNQURBd01DZ0FMQUFzQ1FDQUNLQUlBSVQ4Z1B5RUpRUUJCQkdvaFd5QmJJVm9nV2tFQmF5RlpJQWtnV1dvaENrRUFRUVJxSVY4Z1h5RmVJRjVCQVdzaFhTQmRRWDl6SVZ3Z0NpQmNjU0VMSUFzaERDQU1LQUlBSVEwZ0RFRUVhaUZKSUFJZ1NUWUNBQ0FOclNHVUFTQUFJSlFCTndNQURBc01DUUFMQUFzQ1FDQUNLQUlBSVVBZ1FDRU9RUUJCQ0dvaFlpQmlJV0VnWVVFQmF5RmdJQTRnWUdvaEQwRUFRUWhxSVdZZ1ppRmxJR1ZCQVdzaFpDQmtRWDl6SVdNZ0R5QmpjU0VRSUJBaEVTQVJLUU1BSVpVQklCRkJDR29oU2lBQ0lFbzJBZ0FnQUNDVkFUY0RBQXdLREFnQUN3QUxBa0FnQWlnQ0FDRTRJRGdoRWtFQVFRUnFJV2tnYVNGb0lHaEJBV3NoWnlBU0lHZHFJUk5CQUVFRWFpRnRJRzBoYkNCc1FRRnJJV3NnYTBGL2N5RnFJQk1nYW5FaEZDQVVJUlVnRlNnQ0FDRVhJQlZCQkdvaFFpQUNJRUkyQWdBZ0YwSC8vd054SVJnZ0dFRVFkRUVRZGF3aGxnRWdBQ0NXQVRjREFBd0pEQWNBQ3dBTEFrQWdBaWdDQUNFNUlEa2hHVUVBUVFScUlYQWdjQ0Z2SUc5QkFXc2hiaUFaSUc1cUlScEJBRUVFYWlGMElIUWhjeUJ6UVFGcklYSWdja0YvY3lGeElCb2djWEVoR3lBYklSd2dIQ2dDQUNFZElCeEJCR29oUXlBQ0lFTTJBZ0FnSFVILy93TnhJUVFnQkswaGx3RWdBQ0NYQVRjREFBd0lEQVlBQ3dBTEFrQWdBaWdDQUNFNklEb2hIa0VBUVFScUlYY2dkeUYySUhaQkFXc2hkU0FlSUhWcUlTQkJBRUVFYWlGN0lIc2hlaUI2UVFGcklYa2dlVUYvY3lGNElDQWdlSEVoSVNBaElTSWdJaWdDQUNFaklDSkJCR29oUkNBQ0lFUTJBZ0FnSTBIL0FYRWhKQ0FrUVJoMFFSaDFyQ0dZQVNBQUlKZ0JOd01BREFjTUJRQUxBQXNDUUNBQ0tBSUFJVHdnUENFbFFRQkJCR29oZmlCK0lYMGdmVUVCYXlGOElDVWdmR29oSmtFQVFRUnFJWUlCSUlJQklZRUJJSUVCUVFGcklZQUJJSUFCUVg5eklYOGdKaUIvY1NFbklDY2hLQ0FvS0FJQUlTb2dLRUVFYWlGRklBSWdSVFlDQUNBcVFmOEJjU0VESUFPdElaa0JJQUFnbVFFM0F3QU1CZ3dFQUFzQUN3SkFJQUlvQWdBaFBTQTlJU3RCQUVFSWFpR0ZBU0NGQVNHRUFTQ0VBVUVCYXlHREFTQXJJSU1CYWlFc1FRQkJDR29oaVFFZ2lRRWhpQUVnaUFGQkFXc2hod0VnaHdGQmYzTWhoZ0VnTENDR0FYRWhMU0F0SVM0Z0xpc0RBQ0dhQVNBdVFRaHFJVVlnQWlCR05nSUFJQUFnbWdFNUF3QU1CUXdEQUFzQUN3SkFJQUlvQWdBaFBpQStJUzlCQUVFSWFpR01BU0NNQVNHTEFTQ0xBVUVCYXlHS0FTQXZJSW9CYWlFd1FRQkJDR29oa0FFZ2tBRWhqd0VnandGQkFXc2hqZ0VnamdGQmYzTWhqUUVnTUNDTkFYRWhNU0F4SVRNZ015c0RBQ0diQVNBelFRaHFJVWNnQWlCSE5nSUFJQUFnbXdFNUF3QU1CQXdDQUFzQUN3d0NDd3NMRHd1UUFRSU9md0orSXcwaEVDQUFRZ0JSSVFnZ0NBUkFJQUVoQXdVZ0FTRUVJQUFoRVFOQUFrQWdFYWNoQ1NBSlFROXhJUXBCeGljZ0Ntb2hDeUFMTEFBQUlRd2dERUgvQVhFaERTQU5JQUp5SVE0Z0RrSC9BWEVoQlNBRVFYOXFJUVlnQmlBRk9nQUFJQkZDQklnaEVpQVNRZ0JSSVFjZ0J3UkFJQVloQXd3QkJTQUdJUVFnRWlFUkN3d0JDd3NMSUFNUEMzVUNDbjhDZmlNTklRc2dBRUlBVVNFRUlBUUVRQ0FCSVFJRklBQWhEQ0FCSVFNRFFBSkFJQXluUWY4QmNTRUZJQVZCQjNFaEJpQUdRVEJ5SVFjZ0EwRi9haUVJSUFnZ0J6b0FBQ0FNUWdPSUlRMGdEVUlBVVNFSklBa0VRQ0FJSVFJTUFRVWdEU0VNSUFnaEF3c01BUXNMQ3lBQ0R3djlBUUlXZndOK0l3MGhGeUFBUXYvLy8vOFBWaUVPSUFDbklSUWdEZ1JBSUFBaEdDQUJJUVVEUUFKQUlCaENDb0loR1NBWnAwSC9BWEVoRHlBUFFUQnlJUkFnQlVGL2FpRVJJQkVnRURvQUFDQVlRZ3FBSVJvZ0dFTC8vLy8vbndGV0lSSWdFZ1JBSUJvaEdDQVJJUVVGREFFTERBRUxDeUFhcHlFVklCVWhBaUFSSVFRRklCUWhBaUFCSVFRTElBSkJBRVloRXlBVEJFQWdCQ0VHQlNBQ0lRTWdCQ0VIQTBBQ1FDQURRUXB3UVg5eElRZ2dDRUV3Y2lFSklBbEIvd0Z4SVFvZ0IwRi9haUVMSUFzZ0Nqb0FBQ0FEUVFwdVFYOXhJUXdnQTBFS1NTRU5JQTBFUUNBTElRWU1BUVVnRENFRElBc2hCd3NNQVFzTEN5QUdEd3NtQVFaL0l3MGhCaEJLSVFFZ0FVRzhBV29oQWlBQ0tBSUFJUU1nQUNBREVFc2hCQ0FFRHd1SEJRRTRmeU1OSVRvZ0FVSC9BWEVoSmlBQUlURWdNVUVEY1NFeUlESkJBRWNoTXlBQ1FRQkhJVFFnTkNBemNTRTRBa0FnT0FSQUlBRkIvd0Z4SVRVZ0FDRUdJQUloQ1FOQUFrQWdCaXdBQUNFMklEWkJHSFJCR0hVZ05VRVlkRUVZZFVZaEVpQVNCRUFnQmlFRklBa2hDRUVHSVRrTUJBc2dCa0VCYWlFVElBbEJmMm9oRkNBVElSVWdGVUVEY1NFV0lCWkJBRWNoRnlBVVFRQkhJUmdnR0NBWGNTRTNJRGNFUUNBVElRWWdGQ0VKQlNBVElRUWdGQ0VISUJnaEVVRUZJVGtNQVFzTUFRc0xCU0FBSVFRZ0FpRUhJRFFoRVVFRklUa0xDeUE1UVFWR0JFQWdFUVJBSUFRaEJTQUhJUWhCQmlFNUJTQUVJUTVCQUNFUUN3c0NRQ0E1UVFaR0JFQWdCU3dBQUNFWklBRkIvd0Z4SVJvZ0dVRVlkRUVZZFNBYVFSaDBRUmgxUmlFYklCc0VRQ0FGSVE0Z0NDRVFCU0FtUVlHQ2hBaHNJUndnQ0VFRFN5RWRBa0FnSFFSQUlBVWhDaUFJSVF3RFFBSkFJQW9vQWdBaEhpQWVJQnh6SVI4Z0gwSC8vZnQzYWlFZ0lCOUJnSUdDaEhoeElTRWdJVUdBZ1lLRWVITWhJaUFpSUNCeElTTWdJMEVBUmlFa0lDUkZCRUFNQVFzZ0NrRUVhaUVsSUF4QmZHb2hKeUFuUVFOTElTZ2dLQVJBSUNVaENpQW5JUXdGSUNVaEF5QW5JUXRCQ3lFNURBUUxEQUVMQ3lBS0lRMGdEQ0VQQlNBRklRTWdDQ0VMUVFzaE9Rc0xJRGxCQzBZRVFDQUxRUUJHSVNrZ0tRUkFJQU1oRGtFQUlSQU1CQVVnQXlFTklBc2hEd3NMQTBBQ1FDQU5MQUFBSVNvZ0trRVlkRUVZZFNBYVFSaDBRUmgxUmlFcklDc0VRQ0FOSVE0Z0R5RVFEQVVMSUExQkFXb2hMQ0FQUVg5cUlTMGdMVUVBUmlFdUlDNEVRQ0FzSVE1QkFDRVFEQUVGSUN3aERTQXRJUThMREFFTEN3c0xDeUFRUVFCSElTOGdMd1IvSUE0RlFRQUxJVEFnTUE4THpBRUJFWDhqRFNFVkl3MUJnQUpxSkEwakRTTU9UZ1JBUVlBQ0VBTUxJQlVoRGlBRVFZREFCSEVoRHlBUFFRQkdJUkFnQWlBRFNpRVJJQkVnRUhFaEV5QVRCRUFnQWlBRGF5RVNJQkpCZ0FKSklRY2dCd1IvSUJJRlFZQUNDeUVJSUE0Z0FTQUlFRjRhSUJKQi93RkxJUWtnQ1FSQUlBSWdBMnNoQ2lBU0lRWURRQUpBSUFBZ0RrR0FBaEE1SUFaQmdINXFJUXNnQzBIL0FVc2hEQ0FNQkVBZ0N5RUdCUXdCQ3d3QkN3c2dDa0gvQVhFaERTQU5JUVVGSUJJaEJRc2dBQ0FPSUFVUU9Rc2dGU1FORHdzcUFRVi9JdzBoQmlBQVFRQkdJUU1nQXdSQVFRQWhBZ1VnQUNBQlFRQVFSeUVFSUFRaEFnc2dBZzhMM0RBRDBnTi9EMzRoZkNNTklkY0RJdzFCc0FScUpBMGpEU01PVGdSQVFiQUVFQU1MSU5jRFFRaHFJYVVESU5jRElhOERJTmNEUVl3RWFpRzZBeUM2QXlIQ0F5RFhBMEdBQkdvaGJpQ3ZBMEVBTmdJQUlHNUJER29oZUNBQkVFUWgyQU1nMkFOQ0FGTWhoUUVnaFFFRVFDQUJtaUg0QXlENEF5SHFBMEVCSVJ4Qm95Y2hIUVVnQkVHQUVIRWhtQUVnbUFGQkFFWWhvd0VnQkVFQmNTR3VBU0N1QVVFQVJpRzVBU0M1QVFSL1FhUW5CVUdwSndzaEJpQ2pBUVIvSUFZRlFhWW5DeUVISUFSQmdSQnhJY1FCSU1RQlFRQkhJYzhCSU04QlFRRnhJVW9nQVNIcUF5QktJUndnQnlFZEN5RHFBeEJFSWVBRElPQURRb0NBZ0lDQWdJRDQvd0NESWVFRElPRURRb0NBZ0lDQWdJRDQvd0JSSWUwQkFrQWc3UUVFUUNBRlFTQnhJZllCSVBZQlFRQkhJWUVDSUlFQ0JIOUJ0aWNGUWJvbkN5R01BaURxQXlEcUEySkVBQUFBQUFBQUFBQkVBQUFBQUFBQUFBQmljaUdYQWlDQkFnUi9RYjRuQlVIQ0p3c2hvZ0lnbHdJRWZ5Q2lBZ1VnakFJTElSa2dIRUVEYWlHdEFpQUVRZi8vZTNFaHR3SWdBRUVnSUFJZ3JRSWd0d0lRUVNBQUlCMGdIQkE1SUFBZ0dVRURFRGtnQkVHQXdBQnpJY0lDSUFCQklDQUNJSzBDSU1JQ0VFRWdyUUloYlFVZzZnTWdyd01RUlNIOEF5RDhBMFFBQUFBQUFBQUFRS0loL1FNZy9RTkVBQUFBQUFBQUFBQmlJZUFDSU9BQ0JFQWdyd01vQWdBaDZnSWc2Z0pCZjJvaDlRSWdyd01nOVFJMkFnQUxJQVZCSUhJaC93SWcvd0pCNFFCR0lZb0RJSW9EQkVBZ0JVRWdjU0dWQXlDVkEwRUFSaUdZQXlBZFFRbHFJWmtESUpnREJIOGdIUVVnbVFNTElSNGdIRUVDY2lHYUF5QURRUXRMSVpzRFFRd2dBMnNobkFNZ25BTkJBRVloblFNZ213TWduUU55SVo0REFrQWduZ01FUUNEOUF5SHVBd1ZFQUFBQUFBQUFJRUFoNndNZ25BTWhLZ05BQWtBZ0trRi9haUdmQXlEckEwUUFBQUFBQUFBd1FLSWgvZ01nbndOQkFFWWhvQU1nb0FNRVFBd0JCU0QrQXlIckF5Q2ZBeUVxQ3d3QkN3c2dIaXdBQUNHaEF5Q2hBMEVZZEVFWWRVRXRSaUdpQXlDaUF3UkFJUDBEbWlIL0F5RC9BeUQrQTZFaGdBUWcvZ01nZ0FTZ0lZRUVJSUVFbWlHQ0JDQ0NCQ0h1QXd3Q0JTRDlBeUQrQTZBaGd3UWdnd1FnL2dPaElZUUVJSVFFSWU0RERBSUxBQXNMSUs4REtBSUFJYU1ESUtNRFFRQklJYVFEUVFBZ293TnJJYVlESUtRREJIOGdwZ01GSUtNREN5R25BeUNuQTZ3aDVnTWc1Z01nZUJBK0lhZ0RJS2dESUhoR0lha0RJS2tEQkVBZ2JrRUxhaUdxQXlDcUEwRXdPZ0FBSUtvRElSb0ZJS2dESVJvTElLTURRUjkxSWFzRElLc0RRUUp4SWF3RElLd0RRU3RxSWEwRElLMERRZjhCY1NHdUF5QWFRWDlxSWJBRElMQURJSzRET2dBQUlBVkJEMm9oc1FNZ3NRTkIvd0Z4SWJJRElCcEJmbW9oc3dNZ3N3TWdzZ002QUFBZ0EwRUJTQ0cwQXlBRVFRaHhJYlVESUxVRFFRQkdJYllESUxvRElSOGc3Z01oN3dNRFFBSkFJTzhEcWlHM0EwSEdKeUMzQTJvaHVBTWd1QU1zQUFBaHVRTWd1UU5CL3dGeElic0RJSlVESUxzRGNpRzhBeUM4QTBIL0FYRWh2UU1nSDBFQmFpRytBeUFmSUwwRE9nQUFJTGNEdHlHRkJDRHZBeUNGQktFaGhnUWdoZ1JFQUFBQUFBQUFNRUNpSVljRUlMNERJYjhESUw4RElNSURheUhBQXlEQUEwRUJSaUhCQXlEQkF3UkFJSWNFUkFBQUFBQUFBQUFBWVNIREF5QzBBeUREQTNFaHp3TWd0Z01nendOeEljNERJTTREQkVBZ3ZnTWhMZ1VnSDBFQ2FpSEVBeUMrQTBFdU9nQUFJTVFESVM0TEJTQytBeUV1Q3lDSEJFUUFBQUFBQUFBQUFHSWh4UU1neFFNRVFDQXVJUjhnaHdRaDd3TUZEQUVMREFFTEN5QURRUUJHSWNZRElDNGhhQ0RHQXdSQVFSZ2gxZ01GUVg0Z3dnTnJJY2NESU1jRElHaHFJY2dESU1nRElBTklJY2tESU1rREJFQWdBMEVDYWlIS0F5Qm9JTUlEYXlGbklHY2haU0RLQXlGcUJVRVlJZFlEQ3dzZzFnTkJHRVlFUUNCb0lNSURheUhMQXlETEF5RmxJTXNESVdvTElIZ2h6QU1nc3dNaGJ5RE1BeUJ2YXlGd0lIQWdtZ05xSVhFZ2NTQnFhaUZ5SUFCQklDQUNJSElnQkJCQklBQWdIaUNhQXhBNUlBUkJnSUFFY3lGeklBQkJNQ0FDSUhJZ2N4QkJJQUFndWdNZ1pSQTVJR29nWldzaGRDQUFRVEFnZEVFQVFRQVFRU0FBSUxNRElIQVFPU0FFUVlEQUFITWhkU0FBUVNBZ0FpQnlJSFVRUVNCeUlXME1BZ3NnQTBFQVNDRjJJSFlFZjBFR0JTQURDeUZMSU9BQ0JFQWcvUU5FQUFBQUFBQUFzRUdpSWZRRElLOERLQUlBSVhjZ2QwRmthaUY1SUs4RElIazJBZ0FnOUFNaDhBTWdlU0ZpQlNDdkF5Z0NBQ0ZrSVAwRElmQURJR1FoWWdzZ1lrRUFTQ0Y2SUtVRFFhQUNhaUY3SUhvRWZ5Q2xBd1VnZXdzaFZTQlZJUmdnOEFNaDhRTURRQUpBSVBFRHF5RjhJQmdnZkRZQ0FDQVlRUVJxSVgwZ2ZMZ2g5UU1nOFFNZzlRT2hJZllESVBZRFJBQUFBQUJsemMxQm9pSDNBeUQzQTBRQUFBQUFBQUFBQUdJaGZpQitCRUFnZlNFWUlQY0RJZkVEQlF3QkN3d0JDd3NnWWtFQVNpRi9JSDhFUUNCVklTWWdmU0VwSUdJaGdRRURRQUpBSUlFQlFSMUlJWUFCSUlBQkJIOGdnUUVGUVIwTElZSUJJQ2xCZkdvaEZDQVVJQ1pKSVlNQklJTUJCRUFnSmlFNEJTQ0NBYTBoMlFNZ0ZDRVZRUUFoRndOQUFrQWdGU2dDQUNHRUFTQ0VBYTBoMmdNZzJnTWcyUU9HSWRzRElCZXRJZHdESU5zRElOd0RmQ0hkQXlEZEEwS0FsT3ZjQTRJaDNnTWczZ09uSVlZQklCVWdoZ0UyQWdBZzNRTkNnSlRyM0FPQUlkOERJTjhEcHlHSEFTQVZRWHhxSVJNZ0V5QW1TU0dJQVNDSUFRUkFEQUVGSUJNaEZTQ0hBU0VYQ3d3QkN3c2dod0ZCQUVZaGlRRWdpUUVFUUNBbUlUZ0ZJQ1pCZkdvaGlnRWdpZ0VnaHdFMkFnQWdpZ0VoT0FzTElDa2hPUU5BQWtBZ09TQTRTeUdMQVNDTEFVVUVRQXdCQ3lBNVFYeHFJWXdCSUl3QktBSUFJWTBCSUkwQlFRQkdJWTRCSUk0QkJFQWdqQUVoT1FVTUFRc01BUXNMSUs4REtBSUFJWThCSUk4QklJSUJheUdRQVNDdkF5Q1FBVFlDQUNDUUFVRUFTaUdSQVNDUkFRUkFJRGdoSmlBNUlTa2drQUVoZ1FFRklEZ2hKU0E1SVNnZ2tBRWhZd3dCQ3d3QkN3c0ZJRlVoSlNCOUlTZ2dZaUZqQ3lCalFRQklJWklCSUpJQkJFQWdTMEVaYWlHVEFTQ1RBVUVKYlVGL2NTR1VBU0NVQVVFQmFpR1ZBU0QvQWtIbUFFWWhsZ0VnSlNGQUlDZ2hRaUJqSVprQkEwQUNRRUVBSUprQmF5R1hBU0NYQVVFSlNDR2FBU0NhQVFSL0lKY0JCVUVKQ3lHYkFTQkFJRUpKSVp3QklKd0JCRUJCQVNDYkFYUWhvQUVnb0FGQmYyb2hvUUZCZ0pUcjNBTWdtd0YySWFJQlFRQWhFaUJBSVNjRFFBSkFJQ2NvQWdBaHBBRWdwQUVnb1FGeElhVUJJS1FCSUpzQmRpR21BU0NtQVNBU2FpR25BU0FuSUtjQk5nSUFJS1VCSUtJQmJDR29BU0FuUVFScUlha0JJS2tCSUVKSklhb0JJS29CQkVBZ3FBRWhFaUNwQVNFbkJRd0JDd3dCQ3dzZ1FDZ0NBQ0dyQVNDckFVRUFSaUdzQVNCQVFRUnFJYTBCSUt3QkJIOGdyUUVGSUVBTElRZ2dxQUZCQUVZaHJ3RWdyd0VFUUNBSUlRb2dRaUZIQlNCQ1FRUnFJYkFCSUVJZ3FBRTJBZ0FnQ0NFS0lMQUJJVWNMQlNCQUtBSUFJWjBCSUowQlFRQkdJWjRCSUVCQkJHb2hud0VnbmdFRWZ5Q2ZBUVVnUUFzaENTQUpJUW9nUWlGSEN5Q1dBUVIvSUZVRklBb0xJYkVCSUVjaHNnRWdzUUVoc3dFZ3NnRWdzd0ZySWJRQklMUUJRUUoxSWJVQklMVUJJSlVCU2lHMkFTQ3hBU0NWQVVFQ2RHb2h0d0VndGdFRWZ5QzNBUVVnUndzaERDQ3ZBeWdDQUNHNEFTQzRBU0NiQVdvaHVnRWdyd01ndWdFMkFnQWd1Z0ZCQUVnaHV3RWd1d0VFUUNBS0lVQWdEQ0ZDSUxvQklaa0JCU0FLSVQ4Z0RDRkJEQUVMREFFTEN3VWdKU0UvSUNnaFFRc2dQeUJCU1NHOEFTQlZJYjBCSUx3QkJFQWdQeUcrQVNDOUFTQytBV3NodndFZ3Z3RkJBblVod0FFZ3dBRkJDV3dod1FFZ1B5Z0NBQ0hDQVNEQ0FVRUtTU0hEQVNEREFRUkFJTUVCSVMwRklNRUJJUnRCQ2lFaUEwQUNRQ0FpUVFwc0ljVUJJQnRCQVdvaHhnRWd3Z0VneFFGSkljY0JJTWNCQkVBZ3hnRWhMUXdCQlNER0FTRWJJTVVCSVNJTERBRUxDd3NGUVFBaExRc2cvd0pCNWdCSEljZ0JJTWdCQkg4Z0xRVkJBQXNoeVFFZ1N5REpBV3NoeWdFZy93SkI1d0JHSWNzQklFdEJBRWNoekFFZ3pBRWd5d0Z4SWMwQklNMEJRUjkwUVI5MUlWOGd5Z0VnWDJvaHpnRWdRU0hRQVNEUUFTQzlBV3NoMFFFZzBRRkJBblVoMGdFZzBnRkJDV3doMHdFZzB3RkJkMm9oMUFFZ3pnRWcxQUZJSWRVQklOVUJCRUFnVlVFRWFpSFdBU0RPQVVHQXlBQnFJZGNCSU5jQlFRbHRRWDl4SWRnQklOZ0JRWUI0YWlIWkFTRFdBU0RaQVVFQ2RHb2gyZ0VnMXdGQkNXOUJmM0VoMndFZzJ3RkJDRWdoM0FFZzNBRUVRQ0RiQVNFaFFRb2hNZ05BQWtBZ0lVRUJhaUVnSURKQkNtd2gzUUVnSVVFSFNDSGVBU0RlQVFSQUlDQWhJU0RkQVNFeUJTRGRBU0V4REFFTERBRUxDd1ZCQ2lFeEN5RGFBU2dDQUNIZkFTRGZBU0F4Y0VGL2NTSGdBU0RnQVVFQVJpSGhBU0RhQVVFRWFpSGlBU0RpQVNCQlJpSGpBU0RqQVNEaEFYRWgwQU1nMEFNRVFDRGFBU0ZHSUMwaFNDQS9JVndGSU44QklERnVRWDl4SWVRQklPUUJRUUZ4SWVVQklPVUJRUUJHSWVZQklPWUJCSHhFQUFBQUFBQUFRRU1GUkFFQUFBQUFBRUJEQ3lIeUF5QXhRUUp0UVg5eEllY0JJT0FCSU9jQlNTSG9BU0RnQVNEbkFVWWg2UUVnNHdFZzZRRnhJZEVESU5FREJIeEVBQUFBQUFBQThEOEZSQUFBQUFBQUFQZy9DeUh6QXlEb0FRUjhSQUFBQUFBQUFPQS9CU0R6QXdzaDZRTWdIRUVBUmlIcUFTRHFBUVJBSU9rRElld0RJUElESWUwREJTQWRMQUFBSWVzQklPc0JRUmgwUVJoMVFTMUdJZXdCSVBJRG1pSDVBeURwQTVvaCtnTWc3QUVFZkNENUF3VWc4Z01MSWVnRElPd0JCSHdnK2dNRklPa0RDeUhuQXlEbkF5SHNBeURvQXlIdEF3c2czd0VnNEFGckllNEJJTm9CSU80Qk5nSUFJTzBESU93RG9DSDdBeUQ3QXlEdEEySWg3d0VnN3dFRVFDRHVBU0F4YWlId0FTRGFBU0R3QVRZQ0FDRHdBVUgvayt2Y0Ewc2g4UUVnOFFFRVFDQS9JVThnMmdFaGJBTkFBa0FnYkVGOGFpSHlBU0JzUVFBMkFnQWc4Z0VnVDBraDh3RWc4d0VFUUNCUFFYeHFJZlFCSVBRQlFRQTJBZ0FnOUFFaFZnVWdUeUZXQ3lEeUFTZ0NBQ0gxQVNEMUFVRUJhaUgzQVNEeUFTRDNBVFlDQUNEM0FVSC9rK3ZjQTBzaCtBRWcrQUVFUUNCV0lVOGc4Z0VoYkFVZ1ZpRk9JUElCSVdzTUFRc01BUXNMQlNBL0lVNGcyZ0VoYXdzZ1RpSDVBU0M5QVNENUFXc2grZ0VnK2dGQkFuVWgrd0VnK3dGQkNXd2gvQUVnVGlnQ0FDSDlBU0Q5QVVFS1NTSCtBU0QrQVFSQUlHc2hSaUQ4QVNGSUlFNGhYQVVnL0FFaE8wRUtJVDBEUUFKQUlEMUJDbXdoL3dFZ08wRUJhaUdBQWlEOUFTRC9BVWtoZ2dJZ2dnSUVRQ0JySVVZZ2dBSWhTQ0JPSVZ3TUFRVWdnQUloT3lEL0FTRTlDd3dCQ3dzTEJTRGFBU0ZHSUMwaFNDQS9JVndMQ3lCR1FRUnFJWU1DSUVFZ2d3SkxJWVFDSUlRQ0JIOGdnd0lGSUVFTElRc2dTQ0ZTSUFzaFd5QmNJVjBGSUMwaFVpQkJJVnNnUHlGZEN5QmJJVmtEUUFKQUlGa2dYVXNoaFFJZ2hRSkZCRUJCQUNGZURBRUxJRmxCZkdvaGhnSWdoZ0lvQWdBaGh3SWdod0pCQUVZaGlBSWdpQUlFUUNDR0FpRlpCVUVCSVY0TUFRc01BUXNMUVFBZ1Vtc2hpUUlDUUNETEFRUkFJTXdCUVFGekljMERJTTBEUVFGeElZb0NJRXNnaWdKcUlVd2dUQ0JTU2lHTEFpQlNRWHRLSVkwQ0lJc0NJSTBDY1NIVEF5RFRBd1JBSUFWQmYyb2hqZ0lnVEVGL2FpRmdJR0FnVW1zaGp3SWdqZ0loRVNDUEFpRTFCU0FGUVg1cUlaQUNJRXhCZjJvaGtRSWdrQUloRVNDUkFpRTFDeUFFUVFoeElaSUNJSklDUVFCR0laTUNJSk1DQkVBZ1hnUkFJRmxCZkdvaGxBSWdsQUlvQWdBaGxRSWdsUUpCQUVZaGxnSWdsZ0lFUUVFSklUd0ZJSlVDUVFwd1FYOXhJWmdDSUpnQ1FRQkdJWmtDSUprQ0JFQkJBQ0V3UVFvaFF3TkFBa0FnUTBFS2JDR2FBaUF3UVFGcUlac0NJSlVDSUpvQ2NFRi9jU0djQWlDY0FrRUFSaUdkQWlDZEFnUkFJSnNDSVRBZ21nSWhRd1VnbXdJaFBBd0JDd3dCQ3dzRlFRQWhQQXNMQlVFSklUd0xJQkZCSUhJaG5nSWduZ0pCNWdCR0laOENJRmtob0FJZ29BSWd2UUZySWFFQ0lLRUNRUUoxSWFNQ0lLTUNRUWxzSWFRQ0lLUUNRWGRxSWFVQ0lKOENCRUFncFFJZ1BHc2hwZ0lncGdKQkFFb2hwd0lncHdJRWZ5Q21BZ1ZCQUFzaFRTQTFJRTFJSWFnQ0lLZ0NCSDhnTlFVZ1RRc2hOaUFSSVNRZ05pRStRUUFoWmd3REJTQ2xBaUJTYWlHcEFpQ3BBaUE4YXlHcUFpQ3FBa0VBU2lHckFpQ3JBZ1IvSUtvQ0JVRUFDeUZSSURVZ1VVZ2hyQUlnckFJRWZ5QTFCU0JSQ3lFM0lCRWhKQ0EzSVQ1QkFDRm1EQU1MQUFVZ0VTRWtJRFVoUGlDU0FpRm1Dd1VnQkVFSWNTRnBJQVVoSkNCTElUNGdhU0ZtQ3dzZ1BpQm1jaUd1QWlDdUFrRUFSeUd2QWlDdkFrRUJjU0d3QWlBa1FTQnlJYkVDSUxFQ1FlWUFSaUd5QWlDeUFnUkFJRkpCQUVvaHN3SWdzd0lFZnlCU0JVRUFDeUcwQWtFQUlUb2d0QUloWVFVZ1VrRUFTQ0cxQWlDMUFnUi9JSWtDQlNCU0N5RzJBaUMyQXF3aDRnTWc0Z01nZUJBK0liZ0NJSGdodVFJZ3VBSWh1Z0lndVFJZ3VnSnJJYnNDSUxzQ1FRSklJYndDSUx3Q0JFQWd1QUloTEFOQUFrQWdMRUYvYWlHOUFpQzlBa0V3T2dBQUlMMENJYjRDSUxrQ0lMNENheUcvQWlDL0FrRUNTQ0hBQWlEQUFnUkFJTDBDSVN3RklMMENJU3NNQVFzTUFRc0xCU0M0QWlFckN5QlNRUjkxSWNFQ0lNRUNRUUp4SWNNQ0lNTUNRU3RxSWNRQ0lNUUNRZjhCY1NIRkFpQXJRWDlxSWNZQ0lNWUNJTVVDT2dBQUlDUkIvd0Z4SWNjQ0lDdEJmbW9oeUFJZ3lBSWd4d0k2QUFBZ3lBSWh5UUlndVFJZ3lRSnJJY29DSU1nQ0lUb2d5Z0loWVFzZ0hFRUJhaUhMQWlETEFpQSthaUhNQWlETUFpQ3dBbW9oTHlBdklHRnFJYzBDSUFCQklDQUNJTTBDSUFRUVFTQUFJQjBnSEJBNUlBUkJnSUFFY3lIT0FpQUFRVEFnQWlETkFpRE9BaEJCSUxJQ0JFQWdYU0JWU3lIUEFpRFBBZ1IvSUZVRklGMExJUllndWdOQkNXb2gwQUlnMEFJaDBRSWd1Z05CQ0dvaDBnSWdGaUZRQTBBQ1FDQlFLQUlBSWRNQ0lOTUNyU0hqQXlEakF5RFFBaEErSWRRQ0lGQWdGa1loMVFJZzFRSUVRQ0RVQWlEUUFrWWgyd0lnMndJRVFDRFNBa0V3T2dBQUlOSUNJU01GSU5RQ0lTTUxCU0RVQWlDNkEwc2gxZ0lnMWdJRVFDRFVBaUhYQWlEWEFpRENBMnNoMkFJZ3VnTkJNQ0RZQWhCZUdpRFVBaUVRQTBBQ1FDQVFRWDlxSWRrQ0lOa0NJTG9EU3lIYUFpRGFBZ1JBSU5rQ0lSQUZJTmtDSVNNTUFRc01BUXNMQlNEVUFpRWpDd3NnSXlIY0FpRFJBaURjQW1zaDNRSWdBQ0FqSU4wQ0VEa2dVRUVFYWlIZUFpRGVBaUJWU3lIZkFpRGZBZ1JBREFFRklONENJVkFMREFFTEN5Q3VBa0VBUmlIaEFpRGhBa1VFUUNBQVFkWW5RUUVRT1FzZzNnSWdXVWtoNGdJZ1BrRUFTaUhqQWlEaUFpRGpBbkVoNUFJZzVBSUVRQ0ErSVVVZzNnSWhWd05BQWtBZ1Z5Z0NBQ0hsQWlEbEFxMGg1QU1nNUFNZzBBSVFQaUhtQWlEbUFpQzZBMHNoNXdJZzV3SUVRQ0RtQWlIb0FpRG9BaURDQTJzaDZRSWd1Z05CTUNEcEFoQmVHaURtQWlFUEEwQUNRQ0FQUVg5cUllc0NJT3NDSUxvRFN5SHNBaURzQWdSQUlPc0NJUThGSU9zQ0lRNE1BUXNNQVFzTEJTRG1BaUVPQ3lCRlFRbElJZTBDSU8wQ0JIOGdSUVZCQ1FzaDdnSWdBQ0FPSU80Q0VEa2dWMEVFYWlIdkFpQkZRWGRxSWZBQ0lPOENJRmxKSWZFQ0lFVkJDVW9oOGdJZzhRSWc4Z0p4SWZNQ0lQTUNCRUFnOEFJaFJTRHZBaUZYQlNEd0FpRkVEQUVMREFFTEN3VWdQaUZFQ3lCRVFRbHFJZlFDSUFCQk1DRDBBa0VKUVFBUVFRVWdYVUVFYWlIMkFpQmVCSDhnV1FVZzlnSUxJVm9nUGtGL1NpSDNBaUQzQWdSQUlMb0RRUWxxSWZnQ0lHWkJBRVloK1FJZytBSWgrZ0pCQUNEQ0Eyc2grd0lndWdOQkNHb2gvQUlnUGlGVUlGMGhXQU5BQWtBZ1dDZ0NBQ0g5QWlEOUFxMGg1UU1nNVFNZytBSVFQaUgrQWlEK0FpRDRBa1loZ0FNZ2dBTUVRQ0Q4QWtFd09nQUFJUHdDSVEwRklQNENJUTBMSUZnZ1hVWWhnUU1DUUNDQkF3UkFJQTFCQVdvaGhRTWdBQ0FOUVFFUU9TQlVRUUZJSVlZRElQa0NJSVlEY1NIU0F5RFNBd1JBSUlVRElUUU1BZ3NnQUVIV0owRUJFRGtnaFFNaE5BVWdEU0M2QTBzaGdnTWdnZ05GQkVBZ0RTRTBEQUlMSUEwZyt3SnFJZFFESU5RRElkVURJTG9EUVRBZzFRTVFYaG9nRFNFekEwQUNRQ0F6UVg5cUlZTURJSU1ESUxvRFN5R0VBeUNFQXdSQUlJTURJVE1GSUlNRElUUU1BUXNNQVFzTEN3c2dOQ0dIQXlENkFpQ0hBMnNoaUFNZ1ZDQ0lBMG9oaVFNZ2lRTUVmeUNJQXdVZ1ZBc2hpd01nQUNBMElJc0RFRGtnVkNDSUEyc2hqQU1nV0VFRWFpR05BeUNOQXlCYVNTR09BeUNNQTBGL1NpR1BBeUNPQXlDUEEzRWhrQU1na0FNRVFDQ01BeUZVSUkwRElWZ0ZJSXdESVVrTUFRc01BUXNMQlNBK0lVa0xJRWxCRW1vaGtRTWdBRUV3SUpFRFFSSkJBQkJCSUhnaGtnTWdPaUdUQXlDU0F5Q1RBMnNobEFNZ0FDQTZJSlFERURrTElBUkJnTUFBY3lHV0F5QUFRU0FnQWlETkFpQ1dBeEJCSU0wQ0lXMExDeUJ0SUFKSUlaY0RJSmNEQkg4Z0FnVWdiUXNoVXlEWEF5UU5JRk1QQ3hJQ0FuOEJmaU1OSVFJZ0FMMGhBeUFERHdzVkFnSi9BWHdqRFNFRElBQWdBUkJHSVFRZ0JBOEw5QkVEQzM4RWZnVjhJdzBoRENBQXZTRVBJQTlDTklnaEVDQVFwMEgvL3dOeElRa2dDVUgvRDNFaENnSkFBa0FDUUFKQUlBcEJFSFJCRUhWQkFHc09nQkFBQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FRSUxBa0FnQUVRQUFBQUFBQUFBQUdJaEJDQUVCRUFnQUVRQUFBQUFBQUR3UTZJaEZDQVVJQUVRUmlFVklBRW9BZ0FoQlNBRlFVQnFJUVlnRlNFU0lBWWhDQVVnQUNFU1FRQWhDQXNnQVNBSU5nSUFJQkloRVF3REFBc0FDd0pBSUFBaEVRd0NBQXNBQ3dKQUlCQ25JUWNnQjBIL0QzRWhBaUFDUVlKNGFpRURJQUVnQXpZQ0FDQVBRdi8vLy8vLy8vK0hnSCtESVEwZ0RVS0FnSUNBZ0lDQThEK0VJUTRnRHI4aEV5QVRJUkVMQ3lBUkR3dmtCQUU3ZnlNTklUMGdBRUVBUmlFWUFrQWdHQVJBUVFFaEF3VWdBVUdBQVVraEl5QWpCRUFnQVVIL0FYRWhMaUFBSUM0NkFBQkJBU0VEREFJTEVFZ2hOeUEzUWJ3QmFpRTRJRGdvQWdBaE9TQTVLQUlBSVRvZ09rRUFSaUVFSUFRRVFDQUJRWUIvY1NFRklBVkJnTDhEUmlFR0lBWUVRQ0FCUWY4QmNTRUlJQUFnQ0RvQUFFRUJJUU1NQXdVUU1TRUhJQWRCMUFBMkFnQkJmeUVEREFNTEFBc2dBVUdBRUVraENTQUpCRUFnQVVFR2RpRUtJQXBCd0FGeUlRc2dDMEgvQVhFaERDQUFRUUZxSVEwZ0FDQU1PZ0FBSUFGQlAzRWhEaUFPUVlBQmNpRVBJQTlCL3dGeElSQWdEU0FRT2dBQVFRSWhBd3dDQ3lBQlFZQ3dBMGtoRVNBQlFZQkFjU0VTSUJKQmdNQURSaUVUSUJFZ0UzSWhPeUE3QkVBZ0FVRU1kaUVVSUJSQjRBRnlJUlVnRlVIL0FYRWhGaUFBUVFGcUlSY2dBQ0FXT2dBQUlBRkJCblloR1NBWlFUOXhJUm9nR2tHQUFYSWhHeUFiUWY4QmNTRWNJQUJCQW1vaEhTQVhJQnc2QUFBZ0FVRS9jU0VlSUI1QmdBRnlJUjhnSDBIL0FYRWhJQ0FkSUNBNkFBQkJBeUVEREFJTElBRkJnSUI4YWlFaElDRkJnSURBQUVraElpQWlCRUFnQVVFU2RpRWtJQ1JCOEFGeUlTVWdKVUgvQVhFaEppQUFRUUZxSVNjZ0FDQW1PZ0FBSUFGQkRIWWhLQ0FvUVQ5eElTa2dLVUdBQVhJaEtpQXFRZjhCY1NFcklBQkJBbW9oTENBbklDczZBQUFnQVVFR2RpRXRJQzFCUDNFaEx5QXZRWUFCY2lFd0lEQkIvd0Z4SVRFZ0FFRURhaUV5SUN3Z01Ub0FBQ0FCUVQ5eElUTWdNMEdBQVhJaE5DQTBRZjhCY1NFMUlESWdOVG9BQUVFRUlRTU1BZ1VRTVNFMklEWkIxQUEyQWdCQmZ5RUREQUlMQUFzTElBTVBDdzhCQTM4akRTRUNFRWtoQUNBQUR3c01BUUovSXcwaEFVR1VJUThMRHdFRGZ5TU5JUUlRU1NFQUlBQVBDNU1DQVJaL0l3MGhGMEVBSVFRRFFBSkFRZGduSUFScUlROGdEeXdBQUNFUUlCQkIvd0Z4SVJFZ0VTQUFSaUVTSUJJRVFFRUNJUllNQVFzZ0JFRUJhaUVUSUJOQjF3QkdJUlFnRkFSQVFiQW9JUU5CMXdBaEJrRUZJUllNQVFVZ0V5RUVDd3dCQ3dzZ0ZrRUNSZ1JBSUFSQkFFWWhEaUFPQkVCQnNDZ2hBZ1ZCc0NnaEF5QUVJUVpCQlNFV0N3c2dGa0VGUmdSQUEwQUNRRUVBSVJZZ0F5RUZBMEFDUUNBRkxBQUFJUlVnRlVFWWRFRVlkVUVBUmlFSElBVkJBV29oQ0NBSEJFQU1BUVVnQ0NFRkN3d0JDd3NnQmtGL2FpRUpJQWxCQUVZaENpQUtCRUFnQ0NFQ0RBRUZJQWdoQXlBSklRWkJCU0VXQ3d3QkN3c0xJQUZCRkdvaEN5QUxLQUlBSVF3Z0FpQU1FRXdoRFNBTkR3c1RBUU4vSXcwaEJDQUFJQUVRVFNFQ0lBSVBDMUlCQ244akRTRUxJQUZCQUVZaEF5QURCRUJCQUNFQ0JTQUJLQUlBSVFRZ0FVRUVhaUVGSUFVb0FnQWhCaUFFSUFZZ0FCQk9JUWNnQnlFQ0N5QUNRUUJISVFnZ0NBUi9JQUlGSUFBTElRa2dDUThMakFVQlNYOGpEU0ZMSUFBb0FnQWhIU0FkUWFMYTc5Y0dhaUVvSUFCQkNHb2hNeUF6S0FJQUlUNGdQaUFvRUU4aFJDQUFRUXhxSVVVZ1JTZ0NBQ0ZHSUVZZ0tCQlBJUWtnQUVFUWFpRUtJQW9vQWdBaEN5QUxJQ2dRVHlFTUlBRkJBblloRFNCRUlBMUpJUTRDUUNBT0JFQWdSRUVDZENFUElBRWdEMnNoRUNBSklCQkpJUkVnRENBUVNTRVNJQkVnRW5FaFJ5QkhCRUFnRENBSmNpRVRJQk5CQTNFaEZDQVVRUUJHSVJVZ0ZRUkFJQWxCQW5ZaEZpQU1RUUoySVJkQkFDRUVJRVFoQlFOQUFrQWdCVUVCZGlFWUlBUWdHR29oR1NBWlFRRjBJUm9nR2lBV2FpRWJJQUFnRzBFQ2RHb2hIQ0FjS0FJQUlSNGdIaUFvRUU4aEh5QWJRUUZxSVNBZ0FDQWdRUUowYWlFaElDRW9BZ0FoSWlBaUlDZ1FUeUVqSUNNZ0FVa2hKQ0FCSUNOcklTVWdIeUFsU1NFbUlDUWdKbkVoU0NCSVJRUkFRUUFoQ0F3R0N5QWpJQjlxSVNjZ0FDQW5haUVwSUNrc0FBQWhLaUFxUVJoMFFSaDFRUUJHSVNzZ0swVUVRRUVBSVFnTUJnc2dBQ0FqYWlFc0lBSWdMQkEwSVMwZ0xVRUFSaUV1SUM0RVFBd0JDeUFGUVFGR0lVRWdMVUVBU0NGQ0lBVWdHR3NoUXlCQ0JIOGdHQVVnUXdzaEJ5QkNCSDhnQkFVZ0dRc2hCaUJCQkVCQkFDRUlEQVlGSUFZaEJDQUhJUVVMREFFTEN5QWFJQmRxSVM4Z0FDQXZRUUowYWlFd0lEQW9BZ0FoTVNBeElDZ1FUeUV5SUM5QkFXb2hOQ0FBSURSQkFuUnFJVFVnTlNnQ0FDRTJJRFlnS0JCUElUY2dOeUFCU1NFNElBRWdOMnNoT1NBeUlEbEpJVG9nT0NBNmNTRkpJRWtFUUNBQUlEZHFJVHNnTnlBeWFpRThJQUFnUEdvaFBTQTlMQUFBSVQ4Z1AwRVlkRUVZZFVFQVJpRkFJRUFFZnlBN0JVRUFDeUVESUFNaENBVkJBQ0VJQ3dWQkFDRUlDd1ZCQUNFSUN3VkJBQ0VJQ3dzZ0NBOExKQUVGZnlNTklRWWdBVUVBUmlFRElBQVFYQ0VFSUFNRWZ5QUFCU0FFQ3lFQ0lBSVBDNzBEQVNwL0l3MGhMQ0FDUVJCcUlSOGdIeWdDQUNFbElDVkJBRVloSmlBbUJFQWdBaEJSSVNnZ0tFRUFSaUVwSUNrRVFDQWZLQUlBSVFrZ0NTRU5RUVVoS3dWQkFDRUZDd1VnSlNFbklDY2hEVUVGSVNzTEFrQWdLMEVGUmdSQUlBSkJGR29oS2lBcUtBSUFJUXNnRFNBTGF5RU1JQXdnQVVraERpQUxJUThnRGdSQUlBSkJKR29oRUNBUUtBSUFJUkVnQWlBQUlBRWdFVUVIY1VFSWFoRUFBQ0VTSUJJaEJRd0NDeUFDUWNzQWFpRVRJQk1zQUFBaEZDQVVRUmgwUVJoMVFYOUtJUlVDUUNBVkJFQWdBU0VEQTBBQ1FDQURRUUJHSVJZZ0ZnUkFRUUFoQmlBQUlRY2dBU0VJSUE4aElRd0VDeUFEUVg5cUlSY2dBQ0FYYWlFWUlCZ3NBQUFoR1NBWlFSaDBRUmgxUVFwR0lSb2dHZ1JBREFFRklCY2hBd3NNQVFzTElBSkJKR29oR3lBYktBSUFJUndnQWlBQUlBTWdIRUVIY1VFSWFoRUFBQ0VkSUIwZ0Ewa2hIaUFlQkVBZ0hTRUZEQVFMSUFBZ0Eyb2hJQ0FCSUFOcklRUWdLaWdDQUNFS0lBTWhCaUFnSVFjZ0JDRUlJQW9oSVFWQkFDRUdJQUFoQnlBQklRZ2dEeUVoQ3dzZ0lTQUhJQWdRWFJvZ0tpZ0NBQ0VpSUNJZ0NHb2hJeUFxSUNNMkFnQWdCaUFJYWlFa0lDUWhCUXNMSUFVUEMrQUJBUmgvSXcwaEdDQUFRY29BYWlFQ0lBSXNBQUFoRFNBTlFSaDBRUmgxSVJBZ0VFSC9BV29oRVNBUklCQnlJUklnRWtIL0FYRWhFeUFDSUJNNkFBQWdBQ2dDQUNFVUlCUkJDSEVoRlNBVlFRQkdJUllnRmdSQUlBQkJDR29oQkNBRVFRQTJBZ0FnQUVFRWFpRUZJQVZCQURZQ0FDQUFRU3hxSVFZZ0JpZ0NBQ0VISUFCQkhHb2hDQ0FJSUFjMkFnQWdBRUVVYWlFSklBa2dCellDQUNBSElRb2dBRUV3YWlFTElBc29BZ0FoRENBS0lBeHFJUTRnQUVFUWFpRVBJQThnRGpZQ0FFRUFJUUVGSUJSQklISWhBeUFBSUFNMkFnQkJmeUVCQ3lBQkR3czNBUWgvSXcwaENTQUFRUUFnQVJCQUlRSWdBa0VBUmlFRElBSWhCQ0FBSVFVZ0JDQUZheUVHSUFNRWZ5QUJCU0FHQ3lFSElBY1BDODhDQVNCL0l3MGhJQ0FBSVFnZ0NFRURjU0VUSUJOQkFFWWhHQUpBSUJnRVFDQUFJUUpCQkNFZkJTQUFJUU1nQ0NFWEEwQUNRQ0FETEFBQUlSa2dHVUVZZEVFWWRVRUFSaUVhSUJvRVFDQVhJUWNNQkFzZ0EwRUJhaUViSUJzaEhDQWNRUU54SVIwZ0hVRUFSaUVlSUI0RVFDQWJJUUpCQkNFZkRBRUZJQnNoQXlBY0lSY0xEQUVMQ3dzTElCOUJCRVlFUUNBQ0lRRURRQUpBSUFFb0FnQWhDU0FKUWYvOSszZHFJUW9nQ1VHQWdZS0VlSEVoQ3lBTFFZQ0Jnb1I0Y3lFTUlBd2dDbkVoRFNBTlFRQkdJUTRnQVVFRWFpRVBJQTRFUUNBUElRRUZEQUVMREFFTEN5QUpRZjhCY1NFUUlCQkJHSFJCR0hWQkFFWWhFU0FSQkVBZ0FTRUVCU0FCSVFVRFFBSkFJQVZCQVdvaEVpQVNMQUFBSVFZZ0JrRVlkRUVZZFVFQVJpRVVJQlFFUUNBU0lRUU1BUVVnRWlFRkN3d0JDd3NMSUFRaEZTQVZJUWNMSUFjZ0NHc2hGaUFXRHd0QkFRZC9JdzBoQ0NBQUlBRVFWU0VDSUFJc0FBQWhBeUFCUWY4QmNTRUVJQU5CR0hSQkdIVWdCRUVZZEVFWWRVWWhCU0FGQkg4Z0FnVkJBQXNoQmlBR0R3dU1CQUV6ZnlNTklUUWdBVUgvQVhFaEVpQVNRUUJHSVIwQ1FDQWRCRUFnQUJCVElTOGdBQ0F2YWlFd0lEQWhBZ1VnQUNFb0lDaEJBM0VoTENBc1FRQkdJUzBnTFFSQUlBQWhCUVVnQVVIL0FYRWhMaUFBSVFZRFFBSkFJQVlzQUFBaENDQUlRUmgwUVJoMVFRQkdJUWtnQ0VFWWRFRVlkU0F1UVJoMFFSaDFSaUVLSUFrZ0NuSWhNU0F4QkVBZ0JpRUNEQVVMSUFaQkFXb2hDeUFMSVF3Z0RFRURjU0VOSUExQkFFWWhEaUFPQkVBZ0N5RUZEQUVGSUFzaEJnc01BUXNMQ3lBU1FZR0NoQWhzSVE4Z0JTZ0NBQ0VRSUJCQi8vMzdkMm9oRVNBUVFZQ0Jnb1I0Y1NFVElCTkJnSUdDaEhoeklSUWdGQ0FSY1NFVklCVkJBRVloRmdKQUlCWUVRQ0FGSVFRZ0VDRVlBMEFDUUNBWUlBOXpJUmNnRjBILy9mdDNhaUVaSUJkQmdJR0NoSGh4SVJvZ0drR0FnWUtFZUhNaEd5QWJJQmx4SVJ3Z0hFRUFSaUVlSUI1RkJFQWdCQ0VEREFRTElBUkJCR29oSHlBZktBSUFJU0FnSUVILy9mdDNhaUVoSUNCQmdJR0NoSGh4SVNJZ0lrR0FnWUtFZUhNaEl5QWpJQ0Z4SVNRZ0pFRUFSaUVsSUNVRVFDQWZJUVFnSUNFWUJTQWZJUU1NQVFzTUFRc0xCU0FGSVFNTEN5QUJRZjhCY1NFbUlBTWhCd05BQWtBZ0J5d0FBQ0VuSUNkQkdIUkJHSFZCQUVZaEtTQW5RUmgwUVJoMUlDWkJHSFJCR0hWR0lTb2dLU0FxY2lFeUlBZEJBV29oS3lBeUJFQWdCeUVDREFFRklDc2hCd3NNQVFzTEN3c2dBZzhMRVFFQ2Z5TU5JUUZCOERvUUJrSDRPZzhMRGdFQ2Z5TU5JUUZCOERvUURBOEw1d0lCSjM4akRTRW5JQUJCQUVZaENBSkFJQWdFUUVHUUlTZ0NBQ0VqSUNOQkFFWWhKQ0FrQkVCQkFDRWRCVUdRSVNnQ0FDRUpJQWtRV0NFS0lBb2hIUXNRVmlFTElBc29BZ0FoQXlBRFFRQkdJUXdnREFSQUlCMGhCUVVnQXlFRUlCMGhCZ05BQWtBZ0JFSE1BR29oRFNBTktBSUFJUTRnRGtGL1NpRVBJQThFUUNBRUVEY2hFQ0FRSVJvRlFRQWhHZ3NnQkVFVWFpRVJJQkVvQWdBaEVpQUVRUnhxSVJRZ0ZDZ0NBQ0VWSUJJZ0ZVc2hGaUFXQkVBZ0JCQlpJUmNnRnlBR2NpRVlJQmdoQndVZ0JpRUhDeUFhUVFCR0lSa2dHVVVFUUNBRUVEZ0xJQVJCT0dvaEd5QWJLQUlBSVFJZ0FrRUFSaUVjSUJ3RVFDQUhJUVVNQVFVZ0FpRUVJQWNoQmdzTUFRc0xDeEJYSUFVaEFRVWdBRUhNQUdvaEV5QVRLQUlBSVI0Z0hrRi9TaUVmSUI5RkJFQWdBQkJaSVNBZ0lDRUJEQUlMSUFBUU55RWhJQ0ZCQUVZaEpTQUFFRmtoSWlBbEJFQWdJaUVCQlNBQUVEZ2dJaUVCQ3dzTElBRVBDNEVDQVJkL0l3MGhGeUFBUVJScUlRSWdBaWdDQUNFTklBQkJIR29oRHlBUEtBSUFJUkFnRFNBUVN5RVJJQkVFUUNBQVFTUnFJUklnRWlnQ0FDRVRJQUJCQUVFQUlCTkJCM0ZCQ0dvUkFBQWFJQUlvQWdBaEZDQVVRUUJHSVJVZ0ZRUkFRWDhoQVFWQkF5RVdDd1ZCQXlFV0N5QVdRUU5HQkVBZ0FFRUVhaUVESUFNb0FnQWhCQ0FBUVFocUlRVWdCU2dDQUNFR0lBUWdCa2toQnlBSEJFQWdCQ0VJSUFZaENTQUlJQWxySVFvZ0FFRW9haUVMSUFzb0FnQWhEQ0FBSUFwQkFTQU1RUWR4UVFocUVRQUFHZ3NnQUVFUWFpRU9JQTVCQURZQ0FDQVBRUUEyQWdBZ0FrRUFOZ0lBSUFWQkFEWUNBQ0FEUVFBMkFnQkJBQ0VCQ3lBQkR3czNBUVIvSXcwaEJpTU5RUkJxSkEwakRTTU9UZ1JBUVJBUUF3c2dCaUVESUFNZ0FqWUNBQ0FBSUFFZ0F4QTFJUVFnQmlRTklBUVBDd01BQVFzc0FDQUFRZjhCY1VFWWRDQUFRUWgxUWY4QmNVRVFkSElnQUVFUWRVSC9BWEZCQ0hSeUlBQkJHSFp5RHd2a0JBRUVmeUFDUVlEQUFFNEVRQ0FBSUFFZ0FoQU9Ed3NnQUNFRElBQWdBbW9oQmlBQVFRTnhJQUZCQTNGR0JFQURRQUpBSUFCQkEzRkZCRUFNQVFzQ1FDQUNRUUJHQkVBZ0F3OExJQUFnQVN3QUFEb0FBQ0FBUVFGcUlRQWdBVUVCYWlFQklBSkJBV3NoQWdzTUFRc0xJQVpCZkhFaEJDQUVRY0FBYXlFRkEwQUNRQ0FBSUFWTVJRUkFEQUVMQWtBZ0FDQUJLQUlBTmdJQUlBQkJCR29nQVVFRWFpZ0NBRFlDQUNBQVFRaHFJQUZCQ0dvb0FnQTJBZ0FnQUVFTWFpQUJRUXhxS0FJQU5nSUFJQUJCRUdvZ0FVRVFhaWdDQURZQ0FDQUFRUlJxSUFGQkZHb29BZ0EyQWdBZ0FFRVlhaUFCUVJocUtBSUFOZ0lBSUFCQkhHb2dBVUVjYWlnQ0FEWUNBQ0FBUVNCcUlBRkJJR29vQWdBMkFnQWdBRUVrYWlBQlFTUnFLQUlBTmdJQUlBQkJLR29nQVVFb2FpZ0NBRFlDQUNBQVFTeHFJQUZCTEdvb0FnQTJBZ0FnQUVFd2FpQUJRVEJxS0FJQU5nSUFJQUJCTkdvZ0FVRTBhaWdDQURZQ0FDQUFRVGhxSUFGQk9Hb29BZ0EyQWdBZ0FFRThhaUFCUVR4cUtBSUFOZ0lBSUFCQndBQnFJUUFnQVVIQUFHb2hBUXNNQVFzTEEwQUNRQ0FBSUFSSVJRUkFEQUVMQWtBZ0FDQUJLQUlBTmdJQUlBQkJCR29oQUNBQlFRUnFJUUVMREFFTEN3VWdCa0VFYXlFRUEwQUNRQ0FBSUFSSVJRUkFEQUVMQWtBZ0FDQUJMQUFBT2dBQUlBQkJBV29nQVVFQmFpd0FBRG9BQUNBQVFRSnFJQUZCQW1vc0FBQTZBQUFnQUVFRGFpQUJRUU5xTEFBQU9nQUFJQUJCQkdvaEFDQUJRUVJxSVFFTERBRUxDd3NEUUFKQUlBQWdCa2hGQkVBTUFRc0NRQ0FBSUFFc0FBQTZBQUFnQUVFQmFpRUFJQUZCQVdvaEFRc01BUXNMSUFNUEMvRUNBUVIvSUFBZ0Ftb2hBeUFCUWY4QmNTRUJJQUpCd3dCT0JFQURRQUpBSUFCQkEzRkJBRWRGQkVBTUFRc0NRQ0FBSUFFNkFBQWdBRUVCYWlFQUN3d0JDd3NnQTBGOGNTRUVJQVJCd0FCcklRVWdBU0FCUVFoMGNpQUJRUkIwY2lBQlFSaDBjaUVHQTBBQ1FDQUFJQVZNUlFSQURBRUxBa0FnQUNBR05nSUFJQUJCQkdvZ0JqWUNBQ0FBUVFocUlBWTJBZ0FnQUVFTWFpQUdOZ0lBSUFCQkVHb2dCallDQUNBQVFSUnFJQVkyQWdBZ0FFRVlhaUFHTmdJQUlBQkJIR29nQmpZQ0FDQUFRU0JxSUFZMkFnQWdBRUVrYWlBR05nSUFJQUJCS0dvZ0JqWUNBQ0FBUVN4cUlBWTJBZ0FnQUVFd2FpQUdOZ0lBSUFCQk5Hb2dCallDQUNBQVFUaHFJQVkyQWdBZ0FFRThhaUFHTmdJQUlBQkJ3QUJxSVFBTERBRUxDd05BQWtBZ0FDQUVTRVVFUUF3QkN3SkFJQUFnQmpZQ0FDQUFRUVJxSVFBTERBRUxDd3NEUUFKQUlBQWdBMGhGQkVBTUFRc0NRQ0FBSUFFNkFBQWdBRUVCYWlFQUN3d0JDd3NnQXlBQ2F3OExCUUJCQUE4TEJRQkJBQThMWmdFRWZ5QUFRUTlxUVhCeElRQWpDaWdDQUNFQklBRWdBR29oQXlBQVFRQktJQU1nQVVoeElBTkJBRWh5QkVBUUFocEJEQkFIUVg4UEN5TUtJQU0yQWdBUUFTRUVJQU1nQkVvRVFCQUFRUUJHQkVBakNpQUJOZ0lBUVF3UUIwRi9Ed3NMSUFFUEN4QUFJQUVnQUVFSGNVRUFhaEVCQUE4TEZBQWdBU0FDSUFNZ0FFRUhjVUVJYWhFQUFBOExDUUJCQUJBRVFRQVBDd2tBUVFFUUJVRUFEd3NMd2k0QkFFR0FDQXU2TGdBQUFBQnNBUUFBMkFJQUFHc0JBQURYQWdBQWFnRUFBTllDQUFCcEFRQUExUUlBQUdnQkFBRFVBZ0FBWndFQUFOTUNBQUJtQVFBQTBnSUFBR1VCQUFEUkFnQUFaQUVBQU5BQ0FBQmpBUUFBendJQUFHSUJBQURPQWdBQVlRRUFBTTBDQUFCZ0FRQUF6QUlBQUY4QkFBRExBZ0FBWGdFQUFNb0NBQUJkQVFBQXlRSUFBRndCQUFESUFnQUFXd0VBQU1jQ0FBQmFBUUFBeGdJQUFGa0JBQURGQWdBQVdBRUFBTVFDQUFCWEFRQUF3d0lBQUZZQkFBRENBZ0FBVlFFQUFNRUNBQUJVQVFBQXdBSUFBRk1CQUFDL0FnQUFVZ0VBQUw0Q0FBQlJBUUFBdlFJQUFGQUJBQUM4QWdBQVR3RUFBTHNDQUFCT0FRQUF1Z0lBQUUwQkFBQzVBZ0FBVEFFQUFMZ0NBQUJMQVFBQXR3SUFBRW9CQUFDMkFnQUFTUUVBQUxVQ0FBQklBUUFBdEFJQUFFY0JBQUN6QWdBQVJnRUFBTElDQUFCRkFRQUFzUUlBQUVRQkFBQ3dBZ0FBUXdFQUFLOENBQUJDQVFBQXJnSUFBRUVCQUFDdEFnQUFRQUVBQUt3Q0FBQS9BUUFBcXdJQUFENEJBQUNxQWdBQVBRRUFBS2tDQUFBOEFRQUFxQUlBQURzQkFBQ25BZ0FBT2dFQUFLWUNBQUE1QVFBQXBRSUFBRGdCQUFDa0FnQUFOd0VBQUtNQ0FBQTJBUUFBb2dJQUFEVUJBQUNoQWdBQU5BRUFBS0FDQUFBekFRQUFud0lBQURJQkFBQ2VBZ0FBTVFFQUFKMENBQUF3QVFBQW5BSUFBQzhCQUFDYkFnQUFMZ0VBQUpvQ0FBQXRBUUFBbVFJQUFDd0JBQUNZQWdBQUt3RUFBSmNDQUFBcUFRQUFsZ0lBQUNrQkFBQ1ZBZ0FBS0FFQUFKUUNBQUFuQVFBQWt3SUFBQ1lCQUFDU0FnQUFKUUVBQUpFQ0FBQWtBUUFBa0FJQUFDTUJBQUNQQWdBQUlnRUFBSTRDQUFBaEFRQUFqUUlBQUNBQkFBQ01BZ0FBSHdFQUFJc0NBQUFlQVFBQWlnSUFBQjBCQUFDSkFnQUFIQUVBQUlnQ0FBQWJBUUFBaHdJQUFCb0JBQUNHQWdBQUdRRUFBSVVDQUFBWUFRQUFoQUlBQUJjQkFBQ0RBZ0FBRmdFQUFJSUNBQUFWQVFBQWdRSUFBQlFCQUFDQUFnQUFFd0VBQUg4Q0FBQVNBUUFBZmdJQUFCRUJBQUI5QWdBQUVBRUFBSHdDQUFBUEFRQUFld0lBQUE0QkFBQjZBZ0FBRFFFQUFIa0NBQUFNQVFBQWVBSUFBQXNCQUFCM0FnQUFDZ0VBQUhZQ0FBQUpBUUFBZFFJQUFBZ0JBQUIwQWdBQUJ3RUFBSE1DQUFBR0FRQUFjZ0lBQUFVQkFBQnhBZ0FBQkFFQUFIQUNBQUFEQVFBQWJ3SUFBQUlCQUFCdUFnQUFBUUVBQUcwQ0FBQUFBUUFBYkFJQUFQOEFBQUJyQWdBQS9nQUFBR29DQUFEOUFBQUFhUUlBQVB3QUFBQm9BZ0FBK3dBQUFHY0NBQUQ2QUFBQVpnSUFBUGtBQUFCbEFnQUErQUFBQUdRQ0FBRDNBQUFBWXdJQUFQWUFBQUJpQWdBQTlRQUFBR0VDQUFEMEFBQUFZQUlBQVBNQUFBQmZBZ0FBOGdBQUFGNENBQUR4QUFBQVhRSUFBUEFBQUFCY0FnQUE3d0FBQUZzQ0FBRHVBQUFBV2dJQUFPMEFBQUJaQWdBQTdBQUFBRmdDQUFEckFBQUFWd0lBQU9vQUFBQldBZ0FBNlFBQUFGVUNBQURvQUFBQVZBSUFBT2NBQUFCVEFnQUE1Z0FBQUZJQ0FBRGxBQUFBVVFJQUFPUUFBQUJRQWdBQTR3QUFBRThDQUFEaUFBQUFUZ0lBQU9FQUFBQk5BZ0FBNEFBQUFFd0NBQURmQUFBQVN3SUFBTjRBQUFCS0FnQUEzUUFBQUVrQ0FBRGNBQUFBU0FJQUFOc0FBQUJIQWdBQTJnQUFBRVlDQUFEWkFBQUFSUUlBQU5nQUFBQkVBZ0FBMXdBQUFFTUNBQURXQUFBQVFnSUFBTlVBQUFCQkFnQUExQUFBQUVBQ0FBRFRBQUFBUHdJQUFOSUFBQUErQWdBQTBRQUFBRDBDQUFEUUFBQUFQQUlBQU04QUFBQTdBZ0FBemdBQUFEb0NBQUROQUFBQU9RSUFBTXdBQUFBNEFnQUF5d0FBQURjQ0FBREtBQUFBTmdJQUFNa0FBQUExQWdBQXlBQUFBRFFDQUFESEFBQUFNd0lBQU1ZQUFBQXlBZ0FBeFFBQUFERUNBQURFQUFBQU1BSUFBTU1BQUFBdkFnQUF3Z0FBQUM0Q0FBREJBQUFBTFFJQUFNQUFBQUFzQWdBQXZ3QUFBQ3NDQUFDK0FBQUFLZ0lBQUwwQUFBQXBBZ0FBdkFBQUFDZ0NBQUM3QUFBQUp3SUFBTG9BQUFBbUFnQUF1UUFBQUNVQ0FBQzRBQUFBSkFJQUFMY0FBQUFqQWdBQXRnQUFBQ0lDQUFDMUFBQUFJUUlBQUxRQUFBQWdBZ0FBc3dBQUFCOENBQUN5QUFBQUhnSUFBTEVBQUFBZEFnQUFzQUFBQUJ3Q0FBQ3ZBQUFBR3dJQUFLNEFBQUFhQWdBQXJRQUFBQmtDQUFDc0FBQUFHQUlBQUtzQUFBQVhBZ0FBcWdBQUFCWUNBQUNwQUFBQUZRSUFBS2dBQUFBVUFnQUFwd0FBQUJNQ0FBQ21BQUFBRWdJQUFLVUFBQUFSQWdBQXBBQUFBQkFDQUFDakFBQUFEd0lBQUtJQUFBQU9BZ0FBb1FBQUFBMENBQUNnQUFBQURBSUFBSjhBQUFBTEFnQUFuZ0FBQUFvQ0FBQ2RBQUFBQ1FJQUFKd0FBQUFJQWdBQW13QUFBQWNDQUFDYUFBQUFCZ0lBQUprQUFBQUZBZ0FBbUFBQUFBUUNBQUNYQUFBQUF3SUFBSllBQUFBQ0FnQUFsUUFBQUFFQ0FBQ1VBQUFBQUFJQUFKTUFBQUQvQVFBQWtnQUFBUDRCQUFDUkFBQUEvUUVBQUpBQUFBRDhBUUFBandBQUFQc0JBQUNPQUFBQStnRUFBSTBBQUFENUFRQUFqQUFBQVBnQkFBQ0xBQUFBOXdFQUFJb0FBQUQyQVFBQWlRQUFBUFVCQUFDSUFBQUE5QUVBQUljQUFBRHpBUUFBaGdBQUFQSUJBQUNGQUFBQThRRUFBSVFBQUFEd0FRQUFnd0FBQU84QkFBQ0NBQUFBN2dFQUFJRUFBQUR0QVFBQWdBQUFBT3dCQUFCL0FBQUE2d0VBQUg0QUFBRHFBUUFBZlFBQUFPa0JBQUI4QUFBQTZBRUFBSHNBQUFEbkFRQUFlZ0FBQU9ZQkFBQjVBQUFBNVFFQUFIZ0FBQURrQVFBQWR3QUFBT01CQUFCMkFBQUE0Z0VBQUhVQUFBRGhBUUFBZEFBQUFPQUJBQUJ6QUFBQTN3RUFBSElBQUFEZUFRQUFjUUFBQU4wQkFBQndBQUFBM0FFQUFHOEFBQURiQVFBQWJnQUFBTm9CQUFCdEFBQUEyUUVBQUd3QUFBRFlBUUFBYXdBQUFOY0JBQUJxQUFBQTFnRUFBR2tBQUFEVkFRQUFhQUFBQU5RQkFBQm5BQUFBMHdFQUFHWUFBQURTQVFBQVpRQUFBTkVCQUFCa0FBQUEwQUVBQUdNQUFBRFBBUUFBWWdBQUFNNEJBQUJoQUFBQXpRRUFBR0FBQUFETUFRQUFYd0FBQU1zQkFBQmVBQUFBeWdFQUFGMEFBQURKQVFBQVhBQUFBTWdCQUFCYkFBQUF4d0VBQUZvQUFBREdBUUFBV1FBQUFNVUJBQUJZQUFBQXhBRUFBRmNBQUFEREFRQUFWZ0FBQU1JQkFBQlZBQUFBd1FFQUFGUUFBQURBQVFBQVV3QUFBTDhCQUFCU0FBQUF2Z0VBQUZFQUFBQzlBUUFBVUFBQUFMd0JBQUJQQUFBQXV3RUFBRTRBQUFDNkFRQUFUUUFBQUxrQkFBQk1BQUFBdUFFQUFFc0FBQUMzQVFBQVNnQUFBTFlCQUFCSkFBQUF0UUVBQUVnQUFBQzBBUUFBUndBQUFMTUJBQUJHQUFBQXNnRUFBRVVBQUFDeEFRQUFSQUFBQUxBQkFBQkRBQUFBcndFQUFFSUFBQUN1QVFBQVFRQUFBSzBCQUFCQUFBQUFyQUVBQUQ4QUFBQ3JBUUFBUGdBQUFLb0JBQUE5QUFBQXFRRUFBRHdBQUFDb0FRQUFPd0FBQUtjQkFBQTZBQUFBcGdFQUFEa0FBQUNsQVFBQU9BQUFBS1FCQUFBM0FBQUFvd0VBQURZQUFBQ2lBUUFBTlFBQUFLRUJBQUEwQUFBQW9BRUFBRE1BQUFDZkFRQUFNZ0FBQUo0QkFBQXhBQUFBblFFQUFEQUFBQUNjQVFBQUx3QUFBSnNCQUFBdUFBQUFtZ0VBQUMwQUFBQ1pBUUFBTEFBQUFKZ0JBQUFyQUFBQWx3RUFBQ29BQUFDV0FRQUFLUUFBQUpVQkFBQW9BQUFBbEFFQUFDY0FBQUNUQVFBQUpnQUFBSklCQUFBbEFBQUFrUUVBQUNRQUFBQ1FBUUFBSXdBQUFJOEJBQUFpQUFBQWpnRUFBQ0VBQUFDTkFRQUFJQUFBQUl3QkFBQWZBQUFBaXdFQUFCNEFBQUNLQVFBQUhRQUFBSWtCQUFBY0FBQUFpQUVBQUJzQUFBQ0hBUUFBR2dBQUFJWUJBQUFaQUFBQWhRRUFBQmdBQUFDRUFRQUFGd0FBQUlNQkFBQVdBQUFBZ2dFQUFCVUFBQUNCQVFBQUZBQUFBSUFCQUFBVEFBQUFmd0VBQUJJQUFBQitBUUFBRVFBQUFIMEJBQUFRQUFBQWZBRUFBQThBQUFCN0FRQUFEZ0FBQUhvQkFBQU5BQUFBZVFFQUFBd0FBQUI0QVFBQUN3QUFBSGNCQUFBS0FBQUFkZ0VBQUFrQUFBQjFBUUFBQ0FBQUFIUUJBQUFIQUFBQWN3RUFBQVlBQUFCeUFRQUFCUUFBQUhFQkFBQUVBQUFBY0FFQUFBTUFBQUJ2QVFBQUFnQUFBRzRCQUFBQkFBQUFiUUVBQUFBQUFBQUJBQUFBQUFBQUFQLy8vLzhDQUFBQUFRQUFBUC8vLy84QUFBQUFBZ0FBQVAvLy8vOEJBQUFBQUFBQUFKZ1BBQUFGQUFBQUFBQUFBQUFBQUFBQkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFDQUFBQUF3QUFBSlFpQUFBQUFBQUFBQUFBQUFBQUFBQUNBQUFBQUFBQUFBQUFBQUFBQUFELy8vLy8vd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUUFBQUFBQUFBQUFBQUFBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCQUFBQUFNQUFBQ2NJZ0FBQUFRQUFBQUFBQUFBQUFBQUFRQUFBQUFBQUFBQUFBQUFBQUFBQ3YvLy8vOEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRlFkQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBU1c1MllXeHBaQ0J0YVc1WFpXbG5hSFJOWVdkdWFYUjFaR1VnSldRQU9VRkNRMFJGUmtkSVNVcExURTFPVDFCUlVsTlVWVlpYV0ZsYUFCRUFDZ0FSRVJFQUFBQUFCUUFBQUFBQUFBa0FBQUFBQ3dBQUFBQUFBQUFBRVFBUENoRVJFUU1LQndBQkV3a0xDd0FBQ1FZTEFBQUxBQVlSQUFBQUVSRVJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBc0FBQUFBQUFBQUFCRUFDZ29SRVJFQUNnQUFBZ0FKQ3dBQUFBa0FDd0FBQ3dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFNQUFBQUFBQUFBQUFBQUFBTUFBQUFBQXdBQUFBQUNRd0FBQUFBQUF3QUFBd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQURnQUFBQUFBQUFBQUFBQUFEUUFBQUFRTkFBQUFBQWtPQUFBQUFBQU9BQUFPQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkFBQUFBQUFBQUFBQUFBQUE4QUFBQUFEd0FBQUFBSkVBQUFBQUFBRUFBQUVBQUFFZ0FBQUJJU0VnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBU0FBQUFFaElTQUFBQUFBQUFDUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFDd0FBQUFBQUFBQUFBQUFBQ2dBQUFBQUtBQUFBQUFrTEFBQUFBQUFMQUFBTEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUF3QUFBQUFBQUFBQUFBQUFBd0FBQUFBREFBQUFBQUpEQUFBQUFBQURBQUFEQUFBTFNzZ0lDQXdXREI0QUNodWRXeHNLUUF0TUZnck1GZ2dNRmd0TUhnck1IZ2dNSGdBYVc1bUFFbE9SZ0J1WVc0QVRrRk9BREF4TWpNME5UWTNPRGxCUWtORVJVWXVBRlFoSWhrTkFRSURFVXNjREJBRUN4MFNIaWRvYm05d2NXSWdCUVlQRXhRVkdnZ1dCeWdrRnhnSkNnNGJIeVVqZzRKOUppb3JQRDArUDBOSFNrMVlXVnBiWEYxZVgyQmhZMlJsWm1kcGFtdHNjbk4wZVhwN2ZBQkpiR3hsWjJGc0lHSjVkR1VnYzJWeGRXVnVZMlVBUkc5dFlXbHVJR1Z5Y205eUFGSmxjM1ZzZENCdWIzUWdjbVZ3Y21WelpXNTBZV0pzWlFCT2IzUWdZU0IwZEhrQVVHVnliV2x6YzJsdmJpQmtaVzVwWldRQVQzQmxjbUYwYVc5dUlHNXZkQ0J3WlhKdGFYUjBaV1FBVG04Z2MzVmphQ0JtYVd4bElHOXlJR1JwY21WamRHOXllUUJPYnlCemRXTm9JSEJ5YjJObGMzTUFSbWxzWlNCbGVHbHpkSE1BVm1Gc2RXVWdkRzl2SUd4aGNtZGxJR1p2Y2lCa1lYUmhJSFI1Y0dVQVRtOGdjM0JoWTJVZ2JHVm1kQ0J2YmlCa1pYWnBZMlVBVDNWMElHOW1JRzFsYlc5eWVRQlNaWE52ZFhKalpTQmlkWE41QUVsdWRHVnljblZ3ZEdWa0lITjVjM1JsYlNCallXeHNBRkpsYzI5MWNtTmxJSFJsYlhCdmNtRnlhV3g1SUhWdVlYWmhhV3hoWW14bEFFbHVkbUZzYVdRZ2MyVmxhd0JEY205emN5MWtaWFpwWTJVZ2JHbHVhd0JTWldGa0xXOXViSGtnWm1sc1pTQnplWE4wWlcwQVJHbHlaV04wYjNKNUlHNXZkQ0JsYlhCMGVRQkRiMjV1WldOMGFXOXVJSEpsYzJWMElHSjVJSEJsWlhJQVQzQmxjbUYwYVc5dUlIUnBiV1ZrSUc5MWRBQkRiMjV1WldOMGFXOXVJSEpsWm5WelpXUUFTRzl6ZENCcGN5QmtiM2R1QUVodmMzUWdhWE1nZFc1eVpXRmphR0ZpYkdVQVFXUmtjbVZ6Y3lCcGJpQjFjMlVBUW5KdmEyVnVJSEJwY0dVQVNTOVBJR1Z5Y205eUFFNXZJSE4xWTJnZ1pHVjJhV05sSUc5eUlHRmtaSEpsYzNNQVFteHZZMnNnWkdWMmFXTmxJSEpsY1hWcGNtVmtBRTV2SUhOMVkyZ2daR1YyYVdObEFFNXZkQ0JoSUdScGNtVmpkRzl5ZVFCSmN5QmhJR1JwY21WamRHOXllUUJVWlhoMElHWnBiR1VnWW5WemVRQkZlR1ZqSUdadmNtMWhkQ0JsY25KdmNnQkpiblpoYkdsa0lHRnlaM1Z0Wlc1MEFFRnlaM1Z0Wlc1MElHeHBjM1FnZEc5dklHeHZibWNBVTNsdFltOXNhV01nYkdsdWF5QnNiMjl3QUVacGJHVnVZVzFsSUhSdmJ5QnNiMjVuQUZSdmJ5QnRZVzU1SUc5d1pXNGdabWxzWlhNZ2FXNGdjM2x6ZEdWdEFFNXZJR1pwYkdVZ1pHVnpZM0pwY0hSdmNuTWdZWFpoYVd4aFlteGxBRUpoWkNCbWFXeGxJR1JsYzJOeWFYQjBiM0lBVG04Z1kyaHBiR1FnY0hKdlkyVnpjd0JDWVdRZ1lXUmtjbVZ6Y3dCR2FXeGxJSFJ2YnlCc1lYSm5aUUJVYjI4Z2JXRnVlU0JzYVc1cmN3Qk9ieUJzYjJOcmN5QmhkbUZwYkdGaWJHVUFVbVZ6YjNWeVkyVWdaR1ZoWkd4dlkyc2dkMjkxYkdRZ2IyTmpkWElBVTNSaGRHVWdibTkwSUhKbFkyOTJaWEpoWW14bEFGQnlaWFpwYjNWeklHOTNibVZ5SUdScFpXUUFUM0JsY21GMGFXOXVJR05oYm1ObGJHVmtBRVoxYm1OMGFXOXVJRzV2ZENCcGJYQnNaVzFsYm5SbFpBQk9ieUJ0WlhOellXZGxJRzltSUdSbGMybHlaV1FnZEhsd1pRQkpaR1Z1ZEdsbWFXVnlJSEpsYlc5MlpXUUFSR1YyYVdObElHNXZkQ0JoSUhOMGNtVmhiUUJPYnlCa1lYUmhJR0YyWVdsc1lXSnNaUUJFWlhacFkyVWdkR2x0Wlc5MWRBQlBkWFFnYjJZZ2MzUnlaV0Z0Y3lCeVpYTnZkWEpqWlhNQVRHbHVheUJvWVhNZ1ltVmxiaUJ6WlhabGNtVmtBRkJ5YjNSdlkyOXNJR1Z5Y205eUFFSmhaQ0J0WlhOellXZGxBRVpwYkdVZ1pHVnpZM0pwY0hSdmNpQnBiaUJpWVdRZ2MzUmhkR1VBVG05MElHRWdjMjlqYTJWMEFFUmxjM1JwYm1GMGFXOXVJR0ZrWkhKbGMzTWdjbVZ4ZFdseVpXUUFUV1Z6YzJGblpTQjBiMjhnYkdGeVoyVUFVSEp2ZEc5amIyd2dkM0p2Ym1jZ2RIbHdaU0JtYjNJZ2MyOWphMlYwQUZCeWIzUnZZMjlzSUc1dmRDQmhkbUZwYkdGaWJHVUFVSEp2ZEc5amIyd2dibTkwSUhOMWNIQnZjblJsWkFCVGIyTnJaWFFnZEhsd1pTQnViM1FnYzNWd2NHOXlkR1ZrQUU1dmRDQnpkWEJ3YjNKMFpXUUFVSEp2ZEc5amIyd2dabUZ0YVd4NUlHNXZkQ0J6ZFhCd2IzSjBaV1FBUVdSa2NtVnpjeUJtWVcxcGJIa2dibTkwSUhOMWNIQnZjblJsWkNCaWVTQndjbTkwYjJOdmJBQkJaR1J5WlhOeklHNXZkQ0JoZG1GcGJHRmliR1VBVG1WMGQyOXlheUJwY3lCa2IzZHVBRTVsZEhkdmNtc2dkVzV5WldGamFHRmliR1VBUTI5dWJtVmpkR2x2YmlCeVpYTmxkQ0JpZVNCdVpYUjNiM0pyQUVOdmJtNWxZM1JwYjI0Z1lXSnZjblJsWkFCT2J5QmlkV1ptWlhJZ2MzQmhZMlVnWVhaaGFXeGhZbXhsQUZOdlkydGxkQ0JwY3lCamIyNXVaV04wWldRQVUyOWphMlYwSUc1dmRDQmpiMjV1WldOMFpXUUFRMkZ1Ym05MElITmxibVFnWVdaMFpYSWdjMjlqYTJWMElITm9kWFJrYjNkdUFFOXdaWEpoZEdsdmJpQmhiSEpsWVdSNUlHbHVJSEJ5YjJkeVpYTnpBRTl3WlhKaGRHbHZiaUJwYmlCd2NtOW5jbVZ6Y3dCVGRHRnNaU0JtYVd4bElHaGhibVJzWlFCU1pXMXZkR1VnU1M5UElHVnljbTl5QUZGMWIzUmhJR1Y0WTJWbFpHVmtBRTV2SUcxbFpHbDFiU0JtYjNWdVpBQlhjbTl1WnlCdFpXUnBkVzBnZEhsd1pRQk9ieUJsY25KdmNpQnBibVp2Y20xaGRHbHZiZz09JztcclxuICB2YXIgYXNtanNDb2RlRmlsZSA9ICcnO1xyXG5cclxuICBpZiAodHlwZW9mIE1vZHVsZVsnbG9jYXRlRmlsZSddID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICBpZiAoIWlzRGF0YVVSSSh3YXNtVGV4dEZpbGUpKSB7XHJcbiAgICAgIHdhc21UZXh0RmlsZSA9IE1vZHVsZVsnbG9jYXRlRmlsZSddKHdhc21UZXh0RmlsZSk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzRGF0YVVSSSh3YXNtQmluYXJ5RmlsZSkpIHtcclxuICAgICAgd2FzbUJpbmFyeUZpbGUgPSBNb2R1bGVbJ2xvY2F0ZUZpbGUnXSh3YXNtQmluYXJ5RmlsZSk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzRGF0YVVSSShhc21qc0NvZGVGaWxlKSkge1xyXG4gICAgICBhc21qc0NvZGVGaWxlID0gTW9kdWxlWydsb2NhdGVGaWxlJ10oYXNtanNDb2RlRmlsZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyB1dGlsaXRpZXNcclxuXHJcbiAgdmFyIHdhc21QYWdlU2l6ZSA9IDY0KjEwMjQ7XHJcblxyXG4gIHZhciBpbmZvID0ge1xyXG4gICAgJ2dsb2JhbCc6IG51bGwsXHJcbiAgICAnZW52JzogbnVsbCxcclxuICAgICdhc20yd2FzbSc6IHsgLy8gc3BlY2lhbCBhc20yd2FzbSBpbXBvcnRzXHJcbiAgICAgIFwiZjY0LXJlbVwiOiBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICAgICAgcmV0dXJuIHggJSB5O1xyXG4gICAgICB9LFxyXG4gICAgICBcImRlYnVnZ2VyXCI6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGRlYnVnZ2VyO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgJ3BhcmVudCc6IE1vZHVsZSAvLyBNb2R1bGUgaW5zaWRlIHdhc20tanMuY3BwIHJlZmVycyB0byB3YXNtLWpzLmNwcDsgdGhpcyBhbGxvd3MgYWNjZXNzIHRvIHRoZSBvdXRzaWRlIHByb2dyYW0uXHJcbiAgfTtcclxuXHJcbiAgdmFyIGV4cG9ydHMgPSBudWxsO1xyXG5cclxuXHJcbiAgZnVuY3Rpb24gbWVyZ2VNZW1vcnkobmV3QnVmZmVyKSB7XHJcbiAgICAvLyBUaGUgd2FzbSBpbnN0YW5jZSBjcmVhdGVzIGl0cyBtZW1vcnkuIEJ1dCBzdGF0aWMgaW5pdCBjb2RlIG1pZ2h0IGhhdmUgd3JpdHRlbiB0b1xyXG4gICAgLy8gYnVmZmVyIGFscmVhZHksIGluY2x1ZGluZyB0aGUgbWVtIGluaXQgZmlsZSwgYW5kIHdlIG11c3QgY29weSBpdCBvdmVyIGluIGEgcHJvcGVyIG1lcmdlLlxyXG4gICAgLy8gVE9ETzogYXZvaWQgdGhpcyBjb3B5LCBieSBhdm9pZGluZyBzdWNoIHN0YXRpYyBpbml0IHdyaXRlc1xyXG4gICAgLy8gVE9ETzogaW4gc2hvcnRlciB0ZXJtLCBqdXN0IGNvcHkgdXAgdG8gdGhlIGxhc3Qgc3RhdGljIGluaXQgd3JpdGVcclxuICAgIHZhciBvbGRCdWZmZXIgPSBNb2R1bGVbJ2J1ZmZlciddO1xyXG4gICAgaWYgKG5ld0J1ZmZlci5ieXRlTGVuZ3RoIDwgb2xkQnVmZmVyLmJ5dGVMZW5ndGgpIHtcclxuICAgICAgTW9kdWxlWydwcmludEVyciddKCd0aGUgbmV3IGJ1ZmZlciBpbiBtZXJnZU1lbW9yeSBpcyBzbWFsbGVyIHRoYW4gdGhlIHByZXZpb3VzIG9uZS4gaW4gbmF0aXZlIHdhc20sIHdlIHNob3VsZCBncm93IG1lbW9yeSBoZXJlJyk7XHJcbiAgICB9XHJcbiAgICB2YXIgb2xkVmlldyA9IG5ldyBJbnQ4QXJyYXkob2xkQnVmZmVyKTtcclxuICAgIHZhciBuZXdWaWV3ID0gbmV3IEludDhBcnJheShuZXdCdWZmZXIpO1xyXG5cclxuXHJcbiAgICBuZXdWaWV3LnNldChvbGRWaWV3KTtcclxuICAgIHVwZGF0ZUdsb2JhbEJ1ZmZlcihuZXdCdWZmZXIpO1xyXG4gICAgdXBkYXRlR2xvYmFsQnVmZmVyVmlld3MoKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGZpeEltcG9ydHMoaW1wb3J0cykge1xyXG4gICAgcmV0dXJuIGltcG9ydHM7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRCaW5hcnkoKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBpZiAoTW9kdWxlWyd3YXNtQmluYXJ5J10pIHtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoTW9kdWxlWyd3YXNtQmluYXJ5J10pO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBiaW5hcnkgPSB0cnlQYXJzZUFzRGF0YVVSSSh3YXNtQmluYXJ5RmlsZSk7XHJcbiAgICAgIGlmIChiaW5hcnkpIHtcclxuICAgICAgICByZXR1cm4gYmluYXJ5O1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChNb2R1bGVbJ3JlYWRCaW5hcnknXSkge1xyXG4gICAgICAgIHJldHVybiBNb2R1bGVbJ3JlYWRCaW5hcnknXSh3YXNtQmluYXJ5RmlsZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgXCJvbiB0aGUgd2ViLCB3ZSBuZWVkIHRoZSB3YXNtIGJpbmFyeSB0byBiZSBwcmVsb2FkZWQgYW5kIHNldCBvbiBNb2R1bGVbJ3dhc21CaW5hcnknXS4gZW1jYy5weSB3aWxsIGRvIHRoYXQgZm9yIHlvdSB3aGVuIGdlbmVyYXRpbmcgSFRNTCAoYnV0IG5vdCBKUylcIjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycikge1xyXG4gICAgICBhYm9ydChlcnIpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0QmluYXJ5UHJvbWlzZSgpIHtcclxuICAgIC8vIGlmIHdlIGRvbid0IGhhdmUgdGhlIGJpbmFyeSB5ZXQsIGFuZCBoYXZlIHRoZSBGZXRjaCBhcGksIHVzZSB0aGF0XHJcbiAgICAvLyBpbiBzb21lIGVudmlyb25tZW50cywgbGlrZSBFbGVjdHJvbidzIHJlbmRlciBwcm9jZXNzLCBGZXRjaCBhcGkgbWF5IGJlIHByZXNlbnQsIGJ1dCBoYXZlIGEgZGlmZmVyZW50IGNvbnRleHQgdGhhbiBleHBlY3RlZCwgbGV0J3Mgb25seSB1c2UgaXQgb24gdGhlIFdlYlxyXG4gICAgaWYgKCFNb2R1bGVbJ3dhc21CaW5hcnknXSAmJiAoRU5WSVJPTk1FTlRfSVNfV0VCIHx8IEVOVklST05NRU5UX0lTX1dPUktFUikgJiYgdHlwZW9mIGZldGNoID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHJldHVybiBmZXRjaCh3YXNtQmluYXJ5RmlsZSwgeyBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyB9KS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgaWYgKCFyZXNwb25zZVsnb2snXSkge1xyXG4gICAgICAgICAgdGhyb3cgXCJmYWlsZWQgdG8gbG9hZCB3YXNtIGJpbmFyeSBmaWxlIGF0ICdcIiArIHdhc21CaW5hcnlGaWxlICsgXCInXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXNwb25zZVsnYXJyYXlCdWZmZXInXSgpO1xyXG4gICAgICB9KS5jYXRjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldEJpbmFyeSgpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIC8vIE90aGVyd2lzZSwgZ2V0QmluYXJ5IHNob3VsZCBiZSBhYmxlIHRvIGdldCBpdCBzeW5jaHJvbm91c2x5XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgIHJlc29sdmUoZ2V0QmluYXJ5KCkpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvLyBkby1tZXRob2QgZnVuY3Rpb25zXHJcblxyXG5cclxuICBmdW5jdGlvbiBkb05hdGl2ZVdhc20oZ2xvYmFsLCBlbnYsIHByb3ZpZGVkQnVmZmVyKSB7XHJcbiAgICBpZiAodHlwZW9mIFdlYkFzc2VtYmx5ICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICBNb2R1bGVbJ3ByaW50RXJyJ10oJ25vIG5hdGl2ZSB3YXNtIHN1cHBvcnQgZGV0ZWN0ZWQnKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLy8gcHJlcGFyZSBtZW1vcnkgaW1wb3J0XHJcbiAgICBpZiAoIShNb2R1bGVbJ3dhc21NZW1vcnknXSBpbnN0YW5jZW9mIFdlYkFzc2VtYmx5Lk1lbW9yeSkpIHtcclxuICAgICAgTW9kdWxlWydwcmludEVyciddKCdubyBuYXRpdmUgd2FzbSBNZW1vcnkgaW4gdXNlJyk7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGVudlsnbWVtb3J5J10gPSBNb2R1bGVbJ3dhc21NZW1vcnknXTtcclxuICAgIC8vIExvYWQgdGhlIHdhc20gbW9kdWxlIGFuZCBjcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdXNpbmcgbmF0aXZlIHN1cHBvcnQgaW4gdGhlIEpTIGVuZ2luZS5cclxuICAgIGluZm9bJ2dsb2JhbCddID0ge1xyXG4gICAgICAnTmFOJzogTmFOLFxyXG4gICAgICAnSW5maW5pdHknOiBJbmZpbml0eVxyXG4gICAgfTtcclxuICAgIGluZm9bJ2dsb2JhbC5NYXRoJ10gPSBNYXRoO1xyXG4gICAgaW5mb1snZW52J10gPSBlbnY7XHJcbiAgICAvLyBoYW5kbGUgYSBnZW5lcmF0ZWQgd2FzbSBpbnN0YW5jZSwgcmVjZWl2aW5nIGl0cyBleHBvcnRzIGFuZFxyXG4gICAgLy8gcGVyZm9ybWluZyBvdGhlciBuZWNlc3Nhcnkgc2V0dXBcclxuICAgIGZ1bmN0aW9uIHJlY2VpdmVJbnN0YW5jZShpbnN0YW5jZSwgbW9kdWxlKSB7XHJcbiAgICAgIGV4cG9ydHMgPSBpbnN0YW5jZS5leHBvcnRzO1xyXG4gICAgICBpZiAoZXhwb3J0cy5tZW1vcnkpIG1lcmdlTWVtb3J5KGV4cG9ydHMubWVtb3J5KTtcclxuICAgICAgTW9kdWxlWydhc20nXSA9IGV4cG9ydHM7XHJcbiAgICAgIE1vZHVsZVtcInVzaW5nV2FzbVwiXSA9IHRydWU7XHJcbiAgICAgIHJlbW92ZVJ1bkRlcGVuZGVuY3koJ3dhc20taW5zdGFudGlhdGUnKTtcclxuICAgIH1cclxuICAgIGFkZFJ1bkRlcGVuZGVuY3koJ3dhc20taW5zdGFudGlhdGUnKTtcclxuXHJcbiAgICAvLyBVc2VyIHNoZWxsIHBhZ2VzIGNhbiB3cml0ZSB0aGVpciBvd24gTW9kdWxlLmluc3RhbnRpYXRlV2FzbSA9IGZ1bmN0aW9uKGltcG9ydHMsIHN1Y2Nlc3NDYWxsYmFjaykgY2FsbGJhY2tcclxuICAgIC8vIHRvIG1hbnVhbGx5IGluc3RhbnRpYXRlIHRoZSBXYXNtIG1vZHVsZSB0aGVtc2VsdmVzLiBUaGlzIGFsbG93cyBwYWdlcyB0byBydW4gdGhlIGluc3RhbnRpYXRpb24gcGFyYWxsZWxcclxuICAgIC8vIHRvIGFueSBvdGhlciBhc3luYyBzdGFydHVwIGFjdGlvbnMgdGhleSBhcmUgcGVyZm9ybWluZy5cclxuICAgIGlmIChNb2R1bGVbJ2luc3RhbnRpYXRlV2FzbSddKSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIE1vZHVsZVsnaW5zdGFudGlhdGVXYXNtJ10oaW5mbywgcmVjZWl2ZUluc3RhbmNlKTtcclxuICAgICAgfSBjYXRjaChlKSB7XHJcbiAgICAgICAgTW9kdWxlWydwcmludEVyciddKCdNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiAnICsgZSk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQXN5bmMgY29tcGlsYXRpb24gY2FuIGJlIGNvbmZ1c2luZyB3aGVuIGFuIGVycm9yIG9uIHRoZSBwYWdlIG92ZXJ3cml0ZXMgTW9kdWxlXHJcbiAgICAvLyAoZm9yIGV4YW1wbGUsIGlmIHRoZSBvcmRlciBvZiBlbGVtZW50cyBpcyB3cm9uZywgYW5kIHRoZSBvbmUgZGVmaW5pbmcgTW9kdWxlIGlzXHJcbiAgICAvLyBsYXRlciksIHNvIHdlIHNhdmUgTW9kdWxlIGFuZCBjaGVjayBpdCBsYXRlci5cclxuICAgIHZhciB0cnVlTW9kdWxlID0gTW9kdWxlO1xyXG4gICAgZnVuY3Rpb24gcmVjZWl2ZUluc3RhbnRpYXRlZFNvdXJjZShvdXRwdXQpIHtcclxuICAgICAgLy8gJ291dHB1dCcgaXMgYSBXZWJBc3NlbWJseUluc3RhbnRpYXRlZFNvdXJjZSBvYmplY3Qgd2hpY2ggaGFzIGJvdGggdGhlIG1vZHVsZSBhbmQgaW5zdGFuY2UuXHJcbiAgICAgIC8vIHJlY2VpdmVJbnN0YW5jZSgpIHdpbGwgc3dhcCBpbiB0aGUgZXhwb3J0cyAodG8gTW9kdWxlLmFzbSkgc28gdGhleSBjYW4gYmUgY2FsbGVkXHJcbiAgICAgIGFzc2VydChNb2R1bGUgPT09IHRydWVNb2R1bGUsICd0aGUgTW9kdWxlIG9iamVjdCBzaG91bGQgbm90IGJlIHJlcGxhY2VkIGR1cmluZyBhc3luYyBjb21waWxhdGlvbiAtIHBlcmhhcHMgdGhlIG9yZGVyIG9mIEhUTUwgZWxlbWVudHMgaXMgd3Jvbmc/Jyk7XHJcbiAgICAgIHRydWVNb2R1bGUgPSBudWxsO1xyXG4gICAgICByZWNlaXZlSW5zdGFuY2Uob3V0cHV0WydpbnN0YW5jZSddLCBvdXRwdXRbJ21vZHVsZSddKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGluc3RhbnRpYXRlQXJyYXlCdWZmZXIocmVjZWl2ZXIpIHtcclxuICAgICAgZ2V0QmluYXJ5UHJvbWlzZSgpLnRoZW4oZnVuY3Rpb24oYmluYXJ5KSB7XHJcbiAgICAgICAgcmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGJpbmFyeSwgaW5mbyk7XHJcbiAgICAgIH0pLnRoZW4ocmVjZWl2ZXIpLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbikge1xyXG4gICAgICAgIE1vZHVsZVsncHJpbnRFcnInXSgnZmFpbGVkIHRvIGFzeW5jaHJvbm91c2x5IHByZXBhcmUgd2FzbTogJyArIHJlYXNvbik7XHJcbiAgICAgICAgYWJvcnQocmVhc29uKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvLyBQcmVmZXIgc3RyZWFtaW5nIGluc3RhbnRpYXRpb24gaWYgYXZhaWxhYmxlLlxyXG4gICAgaWYgKCFNb2R1bGVbJ3dhc21CaW5hcnknXSAmJlxyXG4gICAgICAgIHR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyA9PT0gJ2Z1bmN0aW9uJyAmJlxyXG4gICAgICAgICFpc0RhdGFVUkkod2FzbUJpbmFyeUZpbGUpICYmXHJcbiAgICAgICAgdHlwZW9mIGZldGNoID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKGZldGNoKHdhc21CaW5hcnlGaWxlLCB7IGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nIH0pLCBpbmZvKVxyXG4gICAgICAgIC50aGVuKHJlY2VpdmVJbnN0YW50aWF0ZWRTb3VyY2UpXHJcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbikge1xyXG4gICAgICAgICAgLy8gV2UgZXhwZWN0IHRoZSBtb3N0IGNvbW1vbiBmYWlsdXJlIGNhdXNlIHRvIGJlIGEgYmFkIE1JTUUgdHlwZSBmb3IgdGhlIGJpbmFyeSxcclxuICAgICAgICAgIC8vIGluIHdoaWNoIGNhc2UgZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb24gc2hvdWxkIHdvcmsuXHJcbiAgICAgICAgICBNb2R1bGVbJ3ByaW50RXJyJ10oJ3dhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiAnICsgcmVhc29uKTtcclxuICAgICAgICAgIE1vZHVsZVsncHJpbnRFcnInXSgnZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb24nKTtcclxuICAgICAgICAgIGluc3RhbnRpYXRlQXJyYXlCdWZmZXIocmVjZWl2ZUluc3RhbnRpYXRlZFNvdXJjZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpbnN0YW50aWF0ZUFycmF5QnVmZmVyKHJlY2VpdmVJbnN0YW50aWF0ZWRTb3VyY2UpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHt9OyAvLyBubyBleHBvcnRzIHlldDsgd2UnbGwgZmlsbCB0aGVtIGluIGxhdGVyXHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gV2UgbWF5IGhhdmUgYSBwcmVsb2FkZWQgdmFsdWUgaW4gTW9kdWxlLmFzbSwgc2F2ZSBpdFxyXG4gIE1vZHVsZVsnYXNtUHJlbG9hZCddID0gTW9kdWxlWydhc20nXTtcclxuXHJcbiAgLy8gTWVtb3J5IGdyb3d0aCBpbnRlZ3JhdGlvbiBjb2RlXHJcblxyXG4gIHZhciBhc21qc1JlYWxsb2NCdWZmZXIgPSBNb2R1bGVbJ3JlYWxsb2NCdWZmZXInXTtcclxuXHJcbiAgdmFyIHdhc21SZWFsbG9jQnVmZmVyID0gZnVuY3Rpb24oc2l6ZSkge1xyXG4gICAgdmFyIFBBR0VfTVVMVElQTEUgPSBNb2R1bGVbXCJ1c2luZ1dhc21cIl0gPyBXQVNNX1BBR0VfU0laRSA6IEFTTUpTX1BBR0VfU0laRTsgLy8gSW4gd2FzbSwgaGVhcCBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NEtCLiBJbiBhc20uanMsIHRoZXkgbmVlZCB0byBiZSBtdWx0aXBsZXMgb2YgMTZNQi5cclxuICAgIHNpemUgPSBhbGlnblVwKHNpemUsIFBBR0VfTVVMVElQTEUpOyAvLyByb3VuZCB1cCB0byB3YXNtIHBhZ2Ugc2l6ZVxyXG4gICAgdmFyIG9sZCA9IE1vZHVsZVsnYnVmZmVyJ107XHJcbiAgICB2YXIgb2xkU2l6ZSA9IG9sZC5ieXRlTGVuZ3RoO1xyXG4gICAgaWYgKE1vZHVsZVtcInVzaW5nV2FzbVwiXSkge1xyXG4gICAgICAvLyBuYXRpdmUgd2FzbSBzdXBwb3J0XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IE1vZHVsZVsnd2FzbU1lbW9yeSddLmdyb3coKHNpemUgLSBvbGRTaXplKSAvIHdhc21QYWdlU2l6ZSk7IC8vIC5ncm93KCkgdGFrZXMgYSBkZWx0YSBjb21wYXJlZCB0byB0aGUgcHJldmlvdXMgc2l6ZVxyXG4gICAgICAgIGlmIChyZXN1bHQgIT09ICgtMSB8IDApKSB7XHJcbiAgICAgICAgICAvLyBzdWNjZXNzIGluIG5hdGl2ZSB3YXNtIG1lbW9yeSBncm93dGgsIGdldCB0aGUgYnVmZmVyIGZyb20gdGhlIG1lbW9yeVxyXG4gICAgICAgICAgcmV0dXJuIE1vZHVsZVsnYnVmZmVyJ10gPSBNb2R1bGVbJ3dhc21NZW1vcnknXS5idWZmZXI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaChlKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignTW9kdWxlLnJlYWxsb2NCdWZmZXI6IEF0dGVtcHRlZCB0byBncm93IGZyb20gJyArIG9sZFNpemUgICsgJyBieXRlcyB0byAnICsgc2l6ZSArICcgYnl0ZXMsIGJ1dCBnb3QgZXJyb3I6ICcgKyBlKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIE1vZHVsZVsncmVhbGxvY0J1ZmZlciddID0gZnVuY3Rpb24oc2l6ZSkge1xyXG4gICAgaWYgKGZpbmFsTWV0aG9kID09PSAnYXNtanMnKSB7XHJcbiAgICAgIHJldHVybiBhc21qc1JlYWxsb2NCdWZmZXIoc2l6ZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gd2FzbVJlYWxsb2NCdWZmZXIoc2l6ZSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8gd2UgbWF5IHRyeSBtb3JlIHRoYW4gb25lOyB0aGlzIGlzIHRoZSBmaW5hbCBvbmUsIHRoYXQgd29ya2VkIGFuZCB3ZSBhcmUgdXNpbmdcclxuICB2YXIgZmluYWxNZXRob2QgPSAnJztcclxuXHJcbiAgLy8gUHJvdmlkZSBhbiBcImFzbS5qcyBmdW5jdGlvblwiIGZvciB0aGUgYXBwbGljYXRpb24sIGNhbGxlZCB0byBcImxpbmtcIiB0aGUgYXNtLmpzIG1vZHVsZS4gV2UgaW5zdGFudGlhdGVcclxuICAvLyB0aGUgd2FzbSBtb2R1bGUgYXQgdGhhdCB0aW1lLCBhbmQgaXQgcmVjZWl2ZXMgaW1wb3J0cyBhbmQgcHJvdmlkZXMgZXhwb3J0cyBhbmQgc28gZm9ydGgsIHRoZSBhcHBcclxuICAvLyBkb2Vzbid0IG5lZWQgdG8gY2FyZSB0aGF0IGl0IGlzIHdhc20gb3Igb2x5ZmlsbGVkIHdhc20gb3IgYXNtLmpzLlxyXG5cclxuICBNb2R1bGVbJ2FzbSddID0gZnVuY3Rpb24oZ2xvYmFsLCBlbnYsIHByb3ZpZGVkQnVmZmVyKSB7XHJcbiAgICBlbnYgPSBmaXhJbXBvcnRzKGVudik7XHJcblxyXG4gICAgLy8gaW1wb3J0IHRhYmxlXHJcbiAgICBpZiAoIWVudlsndGFibGUnXSkge1xyXG4gICAgICB2YXIgVEFCTEVfU0laRSA9IE1vZHVsZVsnd2FzbVRhYmxlU2l6ZSddO1xyXG4gICAgICBpZiAoVEFCTEVfU0laRSA9PT0gdW5kZWZpbmVkKSBUQUJMRV9TSVpFID0gMTAyNDsgLy8gd29ya3MgaW4gYmluYXJ5ZW4gaW50ZXJwcmV0ZXIgYXQgbGVhc3RcclxuICAgICAgdmFyIE1BWF9UQUJMRV9TSVpFID0gTW9kdWxlWyd3YXNtTWF4VGFibGVTaXplJ107XHJcbiAgICAgIGlmICh0eXBlb2YgV2ViQXNzZW1ibHkgPT09ICdvYmplY3QnICYmIHR5cGVvZiBXZWJBc3NlbWJseS5UYWJsZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIGlmIChNQVhfVEFCTEVfU0laRSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBlbnZbJ3RhYmxlJ10gPSBuZXcgV2ViQXNzZW1ibHkuVGFibGUoeyAnaW5pdGlhbCc6IFRBQkxFX1NJWkUsICdtYXhpbXVtJzogTUFYX1RBQkxFX1NJWkUsICdlbGVtZW50JzogJ2FueWZ1bmMnIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBlbnZbJ3RhYmxlJ10gPSBuZXcgV2ViQXNzZW1ibHkuVGFibGUoeyAnaW5pdGlhbCc6IFRBQkxFX1NJWkUsIGVsZW1lbnQ6ICdhbnlmdW5jJyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZW52Wyd0YWJsZSddID0gbmV3IEFycmF5KFRBQkxFX1NJWkUpOyAvLyB3b3JrcyBpbiBiaW5hcnllbiBpbnRlcnByZXRlciBhdCBsZWFzdFxyXG4gICAgICB9XHJcbiAgICAgIE1vZHVsZVsnd2FzbVRhYmxlJ10gPSBlbnZbJ3RhYmxlJ107XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFlbnZbJ21lbW9yeUJhc2UnXSkge1xyXG4gICAgICBlbnZbJ21lbW9yeUJhc2UnXSA9IE1vZHVsZVsnU1RBVElDX0JBU0UnXTsgLy8gdGVsbCB0aGUgbWVtb3J5IHNlZ21lbnRzIHdoZXJlIHRvIHBsYWNlIHRoZW1zZWx2ZXNcclxuICAgIH1cclxuICAgIGlmICghZW52Wyd0YWJsZUJhc2UnXSkge1xyXG4gICAgICBlbnZbJ3RhYmxlQmFzZSddID0gMDsgLy8gdGFibGUgc3RhcnRzIGF0IDAgYnkgZGVmYXVsdCwgaW4gZHluYW1pYyBsaW5raW5nIHRoaXMgd2lsbCBjaGFuZ2VcclxuICAgIH1cclxuXHJcbiAgICAvLyB0cnkgdGhlIG1ldGhvZHMuIGVhY2ggc2hvdWxkIHJldHVybiB0aGUgZXhwb3J0cyBpZiBpdCBzdWNjZWVkZWRcclxuXHJcbiAgICB2YXIgZXhwb3J0cztcclxuICAgIGV4cG9ydHMgPSBkb05hdGl2ZVdhc20oZ2xvYmFsLCBlbnYsIHByb3ZpZGVkQnVmZmVyKTtcclxuXHJcbiAgICBpZiAoIWV4cG9ydHMpIGFib3J0KCdubyBiaW5hcnllbiBtZXRob2Qgc3VjY2VlZGVkLiBjb25zaWRlciBlbmFibGluZyBtb3JlIG9wdGlvbnMsIGxpa2UgaW50ZXJwcmV0aW5nLCBpZiB5b3Ugd2FudCB0aGF0OiBodHRwczovL2dpdGh1Yi5jb20va3JpcGtlbi9lbXNjcmlwdGVuL3dpa2kvV2ViQXNzZW1ibHkjYmluYXJ5ZW4tbWV0aG9kcycpO1xyXG5cclxuXHJcbiAgICByZXR1cm4gZXhwb3J0cztcclxuICB9O1xyXG5cclxuICB2YXIgbWV0aG9kSGFuZGxlciA9IE1vZHVsZVsnYXNtJ107IC8vIG5vdGUgb3VyIG1ldGhvZCBoYW5kbGVyLCBhcyB3ZSBtYXkgbW9kaWZ5IE1vZHVsZVsnYXNtJ10gbGF0ZXJcclxufVxyXG5cclxuaW50ZWdyYXRlV2FzbUpTKCk7XHJcblxyXG4vLyA9PT0gQm9keSA9PT1cclxuXHJcbnZhciBBU01fQ09OU1RTID0gW107XHJcblxyXG5cclxuXHJcblxyXG5TVEFUSUNfQkFTRSA9IEdMT0JBTF9CQVNFO1xyXG5cclxuU1RBVElDVE9QID0gU1RBVElDX0JBU0UgKyA5ODg4O1xyXG4vKiBnbG9iYWwgaW5pdGlhbGl6ZXJzICovICBfX0FUSU5JVF9fLnB1c2goKTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbnZhciBTVEFUSUNfQlVNUCA9IDk4ODg7XHJcbk1vZHVsZVtcIlNUQVRJQ19CQVNFXCJdID0gU1RBVElDX0JBU0U7XHJcbk1vZHVsZVtcIlNUQVRJQ19CVU1QXCJdID0gU1RBVElDX0JVTVA7XHJcblxyXG4vKiBubyBtZW1vcnkgaW5pdGlhbGl6ZXIgKi9cclxudmFyIHRlbXBEb3VibGVQdHIgPSBTVEFUSUNUT1A7IFNUQVRJQ1RPUCArPSAxNjtcclxuXHJcbmFzc2VydCh0ZW1wRG91YmxlUHRyICUgOCA9PSAwKTtcclxuXHJcbmZ1bmN0aW9uIGNvcHlUZW1wRmxvYXQocHRyKSB7IC8vIGZ1bmN0aW9ucywgYmVjYXVzZSBpbmxpbmluZyB0aGlzIGNvZGUgaW5jcmVhc2VzIGNvZGUgc2l6ZSB0b28gbXVjaFxyXG5cclxuICBIRUFQOFt0ZW1wRG91YmxlUHRyXSA9IEhFQVA4W3B0cl07XHJcblxyXG4gIEhFQVA4W3RlbXBEb3VibGVQdHIrMV0gPSBIRUFQOFtwdHIrMV07XHJcblxyXG4gIEhFQVA4W3RlbXBEb3VibGVQdHIrMl0gPSBIRUFQOFtwdHIrMl07XHJcblxyXG4gIEhFQVA4W3RlbXBEb3VibGVQdHIrM10gPSBIRUFQOFtwdHIrM107XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBjb3B5VGVtcERvdWJsZShwdHIpIHtcclxuXHJcbiAgSEVBUDhbdGVtcERvdWJsZVB0cl0gPSBIRUFQOFtwdHJdO1xyXG5cclxuICBIRUFQOFt0ZW1wRG91YmxlUHRyKzFdID0gSEVBUDhbcHRyKzFdO1xyXG5cclxuICBIRUFQOFt0ZW1wRG91YmxlUHRyKzJdID0gSEVBUDhbcHRyKzJdO1xyXG5cclxuICBIRUFQOFt0ZW1wRG91YmxlUHRyKzNdID0gSEVBUDhbcHRyKzNdO1xyXG5cclxuICBIRUFQOFt0ZW1wRG91YmxlUHRyKzRdID0gSEVBUDhbcHRyKzRdO1xyXG5cclxuICBIRUFQOFt0ZW1wRG91YmxlUHRyKzVdID0gSEVBUDhbcHRyKzVdO1xyXG5cclxuICBIRUFQOFt0ZW1wRG91YmxlUHRyKzZdID0gSEVBUDhbcHRyKzZdO1xyXG5cclxuICBIRUFQOFt0ZW1wRG91YmxlUHRyKzddID0gSEVBUDhbcHRyKzddO1xyXG5cclxufVxyXG5cclxuLy8ge3tQUkVfTElCUkFSWX19XHJcblxyXG5cclxuICBmdW5jdGlvbiBfX19sb2NrKCkge31cclxuXHJcbiAgXHJcbiAgdmFyIFNZU0NBTExTPXt2YXJhcmdzOjAsZ2V0OmZ1bmN0aW9uICh2YXJhcmdzKSB7XHJcbiAgICAgICAgU1lTQ0FMTFMudmFyYXJncyArPSA0O1xyXG4gICAgICAgIHZhciByZXQgPSBIRUFQMzJbKCgoU1lTQ0FMTFMudmFyYXJncyktKDQpKT4+MildO1xyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgIH0sZ2V0U3RyOmZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmV0ID0gUG9pbnRlcl9zdHJpbmdpZnkoU1lTQ0FMTFMuZ2V0KCkpO1xyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgIH0sZ2V0NjQ6ZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBsb3cgPSBTWVNDQUxMUy5nZXQoKSwgaGlnaCA9IFNZU0NBTExTLmdldCgpO1xyXG4gICAgICAgIGlmIChsb3cgPj0gMCkgYXNzZXJ0KGhpZ2ggPT09IDApO1xyXG4gICAgICAgIGVsc2UgYXNzZXJ0KGhpZ2ggPT09IC0xKTtcclxuICAgICAgICByZXR1cm4gbG93O1xyXG4gICAgICB9LGdldFplcm86ZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGFzc2VydChTWVNDQUxMUy5nZXQoKSA9PT0gMCk7XHJcbiAgICAgIH19O2Z1bmN0aW9uIF9fX3N5c2NhbGwxNDAod2hpY2gsIHZhcmFyZ3MpIHtTWVNDQUxMUy52YXJhcmdzID0gdmFyYXJncztcclxuICB0cnkge1xyXG4gICAvLyBsbHNlZWtcclxuICAgICAgdmFyIHN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRCgpLCBvZmZzZXRfaGlnaCA9IFNZU0NBTExTLmdldCgpLCBvZmZzZXRfbG93ID0gU1lTQ0FMTFMuZ2V0KCksIHJlc3VsdCA9IFNZU0NBTExTLmdldCgpLCB3aGVuY2UgPSBTWVNDQUxMUy5nZXQoKTtcclxuICAgICAgLy8gTk9URTogb2Zmc2V0X2hpZ2ggaXMgdW51c2VkIC0gRW1zY3JpcHRlbidzIG9mZl90IGlzIDMyLWJpdFxyXG4gICAgICB2YXIgb2Zmc2V0ID0gb2Zmc2V0X2xvdztcclxuICAgICAgRlMubGxzZWVrKHN0cmVhbSwgb2Zmc2V0LCB3aGVuY2UpO1xyXG4gICAgICBIRUFQMzJbKChyZXN1bHQpPj4yKV09c3RyZWFtLnBvc2l0aW9uO1xyXG4gICAgICBpZiAoc3RyZWFtLmdldGRlbnRzICYmIG9mZnNldCA9PT0gMCAmJiB3aGVuY2UgPT09IDApIHN0cmVhbS5nZXRkZW50cyA9IG51bGw7IC8vIHJlc2V0IHJlYWRkaXIgc3RhdGVcclxuICAgICAgcmV0dXJuIDA7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICBpZiAodHlwZW9mIEZTID09PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgYWJvcnQoZSk7XHJcbiAgICByZXR1cm4gLWUuZXJybm87XHJcbiAgfVxyXG4gIH1cclxuXHJcbiAgXHJcbiAgZnVuY3Rpb24gZmx1c2hfTk9fRklMRVNZU1RFTSgpIHtcclxuICAgICAgLy8gZmx1c2ggYW55dGhpbmcgcmVtYWluaW5nIGluIHRoZSBidWZmZXJzIGR1cmluZyBzaHV0ZG93blxyXG4gICAgICB2YXIgZmZsdXNoID0gTW9kdWxlW1wiX2ZmbHVzaFwiXTtcclxuICAgICAgaWYgKGZmbHVzaCkgZmZsdXNoKDApO1xyXG4gICAgICB2YXIgcHJpbnRDaGFyID0gX19fc3lzY2FsbDE0Ni5wcmludENoYXI7XHJcbiAgICAgIGlmICghcHJpbnRDaGFyKSByZXR1cm47XHJcbiAgICAgIHZhciBidWZmZXJzID0gX19fc3lzY2FsbDE0Ni5idWZmZXJzO1xyXG4gICAgICBpZiAoYnVmZmVyc1sxXS5sZW5ndGgpIHByaW50Q2hhcigxLCAxMCk7XHJcbiAgICAgIGlmIChidWZmZXJzWzJdLmxlbmd0aCkgcHJpbnRDaGFyKDIsIDEwKTtcclxuICAgIH1mdW5jdGlvbiBfX19zeXNjYWxsMTQ2KHdoaWNoLCB2YXJhcmdzKSB7U1lTQ0FMTFMudmFyYXJncyA9IHZhcmFyZ3M7XHJcbiAgdHJ5IHtcclxuICAgLy8gd3JpdGV2XHJcbiAgICAgIC8vIGhhY2sgdG8gc3VwcG9ydCBwcmludGYgaW4gTk9fRklMRVNZU1RFTVxyXG4gICAgICB2YXIgc3RyZWFtID0gU1lTQ0FMTFMuZ2V0KCksIGlvdiA9IFNZU0NBTExTLmdldCgpLCBpb3ZjbnQgPSBTWVNDQUxMUy5nZXQoKTtcclxuICAgICAgdmFyIHJldCA9IDA7XHJcbiAgICAgIGlmICghX19fc3lzY2FsbDE0Ni5idWZmZXJzKSB7XHJcbiAgICAgICAgX19fc3lzY2FsbDE0Ni5idWZmZXJzID0gW251bGwsIFtdLCBbXV07IC8vIDEgPT4gc3Rkb3V0LCAyID0+IHN0ZGVyclxyXG4gICAgICAgIF9fX3N5c2NhbGwxNDYucHJpbnRDaGFyID0gZnVuY3Rpb24oc3RyZWFtLCBjdXJyKSB7XHJcbiAgICAgICAgICB2YXIgYnVmZmVyID0gX19fc3lzY2FsbDE0Ni5idWZmZXJzW3N0cmVhbV07XHJcbiAgICAgICAgICBhc3NlcnQoYnVmZmVyKTtcclxuICAgICAgICAgIGlmIChjdXJyID09PSAwIHx8IGN1cnIgPT09IDEwKSB7XHJcbiAgICAgICAgICAgIChzdHJlYW0gPT09IDEgPyBNb2R1bGVbJ3ByaW50J10gOiBNb2R1bGVbJ3ByaW50RXJyJ10pKFVURjhBcnJheVRvU3RyaW5nKGJ1ZmZlciwgMCkpO1xyXG4gICAgICAgICAgICBidWZmZXIubGVuZ3RoID0gMDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKGN1cnIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpb3ZjbnQ7IGkrKykge1xyXG4gICAgICAgIHZhciBwdHIgPSBIRUFQMzJbKCgoaW92KSsoaSo4KSk+PjIpXTtcclxuICAgICAgICB2YXIgbGVuID0gSEVBUDMyWygoKGlvdikrKGkqOCArIDQpKT4+MildO1xyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuOyBqKyspIHtcclxuICAgICAgICAgIF9fX3N5c2NhbGwxNDYucHJpbnRDaGFyKHN0cmVhbSwgSEVBUFU4W3B0citqXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldCArPSBsZW47XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJldDtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgIGlmICh0eXBlb2YgRlMgPT09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSBhYm9ydChlKTtcclxuICAgIHJldHVybiAtZS5lcnJubztcclxuICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBfX19zeXNjYWxsNTQod2hpY2gsIHZhcmFyZ3MpIHtTWVNDQUxMUy52YXJhcmdzID0gdmFyYXJncztcclxuICB0cnkge1xyXG4gICAvLyBpb2N0bFxyXG4gICAgICByZXR1cm4gMDtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgIGlmICh0eXBlb2YgRlMgPT09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSBhYm9ydChlKTtcclxuICAgIHJldHVybiAtZS5lcnJubztcclxuICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBfX19zeXNjYWxsNih3aGljaCwgdmFyYXJncykge1NZU0NBTExTLnZhcmFyZ3MgPSB2YXJhcmdzO1xyXG4gIHRyeSB7XHJcbiAgIC8vIGNsb3NlXHJcbiAgICAgIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoKTtcclxuICAgICAgRlMuY2xvc2Uoc3RyZWFtKTtcclxuICAgICAgcmV0dXJuIDA7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICBpZiAodHlwZW9mIEZTID09PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgYWJvcnQoZSk7XHJcbiAgICByZXR1cm4gLWUuZXJybm87XHJcbiAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gX19fdW5sb2NrKCkge31cclxuXHJcbiAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5faGFzX3RocmVhZGluZ19zdXBwb3J0KCkge1xyXG4gICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuXHJcbiAgIFxyXG5cclxuICBcclxuICB2YXIgY3R0el9pOCA9IGFsbG9jYXRlKFs4LDAsMSwwLDIsMCwxLDAsMywwLDEsMCwyLDAsMSwwLDQsMCwxLDAsMiwwLDEsMCwzLDAsMSwwLDIsMCwxLDAsNSwwLDEsMCwyLDAsMSwwLDMsMCwxLDAsMiwwLDEsMCw0LDAsMSwwLDIsMCwxLDAsMywwLDEsMCwyLDAsMSwwLDYsMCwxLDAsMiwwLDEsMCwzLDAsMSwwLDIsMCwxLDAsNCwwLDEsMCwyLDAsMSwwLDMsMCwxLDAsMiwwLDEsMCw1LDAsMSwwLDIsMCwxLDAsMywwLDEsMCwyLDAsMSwwLDQsMCwxLDAsMiwwLDEsMCwzLDAsMSwwLDIsMCwxLDAsNywwLDEsMCwyLDAsMSwwLDMsMCwxLDAsMiwwLDEsMCw0LDAsMSwwLDIsMCwxLDAsMywwLDEsMCwyLDAsMSwwLDUsMCwxLDAsMiwwLDEsMCwzLDAsMSwwLDIsMCwxLDAsNCwwLDEsMCwyLDAsMSwwLDMsMCwxLDAsMiwwLDEsMCw2LDAsMSwwLDIsMCwxLDAsMywwLDEsMCwyLDAsMSwwLDQsMCwxLDAsMiwwLDEsMCwzLDAsMSwwLDIsMCwxLDAsNSwwLDEsMCwyLDAsMSwwLDMsMCwxLDAsMiwwLDEsMCw0LDAsMSwwLDIsMCwxLDAsMywwLDEsMCwyLDAsMSwwXSwgXCJpOFwiLCBBTExPQ19TVEFUSUMpO2Z1bmN0aW9uIF9sbHZtX2N0dHpfaTMyKHgpIHtcclxuICAgICAgeCA9IHh8MDtcclxuICAgICAgdmFyIHJldCA9IDA7XHJcbiAgICAgIHJldCA9ICgoSEVBUDhbKCgoY3R0el9pOCkrKHggJiAweGZmKSk+PjApXSl8MCk7XHJcbiAgICAgIGlmICgocmV0fDApIDwgOCkgcmV0dXJuIHJldHwwO1xyXG4gICAgICByZXQgPSAoKEhFQVA4WygoKGN0dHpfaTgpKygoeCA+PiA4KSYweGZmKSk+PjApXSl8MCk7XHJcbiAgICAgIGlmICgocmV0fDApIDwgOCkgcmV0dXJuIChyZXQgKyA4KXwwO1xyXG4gICAgICByZXQgPSAoKEhFQVA4WygoKGN0dHpfaTgpKygoeCA+PiAxNikmMHhmZikpPj4wKV0pfDApO1xyXG4gICAgICBpZiAoKHJldHwwKSA8IDgpIHJldHVybiAocmV0ICsgMTYpfDA7XHJcbiAgICAgIHJldHVybiAoKChIRUFQOFsoKChjdHR6X2k4KSsoeCA+Pj4gMjQpKT4+MCldKXwwKSArIDI0KXwwO1xyXG4gICAgfWZ1bmN0aW9uIF9sbHZtX2N0dHpfaTY0KGwsIGgpIHtcclxuICAgICAgdmFyIHJldCA9IF9sbHZtX2N0dHpfaTMyKGwpO1xyXG4gICAgICBpZiAocmV0ID09IDMyKSByZXQgKz0gX2xsdm1fY3R0el9pMzIoaCk7XHJcbiAgICAgIHJldHVybiAoKHNldFRlbXBSZXQwKDApLHJldCl8MCk7XHJcbiAgICB9XHJcblxyXG4gIGZ1bmN0aW9uIF9sbHZtX3N0YWNrcmVzdG9yZShwKSB7XHJcbiAgICAgIHZhciBzZWxmID0gX2xsdm1fc3RhY2tzYXZlO1xyXG4gICAgICB2YXIgcmV0ID0gc2VsZi5MTFZNX1NBVkVEU1RBQ0tTW3BdO1xyXG4gICAgICBzZWxmLkxMVk1fU0FWRURTVEFDS1Muc3BsaWNlKHAsIDEpO1xyXG4gICAgICBzdGFja1Jlc3RvcmUocmV0KTtcclxuICAgIH1cclxuXHJcbiAgZnVuY3Rpb24gX2xsdm1fc3RhY2tzYXZlKCkge1xyXG4gICAgICB2YXIgc2VsZiA9IF9sbHZtX3N0YWNrc2F2ZTtcclxuICAgICAgaWYgKCFzZWxmLkxMVk1fU0FWRURTVEFDS1MpIHtcclxuICAgICAgICBzZWxmLkxMVk1fU0FWRURTVEFDS1MgPSBbXTtcclxuICAgICAgfVxyXG4gICAgICBzZWxmLkxMVk1fU0FWRURTVEFDS1MucHVzaChzdGFja1NhdmUoKSk7XHJcbiAgICAgIHJldHVybiBzZWxmLkxMVk1fU0FWRURTVEFDS1MubGVuZ3RoLTE7XHJcbiAgICB9XHJcblxyXG4gIFxyXG4gIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX21lbWNweV9iaWcoZGVzdCwgc3JjLCBudW0pIHtcclxuICAgICAgSEVBUFU4LnNldChIRUFQVTguc3ViYXJyYXkoc3JjLCBzcmMrbnVtKSwgZGVzdCk7XHJcbiAgICAgIHJldHVybiBkZXN0O1xyXG4gICAgfSBcclxuXHJcbiAgIFxyXG5cclxuICBmdW5jdGlvbiBfcHRocmVhZF9jcmVhdGUoKSB7XHJcbiAgICAgIHJldHVybiAxMTtcclxuICAgIH1cclxuXHJcbiAgZnVuY3Rpb24gX3B0aHJlYWRfam9pbigpIHt9XHJcblxyXG4gIGZ1bmN0aW9uIF9wdGhyZWFkX211dGV4X2luaXQoKSB7fVxyXG5cclxuICAgXHJcblxyXG4gICBcclxuXHJcbiAgXHJcbiAgZnVuY3Rpb24gX19fc2V0RXJyTm8odmFsdWUpIHtcclxuICAgICAgaWYgKE1vZHVsZVsnX19fZXJybm9fbG9jYXRpb24nXSkgSEVBUDMyWygoTW9kdWxlWydfX19lcnJub19sb2NhdGlvbiddKCkpPj4yKV09dmFsdWU7XHJcbiAgICAgIGVsc2UgTW9kdWxlLnByaW50RXJyKCdmYWlsZWQgdG8gc2V0IGVycm5vIGZyb20gSlMnKTtcclxuICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfSBcclxuXHJcbiAgXHJcbiAgdmFyIEVSUk5PX0NPREVTPXtFUEVSTToxLEVOT0VOVDoyLEVTUkNIOjMsRUlOVFI6NCxFSU86NSxFTlhJTzo2LEUyQklHOjcsRU5PRVhFQzo4LEVCQURGOjksRUNISUxEOjEwLEVBR0FJTjoxMSxFV09VTERCTE9DSzoxMSxFTk9NRU06MTIsRUFDQ0VTOjEzLEVGQVVMVDoxNCxFTk9UQkxLOjE1LEVCVVNZOjE2LEVFWElTVDoxNyxFWERFVjoxOCxFTk9ERVY6MTksRU5PVERJUjoyMCxFSVNESVI6MjEsRUlOVkFMOjIyLEVORklMRToyMyxFTUZJTEU6MjQsRU5PVFRZOjI1LEVUWFRCU1k6MjYsRUZCSUc6MjcsRU5PU1BDOjI4LEVTUElQRToyOSxFUk9GUzozMCxFTUxJTks6MzEsRVBJUEU6MzIsRURPTTozMyxFUkFOR0U6MzQsRU5PTVNHOjQyLEVJRFJNOjQzLEVDSFJORzo0NCxFTDJOU1lOQzo0NSxFTDNITFQ6NDYsRUwzUlNUOjQ3LEVMTlJORzo0OCxFVU5BVENIOjQ5LEVOT0NTSTo1MCxFTDJITFQ6NTEsRURFQURMSzozNSxFTk9MQ0s6MzcsRUJBREU6NTIsRUJBRFI6NTMsRVhGVUxMOjU0LEVOT0FOTzo1NSxFQkFEUlFDOjU2LEVCQURTTFQ6NTcsRURFQURMT0NLOjM1LEVCRk9OVDo1OSxFTk9TVFI6NjAsRU5PREFUQTo2MSxFVElNRTo2MixFTk9TUjo2MyxFTk9ORVQ6NjQsRU5PUEtHOjY1LEVSRU1PVEU6NjYsRU5PTElOSzo2NyxFQURWOjY4LEVTUk1OVDo2OSxFQ09NTTo3MCxFUFJPVE86NzEsRU1VTFRJSE9QOjcyLEVET1RET1Q6NzMsRUJBRE1TRzo3NCxFTk9UVU5JUTo3NixFQkFERkQ6NzcsRVJFTUNIRzo3OCxFTElCQUNDOjc5LEVMSUJCQUQ6ODAsRUxJQlNDTjo4MSxFTElCTUFYOjgyLEVMSUJFWEVDOjgzLEVOT1NZUzozOCxFTk9URU1QVFk6MzksRU5BTUVUT09MT05HOjM2LEVMT09QOjQwLEVPUE5PVFNVUFA6OTUsRVBGTk9TVVBQT1JUOjk2LEVDT05OUkVTRVQ6MTA0LEVOT0JVRlM6MTA1LEVBRk5PU1VQUE9SVDo5NyxFUFJPVE9UWVBFOjkxLEVOT1RTT0NLOjg4LEVOT1BST1RPT1BUOjkyLEVTSFVURE9XTjoxMDgsRUNPTk5SRUZVU0VEOjExMSxFQUREUklOVVNFOjk4LEVDT05OQUJPUlRFRDoxMDMsRU5FVFVOUkVBQ0g6MTAxLEVORVRET1dOOjEwMCxFVElNRURPVVQ6MTEwLEVIT1NURE9XTjoxMTIsRUhPU1RVTlJFQUNIOjExMyxFSU5QUk9HUkVTUzoxMTUsRUFMUkVBRFk6MTE0LEVERVNUQUREUlJFUTo4OSxFTVNHU0laRTo5MCxFUFJPVE9OT1NVUFBPUlQ6OTMsRVNPQ0tUTk9TVVBQT1JUOjk0LEVBRERSTk9UQVZBSUw6OTksRU5FVFJFU0VUOjEwMixFSVNDT05OOjEwNixFTk9UQ09OTjoxMDcsRVRPT01BTllSRUZTOjEwOSxFVVNFUlM6ODcsRURRVU9UOjEyMixFU1RBTEU6MTE2LEVOT1RTVVA6OTUsRU5PTUVESVVNOjEyMyxFSUxTRVE6ODQsRU9WRVJGTE9XOjc1LEVDQU5DRUxFRDoxMjUsRU5PVFJFQ09WRVJBQkxFOjEzMSxFT1dORVJERUFEOjEzMCxFU1RSUElQRTo4Nn07ZnVuY3Rpb24gX3N5c2NvbmYobmFtZSkge1xyXG4gICAgICAvLyBsb25nIHN5c2NvbmYoaW50IG5hbWUpO1xyXG4gICAgICAvLyBodHRwOi8vcHVicy5vcGVuZ3JvdXAub3JnL29ubGluZXB1YnMvMDA5Njk1Mzk5L2Z1bmN0aW9ucy9zeXNjb25mLmh0bWxcclxuICAgICAgc3dpdGNoKG5hbWUpIHtcclxuICAgICAgICBjYXNlIDMwOiByZXR1cm4gUEFHRV9TSVpFO1xyXG4gICAgICAgIGNhc2UgODU6XHJcbiAgICAgICAgICB2YXIgbWF4SGVhcFNpemUgPSAyKjEwMjQqMTAyNCoxMDI0IC0gNjU1MzY7XHJcbiAgICAgICAgICBtYXhIZWFwU2l6ZSA9IEhFQVBVOC5sZW5ndGg7XHJcbiAgICAgICAgICByZXR1cm4gbWF4SGVhcFNpemUgLyBQQUdFX1NJWkU7XHJcbiAgICAgICAgY2FzZSAxMzI6XHJcbiAgICAgICAgY2FzZSAxMzM6XHJcbiAgICAgICAgY2FzZSAxMjpcclxuICAgICAgICBjYXNlIDEzNzpcclxuICAgICAgICBjYXNlIDEzODpcclxuICAgICAgICBjYXNlIDE1OlxyXG4gICAgICAgIGNhc2UgMjM1OlxyXG4gICAgICAgIGNhc2UgMTY6XHJcbiAgICAgICAgY2FzZSAxNzpcclxuICAgICAgICBjYXNlIDE4OlxyXG4gICAgICAgIGNhc2UgMTk6XHJcbiAgICAgICAgY2FzZSAyMDpcclxuICAgICAgICBjYXNlIDE0OTpcclxuICAgICAgICBjYXNlIDEzOlxyXG4gICAgICAgIGNhc2UgMTA6XHJcbiAgICAgICAgY2FzZSAyMzY6XHJcbiAgICAgICAgY2FzZSAxNTM6XHJcbiAgICAgICAgY2FzZSA5OlxyXG4gICAgICAgIGNhc2UgMjE6XHJcbiAgICAgICAgY2FzZSAyMjpcclxuICAgICAgICBjYXNlIDE1OTpcclxuICAgICAgICBjYXNlIDE1NDpcclxuICAgICAgICBjYXNlIDE0OlxyXG4gICAgICAgIGNhc2UgNzc6XHJcbiAgICAgICAgY2FzZSA3ODpcclxuICAgICAgICBjYXNlIDEzOTpcclxuICAgICAgICBjYXNlIDgwOlxyXG4gICAgICAgIGNhc2UgODE6XHJcbiAgICAgICAgY2FzZSA4MjpcclxuICAgICAgICBjYXNlIDY4OlxyXG4gICAgICAgIGNhc2UgNjc6XHJcbiAgICAgICAgY2FzZSAxNjQ6XHJcbiAgICAgICAgY2FzZSAxMTpcclxuICAgICAgICBjYXNlIDI5OlxyXG4gICAgICAgIGNhc2UgNDc6XHJcbiAgICAgICAgY2FzZSA0ODpcclxuICAgICAgICBjYXNlIDk1OlxyXG4gICAgICAgIGNhc2UgNTI6XHJcbiAgICAgICAgY2FzZSA1MTpcclxuICAgICAgICBjYXNlIDQ2OlxyXG4gICAgICAgICAgcmV0dXJuIDIwMDgwOTtcclxuICAgICAgICBjYXNlIDc5OlxyXG4gICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgY2FzZSAyNzpcclxuICAgICAgICBjYXNlIDI0NjpcclxuICAgICAgICBjYXNlIDEyNzpcclxuICAgICAgICBjYXNlIDEyODpcclxuICAgICAgICBjYXNlIDIzOlxyXG4gICAgICAgIGNhc2UgMjQ6XHJcbiAgICAgICAgY2FzZSAxNjA6XHJcbiAgICAgICAgY2FzZSAxNjE6XHJcbiAgICAgICAgY2FzZSAxODE6XHJcbiAgICAgICAgY2FzZSAxODI6XHJcbiAgICAgICAgY2FzZSAyNDI6XHJcbiAgICAgICAgY2FzZSAxODM6XHJcbiAgICAgICAgY2FzZSAxODQ6XHJcbiAgICAgICAgY2FzZSAyNDM6XHJcbiAgICAgICAgY2FzZSAyNDQ6XHJcbiAgICAgICAgY2FzZSAyNDU6XHJcbiAgICAgICAgY2FzZSAxNjU6XHJcbiAgICAgICAgY2FzZSAxNzg6XHJcbiAgICAgICAgY2FzZSAxNzk6XHJcbiAgICAgICAgY2FzZSA0OTpcclxuICAgICAgICBjYXNlIDUwOlxyXG4gICAgICAgIGNhc2UgMTY4OlxyXG4gICAgICAgIGNhc2UgMTY5OlxyXG4gICAgICAgIGNhc2UgMTc1OlxyXG4gICAgICAgIGNhc2UgMTcwOlxyXG4gICAgICAgIGNhc2UgMTcxOlxyXG4gICAgICAgIGNhc2UgMTcyOlxyXG4gICAgICAgIGNhc2UgOTc6XHJcbiAgICAgICAgY2FzZSA3NjpcclxuICAgICAgICBjYXNlIDMyOlxyXG4gICAgICAgIGNhc2UgMTczOlxyXG4gICAgICAgIGNhc2UgMzU6XHJcbiAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgY2FzZSAxNzY6XHJcbiAgICAgICAgY2FzZSAxNzc6XHJcbiAgICAgICAgY2FzZSA3OlxyXG4gICAgICAgIGNhc2UgMTU1OlxyXG4gICAgICAgIGNhc2UgODpcclxuICAgICAgICBjYXNlIDE1NzpcclxuICAgICAgICBjYXNlIDEyNTpcclxuICAgICAgICBjYXNlIDEyNjpcclxuICAgICAgICBjYXNlIDkyOlxyXG4gICAgICAgIGNhc2UgOTM6XHJcbiAgICAgICAgY2FzZSAxMjk6XHJcbiAgICAgICAgY2FzZSAxMzA6XHJcbiAgICAgICAgY2FzZSAxMzE6XHJcbiAgICAgICAgY2FzZSA5NDpcclxuICAgICAgICBjYXNlIDkxOlxyXG4gICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgY2FzZSA3NDpcclxuICAgICAgICBjYXNlIDYwOlxyXG4gICAgICAgIGNhc2UgNjk6XHJcbiAgICAgICAgY2FzZSA3MDpcclxuICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICByZXR1cm4gMTAyNDtcclxuICAgICAgICBjYXNlIDMxOlxyXG4gICAgICAgIGNhc2UgNDI6XHJcbiAgICAgICAgY2FzZSA3MjpcclxuICAgICAgICAgIHJldHVybiAzMjtcclxuICAgICAgICBjYXNlIDg3OlxyXG4gICAgICAgIGNhc2UgMjY6XHJcbiAgICAgICAgY2FzZSAzMzpcclxuICAgICAgICAgIHJldHVybiAyMTQ3NDgzNjQ3O1xyXG4gICAgICAgIGNhc2UgMzQ6XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgcmV0dXJuIDQ3ODM5O1xyXG4gICAgICAgIGNhc2UgMzg6XHJcbiAgICAgICAgY2FzZSAzNjpcclxuICAgICAgICAgIHJldHVybiA5OTtcclxuICAgICAgICBjYXNlIDQzOlxyXG4gICAgICAgIGNhc2UgMzc6XHJcbiAgICAgICAgICByZXR1cm4gMjA0ODtcclxuICAgICAgICBjYXNlIDA6IHJldHVybiAyMDk3MTUyO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIDY1NTM2O1xyXG4gICAgICAgIGNhc2UgMjg6IHJldHVybiAzMjc2ODtcclxuICAgICAgICBjYXNlIDQ0OiByZXR1cm4gMzI3Njc7XHJcbiAgICAgICAgY2FzZSA3NTogcmV0dXJuIDE2Mzg0O1xyXG4gICAgICAgIGNhc2UgMzk6IHJldHVybiAxMDAwO1xyXG4gICAgICAgIGNhc2UgODk6IHJldHVybiA3MDA7XHJcbiAgICAgICAgY2FzZSA3MTogcmV0dXJuIDI1NjtcclxuICAgICAgICBjYXNlIDQwOiByZXR1cm4gMjU1O1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIDEwMDtcclxuICAgICAgICBjYXNlIDE4MDogcmV0dXJuIDY0O1xyXG4gICAgICAgIGNhc2UgMjU6IHJldHVybiAyMDtcclxuICAgICAgICBjYXNlIDU6IHJldHVybiAxNjtcclxuICAgICAgICBjYXNlIDY6IHJldHVybiA2O1xyXG4gICAgICAgIGNhc2UgNzM6IHJldHVybiA0O1xyXG4gICAgICAgIGNhc2UgODQ6IHtcclxuICAgICAgICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAnb2JqZWN0JykgcmV0dXJuIG5hdmlnYXRvclsnaGFyZHdhcmVDb25jdXJyZW5jeSddIHx8IDE7XHJcbiAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgX19fc2V0RXJyTm8oRVJSTk9fQ09ERVMuRUlOVkFMKTtcclxuICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG5EWU5BTUlDVE9QX1BUUiA9IHN0YXRpY0FsbG9jKDQpO1xyXG5cclxuU1RBQ0tfQkFTRSA9IFNUQUNLVE9QID0gYWxpZ25NZW1vcnkoU1RBVElDVE9QKTtcclxuXHJcblNUQUNLX01BWCA9IFNUQUNLX0JBU0UgKyBUT1RBTF9TVEFDSztcclxuXHJcbkRZTkFNSUNfQkFTRSA9IGFsaWduTWVtb3J5KFNUQUNLX01BWCk7XHJcblxyXG5IRUFQMzJbRFlOQU1JQ1RPUF9QVFI+PjJdID0gRFlOQU1JQ19CQVNFO1xyXG5cclxuc3RhdGljU2VhbGVkID0gdHJ1ZTsgLy8gc2VhbCB0aGUgc3RhdGljIHBvcnRpb24gb2YgbWVtb3J5XHJcblxyXG5hc3NlcnQoRFlOQU1JQ19CQVNFIDwgVE9UQUxfTUVNT1JZLCBcIlRPVEFMX01FTU9SWSBub3QgYmlnIGVub3VnaCBmb3Igc3RhY2tcIik7XHJcblxyXG52YXIgQVNTRVJUSU9OUyA9IHRydWU7XHJcblxyXG4vKiogQHR5cGUge2Z1bmN0aW9uKHN0cmluZywgYm9vbGVhbj0sIG51bWJlcj0pfSAqL1xyXG5mdW5jdGlvbiBpbnRBcnJheUZyb21TdHJpbmcoc3RyaW5neSwgZG9udEFkZE51bGwsIGxlbmd0aCkge1xyXG4gIHZhciBsZW4gPSBsZW5ndGggPiAwID8gbGVuZ3RoIDogbGVuZ3RoQnl0ZXNVVEY4KHN0cmluZ3kpKzE7XHJcbiAgdmFyIHU4YXJyYXkgPSBuZXcgQXJyYXkobGVuKTtcclxuICB2YXIgbnVtQnl0ZXNXcml0dGVuID0gc3RyaW5nVG9VVEY4QXJyYXkoc3RyaW5neSwgdThhcnJheSwgMCwgdThhcnJheS5sZW5ndGgpO1xyXG4gIGlmIChkb250QWRkTnVsbCkgdThhcnJheS5sZW5ndGggPSBudW1CeXRlc1dyaXR0ZW47XHJcbiAgcmV0dXJuIHU4YXJyYXk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGludEFycmF5VG9TdHJpbmcoYXJyYXkpIHtcclxuICB2YXIgcmV0ID0gW107XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xyXG4gICAgdmFyIGNociA9IGFycmF5W2ldO1xyXG4gICAgaWYgKGNociA+IDB4RkYpIHtcclxuICAgICAgaWYgKEFTU0VSVElPTlMpIHtcclxuICAgICAgICBhc3NlcnQoZmFsc2UsICdDaGFyYWN0ZXIgY29kZSAnICsgY2hyICsgJyAoJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyKSArICcpICBhdCBvZmZzZXQgJyArIGkgKyAnIG5vdCBpbiAweDAwLTB4RkYuJyk7XHJcbiAgICAgIH1cclxuICAgICAgY2hyICY9IDB4RkY7XHJcbiAgICB9XHJcbiAgICByZXQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGNocikpO1xyXG4gIH1cclxuICByZXR1cm4gcmV0LmpvaW4oJycpO1xyXG59XHJcblxyXG5cclxuLy8gQ29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3N0cm9waGUvc3Ryb3BoZWpzL2Jsb2IvZTA2ZDAyNy9zcmMvcG9seWZpbGxzLmpzI0wxNDlcclxuXHJcbi8vIFRoaXMgY29kZSB3YXMgd3JpdHRlbiBieSBUeWxlciBBa2lucyBhbmQgaGFzIGJlZW4gcGxhY2VkIGluIHRoZVxyXG4vLyBwdWJsaWMgZG9tYWluLiAgSXQgd291bGQgYmUgbmljZSBpZiB5b3UgbGVmdCB0aGlzIGhlYWRlciBpbnRhY3QuXHJcbi8vIEJhc2U2NCBjb2RlIGZyb20gVHlsZXIgQWtpbnMgLS0gaHR0cDovL3J1bWtpbi5jb21cclxuXHJcbi8qKlxyXG4gKiBEZWNvZGVzIGEgYmFzZTY0IHN0cmluZy5cclxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgdG8gZGVjb2RlLlxyXG4gKi9cclxudmFyIGRlY29kZUJhc2U2NCA9IHR5cGVvZiBhdG9iID09PSAnZnVuY3Rpb24nID8gYXRvYiA6IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gIHZhciBrZXlTdHIgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nO1xyXG5cclxuICB2YXIgb3V0cHV0ID0gJyc7XHJcbiAgdmFyIGNocjEsIGNocjIsIGNocjM7XHJcbiAgdmFyIGVuYzEsIGVuYzIsIGVuYzMsIGVuYzQ7XHJcbiAgdmFyIGkgPSAwO1xyXG4gIC8vIHJlbW92ZSBhbGwgY2hhcmFjdGVycyB0aGF0IGFyZSBub3QgQS1aLCBhLXosIDAtOSwgKywgLywgb3IgPVxyXG4gIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvW15BLVphLXowLTlcXCtcXC9cXD1dL2csICcnKTtcclxuICBkbyB7XHJcbiAgICBlbmMxID0ga2V5U3RyLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpO1xyXG4gICAgZW5jMiA9IGtleVN0ci5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcclxuICAgIGVuYzMgPSBrZXlTdHIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XHJcbiAgICBlbmM0ID0ga2V5U3RyLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpO1xyXG5cclxuICAgIGNocjEgPSAoZW5jMSA8PCAyKSB8IChlbmMyID4+IDQpO1xyXG4gICAgY2hyMiA9ICgoZW5jMiAmIDE1KSA8PCA0KSB8IChlbmMzID4+IDIpO1xyXG4gICAgY2hyMyA9ICgoZW5jMyAmIDMpIDw8IDYpIHwgZW5jNDtcclxuXHJcbiAgICBvdXRwdXQgPSBvdXRwdXQgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocjEpO1xyXG5cclxuICAgIGlmIChlbmMzICE9PSA2NCkge1xyXG4gICAgICBvdXRwdXQgPSBvdXRwdXQgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocjIpO1xyXG4gICAgfVxyXG4gICAgaWYgKGVuYzQgIT09IDY0KSB7XHJcbiAgICAgIG91dHB1dCA9IG91dHB1dCArIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyMyk7XHJcbiAgICB9XHJcbiAgfSB3aGlsZSAoaSA8IGlucHV0Lmxlbmd0aCk7XHJcbiAgcmV0dXJuIG91dHB1dDtcclxufTtcclxuXHJcbi8vIENvbnZlcnRzIGEgc3RyaW5nIG9mIGJhc2U2NCBpbnRvIGEgYnl0ZSBhcnJheS5cclxuLy8gVGhyb3dzIGVycm9yIG9uIGludmFsaWQgaW5wdXQuXHJcbmZ1bmN0aW9uIGludEFycmF5RnJvbUJhc2U2NChzKSB7XHJcbiAgaWYgKHR5cGVvZiBFTlZJUk9OTUVOVF9JU19OT0RFID09PSAnYm9vbGVhbicgJiYgRU5WSVJPTk1FTlRfSVNfTk9ERSkge1xyXG4gICAgdmFyIGJ1ZjtcclxuICAgIHRyeSB7XHJcbiAgICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKHMsICdiYXNlNjQnKTtcclxuICAgIH0gY2F0Y2ggKF8pIHtcclxuICAgICAgYnVmID0gbmV3IEJ1ZmZlcihzLCAnYmFzZTY0Jyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlTGVuZ3RoKTtcclxuICB9XHJcblxyXG4gIHRyeSB7XHJcbiAgICB2YXIgZGVjb2RlZCA9IGRlY29kZUJhc2U2NChzKTtcclxuICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGRlY29kZWQubGVuZ3RoKTtcclxuICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IGRlY29kZWQubGVuZ3RoIDsgKytpKSB7XHJcbiAgICAgIGJ5dGVzW2ldID0gZGVjb2RlZC5jaGFyQ29kZUF0KGkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGJ5dGVzO1xyXG4gIH0gY2F0Y2ggKF8pIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignQ29udmVydGluZyBiYXNlNjQgc3RyaW5nIHRvIGJ5dGVzIGZhaWxlZC4nKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIElmIGZpbGVuYW1lIGlzIGEgYmFzZTY0IGRhdGEgVVJJLCBwYXJzZXMgYW5kIHJldHVybnMgZGF0YSAoQnVmZmVyIG9uIG5vZGUsXHJcbi8vIFVpbnQ4QXJyYXkgb3RoZXJ3aXNlKS4gSWYgZmlsZW5hbWUgaXMgbm90IGEgYmFzZTY0IGRhdGEgVVJJLCByZXR1cm5zIHVuZGVmaW5lZC5cclxuZnVuY3Rpb24gdHJ5UGFyc2VBc0RhdGFVUkkoZmlsZW5hbWUpIHtcclxuICBpZiAoIWlzRGF0YVVSSShmaWxlbmFtZSkpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIHJldHVybiBpbnRBcnJheUZyb21CYXNlNjQoZmlsZW5hbWUuc2xpY2UoZGF0YVVSSVByZWZpeC5sZW5ndGgpKTtcclxufVxyXG5cclxuXHJcblxyXG5mdW5jdGlvbiBudWxsRnVuY19paSh4KSB7IE1vZHVsZVtcInByaW50RXJyXCJdKFwiSW52YWxpZCBmdW5jdGlvbiBwb2ludGVyIGNhbGxlZCB3aXRoIHNpZ25hdHVyZSAnaWknLiBQZXJoYXBzIHRoaXMgaXMgYW4gaW52YWxpZCB2YWx1ZSAoZS5nLiBjYXVzZWQgYnkgY2FsbGluZyBhIHZpcnR1YWwgbWV0aG9kIG9uIGEgTlVMTCBwb2ludGVyKT8gT3IgY2FsbGluZyBhIGZ1bmN0aW9uIHdpdGggYW4gaW5jb3JyZWN0IHR5cGUsIHdoaWNoIHdpbGwgZmFpbD8gKGl0IGlzIHdvcnRoIGJ1aWxkaW5nIHlvdXIgc291cmNlIGZpbGVzIHdpdGggLVdlcnJvciAod2FybmluZ3MgYXJlIGVycm9ycyksIGFzIHdhcm5pbmdzIGNhbiBpbmRpY2F0ZSB1bmRlZmluZWQgYmVoYXZpb3Igd2hpY2ggY2FuIGNhdXNlIHRoaXMpXCIpOyAgTW9kdWxlW1wicHJpbnRFcnJcIl0oXCJCdWlsZCB3aXRoIEFTU0VSVElPTlM9MiBmb3IgbW9yZSBpbmZvLlwiKTthYm9ydCh4KSB9XHJcblxyXG5mdW5jdGlvbiBudWxsRnVuY19paWlpKHgpIHsgTW9kdWxlW1wicHJpbnRFcnJcIl0oXCJJbnZhbGlkIGZ1bmN0aW9uIHBvaW50ZXIgY2FsbGVkIHdpdGggc2lnbmF0dXJlICdpaWlpJy4gUGVyaGFwcyB0aGlzIGlzIGFuIGludmFsaWQgdmFsdWUgKGUuZy4gY2F1c2VkIGJ5IGNhbGxpbmcgYSB2aXJ0dWFsIG1ldGhvZCBvbiBhIE5VTEwgcG9pbnRlcik/IE9yIGNhbGxpbmcgYSBmdW5jdGlvbiB3aXRoIGFuIGluY29ycmVjdCB0eXBlLCB3aGljaCB3aWxsIGZhaWw/IChpdCBpcyB3b3J0aCBidWlsZGluZyB5b3VyIHNvdXJjZSBmaWxlcyB3aXRoIC1XZXJyb3IgKHdhcm5pbmdzIGFyZSBlcnJvcnMpLCBhcyB3YXJuaW5ncyBjYW4gaW5kaWNhdGUgdW5kZWZpbmVkIGJlaGF2aW9yIHdoaWNoIGNhbiBjYXVzZSB0aGlzKVwiKTsgIE1vZHVsZVtcInByaW50RXJyXCJdKFwiQnVpbGQgd2l0aCBBU1NFUlRJT05TPTIgZm9yIG1vcmUgaW5mby5cIik7YWJvcnQoeCkgfVxyXG5cclxuTW9kdWxlWyd3YXNtVGFibGVTaXplJ10gPSAxNjtcclxuXHJcbk1vZHVsZVsnd2FzbU1heFRhYmxlU2l6ZSddID0gMTY7XHJcblxyXG5mdW5jdGlvbiBpbnZva2VfaWkoaW5kZXgsYTEpIHtcclxuICB0cnkge1xyXG4gICAgcmV0dXJuIE1vZHVsZVtcImR5bkNhbGxfaWlcIl0oaW5kZXgsYTEpO1xyXG4gIH0gY2F0Y2goZSkge1xyXG4gICAgaWYgKHR5cGVvZiBlICE9PSAnbnVtYmVyJyAmJiBlICE9PSAnbG9uZ2ptcCcpIHRocm93IGU7XHJcbiAgICBNb2R1bGVbXCJzZXRUaHJld1wiXSgxLCAwKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGludm9rZV9paWlpKGluZGV4LGExLGEyLGEzKSB7XHJcbiAgdHJ5IHtcclxuICAgIHJldHVybiBNb2R1bGVbXCJkeW5DYWxsX2lpaWlcIl0oaW5kZXgsYTEsYTIsYTMpO1xyXG4gIH0gY2F0Y2goZSkge1xyXG4gICAgaWYgKHR5cGVvZiBlICE9PSAnbnVtYmVyJyAmJiBlICE9PSAnbG9uZ2ptcCcpIHRocm93IGU7XHJcbiAgICBNb2R1bGVbXCJzZXRUaHJld1wiXSgxLCAwKTtcclxuICB9XHJcbn1cclxuXHJcbk1vZHVsZS5hc21HbG9iYWxBcmcgPSB7fTtcclxuXHJcbk1vZHVsZS5hc21MaWJyYXJ5QXJnID0geyBcImFib3J0XCI6IGFib3J0LCBcImFzc2VydFwiOiBhc3NlcnQsIFwiZW5sYXJnZU1lbW9yeVwiOiBlbmxhcmdlTWVtb3J5LCBcImdldFRvdGFsTWVtb3J5XCI6IGdldFRvdGFsTWVtb3J5LCBcImFib3J0T25DYW5ub3RHcm93TWVtb3J5XCI6IGFib3J0T25DYW5ub3RHcm93TWVtb3J5LCBcImFib3J0U3RhY2tPdmVyZmxvd1wiOiBhYm9ydFN0YWNrT3ZlcmZsb3csIFwibnVsbEZ1bmNfaWlcIjogbnVsbEZ1bmNfaWksIFwibnVsbEZ1bmNfaWlpaVwiOiBudWxsRnVuY19paWlpLCBcImludm9rZV9paVwiOiBpbnZva2VfaWksIFwiaW52b2tlX2lpaWlcIjogaW52b2tlX2lpaWksIFwiX19fbG9ja1wiOiBfX19sb2NrLCBcIl9fX3NldEVyck5vXCI6IF9fX3NldEVyck5vLCBcIl9fX3N5c2NhbGwxNDBcIjogX19fc3lzY2FsbDE0MCwgXCJfX19zeXNjYWxsMTQ2XCI6IF9fX3N5c2NhbGwxNDYsIFwiX19fc3lzY2FsbDU0XCI6IF9fX3N5c2NhbGw1NCwgXCJfX19zeXNjYWxsNlwiOiBfX19zeXNjYWxsNiwgXCJfX191bmxvY2tcIjogX19fdW5sb2NrLCBcIl9lbXNjcmlwdGVuX2hhc190aHJlYWRpbmdfc3VwcG9ydFwiOiBfZW1zY3JpcHRlbl9oYXNfdGhyZWFkaW5nX3N1cHBvcnQsIFwiX2Vtc2NyaXB0ZW5fbWVtY3B5X2JpZ1wiOiBfZW1zY3JpcHRlbl9tZW1jcHlfYmlnLCBcIl9sbHZtX2N0dHpfaTMyXCI6IF9sbHZtX2N0dHpfaTMyLCBcIl9sbHZtX2N0dHpfaTY0XCI6IF9sbHZtX2N0dHpfaTY0LCBcIl9sbHZtX3N0YWNrcmVzdG9yZVwiOiBfbGx2bV9zdGFja3Jlc3RvcmUsIFwiX2xsdm1fc3RhY2tzYXZlXCI6IF9sbHZtX3N0YWNrc2F2ZSwgXCJfcHRocmVhZF9jcmVhdGVcIjogX3B0aHJlYWRfY3JlYXRlLCBcIl9wdGhyZWFkX2pvaW5cIjogX3B0aHJlYWRfam9pbiwgXCJfcHRocmVhZF9tdXRleF9pbml0XCI6IF9wdGhyZWFkX211dGV4X2luaXQsIFwiX3N5c2NvbmZcIjogX3N5c2NvbmYsIFwiZmx1c2hfTk9fRklMRVNZU1RFTVwiOiBmbHVzaF9OT19GSUxFU1lTVEVNLCBcIkRZTkFNSUNUT1BfUFRSXCI6IERZTkFNSUNUT1BfUFRSLCBcInRlbXBEb3VibGVQdHJcIjogdGVtcERvdWJsZVB0ciwgXCJBQk9SVFwiOiBBQk9SVCwgXCJTVEFDS1RPUFwiOiBTVEFDS1RPUCwgXCJTVEFDS19NQVhcIjogU1RBQ0tfTUFYLCBcImN0dHpfaThcIjogY3R0el9pOCB9O1xyXG4vLyBFTVNDUklQVEVOX1NUQVJUX0FTTVxyXG52YXIgYXNtID1Nb2R1bGVbXCJhc21cIl0vLyBFTVNDUklQVEVOX0VORF9BU01cclxuKE1vZHVsZS5hc21HbG9iYWxBcmcsIE1vZHVsZS5hc21MaWJyYXJ5QXJnLCBidWZmZXIpO1xyXG5cclxudmFyIHJlYWxfX19fZXJybm9fbG9jYXRpb24gPSBhc21bXCJfX19lcnJub19sb2NhdGlvblwiXTsgYXNtW1wiX19fZXJybm9fbG9jYXRpb25cIl0gPSBmdW5jdGlvbigpIHtcclxuICBhc3NlcnQocnVudGltZUluaXRpYWxpemVkLCAneW91IG5lZWQgdG8gd2FpdCBmb3IgdGhlIHJ1bnRpbWUgdG8gYmUgcmVhZHkgKGUuZy4gd2FpdCBmb3IgbWFpbigpIHRvIGJlIGNhbGxlZCknKTtcclxuICBhc3NlcnQoIXJ1bnRpbWVFeGl0ZWQsICd0aGUgcnVudGltZSB3YXMgZXhpdGVkICh1c2UgTk9fRVhJVF9SVU5USU1FIHRvIGtlZXAgaXQgYWxpdmUgYWZ0ZXIgbWFpbigpIGV4aXRzKScpO1xyXG4gIHJldHVybiByZWFsX19fX2Vycm5vX2xvY2F0aW9uLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG52YXIgcmVhbF9fY2N1cmxfcG93ID0gYXNtW1wiX2NjdXJsX3Bvd1wiXTsgYXNtW1wiX2NjdXJsX3Bvd1wiXSA9IGZ1bmN0aW9uKCkge1xyXG4gIGFzc2VydChydW50aW1lSW5pdGlhbGl6ZWQsICd5b3UgbmVlZCB0byB3YWl0IGZvciB0aGUgcnVudGltZSB0byBiZSByZWFkeSAoZS5nLiB3YWl0IGZvciBtYWluKCkgdG8gYmUgY2FsbGVkKScpO1xyXG4gIGFzc2VydCghcnVudGltZUV4aXRlZCwgJ3RoZSBydW50aW1lIHdhcyBleGl0ZWQgKHVzZSBOT19FWElUX1JVTlRJTUUgdG8ga2VlcCBpdCBhbGl2ZSBhZnRlciBtYWluKCkgZXhpdHMpJyk7XHJcbiAgcmV0dXJuIHJlYWxfX2NjdXJsX3Bvdy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG59O1xyXG5cclxudmFyIHJlYWxfX2ZmbHVzaCA9IGFzbVtcIl9mZmx1c2hcIl07IGFzbVtcIl9mZmx1c2hcIl0gPSBmdW5jdGlvbigpIHtcclxuICBhc3NlcnQocnVudGltZUluaXRpYWxpemVkLCAneW91IG5lZWQgdG8gd2FpdCBmb3IgdGhlIHJ1bnRpbWUgdG8gYmUgcmVhZHkgKGUuZy4gd2FpdCBmb3IgbWFpbigpIHRvIGJlIGNhbGxlZCknKTtcclxuICBhc3NlcnQoIXJ1bnRpbWVFeGl0ZWQsICd0aGUgcnVudGltZSB3YXMgZXhpdGVkICh1c2UgTk9fRVhJVF9SVU5USU1FIHRvIGtlZXAgaXQgYWxpdmUgYWZ0ZXIgbWFpbigpIGV4aXRzKScpO1xyXG4gIHJldHVybiByZWFsX19mZmx1c2guYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxufTtcclxuXHJcbnZhciByZWFsX19mcmVlID0gYXNtW1wiX2ZyZWVcIl07IGFzbVtcIl9mcmVlXCJdID0gZnVuY3Rpb24oKSB7XHJcbiAgYXNzZXJ0KHJ1bnRpbWVJbml0aWFsaXplZCwgJ3lvdSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBydW50aW1lIHRvIGJlIHJlYWR5IChlLmcuIHdhaXQgZm9yIG1haW4oKSB0byBiZSBjYWxsZWQpJyk7XHJcbiAgYXNzZXJ0KCFydW50aW1lRXhpdGVkLCAndGhlIHJ1bnRpbWUgd2FzIGV4aXRlZCAodXNlIE5PX0VYSVRfUlVOVElNRSB0byBrZWVwIGl0IGFsaXZlIGFmdGVyIG1haW4oKSBleGl0cyknKTtcclxuICByZXR1cm4gcmVhbF9fZnJlZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG59O1xyXG5cclxudmFyIHJlYWxfX2xsdm1fYnN3YXBfaTMyID0gYXNtW1wiX2xsdm1fYnN3YXBfaTMyXCJdOyBhc21bXCJfbGx2bV9ic3dhcF9pMzJcIl0gPSBmdW5jdGlvbigpIHtcclxuICBhc3NlcnQocnVudGltZUluaXRpYWxpemVkLCAneW91IG5lZWQgdG8gd2FpdCBmb3IgdGhlIHJ1bnRpbWUgdG8gYmUgcmVhZHkgKGUuZy4gd2FpdCBmb3IgbWFpbigpIHRvIGJlIGNhbGxlZCknKTtcclxuICBhc3NlcnQoIXJ1bnRpbWVFeGl0ZWQsICd0aGUgcnVudGltZSB3YXMgZXhpdGVkICh1c2UgTk9fRVhJVF9SVU5USU1FIHRvIGtlZXAgaXQgYWxpdmUgYWZ0ZXIgbWFpbigpIGV4aXRzKScpO1xyXG4gIHJldHVybiByZWFsX19sbHZtX2Jzd2FwX2kzMi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG59O1xyXG5cclxudmFyIHJlYWxfX21hbGxvYyA9IGFzbVtcIl9tYWxsb2NcIl07IGFzbVtcIl9tYWxsb2NcIl0gPSBmdW5jdGlvbigpIHtcclxuICBhc3NlcnQocnVudGltZUluaXRpYWxpemVkLCAneW91IG5lZWQgdG8gd2FpdCBmb3IgdGhlIHJ1bnRpbWUgdG8gYmUgcmVhZHkgKGUuZy4gd2FpdCBmb3IgbWFpbigpIHRvIGJlIGNhbGxlZCknKTtcclxuICBhc3NlcnQoIXJ1bnRpbWVFeGl0ZWQsICd0aGUgcnVudGltZSB3YXMgZXhpdGVkICh1c2UgTk9fRVhJVF9SVU5USU1FIHRvIGtlZXAgaXQgYWxpdmUgYWZ0ZXIgbWFpbigpIGV4aXRzKScpO1xyXG4gIHJldHVybiByZWFsX19tYWxsb2MuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxufTtcclxuXHJcbnZhciByZWFsX19wdGhyZWFkX211dGV4X2xvY2sgPSBhc21bXCJfcHRocmVhZF9tdXRleF9sb2NrXCJdOyBhc21bXCJfcHRocmVhZF9tdXRleF9sb2NrXCJdID0gZnVuY3Rpb24oKSB7XHJcbiAgYXNzZXJ0KHJ1bnRpbWVJbml0aWFsaXplZCwgJ3lvdSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBydW50aW1lIHRvIGJlIHJlYWR5IChlLmcuIHdhaXQgZm9yIG1haW4oKSB0byBiZSBjYWxsZWQpJyk7XHJcbiAgYXNzZXJ0KCFydW50aW1lRXhpdGVkLCAndGhlIHJ1bnRpbWUgd2FzIGV4aXRlZCAodXNlIE5PX0VYSVRfUlVOVElNRSB0byBrZWVwIGl0IGFsaXZlIGFmdGVyIG1haW4oKSBleGl0cyknKTtcclxuICByZXR1cm4gcmVhbF9fcHRocmVhZF9tdXRleF9sb2NrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG52YXIgcmVhbF9fcHRocmVhZF9tdXRleF91bmxvY2sgPSBhc21bXCJfcHRocmVhZF9tdXRleF91bmxvY2tcIl07IGFzbVtcIl9wdGhyZWFkX211dGV4X3VubG9ja1wiXSA9IGZ1bmN0aW9uKCkge1xyXG4gIGFzc2VydChydW50aW1lSW5pdGlhbGl6ZWQsICd5b3UgbmVlZCB0byB3YWl0IGZvciB0aGUgcnVudGltZSB0byBiZSByZWFkeSAoZS5nLiB3YWl0IGZvciBtYWluKCkgdG8gYmUgY2FsbGVkKScpO1xyXG4gIGFzc2VydCghcnVudGltZUV4aXRlZCwgJ3RoZSBydW50aW1lIHdhcyBleGl0ZWQgKHVzZSBOT19FWElUX1JVTlRJTUUgdG8ga2VlcCBpdCBhbGl2ZSBhZnRlciBtYWluKCkgZXhpdHMpJyk7XHJcbiAgcmV0dXJuIHJlYWxfX3B0aHJlYWRfbXV0ZXhfdW5sb2NrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG52YXIgcmVhbF9fc2JyayA9IGFzbVtcIl9zYnJrXCJdOyBhc21bXCJfc2Jya1wiXSA9IGZ1bmN0aW9uKCkge1xyXG4gIGFzc2VydChydW50aW1lSW5pdGlhbGl6ZWQsICd5b3UgbmVlZCB0byB3YWl0IGZvciB0aGUgcnVudGltZSB0byBiZSByZWFkeSAoZS5nLiB3YWl0IGZvciBtYWluKCkgdG8gYmUgY2FsbGVkKScpO1xyXG4gIGFzc2VydCghcnVudGltZUV4aXRlZCwgJ3RoZSBydW50aW1lIHdhcyBleGl0ZWQgKHVzZSBOT19FWElUX1JVTlRJTUUgdG8ga2VlcCBpdCBhbGl2ZSBhZnRlciBtYWluKCkgZXhpdHMpJyk7XHJcbiAgcmV0dXJuIHJlYWxfX3NicmsuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxufTtcclxuXHJcbnZhciByZWFsX2VzdGFibGlzaFN0YWNrU3BhY2UgPSBhc21bXCJlc3RhYmxpc2hTdGFja1NwYWNlXCJdOyBhc21bXCJlc3RhYmxpc2hTdGFja1NwYWNlXCJdID0gZnVuY3Rpb24oKSB7XHJcbiAgYXNzZXJ0KHJ1bnRpbWVJbml0aWFsaXplZCwgJ3lvdSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBydW50aW1lIHRvIGJlIHJlYWR5IChlLmcuIHdhaXQgZm9yIG1haW4oKSB0byBiZSBjYWxsZWQpJyk7XHJcbiAgYXNzZXJ0KCFydW50aW1lRXhpdGVkLCAndGhlIHJ1bnRpbWUgd2FzIGV4aXRlZCAodXNlIE5PX0VYSVRfUlVOVElNRSB0byBrZWVwIGl0IGFsaXZlIGFmdGVyIG1haW4oKSBleGl0cyknKTtcclxuICByZXR1cm4gcmVhbF9lc3RhYmxpc2hTdGFja1NwYWNlLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG52YXIgcmVhbF9nZXRUZW1wUmV0MCA9IGFzbVtcImdldFRlbXBSZXQwXCJdOyBhc21bXCJnZXRUZW1wUmV0MFwiXSA9IGZ1bmN0aW9uKCkge1xyXG4gIGFzc2VydChydW50aW1lSW5pdGlhbGl6ZWQsICd5b3UgbmVlZCB0byB3YWl0IGZvciB0aGUgcnVudGltZSB0byBiZSByZWFkeSAoZS5nLiB3YWl0IGZvciBtYWluKCkgdG8gYmUgY2FsbGVkKScpO1xyXG4gIGFzc2VydCghcnVudGltZUV4aXRlZCwgJ3RoZSBydW50aW1lIHdhcyBleGl0ZWQgKHVzZSBOT19FWElUX1JVTlRJTUUgdG8ga2VlcCBpdCBhbGl2ZSBhZnRlciBtYWluKCkgZXhpdHMpJyk7XHJcbiAgcmV0dXJuIHJlYWxfZ2V0VGVtcFJldDAuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxufTtcclxuXHJcbnZhciByZWFsX3NldFRlbXBSZXQwID0gYXNtW1wic2V0VGVtcFJldDBcIl07IGFzbVtcInNldFRlbXBSZXQwXCJdID0gZnVuY3Rpb24oKSB7XHJcbiAgYXNzZXJ0KHJ1bnRpbWVJbml0aWFsaXplZCwgJ3lvdSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBydW50aW1lIHRvIGJlIHJlYWR5IChlLmcuIHdhaXQgZm9yIG1haW4oKSB0byBiZSBjYWxsZWQpJyk7XHJcbiAgYXNzZXJ0KCFydW50aW1lRXhpdGVkLCAndGhlIHJ1bnRpbWUgd2FzIGV4aXRlZCAodXNlIE5PX0VYSVRfUlVOVElNRSB0byBrZWVwIGl0IGFsaXZlIGFmdGVyIG1haW4oKSBleGl0cyknKTtcclxuICByZXR1cm4gcmVhbF9zZXRUZW1wUmV0MC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG59O1xyXG5cclxudmFyIHJlYWxfc2V0VGhyZXcgPSBhc21bXCJzZXRUaHJld1wiXTsgYXNtW1wic2V0VGhyZXdcIl0gPSBmdW5jdGlvbigpIHtcclxuICBhc3NlcnQocnVudGltZUluaXRpYWxpemVkLCAneW91IG5lZWQgdG8gd2FpdCBmb3IgdGhlIHJ1bnRpbWUgdG8gYmUgcmVhZHkgKGUuZy4gd2FpdCBmb3IgbWFpbigpIHRvIGJlIGNhbGxlZCknKTtcclxuICBhc3NlcnQoIXJ1bnRpbWVFeGl0ZWQsICd0aGUgcnVudGltZSB3YXMgZXhpdGVkICh1c2UgTk9fRVhJVF9SVU5USU1FIHRvIGtlZXAgaXQgYWxpdmUgYWZ0ZXIgbWFpbigpIGV4aXRzKScpO1xyXG4gIHJldHVybiByZWFsX3NldFRocmV3LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG52YXIgcmVhbF9zdGFja0FsbG9jID0gYXNtW1wic3RhY2tBbGxvY1wiXTsgYXNtW1wic3RhY2tBbGxvY1wiXSA9IGZ1bmN0aW9uKCkge1xyXG4gIGFzc2VydChydW50aW1lSW5pdGlhbGl6ZWQsICd5b3UgbmVlZCB0byB3YWl0IGZvciB0aGUgcnVudGltZSB0byBiZSByZWFkeSAoZS5nLiB3YWl0IGZvciBtYWluKCkgdG8gYmUgY2FsbGVkKScpO1xyXG4gIGFzc2VydCghcnVudGltZUV4aXRlZCwgJ3RoZSBydW50aW1lIHdhcyBleGl0ZWQgKHVzZSBOT19FWElUX1JVTlRJTUUgdG8ga2VlcCBpdCBhbGl2ZSBhZnRlciBtYWluKCkgZXhpdHMpJyk7XHJcbiAgcmV0dXJuIHJlYWxfc3RhY2tBbGxvYy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG59O1xyXG5cclxudmFyIHJlYWxfc3RhY2tSZXN0b3JlID0gYXNtW1wic3RhY2tSZXN0b3JlXCJdOyBhc21bXCJzdGFja1Jlc3RvcmVcIl0gPSBmdW5jdGlvbigpIHtcclxuICBhc3NlcnQocnVudGltZUluaXRpYWxpemVkLCAneW91IG5lZWQgdG8gd2FpdCBmb3IgdGhlIHJ1bnRpbWUgdG8gYmUgcmVhZHkgKGUuZy4gd2FpdCBmb3IgbWFpbigpIHRvIGJlIGNhbGxlZCknKTtcclxuICBhc3NlcnQoIXJ1bnRpbWVFeGl0ZWQsICd0aGUgcnVudGltZSB3YXMgZXhpdGVkICh1c2UgTk9fRVhJVF9SVU5USU1FIHRvIGtlZXAgaXQgYWxpdmUgYWZ0ZXIgbWFpbigpIGV4aXRzKScpO1xyXG4gIHJldHVybiByZWFsX3N0YWNrUmVzdG9yZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG59O1xyXG5cclxudmFyIHJlYWxfc3RhY2tTYXZlID0gYXNtW1wic3RhY2tTYXZlXCJdOyBhc21bXCJzdGFja1NhdmVcIl0gPSBmdW5jdGlvbigpIHtcclxuICBhc3NlcnQocnVudGltZUluaXRpYWxpemVkLCAneW91IG5lZWQgdG8gd2FpdCBmb3IgdGhlIHJ1bnRpbWUgdG8gYmUgcmVhZHkgKGUuZy4gd2FpdCBmb3IgbWFpbigpIHRvIGJlIGNhbGxlZCknKTtcclxuICBhc3NlcnQoIXJ1bnRpbWVFeGl0ZWQsICd0aGUgcnVudGltZSB3YXMgZXhpdGVkICh1c2UgTk9fRVhJVF9SVU5USU1FIHRvIGtlZXAgaXQgYWxpdmUgYWZ0ZXIgbWFpbigpIGV4aXRzKScpO1xyXG4gIHJldHVybiByZWFsX3N0YWNrU2F2ZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG59O1xyXG5Nb2R1bGVbXCJhc21cIl0gPSBhc207XHJcbnZhciBfX19lcnJub19sb2NhdGlvbiA9IE1vZHVsZVtcIl9fX2Vycm5vX2xvY2F0aW9uXCJdID0gZnVuY3Rpb24oKSB7XHJcbiAgYXNzZXJ0KHJ1bnRpbWVJbml0aWFsaXplZCwgJ3lvdSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBydW50aW1lIHRvIGJlIHJlYWR5IChlLmcuIHdhaXQgZm9yIG1haW4oKSB0byBiZSBjYWxsZWQpJyk7XHJcbiAgYXNzZXJ0KCFydW50aW1lRXhpdGVkLCAndGhlIHJ1bnRpbWUgd2FzIGV4aXRlZCAodXNlIE5PX0VYSVRfUlVOVElNRSB0byBrZWVwIGl0IGFsaXZlIGFmdGVyIG1haW4oKSBleGl0cyknKTtcclxuICByZXR1cm4gTW9kdWxlW1wiYXNtXCJdW1wiX19fZXJybm9fbG9jYXRpb25cIl0uYXBwbHkobnVsbCwgYXJndW1lbnRzKSB9O1xyXG52YXIgX2NjdXJsX3BvdyA9IE1vZHVsZVtcIl9jY3VybF9wb3dcIl0gPSBmdW5jdGlvbigpIHtcclxuICBhc3NlcnQocnVudGltZUluaXRpYWxpemVkLCAneW91IG5lZWQgdG8gd2FpdCBmb3IgdGhlIHJ1bnRpbWUgdG8gYmUgcmVhZHkgKGUuZy4gd2FpdCBmb3IgbWFpbigpIHRvIGJlIGNhbGxlZCknKTtcclxuICBhc3NlcnQoIXJ1bnRpbWVFeGl0ZWQsICd0aGUgcnVudGltZSB3YXMgZXhpdGVkICh1c2UgTk9fRVhJVF9SVU5USU1FIHRvIGtlZXAgaXQgYWxpdmUgYWZ0ZXIgbWFpbigpIGV4aXRzKScpO1xyXG4gIHJldHVybiBNb2R1bGVbXCJhc21cIl1bXCJfY2N1cmxfcG93XCJdLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgfTtcclxudmFyIF9mZmx1c2ggPSBNb2R1bGVbXCJfZmZsdXNoXCJdID0gZnVuY3Rpb24oKSB7XHJcbiAgYXNzZXJ0KHJ1bnRpbWVJbml0aWFsaXplZCwgJ3lvdSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBydW50aW1lIHRvIGJlIHJlYWR5IChlLmcuIHdhaXQgZm9yIG1haW4oKSB0byBiZSBjYWxsZWQpJyk7XHJcbiAgYXNzZXJ0KCFydW50aW1lRXhpdGVkLCAndGhlIHJ1bnRpbWUgd2FzIGV4aXRlZCAodXNlIE5PX0VYSVRfUlVOVElNRSB0byBrZWVwIGl0IGFsaXZlIGFmdGVyIG1haW4oKSBleGl0cyknKTtcclxuICByZXR1cm4gTW9kdWxlW1wiYXNtXCJdW1wiX2ZmbHVzaFwiXS5hcHBseShudWxsLCBhcmd1bWVudHMpIH07XHJcbnZhciBfZnJlZSA9IE1vZHVsZVtcIl9mcmVlXCJdID0gZnVuY3Rpb24oKSB7XHJcbiAgYXNzZXJ0KHJ1bnRpbWVJbml0aWFsaXplZCwgJ3lvdSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBydW50aW1lIHRvIGJlIHJlYWR5IChlLmcuIHdhaXQgZm9yIG1haW4oKSB0byBiZSBjYWxsZWQpJyk7XHJcbiAgYXNzZXJ0KCFydW50aW1lRXhpdGVkLCAndGhlIHJ1bnRpbWUgd2FzIGV4aXRlZCAodXNlIE5PX0VYSVRfUlVOVElNRSB0byBrZWVwIGl0IGFsaXZlIGFmdGVyIG1haW4oKSBleGl0cyknKTtcclxuICByZXR1cm4gTW9kdWxlW1wiYXNtXCJdW1wiX2ZyZWVcIl0uYXBwbHkobnVsbCwgYXJndW1lbnRzKSB9O1xyXG52YXIgX2xsdm1fYnN3YXBfaTMyID0gTW9kdWxlW1wiX2xsdm1fYnN3YXBfaTMyXCJdID0gZnVuY3Rpb24oKSB7XHJcbiAgYXNzZXJ0KHJ1bnRpbWVJbml0aWFsaXplZCwgJ3lvdSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBydW50aW1lIHRvIGJlIHJlYWR5IChlLmcuIHdhaXQgZm9yIG1haW4oKSB0byBiZSBjYWxsZWQpJyk7XHJcbiAgYXNzZXJ0KCFydW50aW1lRXhpdGVkLCAndGhlIHJ1bnRpbWUgd2FzIGV4aXRlZCAodXNlIE5PX0VYSVRfUlVOVElNRSB0byBrZWVwIGl0IGFsaXZlIGFmdGVyIG1haW4oKSBleGl0cyknKTtcclxuICByZXR1cm4gTW9kdWxlW1wiYXNtXCJdW1wiX2xsdm1fYnN3YXBfaTMyXCJdLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgfTtcclxudmFyIF9tYWxsb2MgPSBNb2R1bGVbXCJfbWFsbG9jXCJdID0gZnVuY3Rpb24oKSB7XHJcbiAgYXNzZXJ0KHJ1bnRpbWVJbml0aWFsaXplZCwgJ3lvdSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBydW50aW1lIHRvIGJlIHJlYWR5IChlLmcuIHdhaXQgZm9yIG1haW4oKSB0byBiZSBjYWxsZWQpJyk7XHJcbiAgYXNzZXJ0KCFydW50aW1lRXhpdGVkLCAndGhlIHJ1bnRpbWUgd2FzIGV4aXRlZCAodXNlIE5PX0VYSVRfUlVOVElNRSB0byBrZWVwIGl0IGFsaXZlIGFmdGVyIG1haW4oKSBleGl0cyknKTtcclxuICByZXR1cm4gTW9kdWxlW1wiYXNtXCJdW1wiX21hbGxvY1wiXS5hcHBseShudWxsLCBhcmd1bWVudHMpIH07XHJcbnZhciBfbWVtY3B5ID0gTW9kdWxlW1wiX21lbWNweVwiXSA9IGZ1bmN0aW9uKCkge1xyXG4gIGFzc2VydChydW50aW1lSW5pdGlhbGl6ZWQsICd5b3UgbmVlZCB0byB3YWl0IGZvciB0aGUgcnVudGltZSB0byBiZSByZWFkeSAoZS5nLiB3YWl0IGZvciBtYWluKCkgdG8gYmUgY2FsbGVkKScpO1xyXG4gIGFzc2VydCghcnVudGltZUV4aXRlZCwgJ3RoZSBydW50aW1lIHdhcyBleGl0ZWQgKHVzZSBOT19FWElUX1JVTlRJTUUgdG8ga2VlcCBpdCBhbGl2ZSBhZnRlciBtYWluKCkgZXhpdHMpJyk7XHJcbiAgcmV0dXJuIE1vZHVsZVtcImFzbVwiXVtcIl9tZW1jcHlcIl0uYXBwbHkobnVsbCwgYXJndW1lbnRzKSB9O1xyXG52YXIgX21lbXNldCA9IE1vZHVsZVtcIl9tZW1zZXRcIl0gPSBmdW5jdGlvbigpIHtcclxuICBhc3NlcnQocnVudGltZUluaXRpYWxpemVkLCAneW91IG5lZWQgdG8gd2FpdCBmb3IgdGhlIHJ1bnRpbWUgdG8gYmUgcmVhZHkgKGUuZy4gd2FpdCBmb3IgbWFpbigpIHRvIGJlIGNhbGxlZCknKTtcclxuICBhc3NlcnQoIXJ1bnRpbWVFeGl0ZWQsICd0aGUgcnVudGltZSB3YXMgZXhpdGVkICh1c2UgTk9fRVhJVF9SVU5USU1FIHRvIGtlZXAgaXQgYWxpdmUgYWZ0ZXIgbWFpbigpIGV4aXRzKScpO1xyXG4gIHJldHVybiBNb2R1bGVbXCJhc21cIl1bXCJfbWVtc2V0XCJdLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgfTtcclxudmFyIF9wdGhyZWFkX211dGV4X2xvY2sgPSBNb2R1bGVbXCJfcHRocmVhZF9tdXRleF9sb2NrXCJdID0gZnVuY3Rpb24oKSB7XHJcbiAgYXNzZXJ0KHJ1bnRpbWVJbml0aWFsaXplZCwgJ3lvdSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBydW50aW1lIHRvIGJlIHJlYWR5IChlLmcuIHdhaXQgZm9yIG1haW4oKSB0byBiZSBjYWxsZWQpJyk7XHJcbiAgYXNzZXJ0KCFydW50aW1lRXhpdGVkLCAndGhlIHJ1bnRpbWUgd2FzIGV4aXRlZCAodXNlIE5PX0VYSVRfUlVOVElNRSB0byBrZWVwIGl0IGFsaXZlIGFmdGVyIG1haW4oKSBleGl0cyknKTtcclxuICByZXR1cm4gTW9kdWxlW1wiYXNtXCJdW1wiX3B0aHJlYWRfbXV0ZXhfbG9ja1wiXS5hcHBseShudWxsLCBhcmd1bWVudHMpIH07XHJcbnZhciBfcHRocmVhZF9tdXRleF91bmxvY2sgPSBNb2R1bGVbXCJfcHRocmVhZF9tdXRleF91bmxvY2tcIl0gPSBmdW5jdGlvbigpIHtcclxuICBhc3NlcnQocnVudGltZUluaXRpYWxpemVkLCAneW91IG5lZWQgdG8gd2FpdCBmb3IgdGhlIHJ1bnRpbWUgdG8gYmUgcmVhZHkgKGUuZy4gd2FpdCBmb3IgbWFpbigpIHRvIGJlIGNhbGxlZCknKTtcclxuICBhc3NlcnQoIXJ1bnRpbWVFeGl0ZWQsICd0aGUgcnVudGltZSB3YXMgZXhpdGVkICh1c2UgTk9fRVhJVF9SVU5USU1FIHRvIGtlZXAgaXQgYWxpdmUgYWZ0ZXIgbWFpbigpIGV4aXRzKScpO1xyXG4gIHJldHVybiBNb2R1bGVbXCJhc21cIl1bXCJfcHRocmVhZF9tdXRleF91bmxvY2tcIl0uYXBwbHkobnVsbCwgYXJndW1lbnRzKSB9O1xyXG52YXIgX3NicmsgPSBNb2R1bGVbXCJfc2Jya1wiXSA9IGZ1bmN0aW9uKCkge1xyXG4gIGFzc2VydChydW50aW1lSW5pdGlhbGl6ZWQsICd5b3UgbmVlZCB0byB3YWl0IGZvciB0aGUgcnVudGltZSB0byBiZSByZWFkeSAoZS5nLiB3YWl0IGZvciBtYWluKCkgdG8gYmUgY2FsbGVkKScpO1xyXG4gIGFzc2VydCghcnVudGltZUV4aXRlZCwgJ3RoZSBydW50aW1lIHdhcyBleGl0ZWQgKHVzZSBOT19FWElUX1JVTlRJTUUgdG8ga2VlcCBpdCBhbGl2ZSBhZnRlciBtYWluKCkgZXhpdHMpJyk7XHJcbiAgcmV0dXJuIE1vZHVsZVtcImFzbVwiXVtcIl9zYnJrXCJdLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgfTtcclxudmFyIGVzdGFibGlzaFN0YWNrU3BhY2UgPSBNb2R1bGVbXCJlc3RhYmxpc2hTdGFja1NwYWNlXCJdID0gZnVuY3Rpb24oKSB7XHJcbiAgYXNzZXJ0KHJ1bnRpbWVJbml0aWFsaXplZCwgJ3lvdSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBydW50aW1lIHRvIGJlIHJlYWR5IChlLmcuIHdhaXQgZm9yIG1haW4oKSB0byBiZSBjYWxsZWQpJyk7XHJcbiAgYXNzZXJ0KCFydW50aW1lRXhpdGVkLCAndGhlIHJ1bnRpbWUgd2FzIGV4aXRlZCAodXNlIE5PX0VYSVRfUlVOVElNRSB0byBrZWVwIGl0IGFsaXZlIGFmdGVyIG1haW4oKSBleGl0cyknKTtcclxuICByZXR1cm4gTW9kdWxlW1wiYXNtXCJdW1wiZXN0YWJsaXNoU3RhY2tTcGFjZVwiXS5hcHBseShudWxsLCBhcmd1bWVudHMpIH07XHJcbnZhciBnZXRUZW1wUmV0MCA9IE1vZHVsZVtcImdldFRlbXBSZXQwXCJdID0gZnVuY3Rpb24oKSB7XHJcbiAgYXNzZXJ0KHJ1bnRpbWVJbml0aWFsaXplZCwgJ3lvdSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBydW50aW1lIHRvIGJlIHJlYWR5IChlLmcuIHdhaXQgZm9yIG1haW4oKSB0byBiZSBjYWxsZWQpJyk7XHJcbiAgYXNzZXJ0KCFydW50aW1lRXhpdGVkLCAndGhlIHJ1bnRpbWUgd2FzIGV4aXRlZCAodXNlIE5PX0VYSVRfUlVOVElNRSB0byBrZWVwIGl0IGFsaXZlIGFmdGVyIG1haW4oKSBleGl0cyknKTtcclxuICByZXR1cm4gTW9kdWxlW1wiYXNtXCJdW1wiZ2V0VGVtcFJldDBcIl0uYXBwbHkobnVsbCwgYXJndW1lbnRzKSB9O1xyXG52YXIgcnVuUG9zdFNldHMgPSBNb2R1bGVbXCJydW5Qb3N0U2V0c1wiXSA9IGZ1bmN0aW9uKCkge1xyXG4gIGFzc2VydChydW50aW1lSW5pdGlhbGl6ZWQsICd5b3UgbmVlZCB0byB3YWl0IGZvciB0aGUgcnVudGltZSB0byBiZSByZWFkeSAoZS5nLiB3YWl0IGZvciBtYWluKCkgdG8gYmUgY2FsbGVkKScpO1xyXG4gIGFzc2VydCghcnVudGltZUV4aXRlZCwgJ3RoZSBydW50aW1lIHdhcyBleGl0ZWQgKHVzZSBOT19FWElUX1JVTlRJTUUgdG8ga2VlcCBpdCBhbGl2ZSBhZnRlciBtYWluKCkgZXhpdHMpJyk7XHJcbiAgcmV0dXJuIE1vZHVsZVtcImFzbVwiXVtcInJ1blBvc3RTZXRzXCJdLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgfTtcclxudmFyIHNldFRlbXBSZXQwID0gTW9kdWxlW1wic2V0VGVtcFJldDBcIl0gPSBmdW5jdGlvbigpIHtcclxuICBhc3NlcnQocnVudGltZUluaXRpYWxpemVkLCAneW91IG5lZWQgdG8gd2FpdCBmb3IgdGhlIHJ1bnRpbWUgdG8gYmUgcmVhZHkgKGUuZy4gd2FpdCBmb3IgbWFpbigpIHRvIGJlIGNhbGxlZCknKTtcclxuICBhc3NlcnQoIXJ1bnRpbWVFeGl0ZWQsICd0aGUgcnVudGltZSB3YXMgZXhpdGVkICh1c2UgTk9fRVhJVF9SVU5USU1FIHRvIGtlZXAgaXQgYWxpdmUgYWZ0ZXIgbWFpbigpIGV4aXRzKScpO1xyXG4gIHJldHVybiBNb2R1bGVbXCJhc21cIl1bXCJzZXRUZW1wUmV0MFwiXS5hcHBseShudWxsLCBhcmd1bWVudHMpIH07XHJcbnZhciBzZXRUaHJldyA9IE1vZHVsZVtcInNldFRocmV3XCJdID0gZnVuY3Rpb24oKSB7XHJcbiAgYXNzZXJ0KHJ1bnRpbWVJbml0aWFsaXplZCwgJ3lvdSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBydW50aW1lIHRvIGJlIHJlYWR5IChlLmcuIHdhaXQgZm9yIG1haW4oKSB0byBiZSBjYWxsZWQpJyk7XHJcbiAgYXNzZXJ0KCFydW50aW1lRXhpdGVkLCAndGhlIHJ1bnRpbWUgd2FzIGV4aXRlZCAodXNlIE5PX0VYSVRfUlVOVElNRSB0byBrZWVwIGl0IGFsaXZlIGFmdGVyIG1haW4oKSBleGl0cyknKTtcclxuICByZXR1cm4gTW9kdWxlW1wiYXNtXCJdW1wic2V0VGhyZXdcIl0uYXBwbHkobnVsbCwgYXJndW1lbnRzKSB9O1xyXG52YXIgc3RhY2tBbGxvYyA9IE1vZHVsZVtcInN0YWNrQWxsb2NcIl0gPSBmdW5jdGlvbigpIHtcclxuICBhc3NlcnQocnVudGltZUluaXRpYWxpemVkLCAneW91IG5lZWQgdG8gd2FpdCBmb3IgdGhlIHJ1bnRpbWUgdG8gYmUgcmVhZHkgKGUuZy4gd2FpdCBmb3IgbWFpbigpIHRvIGJlIGNhbGxlZCknKTtcclxuICBhc3NlcnQoIXJ1bnRpbWVFeGl0ZWQsICd0aGUgcnVudGltZSB3YXMgZXhpdGVkICh1c2UgTk9fRVhJVF9SVU5USU1FIHRvIGtlZXAgaXQgYWxpdmUgYWZ0ZXIgbWFpbigpIGV4aXRzKScpO1xyXG4gIHJldHVybiBNb2R1bGVbXCJhc21cIl1bXCJzdGFja0FsbG9jXCJdLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgfTtcclxudmFyIHN0YWNrUmVzdG9yZSA9IE1vZHVsZVtcInN0YWNrUmVzdG9yZVwiXSA9IGZ1bmN0aW9uKCkge1xyXG4gIGFzc2VydChydW50aW1lSW5pdGlhbGl6ZWQsICd5b3UgbmVlZCB0byB3YWl0IGZvciB0aGUgcnVudGltZSB0byBiZSByZWFkeSAoZS5nLiB3YWl0IGZvciBtYWluKCkgdG8gYmUgY2FsbGVkKScpO1xyXG4gIGFzc2VydCghcnVudGltZUV4aXRlZCwgJ3RoZSBydW50aW1lIHdhcyBleGl0ZWQgKHVzZSBOT19FWElUX1JVTlRJTUUgdG8ga2VlcCBpdCBhbGl2ZSBhZnRlciBtYWluKCkgZXhpdHMpJyk7XHJcbiAgcmV0dXJuIE1vZHVsZVtcImFzbVwiXVtcInN0YWNrUmVzdG9yZVwiXS5hcHBseShudWxsLCBhcmd1bWVudHMpIH07XHJcbnZhciBzdGFja1NhdmUgPSBNb2R1bGVbXCJzdGFja1NhdmVcIl0gPSBmdW5jdGlvbigpIHtcclxuICBhc3NlcnQocnVudGltZUluaXRpYWxpemVkLCAneW91IG5lZWQgdG8gd2FpdCBmb3IgdGhlIHJ1bnRpbWUgdG8gYmUgcmVhZHkgKGUuZy4gd2FpdCBmb3IgbWFpbigpIHRvIGJlIGNhbGxlZCknKTtcclxuICBhc3NlcnQoIXJ1bnRpbWVFeGl0ZWQsICd0aGUgcnVudGltZSB3YXMgZXhpdGVkICh1c2UgTk9fRVhJVF9SVU5USU1FIHRvIGtlZXAgaXQgYWxpdmUgYWZ0ZXIgbWFpbigpIGV4aXRzKScpO1xyXG4gIHJldHVybiBNb2R1bGVbXCJhc21cIl1bXCJzdGFja1NhdmVcIl0uYXBwbHkobnVsbCwgYXJndW1lbnRzKSB9O1xyXG52YXIgZHluQ2FsbF9paSA9IE1vZHVsZVtcImR5bkNhbGxfaWlcIl0gPSBmdW5jdGlvbigpIHtcclxuICBhc3NlcnQocnVudGltZUluaXRpYWxpemVkLCAneW91IG5lZWQgdG8gd2FpdCBmb3IgdGhlIHJ1bnRpbWUgdG8gYmUgcmVhZHkgKGUuZy4gd2FpdCBmb3IgbWFpbigpIHRvIGJlIGNhbGxlZCknKTtcclxuICBhc3NlcnQoIXJ1bnRpbWVFeGl0ZWQsICd0aGUgcnVudGltZSB3YXMgZXhpdGVkICh1c2UgTk9fRVhJVF9SVU5USU1FIHRvIGtlZXAgaXQgYWxpdmUgYWZ0ZXIgbWFpbigpIGV4aXRzKScpO1xyXG4gIHJldHVybiBNb2R1bGVbXCJhc21cIl1bXCJkeW5DYWxsX2lpXCJdLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgfTtcclxudmFyIGR5bkNhbGxfaWlpaSA9IE1vZHVsZVtcImR5bkNhbGxfaWlpaVwiXSA9IGZ1bmN0aW9uKCkge1xyXG4gIGFzc2VydChydW50aW1lSW5pdGlhbGl6ZWQsICd5b3UgbmVlZCB0byB3YWl0IGZvciB0aGUgcnVudGltZSB0byBiZSByZWFkeSAoZS5nLiB3YWl0IGZvciBtYWluKCkgdG8gYmUgY2FsbGVkKScpO1xyXG4gIGFzc2VydCghcnVudGltZUV4aXRlZCwgJ3RoZSBydW50aW1lIHdhcyBleGl0ZWQgKHVzZSBOT19FWElUX1JVTlRJTUUgdG8ga2VlcCBpdCBhbGl2ZSBhZnRlciBtYWluKCkgZXhpdHMpJyk7XHJcbiAgcmV0dXJuIE1vZHVsZVtcImFzbVwiXVtcImR5bkNhbGxfaWlpaVwiXS5hcHBseShudWxsLCBhcmd1bWVudHMpIH07XHJcbjtcclxuXHJcblxyXG5cclxuLy8gPT09IEF1dG8tZ2VuZXJhdGVkIHBvc3RhbWJsZSBzZXR1cCBlbnRyeSBzdHVmZiA9PT1cclxuXHJcbk1vZHVsZVsnYXNtJ10gPSBhc207XHJcblxyXG5pZiAoIU1vZHVsZVtcImludEFycmF5RnJvbVN0cmluZ1wiXSkgTW9kdWxlW1wiaW50QXJyYXlGcm9tU3RyaW5nXCJdID0gZnVuY3Rpb24oKSB7IGFib3J0KFwiJ2ludEFycmF5RnJvbVN0cmluZycgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXCIpIH07XHJcbmlmICghTW9kdWxlW1wiaW50QXJyYXlUb1N0cmluZ1wiXSkgTW9kdWxlW1wiaW50QXJyYXlUb1N0cmluZ1wiXSA9IGZ1bmN0aW9uKCkgeyBhYm9ydChcIidpbnRBcnJheVRvU3RyaW5nJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcIikgfTtcclxuTW9kdWxlW1wiY2NhbGxcIl0gPSBjY2FsbDtcclxuTW9kdWxlW1wiY3dyYXBcIl0gPSBjd3JhcDtcclxuaWYgKCFNb2R1bGVbXCJzZXRWYWx1ZVwiXSkgTW9kdWxlW1wic2V0VmFsdWVcIl0gPSBmdW5jdGlvbigpIHsgYWJvcnQoXCInc2V0VmFsdWUnIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVwiKSB9O1xyXG5pZiAoIU1vZHVsZVtcImdldFZhbHVlXCJdKSBNb2R1bGVbXCJnZXRWYWx1ZVwiXSA9IGZ1bmN0aW9uKCkgeyBhYm9ydChcIidnZXRWYWx1ZScgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXCIpIH07XHJcbmlmICghTW9kdWxlW1wiYWxsb2NhdGVcIl0pIE1vZHVsZVtcImFsbG9jYXRlXCJdID0gZnVuY3Rpb24oKSB7IGFib3J0KFwiJ2FsbG9jYXRlJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcIikgfTtcclxuaWYgKCFNb2R1bGVbXCJnZXRNZW1vcnlcIl0pIE1vZHVsZVtcImdldE1lbW9yeVwiXSA9IGZ1bmN0aW9uKCkgeyBhYm9ydChcIidnZXRNZW1vcnknIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKS4gQWx0ZXJuYXRpdmVseSwgZm9yY2luZyBmaWxlc3lzdGVtIHN1cHBvcnQgKC1zIEZPUkNFX0ZJTEVTWVNURU09MSkgY2FuIGV4cG9ydCB0aGlzIGZvciB5b3VcIikgfTtcclxuaWYgKCFNb2R1bGVbXCJQb2ludGVyX3N0cmluZ2lmeVwiXSkgTW9kdWxlW1wiUG9pbnRlcl9zdHJpbmdpZnlcIl0gPSBmdW5jdGlvbigpIHsgYWJvcnQoXCInUG9pbnRlcl9zdHJpbmdpZnknIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVwiKSB9O1xyXG5pZiAoIU1vZHVsZVtcIkFzY2lpVG9TdHJpbmdcIl0pIE1vZHVsZVtcIkFzY2lpVG9TdHJpbmdcIl0gPSBmdW5jdGlvbigpIHsgYWJvcnQoXCInQXNjaWlUb1N0cmluZycgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXCIpIH07XHJcbmlmICghTW9kdWxlW1wic3RyaW5nVG9Bc2NpaVwiXSkgTW9kdWxlW1wic3RyaW5nVG9Bc2NpaVwiXSA9IGZ1bmN0aW9uKCkgeyBhYm9ydChcIidzdHJpbmdUb0FzY2lpJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcIikgfTtcclxuaWYgKCFNb2R1bGVbXCJVVEY4QXJyYXlUb1N0cmluZ1wiXSkgTW9kdWxlW1wiVVRGOEFycmF5VG9TdHJpbmdcIl0gPSBmdW5jdGlvbigpIHsgYWJvcnQoXCInVVRGOEFycmF5VG9TdHJpbmcnIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVwiKSB9O1xyXG5pZiAoIU1vZHVsZVtcIlVURjhUb1N0cmluZ1wiXSkgTW9kdWxlW1wiVVRGOFRvU3RyaW5nXCJdID0gZnVuY3Rpb24oKSB7IGFib3J0KFwiJ1VURjhUb1N0cmluZycgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXCIpIH07XHJcbmlmICghTW9kdWxlW1wic3RyaW5nVG9VVEY4QXJyYXlcIl0pIE1vZHVsZVtcInN0cmluZ1RvVVRGOEFycmF5XCJdID0gZnVuY3Rpb24oKSB7IGFib3J0KFwiJ3N0cmluZ1RvVVRGOEFycmF5JyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcIikgfTtcclxuaWYgKCFNb2R1bGVbXCJzdHJpbmdUb1VURjhcIl0pIE1vZHVsZVtcInN0cmluZ1RvVVRGOFwiXSA9IGZ1bmN0aW9uKCkgeyBhYm9ydChcIidzdHJpbmdUb1VURjgnIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVwiKSB9O1xyXG5pZiAoIU1vZHVsZVtcImxlbmd0aEJ5dGVzVVRGOFwiXSkgTW9kdWxlW1wibGVuZ3RoQnl0ZXNVVEY4XCJdID0gZnVuY3Rpb24oKSB7IGFib3J0KFwiJ2xlbmd0aEJ5dGVzVVRGOCcgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXCIpIH07XHJcbmlmICghTW9kdWxlW1wiVVRGMTZUb1N0cmluZ1wiXSkgTW9kdWxlW1wiVVRGMTZUb1N0cmluZ1wiXSA9IGZ1bmN0aW9uKCkgeyBhYm9ydChcIidVVEYxNlRvU3RyaW5nJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcIikgfTtcclxuaWYgKCFNb2R1bGVbXCJzdHJpbmdUb1VURjE2XCJdKSBNb2R1bGVbXCJzdHJpbmdUb1VURjE2XCJdID0gZnVuY3Rpb24oKSB7IGFib3J0KFwiJ3N0cmluZ1RvVVRGMTYnIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVwiKSB9O1xyXG5pZiAoIU1vZHVsZVtcImxlbmd0aEJ5dGVzVVRGMTZcIl0pIE1vZHVsZVtcImxlbmd0aEJ5dGVzVVRGMTZcIl0gPSBmdW5jdGlvbigpIHsgYWJvcnQoXCInbGVuZ3RoQnl0ZXNVVEYxNicgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXCIpIH07XHJcbmlmICghTW9kdWxlW1wiVVRGMzJUb1N0cmluZ1wiXSkgTW9kdWxlW1wiVVRGMzJUb1N0cmluZ1wiXSA9IGZ1bmN0aW9uKCkgeyBhYm9ydChcIidVVEYzMlRvU3RyaW5nJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcIikgfTtcclxuaWYgKCFNb2R1bGVbXCJzdHJpbmdUb1VURjMyXCJdKSBNb2R1bGVbXCJzdHJpbmdUb1VURjMyXCJdID0gZnVuY3Rpb24oKSB7IGFib3J0KFwiJ3N0cmluZ1RvVVRGMzInIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVwiKSB9O1xyXG5pZiAoIU1vZHVsZVtcImxlbmd0aEJ5dGVzVVRGMzJcIl0pIE1vZHVsZVtcImxlbmd0aEJ5dGVzVVRGMzJcIl0gPSBmdW5jdGlvbigpIHsgYWJvcnQoXCInbGVuZ3RoQnl0ZXNVVEYzMicgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXCIpIH07XHJcbmlmICghTW9kdWxlW1wiYWxsb2NhdGVVVEY4XCJdKSBNb2R1bGVbXCJhbGxvY2F0ZVVURjhcIl0gPSBmdW5jdGlvbigpIHsgYWJvcnQoXCInYWxsb2NhdGVVVEY4JyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcIikgfTtcclxuaWYgKCFNb2R1bGVbXCJzdGFja1RyYWNlXCJdKSBNb2R1bGVbXCJzdGFja1RyYWNlXCJdID0gZnVuY3Rpb24oKSB7IGFib3J0KFwiJ3N0YWNrVHJhY2UnIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVwiKSB9O1xyXG5pZiAoIU1vZHVsZVtcImFkZE9uUHJlUnVuXCJdKSBNb2R1bGVbXCJhZGRPblByZVJ1blwiXSA9IGZ1bmN0aW9uKCkgeyBhYm9ydChcIidhZGRPblByZVJ1bicgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXCIpIH07XHJcbmlmICghTW9kdWxlW1wiYWRkT25Jbml0XCJdKSBNb2R1bGVbXCJhZGRPbkluaXRcIl0gPSBmdW5jdGlvbigpIHsgYWJvcnQoXCInYWRkT25Jbml0JyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcIikgfTtcclxuaWYgKCFNb2R1bGVbXCJhZGRPblByZU1haW5cIl0pIE1vZHVsZVtcImFkZE9uUHJlTWFpblwiXSA9IGZ1bmN0aW9uKCkgeyBhYm9ydChcIidhZGRPblByZU1haW4nIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVwiKSB9O1xyXG5pZiAoIU1vZHVsZVtcImFkZE9uRXhpdFwiXSkgTW9kdWxlW1wiYWRkT25FeGl0XCJdID0gZnVuY3Rpb24oKSB7IGFib3J0KFwiJ2FkZE9uRXhpdCcgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXCIpIH07XHJcbmlmICghTW9kdWxlW1wiYWRkT25Qb3N0UnVuXCJdKSBNb2R1bGVbXCJhZGRPblBvc3RSdW5cIl0gPSBmdW5jdGlvbigpIHsgYWJvcnQoXCInYWRkT25Qb3N0UnVuJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcIikgfTtcclxuaWYgKCFNb2R1bGVbXCJ3cml0ZVN0cmluZ1RvTWVtb3J5XCJdKSBNb2R1bGVbXCJ3cml0ZVN0cmluZ1RvTWVtb3J5XCJdID0gZnVuY3Rpb24oKSB7IGFib3J0KFwiJ3dyaXRlU3RyaW5nVG9NZW1vcnknIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVwiKSB9O1xyXG5pZiAoIU1vZHVsZVtcIndyaXRlQXJyYXlUb01lbW9yeVwiXSkgTW9kdWxlW1wid3JpdGVBcnJheVRvTWVtb3J5XCJdID0gZnVuY3Rpb24oKSB7IGFib3J0KFwiJ3dyaXRlQXJyYXlUb01lbW9yeScgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXCIpIH07XHJcbmlmICghTW9kdWxlW1wid3JpdGVBc2NpaVRvTWVtb3J5XCJdKSBNb2R1bGVbXCJ3cml0ZUFzY2lpVG9NZW1vcnlcIl0gPSBmdW5jdGlvbigpIHsgYWJvcnQoXCInd3JpdGVBc2NpaVRvTWVtb3J5JyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcIikgfTtcclxuaWYgKCFNb2R1bGVbXCJhZGRSdW5EZXBlbmRlbmN5XCJdKSBNb2R1bGVbXCJhZGRSdW5EZXBlbmRlbmN5XCJdID0gZnVuY3Rpb24oKSB7IGFib3J0KFwiJ2FkZFJ1bkRlcGVuZGVuY3knIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKS4gQWx0ZXJuYXRpdmVseSwgZm9yY2luZyBmaWxlc3lzdGVtIHN1cHBvcnQgKC1zIEZPUkNFX0ZJTEVTWVNURU09MSkgY2FuIGV4cG9ydCB0aGlzIGZvciB5b3VcIikgfTtcclxuaWYgKCFNb2R1bGVbXCJyZW1vdmVSdW5EZXBlbmRlbmN5XCJdKSBNb2R1bGVbXCJyZW1vdmVSdW5EZXBlbmRlbmN5XCJdID0gZnVuY3Rpb24oKSB7IGFib3J0KFwiJ3JlbW92ZVJ1bkRlcGVuZGVuY3knIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKS4gQWx0ZXJuYXRpdmVseSwgZm9yY2luZyBmaWxlc3lzdGVtIHN1cHBvcnQgKC1zIEZPUkNFX0ZJTEVTWVNURU09MSkgY2FuIGV4cG9ydCB0aGlzIGZvciB5b3VcIikgfTtcclxuaWYgKCFNb2R1bGVbXCJGU1wiXSkgTW9kdWxlW1wiRlNcIl0gPSBmdW5jdGlvbigpIHsgYWJvcnQoXCInRlMnIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVwiKSB9O1xyXG5pZiAoIU1vZHVsZVtcIkZTX2NyZWF0ZUZvbGRlclwiXSkgTW9kdWxlW1wiRlNfY3JlYXRlRm9sZGVyXCJdID0gZnVuY3Rpb24oKSB7IGFib3J0KFwiJ0ZTX2NyZWF0ZUZvbGRlcicgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpLiBBbHRlcm5hdGl2ZWx5LCBmb3JjaW5nIGZpbGVzeXN0ZW0gc3VwcG9ydCAoLXMgRk9SQ0VfRklMRVNZU1RFTT0xKSBjYW4gZXhwb3J0IHRoaXMgZm9yIHlvdVwiKSB9O1xyXG5pZiAoIU1vZHVsZVtcIkZTX2NyZWF0ZVBhdGhcIl0pIE1vZHVsZVtcIkZTX2NyZWF0ZVBhdGhcIl0gPSBmdW5jdGlvbigpIHsgYWJvcnQoXCInRlNfY3JlYXRlUGF0aCcgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpLiBBbHRlcm5hdGl2ZWx5LCBmb3JjaW5nIGZpbGVzeXN0ZW0gc3VwcG9ydCAoLXMgRk9SQ0VfRklMRVNZU1RFTT0xKSBjYW4gZXhwb3J0IHRoaXMgZm9yIHlvdVwiKSB9O1xyXG5pZiAoIU1vZHVsZVtcIkZTX2NyZWF0ZURhdGFGaWxlXCJdKSBNb2R1bGVbXCJGU19jcmVhdGVEYXRhRmlsZVwiXSA9IGZ1bmN0aW9uKCkgeyBhYm9ydChcIidGU19jcmVhdGVEYXRhRmlsZScgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpLiBBbHRlcm5hdGl2ZWx5LCBmb3JjaW5nIGZpbGVzeXN0ZW0gc3VwcG9ydCAoLXMgRk9SQ0VfRklMRVNZU1RFTT0xKSBjYW4gZXhwb3J0IHRoaXMgZm9yIHlvdVwiKSB9O1xyXG5pZiAoIU1vZHVsZVtcIkZTX2NyZWF0ZVByZWxvYWRlZEZpbGVcIl0pIE1vZHVsZVtcIkZTX2NyZWF0ZVByZWxvYWRlZEZpbGVcIl0gPSBmdW5jdGlvbigpIHsgYWJvcnQoXCInRlNfY3JlYXRlUHJlbG9hZGVkRmlsZScgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpLiBBbHRlcm5hdGl2ZWx5LCBmb3JjaW5nIGZpbGVzeXN0ZW0gc3VwcG9ydCAoLXMgRk9SQ0VfRklMRVNZU1RFTT0xKSBjYW4gZXhwb3J0IHRoaXMgZm9yIHlvdVwiKSB9O1xyXG5pZiAoIU1vZHVsZVtcIkZTX2NyZWF0ZUxhenlGaWxlXCJdKSBNb2R1bGVbXCJGU19jcmVhdGVMYXp5RmlsZVwiXSA9IGZ1bmN0aW9uKCkgeyBhYm9ydChcIidGU19jcmVhdGVMYXp5RmlsZScgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpLiBBbHRlcm5hdGl2ZWx5LCBmb3JjaW5nIGZpbGVzeXN0ZW0gc3VwcG9ydCAoLXMgRk9SQ0VfRklMRVNZU1RFTT0xKSBjYW4gZXhwb3J0IHRoaXMgZm9yIHlvdVwiKSB9O1xyXG5pZiAoIU1vZHVsZVtcIkZTX2NyZWF0ZUxpbmtcIl0pIE1vZHVsZVtcIkZTX2NyZWF0ZUxpbmtcIl0gPSBmdW5jdGlvbigpIHsgYWJvcnQoXCInRlNfY3JlYXRlTGluaycgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpLiBBbHRlcm5hdGl2ZWx5LCBmb3JjaW5nIGZpbGVzeXN0ZW0gc3VwcG9ydCAoLXMgRk9SQ0VfRklMRVNZU1RFTT0xKSBjYW4gZXhwb3J0IHRoaXMgZm9yIHlvdVwiKSB9O1xyXG5pZiAoIU1vZHVsZVtcIkZTX2NyZWF0ZURldmljZVwiXSkgTW9kdWxlW1wiRlNfY3JlYXRlRGV2aWNlXCJdID0gZnVuY3Rpb24oKSB7IGFib3J0KFwiJ0ZTX2NyZWF0ZURldmljZScgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpLiBBbHRlcm5hdGl2ZWx5LCBmb3JjaW5nIGZpbGVzeXN0ZW0gc3VwcG9ydCAoLXMgRk9SQ0VfRklMRVNZU1RFTT0xKSBjYW4gZXhwb3J0IHRoaXMgZm9yIHlvdVwiKSB9O1xyXG5pZiAoIU1vZHVsZVtcIkZTX3VubGlua1wiXSkgTW9kdWxlW1wiRlNfdW5saW5rXCJdID0gZnVuY3Rpb24oKSB7IGFib3J0KFwiJ0ZTX3VubGluaycgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpLiBBbHRlcm5hdGl2ZWx5LCBmb3JjaW5nIGZpbGVzeXN0ZW0gc3VwcG9ydCAoLXMgRk9SQ0VfRklMRVNZU1RFTT0xKSBjYW4gZXhwb3J0IHRoaXMgZm9yIHlvdVwiKSB9O1xyXG5pZiAoIU1vZHVsZVtcIkdMXCJdKSBNb2R1bGVbXCJHTFwiXSA9IGZ1bmN0aW9uKCkgeyBhYm9ydChcIidHTCcgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXCIpIH07XHJcbmlmICghTW9kdWxlW1wic3RhdGljQWxsb2NcIl0pIE1vZHVsZVtcInN0YXRpY0FsbG9jXCJdID0gZnVuY3Rpb24oKSB7IGFib3J0KFwiJ3N0YXRpY0FsbG9jJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcIikgfTtcclxuaWYgKCFNb2R1bGVbXCJkeW5hbWljQWxsb2NcIl0pIE1vZHVsZVtcImR5bmFtaWNBbGxvY1wiXSA9IGZ1bmN0aW9uKCkgeyBhYm9ydChcIidkeW5hbWljQWxsb2MnIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVwiKSB9O1xyXG5pZiAoIU1vZHVsZVtcIndhcm5PbmNlXCJdKSBNb2R1bGVbXCJ3YXJuT25jZVwiXSA9IGZ1bmN0aW9uKCkgeyBhYm9ydChcIid3YXJuT25jZScgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXCIpIH07XHJcbmlmICghTW9kdWxlW1wibG9hZER5bmFtaWNMaWJyYXJ5XCJdKSBNb2R1bGVbXCJsb2FkRHluYW1pY0xpYnJhcnlcIl0gPSBmdW5jdGlvbigpIHsgYWJvcnQoXCInbG9hZER5bmFtaWNMaWJyYXJ5JyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcIikgfTtcclxuaWYgKCFNb2R1bGVbXCJsb2FkV2ViQXNzZW1ibHlNb2R1bGVcIl0pIE1vZHVsZVtcImxvYWRXZWJBc3NlbWJseU1vZHVsZVwiXSA9IGZ1bmN0aW9uKCkgeyBhYm9ydChcIidsb2FkV2ViQXNzZW1ibHlNb2R1bGUnIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVwiKSB9O1xyXG5pZiAoIU1vZHVsZVtcImdldExFQlwiXSkgTW9kdWxlW1wiZ2V0TEVCXCJdID0gZnVuY3Rpb24oKSB7IGFib3J0KFwiJ2dldExFQicgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXCIpIH07XHJcbmlmICghTW9kdWxlW1wiZ2V0RnVuY3Rpb25UYWJsZXNcIl0pIE1vZHVsZVtcImdldEZ1bmN0aW9uVGFibGVzXCJdID0gZnVuY3Rpb24oKSB7IGFib3J0KFwiJ2dldEZ1bmN0aW9uVGFibGVzJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcIikgfTtcclxuaWYgKCFNb2R1bGVbXCJhbGlnbkZ1bmN0aW9uVGFibGVzXCJdKSBNb2R1bGVbXCJhbGlnbkZ1bmN0aW9uVGFibGVzXCJdID0gZnVuY3Rpb24oKSB7IGFib3J0KFwiJ2FsaWduRnVuY3Rpb25UYWJsZXMnIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVwiKSB9O1xyXG5pZiAoIU1vZHVsZVtcInJlZ2lzdGVyRnVuY3Rpb25zXCJdKSBNb2R1bGVbXCJyZWdpc3RlckZ1bmN0aW9uc1wiXSA9IGZ1bmN0aW9uKCkgeyBhYm9ydChcIidyZWdpc3RlckZ1bmN0aW9ucycgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXCIpIH07XHJcbmlmICghTW9kdWxlW1wiYWRkRnVuY3Rpb25cIl0pIE1vZHVsZVtcImFkZEZ1bmN0aW9uXCJdID0gZnVuY3Rpb24oKSB7IGFib3J0KFwiJ2FkZEZ1bmN0aW9uJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcIikgfTtcclxuaWYgKCFNb2R1bGVbXCJyZW1vdmVGdW5jdGlvblwiXSkgTW9kdWxlW1wicmVtb3ZlRnVuY3Rpb25cIl0gPSBmdW5jdGlvbigpIHsgYWJvcnQoXCIncmVtb3ZlRnVuY3Rpb24nIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVwiKSB9O1xyXG5pZiAoIU1vZHVsZVtcImdldEZ1bmNXcmFwcGVyXCJdKSBNb2R1bGVbXCJnZXRGdW5jV3JhcHBlclwiXSA9IGZ1bmN0aW9uKCkgeyBhYm9ydChcIidnZXRGdW5jV3JhcHBlcicgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXCIpIH07XHJcbmlmICghTW9kdWxlW1wicHJldHR5UHJpbnRcIl0pIE1vZHVsZVtcInByZXR0eVByaW50XCJdID0gZnVuY3Rpb24oKSB7IGFib3J0KFwiJ3ByZXR0eVByaW50JyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcIikgfTtcclxuaWYgKCFNb2R1bGVbXCJtYWtlQmlnSW50XCJdKSBNb2R1bGVbXCJtYWtlQmlnSW50XCJdID0gZnVuY3Rpb24oKSB7IGFib3J0KFwiJ21ha2VCaWdJbnQnIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVwiKSB9O1xyXG5pZiAoIU1vZHVsZVtcImR5bkNhbGxcIl0pIE1vZHVsZVtcImR5bkNhbGxcIl0gPSBmdW5jdGlvbigpIHsgYWJvcnQoXCInZHluQ2FsbCcgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXCIpIH07XHJcbmlmICghTW9kdWxlW1wiZ2V0Q29tcGlsZXJTZXR0aW5nXCJdKSBNb2R1bGVbXCJnZXRDb21waWxlclNldHRpbmdcIl0gPSBmdW5jdGlvbigpIHsgYWJvcnQoXCInZ2V0Q29tcGlsZXJTZXR0aW5nJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcIikgfTtcclxuaWYgKCFNb2R1bGVbXCJpbnRBcnJheUZyb21CYXNlNjRcIl0pIE1vZHVsZVtcImludEFycmF5RnJvbUJhc2U2NFwiXSA9IGZ1bmN0aW9uKCkgeyBhYm9ydChcIidpbnRBcnJheUZyb21CYXNlNjQnIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVwiKSB9O1xyXG5pZiAoIU1vZHVsZVtcInRyeVBhcnNlQXNEYXRhVVJJXCJdKSBNb2R1bGVbXCJ0cnlQYXJzZUFzRGF0YVVSSVwiXSA9IGZ1bmN0aW9uKCkgeyBhYm9ydChcIid0cnlQYXJzZUFzRGF0YVVSSScgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXCIpIH07aWYgKCFNb2R1bGVbXCJBTExPQ19OT1JNQUxcIl0pIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGUsIFwiQUxMT0NfTk9STUFMXCIsIHsgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoXCInQUxMT0NfTk9STUFMJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcIikgfSB9KTtcclxuaWYgKCFNb2R1bGVbXCJBTExPQ19TVEFDS1wiXSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZSwgXCJBTExPQ19TVEFDS1wiLCB7IGdldDogZnVuY3Rpb24oKSB7IGFib3J0KFwiJ0FMTE9DX1NUQUNLJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcIikgfSB9KTtcclxuaWYgKCFNb2R1bGVbXCJBTExPQ19TVEFUSUNcIl0pIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGUsIFwiQUxMT0NfU1RBVElDXCIsIHsgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoXCInQUxMT0NfU1RBVElDJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcIikgfSB9KTtcclxuaWYgKCFNb2R1bGVbXCJBTExPQ19EWU5BTUlDXCJdKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlLCBcIkFMTE9DX0RZTkFNSUNcIiwgeyBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydChcIidBTExPQ19EWU5BTUlDJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcIikgfSB9KTtcclxuaWYgKCFNb2R1bGVbXCJBTExPQ19OT05FXCJdKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlLCBcIkFMTE9DX05PTkVcIiwgeyBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydChcIidBTExPQ19OT05FJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcIikgfSB9KTtcclxuXHJcblxyXG5cclxuLy8gTW9kdWxhcml6ZSBtb2RlIHJldHVybnMgYSBmdW5jdGlvbiwgd2hpY2ggY2FuIGJlIGNhbGxlZCB0b1xyXG4vLyBjcmVhdGUgaW5zdGFuY2VzLiBUaGUgaW5zdGFuY2VzIHByb3ZpZGUgYSB0aGVuKCkgbWV0aG9kLFxyXG4vLyBtdXN0IGxpa2UgYSBQcm9taXNlLCB0aGF0IHJlY2VpdmVzIGEgY2FsbGJhY2suIFRoZSBjYWxsYmFja1xyXG4vLyBpcyBjYWxsZWQgd2hlbiB0aGUgbW9kdWxlIGlzIHJlYWR5IHRvIHJ1biwgd2l0aCB0aGUgbW9kdWxlXHJcbi8vIGFzIGEgcGFyYW1ldGVyLiAoTGlrZSBhIFByb21pc2UsIGl0IGFsc28gcmV0dXJucyB0aGUgbW9kdWxlXHJcbi8vIHNvIHlvdSBjYW4gdXNlIHRoZSBvdXRwdXQgb2YgLnRoZW4oLi4pKS5cclxuTW9kdWxlWyd0aGVuJ10gPSBmdW5jdGlvbihmdW5jKSB7XHJcbiAgLy8gV2UgbWF5IGFscmVhZHkgYmUgcmVhZHkgdG8gcnVuIGNvZGUgYXQgdGhpcyB0aW1lLiBpZlxyXG4gIC8vIHNvLCBqdXN0IHF1ZXVlIGEgY2FsbCB0byB0aGUgY2FsbGJhY2suXHJcbiAgaWYgKE1vZHVsZVsnY2FsbGVkUnVuJ10pIHtcclxuICAgIGZ1bmMoTW9kdWxlKTtcclxuICB9IGVsc2Uge1xyXG4gICAgLy8gd2UgYXJlIG5vdCByZWFkeSB0byBjYWxsIHRoZW4oKSB5ZXQuIHdlIG11c3QgY2FsbCBpdFxyXG4gICAgLy8gYXQgdGhlIHNhbWUgdGltZSB3ZSB3b3VsZCBjYWxsIG9uUnVudGltZUluaXRpYWxpemVkLlxyXG4gICAgdmFyIG9sZCA9IE1vZHVsZVsnb25SdW50aW1lSW5pdGlhbGl6ZWQnXTtcclxuICAgIE1vZHVsZVsnb25SdW50aW1lSW5pdGlhbGl6ZWQnXSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICBpZiAob2xkKSBvbGQoKTtcclxuICAgICAgZnVuYyhNb2R1bGUpO1xyXG4gICAgfTtcclxuICB9XHJcbiAgcmV0dXJuIE1vZHVsZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGV4dGVuZHMge0Vycm9yfVxyXG4gKiBAdGhpcyB7RXhpdFN0YXR1c31cclxuICovXHJcbmZ1bmN0aW9uIEV4aXRTdGF0dXMoc3RhdHVzKSB7XHJcbiAgdGhpcy5uYW1lID0gXCJFeGl0U3RhdHVzXCI7XHJcbiAgdGhpcy5tZXNzYWdlID0gXCJQcm9ncmFtIHRlcm1pbmF0ZWQgd2l0aCBleGl0KFwiICsgc3RhdHVzICsgXCIpXCI7XHJcbiAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XHJcbn07XHJcbkV4aXRTdGF0dXMucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XHJcbkV4aXRTdGF0dXMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRXhpdFN0YXR1cztcclxuXHJcbnZhciBpbml0aWFsU3RhY2tUb3A7XHJcbnZhciBjYWxsZWRNYWluID0gZmFsc2U7XHJcblxyXG5kZXBlbmRlbmNpZXNGdWxmaWxsZWQgPSBmdW5jdGlvbiBydW5DYWxsZXIoKSB7XHJcbiAgLy8gSWYgcnVuIGhhcyBuZXZlciBiZWVuIGNhbGxlZCwgYW5kIHdlIHNob3VsZCBjYWxsIHJ1biAoSU5WT0tFX1JVTiBpcyB0cnVlLCBhbmQgTW9kdWxlLm5vSW5pdGlhbFJ1biBpcyBub3QgZmFsc2UpXHJcbiAgaWYgKCFNb2R1bGVbJ2NhbGxlZFJ1biddKSBydW4oKTtcclxuICBpZiAoIU1vZHVsZVsnY2FsbGVkUnVuJ10pIGRlcGVuZGVuY2llc0Z1bGZpbGxlZCA9IHJ1bkNhbGxlcjsgLy8gdHJ5IHRoaXMgYWdhaW4gbGF0ZXIsIGFmdGVyIG5ldyBkZXBzIGFyZSBmdWxmaWxsZWRcclxufVxyXG5cclxuXHJcblxyXG5cclxuXHJcbi8qKiBAdHlwZSB7ZnVuY3Rpb24oQXJyYXk9KX0gKi9cclxuZnVuY3Rpb24gcnVuKGFyZ3MpIHtcclxuICBhcmdzID0gYXJncyB8fCBNb2R1bGVbJ2FyZ3VtZW50cyddO1xyXG5cclxuICBpZiAocnVuRGVwZW5kZW5jaWVzID4gMCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgd3JpdGVTdGFja0Nvb2tpZSgpO1xyXG5cclxuICBwcmVSdW4oKTtcclxuXHJcbiAgaWYgKHJ1bkRlcGVuZGVuY2llcyA+IDApIHJldHVybjsgLy8gYSBwcmVSdW4gYWRkZWQgYSBkZXBlbmRlbmN5LCBydW4gd2lsbCBiZSBjYWxsZWQgbGF0ZXJcclxuICBpZiAoTW9kdWxlWydjYWxsZWRSdW4nXSkgcmV0dXJuOyAvLyBydW4gbWF5IGhhdmUganVzdCBiZWVuIGNhbGxlZCB0aHJvdWdoIGRlcGVuZGVuY2llcyBiZWluZyBmdWxmaWxsZWQganVzdCBpbiB0aGlzIHZlcnkgZnJhbWVcclxuXHJcbiAgZnVuY3Rpb24gZG9SdW4oKSB7XHJcbiAgICBpZiAoTW9kdWxlWydjYWxsZWRSdW4nXSkgcmV0dXJuOyAvLyBydW4gbWF5IGhhdmUganVzdCBiZWVuIGNhbGxlZCB3aGlsZSB0aGUgYXN5bmMgc2V0U3RhdHVzIHRpbWUgYmVsb3cgd2FzIGhhcHBlbmluZ1xyXG4gICAgTW9kdWxlWydjYWxsZWRSdW4nXSA9IHRydWU7XHJcblxyXG4gICAgaWYgKEFCT1JUKSByZXR1cm47XHJcblxyXG4gICAgZW5zdXJlSW5pdFJ1bnRpbWUoKTtcclxuXHJcbiAgICBwcmVNYWluKCk7XHJcblxyXG4gICAgaWYgKE1vZHVsZVsnb25SdW50aW1lSW5pdGlhbGl6ZWQnXSkgTW9kdWxlWydvblJ1bnRpbWVJbml0aWFsaXplZCddKCk7XHJcblxyXG4gICAgYXNzZXJ0KCFNb2R1bGVbJ19tYWluJ10sICdjb21waWxlZCB3aXRob3V0IGEgbWFpbiwgYnV0IG9uZSBpcyBwcmVzZW50LiBpZiB5b3UgYWRkZWQgaXQgZnJvbSBKUywgdXNlIE1vZHVsZVtcIm9uUnVudGltZUluaXRpYWxpemVkXCJdJyk7XHJcblxyXG4gICAgcG9zdFJ1bigpO1xyXG4gIH1cclxuXHJcbiAgaWYgKE1vZHVsZVsnc2V0U3RhdHVzJ10pIHtcclxuICAgIE1vZHVsZVsnc2V0U3RhdHVzJ10oJ1J1bm5pbmcuLi4nKTtcclxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgTW9kdWxlWydzZXRTdGF0dXMnXSgnJyk7XHJcbiAgICAgIH0sIDEpO1xyXG4gICAgICBkb1J1bigpO1xyXG4gICAgfSwgMSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGRvUnVuKCk7XHJcbiAgfVxyXG4gIGNoZWNrU3RhY2tDb29raWUoKTtcclxufVxyXG5Nb2R1bGVbJ3J1biddID0gcnVuO1xyXG5cclxuZnVuY3Rpb24gY2hlY2tVbmZsdXNoZWRDb250ZW50KCkge1xyXG4gIC8vIENvbXBpbGVyIHNldHRpbmdzIGRvIG5vdCBhbGxvdyBleGl0aW5nIHRoZSBydW50aW1lLCBzbyBmbHVzaGluZ1xyXG4gIC8vIHRoZSBzdHJlYW1zIGlzIG5vdCBwb3NzaWJsZS4gYnV0IGluIEFTU0VSVElPTlMgbW9kZSB3ZSBjaGVja1xyXG4gIC8vIGlmIHRoZXJlIHdhcyBzb21ldGhpbmcgdG8gZmx1c2gsIGFuZCBpZiBzbyB0ZWxsIHRoZSB1c2VyIHRoZXlcclxuICAvLyBzaG91bGQgcmVxdWVzdCB0aGF0IHRoZSBydW50aW1lIGJlIGV4aXRhYmxlLlxyXG4gIC8vIE5vcm1hbGx5IHdlIHdvdWxkIG5vdCBldmVuIGluY2x1ZGUgZmx1c2goKSBhdCBhbGwsIGJ1dCBpbiBBU1NFUlRJT05TXHJcbiAgLy8gYnVpbGRzIHdlIGRvIHNvIGp1c3QgZm9yIHRoaXMgY2hlY2ssIGFuZCBoZXJlIHdlIHNlZSBpZiB0aGVyZSBpcyBhbnlcclxuICAvLyBjb250ZW50IHRvIGZsdXNoLCB0aGF0IGlzLCB3ZSBjaGVjayBpZiB0aGVyZSB3b3VsZCBoYXZlIGJlZW5cclxuICAvLyBzb21ldGhpbmcgYSBub24tQVNTRVJUSU9OUyBidWlsZCB3b3VsZCBoYXZlIG5vdCBzZWVuLlxyXG4gIC8vIEhvdyB3ZSBmbHVzaCB0aGUgc3RyZWFtcyBkZXBlbmRzIG9uIHdoZXRoZXIgd2UgYXJlIGluIE5PX0ZJTEVTWVNURU1cclxuICAvLyBtb2RlICh3aGljaCBoYXMgaXRzIG93biBzcGVjaWFsIGZ1bmN0aW9uIGZvciB0aGlzOyBvdGhlcndpc2UsIGFsbFxyXG4gIC8vIHRoZSBjb2RlIGlzIGluc2lkZSBsaWJjKVxyXG4gIHZhciBwcmludCA9IE1vZHVsZVsncHJpbnQnXTtcclxuICB2YXIgcHJpbnRFcnIgPSBNb2R1bGVbJ3ByaW50RXJyJ107XHJcbiAgdmFyIGhhcyA9IGZhbHNlO1xyXG4gIE1vZHVsZVsncHJpbnQnXSA9IE1vZHVsZVsncHJpbnRFcnInXSA9IGZ1bmN0aW9uKHgpIHtcclxuICAgIGhhcyA9IHRydWU7XHJcbiAgfVxyXG4gIHRyeSB7IC8vIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIGl0IGZhaWxzXHJcbiAgICB2YXIgZmx1c2ggPSBmbHVzaF9OT19GSUxFU1lTVEVNO1xyXG4gICAgaWYgKGZsdXNoKSBmbHVzaCgwKTtcclxuICB9IGNhdGNoKGUpIHt9XHJcbiAgTW9kdWxlWydwcmludCddID0gcHJpbnQ7XHJcbiAgTW9kdWxlWydwcmludEVyciddID0gcHJpbnRFcnI7XHJcbiAgaWYgKGhhcykge1xyXG4gICAgd2Fybk9uY2UoJ3N0ZGlvIHN0cmVhbXMgaGFkIGNvbnRlbnQgaW4gdGhlbSB0aGF0IHdhcyBub3QgZmx1c2hlZC4geW91IHNob3VsZCBzZXQgTk9fRVhJVF9SVU5USU1FIHRvIDAgKHNlZSB0aGUgRkFRKSwgb3IgbWFrZSBzdXJlIHRvIGVtaXQgYSBuZXdsaW5lIHdoZW4geW91IHByaW50ZiBldGMuJyk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBleGl0KHN0YXR1cywgaW1wbGljaXQpIHtcclxuICBjaGVja1VuZmx1c2hlZENvbnRlbnQoKTtcclxuXHJcbiAgLy8gaWYgdGhpcyBpcyBqdXN0IG1haW4gZXhpdC1pbmcgaW1wbGljaXRseSwgYW5kIHRoZSBzdGF0dXMgaXMgMCwgdGhlbiB3ZVxyXG4gIC8vIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmcgaGVyZSBhbmQgY2FuIGp1c3QgbGVhdmUuIGlmIHRoZSBzdGF0dXMgaXNcclxuICAvLyBub24temVybywgdGhvdWdoLCB0aGVuIHdlIG5lZWQgdG8gcmVwb3J0IGl0LlxyXG4gIC8vICh3ZSBtYXkgaGF2ZSB3YXJuZWQgYWJvdXQgdGhpcyBlYXJsaWVyLCBpZiBhIHNpdHVhdGlvbiBqdXN0aWZpZXMgZG9pbmcgc28pXHJcbiAgaWYgKGltcGxpY2l0ICYmIE1vZHVsZVsnbm9FeGl0UnVudGltZSddICYmIHN0YXR1cyA9PT0gMCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgaWYgKE1vZHVsZVsnbm9FeGl0UnVudGltZSddKSB7XHJcbiAgICAvLyBpZiBleGl0KCkgd2FzIGNhbGxlZCwgd2UgbWF5IHdhcm4gdGhlIHVzZXIgaWYgdGhlIHJ1bnRpbWUgaXNuJ3QgYWN0dWFsbHkgYmVpbmcgc2h1dCBkb3duXHJcbiAgICBpZiAoIWltcGxpY2l0KSB7XHJcbiAgICAgIE1vZHVsZS5wcmludEVycignZXhpdCgnICsgc3RhdHVzICsgJykgY2FsbGVkLCBidXQgTk9fRVhJVF9SVU5USU1FIGlzIHNldCwgc28gaGFsdGluZyBleGVjdXRpb24gYnV0IG5vdCBleGl0aW5nIHRoZSBydW50aW1lIG9yIHByZXZlbnRpbmcgZnVydGhlciBhc3luYyBleGVjdXRpb24gKGJ1aWxkIHdpdGggTk9fRVhJVF9SVU5USU1FPTAsIGlmIHlvdSB3YW50IGEgdHJ1ZSBzaHV0ZG93biknKTtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG5cclxuICAgIEFCT1JUID0gdHJ1ZTtcclxuICAgIEVYSVRTVEFUVVMgPSBzdGF0dXM7XHJcbiAgICBTVEFDS1RPUCA9IGluaXRpYWxTdGFja1RvcDtcclxuXHJcbiAgICBleGl0UnVudGltZSgpO1xyXG5cclxuICAgIGlmIChNb2R1bGVbJ29uRXhpdCddKSBNb2R1bGVbJ29uRXhpdCddKHN0YXR1cyk7XHJcbiAgfVxyXG5cclxuICBpZiAoRU5WSVJPTk1FTlRfSVNfTk9ERSkge1xyXG4gICAgcHJvY2Vzc1snZXhpdCddKHN0YXR1cyk7XHJcbiAgfVxyXG4gIE1vZHVsZVsncXVpdCddKHN0YXR1cywgbmV3IEV4aXRTdGF0dXMoc3RhdHVzKSk7XHJcbn1cclxuTW9kdWxlWydleGl0J10gPSBleGl0O1xyXG5cclxudmFyIGFib3J0RGVjb3JhdG9ycyA9IFtdO1xyXG5cclxuZnVuY3Rpb24gYWJvcnQod2hhdCkge1xyXG4gIGlmIChNb2R1bGVbJ29uQWJvcnQnXSkge1xyXG4gICAgTW9kdWxlWydvbkFib3J0J10od2hhdCk7XHJcbiAgfVxyXG5cclxuICBpZiAod2hhdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICBNb2R1bGUucHJpbnQod2hhdCk7XHJcbiAgICBNb2R1bGUucHJpbnRFcnIod2hhdCk7XHJcbiAgICB3aGF0ID0gSlNPTi5zdHJpbmdpZnkod2hhdClcclxuICB9IGVsc2Uge1xyXG4gICAgd2hhdCA9ICcnO1xyXG4gIH1cclxuXHJcbiAgQUJPUlQgPSB0cnVlO1xyXG4gIEVYSVRTVEFUVVMgPSAxO1xyXG5cclxuICB2YXIgZXh0cmEgPSAnJztcclxuICB2YXIgb3V0cHV0ID0gJ2Fib3J0KCcgKyB3aGF0ICsgJykgYXQgJyArIHN0YWNrVHJhY2UoKSArIGV4dHJhO1xyXG4gIGlmIChhYm9ydERlY29yYXRvcnMpIHtcclxuICAgIGFib3J0RGVjb3JhdG9ycy5mb3JFYWNoKGZ1bmN0aW9uKGRlY29yYXRvcikge1xyXG4gICAgICBvdXRwdXQgPSBkZWNvcmF0b3Iob3V0cHV0LCB3aGF0KTtcclxuICAgIH0pO1xyXG4gIH1cclxuICB0aHJvdyBvdXRwdXQ7XHJcbn1cclxuTW9kdWxlWydhYm9ydCddID0gYWJvcnQ7XHJcblxyXG4vLyB7e1BSRV9SVU5fQURESVRJT05TfX1cclxuXHJcbmlmIChNb2R1bGVbJ3ByZUluaXQnXSkge1xyXG4gIGlmICh0eXBlb2YgTW9kdWxlWydwcmVJbml0J10gPT0gJ2Z1bmN0aW9uJykgTW9kdWxlWydwcmVJbml0J10gPSBbTW9kdWxlWydwcmVJbml0J11dO1xyXG4gIHdoaWxlIChNb2R1bGVbJ3ByZUluaXQnXS5sZW5ndGggPiAwKSB7XHJcbiAgICBNb2R1bGVbJ3ByZUluaXQnXS5wb3AoKSgpO1xyXG4gIH1cclxufVxyXG5cclxuXHJcbk1vZHVsZVtcIm5vRXhpdFJ1bnRpbWVcIl0gPSB0cnVlO1xyXG5cclxucnVuKCk7XHJcblxyXG4vLyB7e1BPU1RfUlVOX0FERElUSU9OU319XHJcblxyXG5cclxuXHJcblxyXG5cclxuLy8ge3tNT0RVTEVfQURESVRJT05TfX1cclxuXHJcblxyXG5cclxuXHJcblxyXG4gIHJldHVybiBNb2R1bGU7XHJcbn07XHJcbmlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXHJcbiAgbW9kdWxlLmV4cG9ydHMgPSBNb2R1bGU7XHJcbmVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lWydhbWQnXSlcclxuICBkZWZpbmUoW10sIGZ1bmN0aW9uKCkgeyByZXR1cm4gTW9kdWxlOyB9KTtcclxuZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxyXG4gIGV4cG9ydHNbXCJNb2R1bGVcIl0gPSBNb2R1bGU7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=